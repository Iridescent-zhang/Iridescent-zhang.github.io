[{"title":"学习Git","url":"/2022/09/20/GitNote/","content":"<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><p>Git 是一个开源的<strong>分布式-版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。<br>Git 与常用的版本控制工具 CVS, Subversion（SVN）等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p>\n<span id=\"more\"></span>\n<p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录（工作目录下含有.git文件夹），它持有实际文件；第二个是 暂存区（Index，stage），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。<br><img src=\"https://www.runoob.com/manual/git-guide/img/trees.png\" alt=\"本地仓库组成\"></p>\n<blockquote>\n<p><strong>git 基本工作流程</strong></p>\n<ol>\n<li><p>提出更改（把它们添加到暂存区），使用如下命令：<br> <code>git add &lt;filename&gt;</code> </p>\n</li>\n<li><p>使用如下命令以实际提交改动：<br> <code>git commit -m &quot;代码提交备注&quot; </code><br> 现在，你的改动已经提交到了本地仓库的 HEAD 中，但是还没到你的远端仓库。</p>\n</li>\n<li><p>执行如下命令以将这些改动推送到远端仓库：<br> <code>git push origin master</code><br> 可以把 master 换成你想要推送的任何分支。</p>\n</li>\n<li><p>如果你想要将你的本地仓库连接到某个远程服务器（github），你可以使用如下命令添加：<br> <code>git remote add origin https://github.com/Iridescent-zhang/blog.git</code><br> 如此你就能够将你的改动推送到所添加的服务器上去了。</p>\n</li>\n<li><p>在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。<br><img src=\"https://www.runoob.com/manual/git-guide/img/branches.png\" alt=\"分支\"><br>创建一个叫做“feature_x”的分支，并切换过去：<br><code>git checkout -b feature_x</code><br>切换回主分支：<br><code>git checkout master</code><br>再把新建的分支删掉：<br><code>git branch -d feature_x</code><br>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：<br><code>git push origin &lt;branch&gt;</code></p>\n</li>\n<li><p>更新与合并<br>要更新你的本地仓库至最新改动，执行：<br><code>git pull</code><br>以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：<br><code>git merge &lt;branch&gt;</code><br>这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。<br>在合并改动之前，你可以使用如下命令预览差异：<br><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p>\n</li>\n<li><p>标签<br>你可以执行如下命令创建一个叫做 1.0.0 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br>b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：<br><code>git log</code></p>\n</li>\n<li><p>替换本地改动<br>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：<br><code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。<br>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：<br><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"Git-工作流程\"><a href=\"#Git-工作流程\" class=\"headerlink\" title=\"Git 工作流程\"></a>Git 工作流程</h2><blockquote>\n<p>一般工作流程如下：</p>\n<ul>\n<li>克隆 Git 资源作为工作目录(git clone <a href=\"https://github.com/Iridescent-zhang/blog.git)%E3%80%82\">https://github.com/Iridescent-zhang/blog.git)。</a></li>\n<li>在克隆的资源上添加或修改文件。</li>\n<li>如果其他人修改了，你可以更新资源。</li>\n<li>在提交前查看修改。</li>\n<li>提交修改。</li>\n<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。<br><img src=\"https://www.runoob.com/wp-content/uploads/2015/02/git-process.png\" alt=\"Git工作流程\"></li>\n</ul>\n</blockquote>\n<h2 id=\"Git-工作区、暂存区和版本库\"><a href=\"#Git-工作区、暂存区和版本库\" class=\"headerlink\" title=\"Git 工作区、暂存区和版本库\"></a>Git 工作区、暂存区和版本库</h2><ul>\n<li>工作区：就是你在电脑里能看到的目录。</li>\n<li>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li>\n<li>版本库：工作区中有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</li>\n</ul>\n<blockquote>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg\" alt=\"工作区、版本库中的暂存区和版本库之间的关系\"></p>\n<ul>\n<li>在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树。</li>\n<li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li>\n<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git&#x2F;objects” 目录下，里面包含了创建的各种对象及内容。</li>\n<li>当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>\n<li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li>\n<li>当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>\n<li>当执行 git rm –cached <file> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>\n<li>当执行 git checkout . 或者 git checkout – <file> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>\n<li>当执行 git checkout HEAD . 或者 git checkout HEAD <file> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未添加到暂存区中的改动，也会清除暂存区中未提交的改动。</li>\n</ul>\n</blockquote>\n<h2 id=\"Git操作\"><a href=\"#Git操作\" class=\"headerlink\" title=\"Git操作\"></a>Git操作</h2><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。<br>本节将对有关创建与提交你的项目快照的命令作介绍。<br>Git 常用的是以下 6 个命令：git clone、git push、git add 、git commit、git checkout、git pull。<br><img src=\"https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg\" alt=\"Git常用命令\"></p>\n<blockquote>\n<p>workspace：工作区<br>staging area：暂存区&#x2F;缓存区<br>local repository： <strong>版本库或本地仓库</strong><br>remote repository：远程仓库</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init //初始化仓库</span><br><span class=\"line\">git clone //拷贝一份远程仓库，也就是下载一个项目。</span><br><span class=\"line\">git remote add origin git@github.com:yourName/yourRepo.git //添加远程地址, 后面的yourName和yourRepo表示你在github的用户名和仓库，加完之后进入.git，打开 config，这里会多出一个remote <span class=\"string\">&quot;origin&quot;</span>内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"Git-分支管理\"><a href=\"#Git-分支管理\" class=\"headerlink\" title=\"Git 分支管理\"></a>Git 分支管理</h2><p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。<br>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。<br><img src=\"https://static.runoob.com/images/svg/git-brance.svg\" alt=\"分支\"></p>\n<p>Git 分支实际上是指向更改快照的指针。</p>\n<p>有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。<br>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p>\n<p>当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。<br><strong>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。</strong></p>\n<p><strong>分支实在是太妙了，不管你在这个分支做了什么，<code>git checkout &lt;branchname&gt;</code>切换分支时（注意，如果你在这个分支做的改变没有commit时是无法切换到另一个已经存在的分支的，但是是可以切换到一个新建分支的(git branch &lt;branchname&gt; )。），Git 将还原你的工作目录到该分支<branchbname>上一次commit时的状态(对于新分支，则是切换到原来分支创建新分支前一次提交更新时的样子) 也不大对，好像也可以切换到已存在的分支，再说吧</strong></p>\n<p>使用分支将我们自己的工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>\n<blockquote>\n<p><strong>分支命令</strong><br>   <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch //查看已有分支</span><br><span class=\"line\">git branch &lt;branchname&gt; //新建分支</span><br><span class=\"line\">git checkout &lt;branchname&gt; //切换分支</span><br><span class=\"line\">git checkout -b &lt;branchname&gt; //创建新分支并立即切换到该分支下，从而在该分支中操作。</span><br><span class=\"line\">git branch -d &lt;branchname&gt; //删除分支</span><br><span class=\"line\">git rm &lt;filename&gt; //删除文件</span><br><span class=\"line\">git add . //添加当前项目的所有文件</span><br><span class=\"line\">echo <span class=\"string\">&#x27;runoob.com&#x27;</span> &gt; test.txt //向test.txt中写入runoob.com</span><br><span class=\"line\">git branch -M master //删去其他分支，主分支改名为master</span><br><span class=\"line\">git merge &lt;branchname&gt; //一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用该命令将任何分支合并到当前分支中去：</span><br><span class=\"line\">合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</span><br><span class=\"line\">git commit -v //查看当前分支是否有change没有被stage和commit</span><br><span class=\"line\">git commit -am <span class=\"string\">&quot;备注&quot;</span> //相当于git add &lt;filename&gt;之后git commit -m <span class=\"string\">&quot;备注&quot;</span>，commit <span class=\"built_in\">all</span> changed files</span><br><span class=\"line\">git commit -<span class=\"built_in\">help</span> //该命令可以查看 commit 的命令选项。</span><br><span class=\"line\">git status -s //该命令用于查看项目的当前状态，git commit -v有类似功能。</span><br></pre></td></tr></table></figure><br><code>git status</code>显示的状态：<br>??：新添加的文件未添加到index；<br>A：表示这个文件添加到了缓存区；<br>AM：该状态的意思是这个文件在我们将它添加到缓存之后又有了改动；<br>文件修改后，我们一般都需要进行 git add 操作，从而保存历史版本。</p>\n</blockquote>\n<blockquote>\n<p>   合并冲突出现时，需要手动去修改它，修改完之后用git add告诉Git文件冲突已经解决<br>   用git status -s查看时，冲突文件前显示UU，git add后显示M(modify)<br>   最后git commit提交。现在便成功解决了合并中的冲突，并提交了结果。</p>\n</blockquote>\n<h2 id=\"Git-查看提交历史\"><a href=\"#Git-查看提交历史\" class=\"headerlink\" title=\"Git 查看提交历史\"></a>Git 查看提交历史</h2><p>Git 提交历史一般常用两个命令：</p>\n<ul>\n<li>git log - 查看历史提交记录。</li>\n<li>git blame <file> - 以列表形式查看指定文件的历史修改记录。</li>\n</ul>\n<h3 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h3><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。<br>可以用 –oneline 选项来查看历史记录的简洁的版本，即<code>git log --oneline</code><br>还可以用 –graph 选项，查看历史中什么时候出现了分支、合并，即<code>git log --graph</code><br>也可以用 –reverse 参数来逆向显示所有日志，即<code>git log --reverse --graph</code>，这样从上往下是按时间顺序，没有这个参数是逆序。<br><code>git log --oneline --graph</code>很清楚</p>\n<h3 id=\"git-blame\"><a href=\"#git-blame\" class=\"headerlink\" title=\"git blame\"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：<br><code>git blame &lt;file&gt;</code><br>git blame 命令是以列表形式显示修改记录。</p>\n<h2 id=\"git-标签\"><a href=\"#git-标签\" class=\"headerlink\" title=\"git 标签\"></a>git 标签</h2><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。<br> 我们可以用 <code>git tag -a v1.0</code> 命令给最新一次提交打上（HEAD）”v1.0”的标签。<br>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的。 我推荐一直创建带注解的标签。<br>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。<br>现在，注意当我们执行 <code>git log --decorate</code> 时，我们可以看到我们的标签了。<br><code>git log --oneline --graph --decorate</code>好用<br>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。<br>假设我们发布了提交 85fc7e7 (git log可以看到 <em><strong>commit</strong></em> 后面跟着很长的一段字符，取前七位)，但是那时候忘了给它打标签。 我们现在也可以：<code>git tag -a v0.9 85fc7e7</code>。<br>如果我们要查看所有标签可以使用以下命令：<code>git tag</code>。</p>\n<p>将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。<br>所以，标签也是版本库的一个快照。<br>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的</p>\n<p>“请把上周一的那个版本打包发布，版本号是v1.2”<br>“好的，按照tag v1.2查找commit就行！<br>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit(commit号前七位)绑在一起。</p>\n<p> 删除标签 git tag -d v1.1</p>\n<h2 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h2><blockquote>\n<p><code>git init, git add, git commit</code> 之后<br>添加远程仓库:<br><code>git remote add origin git@github.com:Iridescent-zhang/blog.git</code><br>查看当前的远程库:<br><code>git remote, git remote -v</code><br>删除远程仓库:<br><code>git remote rm [别名]</code></p>\n<ol>\n<li>从远程仓库下载新分支与数据到本地分支：<br><code>git fetch</code></li>\n<li>从远端仓库提取数据并尝试合并到当前分支：<br><code>git merge</code></li>\n</ol>\n<p>从远程仓库获取更新也可以用:<br><code>git pull</code><br><img src=\"https://www.runoob.com/wp-content/uploads/2015/03/main-qimg-00a6b5a8ec82400657444504c4d4d1a7.png\" alt=\"pull equal to &lt;fetch+merge&gt;\"><br>假设你配置好了一个远程仓库[alias]，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据（假设有人这时候推送到服务器了），然后你可以执行 git merge [alias]&#x2F;[branch] 以将服务器上的任何更新的分支合并到你的当前分支。</p>\n<p>推送你的新分支与数据到某个远端仓库命令:<br><code>git push [alias] [branch]</code><br>以上命令将你的本地 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，所以push时本地分支名和远程分支名得一样。</p>\n<p><strong>执行 git fetch origin master 时，它的意思是从名为 origin 的远程上拉取名为 master 的分支到本地分支 origin&#x2F;master 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。</strong><br><em><strong>执行 git merge origin&#x2F;master 时，它的意思是合并名为 origin&#x2F;master 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。</strong></em><br><strong>执行 git push origin master 时，它的意思是推送本地的 master 分支到远程 origin（成为远程仓库的同名master分支），涉及到远程以及分支，当然也得分开写了。</strong></p>\n</blockquote>\n<h2 id=\"END\"><a href=\"#END\" class=\"headerlink\" title=\"END\"></a>END</h2><p>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。<br>git add -A 或者 git add –all 表示追踪所有操作，包括新增、修改和删除。<br>添加远程版本库命令格式：git remote add [shortname] [url]，一般shortname用origin，origin2…<br>git fetch 命令将提交、文件和引用从远程存储库下载到本地存储库中。<br><strong>git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。</strong></p>\n<hr>\n<blockquote>\n<p>这是在github新建仓库时给出的代码<br>create a new repository on the command line</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;echo <span class=\"string\">&quot;# git-test&quot;</span> &gt;&gt; README.md</span><br><span class=\"line\">&gt;git init</span><br><span class=\"line\">&gt;git add README.md</span><br><span class=\"line\">&gt;git commit -m <span class=\"string\">&quot;first commit&quot;</span></span><br><span class=\"line\">&gt;git branch -M main</span><br><span class=\"line\">&gt;git remote add origin git@github.com:Iridescent-zhang/git-test.git</span><br><span class=\"line\">&gt;git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<p>push an existing repository from the command line</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;git remote add origin git@github.com:Iridescent-zhang/git-test.git</span><br><span class=\"line\">&gt;git branch -M main</span><br><span class=\"line\">&gt;git push -u origin main</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"git-rebase（变基）详解\"><a href=\"#git-rebase（变基）详解\" class=\"headerlink\" title=\"git rebase（变基）详解\"></a>git rebase（变基）详解</h3><p>两个分支master和feature，其中feature是在提交点B处从master上拉出的分支<br>master上有一个新提交M，feature上有两个新提交C和D<br><img src=\"https://img-blog.csdnimg.cn/36efc2704d174acab598c4b9addd3694.png\"></p>\n<p>此时切换到feature分支上，执行如下命令，相当于是想要把master分支合并到feature分支（这一步的场景就可以类比为我们在自己的分支feature上开发了一段时间了，准备从主干master上拉一下最新改动）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout feature</span><br><span class=\"line\">git rebase master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这两条命令等价于git rebase master feature</span></span><br></pre></td></tr></table></figure>\n<p>下图为变基后的提交节点图，解释一下其工作原理：<br><img src=\"https://img-blog.csdnimg.cn/12b959efcc454da5a15b9fdec493d61b.png\"></p>\n<blockquote>\n<p>官方解释（如果觉得看不懂可以直接看下一段）：当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到基分支的最新提交的后面。</p>\n<p>结合例子解释：当在feature分支上执行git rebase master时，git会从master和featuer的共同祖先B开始提取feature分支上的修改，也就是C和D两个提交，先提取到。然后将feature分支指向master分支的最新提交上，也就是M。最后把提取的C和D接到M后面，但这个过程是删除原来的C和D，生成新的C’和D’，他们的提交内容一样，但commit id不同。feature自然最后也是指向D’。</p>\n<p>通俗解释（重要！！）：rebase，变基，可以直接理解为改变基底。feature分支是基于master分支的B拉出来的分支，feature的基底是B。而master在B之后有新的提交，就相当于此时要用master上新的提交来作为feature分支的新基底。实际操作为把B之后feature的提交存下来，然后删掉原来这些提交，再找到master的最新提交位置，把存下来的提交再接上去（新节点新commit id），如此feature分支的基底就相当于变成了M而不是原来的B了。（注意，如果master上在B以后没有新提交，那么就还是用原来的B作为基，rebase操作相当于无效，此时和git merge就基本没区别了，差异只在于git merge会多一条记录Merge操作的提交记录）</p>\n<p>上面的例子可抽象为如下实际工作场景：张三从B拉了代码进行开发，目前提交了两次，开发到D了；李四也从B拉出来开发了并且开发完毕，他提交到了M，然后合到主干上了。此时张三想拉下最新代码，于是他在feature分支上执行了git rebase master，即把master分支给rebase过来，由于李四更早开发完并合了主干，如此就相当于张三是基于李四的最新提交M进行的开发了。</p>\n</blockquote>\n<p><strong>无论是个人开发，还是公司协作开发，只要没有特殊需求，用merge准没错！！</strong></p>\n<h2 id=\"git-pull-request\"><a href=\"#git-pull-request\" class=\"headerlink\" title=\"git pull request\"></a>git pull request</h2><p><strong>github的多人协作</strong><br>github上你可以用别人的现成的代码 直接 git clone 即可了</p>\n<p>然后<strong>你也想改代码或者贡献代码</strong>咋办？</p>\n<p><strong>Fork</strong><br>从别人的项目中fork一个到你自己的仓库 这个时候这个仓库就是你的了，要删除这个仓库到设置-admin 那里，像你删除你自己创建的repo一样删除，（因为这个库就是你的了，你现在可以任意修改这个库，<strong>除非你pull request被接受否则你 不会对原作者的库产生任何影响</strong>）</p>\n<p>比如osteach账号下有个osteach.github.com的库 这个项目的地址是https&#x2F;github.com&#x2F;osteach&#x2F;osteach.github.com</p>\n<p>这时候我（suziewong）想贡献代码了。fork之后，你的个人仓库就多了这个库 <a href=\"https://github.com/suziewong/osteach.github.com\">https://github.com/suziewong/osteach.github.com</a></p>\n<p><strong>开发并且提交代码 clone</strong></p>\n<p>首先要从github上下载代码到本地，你需要执行如下命令：<br>git clone <a href=\"https://github.com/suziewong/osteach.github.com.git\">https://github.com/suziewong/osteach.github.com.git</a><br><strong>clone的是自己的库看，并且clone的时候会产生osteach.github.com这个文件夹，所以不用自己新建osteach.github.com文件夹</strong><br>cd osteach.github.com， 这个文件夹里面才有.git，才是你的本地库<br>然后代码到本地里了，你就可以各种修改 add commit 了</p>\n<p>commit<br>当你修改代码之后，需要commit到本地仓库，执行的命令如下：<br>git add xx<br>git commit  -m ‘修改原因，相关说明信息’</p>\n<p><strong>push</strong><br>执行git commit之后，只是提交到了本机的仓库，而不是github上你账号的仓库。你需要执行push命令，把commit提交到服务器。</p>\n<p>这里你可以直接git push 木有问题直接到远程默认仓库，当然remote add 也木有问题，因为和操纵自己的库没有任何区别(默认的origin就是自己的库，所以不需要remote add origin)<br>git push<br>这里的git push  指的是push 到suziewong&#x2F;osteach.github.com 的默认仓库（master）</p>\n<p>这里有重点<br>这里你如果 remote add osteach osteach&#x2F;osteach.github.com.git<br>好吧，你git push osteach master 之类的都是没用的<br>因为你没有权限！没有权限修改别人(osteach)的库!</p>\n<p>上游仓库<br>添加远程仓库<br>git remote add origin <a href=\"https://github.com/suziewong/osteach.github.com.git\">https://github.com/suziewong/osteach.github.com.git</a><br>更新远程代码： 好吧，这里得分2种情况<br>1.拉取自己的库的最新的代码到本地（这个其实和操纵自己的库没撒区别）</p>\n<p>git pull<br>2.你正在开发，主作者【项目负责人】osteach也在开发，你当时fork的代码已经不是osteach的最新的代码了。 这时候的你对你的代码肯定没问题，但是pull request 就有可以会出错，因为你fork的repo和现在的osteach的repo已经不一样了。 这时候理论上osteach会<strong>close</strong>你的request，让你先pull osteach的最新代码。 于是乎 git remote add osteach osteach&#x2F;osteach.github.com.git git<br><code>fetch osteach master:develop</code><br><code>pull Unlocksun loading_bots:develop</code>远程分支名：本地分支名</p>\n<p>自己merge代码 不和谐的地方，这里肯定不能git pull,会提示conflict 即代码是需要自己merge的</p>\n<p>你修改代码后<br>git add<br>git commit<br>然后测试一下是不是已经拉取完成最新的了。</p>\n<p>现在可以pull，即<code>git pull osteach master </code><br>你就会发现原先的出错不见了，变成了<strong>everything update</strong></p>\n<p>你就可以提交到自己的远程版本库了。 git push origin master</p>\n<p>之后你再pull request，osteach那边就木有出现 不能 auto merge的情况了，然后osteach看你的代码给不给力， 给力就merge你的代码到他的主分支去了。 功德圆满 ：）</p>\n<p>pull request<br>登陆github，在你自己的账号中的仓库中点击pull request，就会要求你输入pull request的原因和详细信息，你确认之后。osteach的owner就会收到并且审查，审查通过就会合并到主干上。</p>\n<p>参考自 <a href=\"https://gist.github.com/suziewong/4378619\">github的多人协作</a></p>\n<p><a href=\"https://blog.csdn.net/gggg989898/article/details/108639631\">git添加多个远程仓库</a> 进一步描述上一篇文章中 git remote add (想个名字) 你想要pr的库的链接.git <strong>的意义</strong></p>\n<p>添加一个远程库 名字不能是origin（origin是你fork的库在本地的名字了）</p>\n<h1 id=\"ssh\"><a href=\"#ssh\" class=\"headerlink\" title=\"ssh\"></a>ssh</h1><p>痛苦的ssh</p>\n<p><code>ssh -T git@github.com</code>命令检查ssh连接是否成功</p>\n<p><code>ssh -T git@github.com</code>命令检查ssh连接是否成功<br>新建ssh连接首先需要删除.ssh文件夹中的<code>known_hosts</code>（本用户曾经ssh连接过的主机的公钥都会保存在这里），<br>流程为：<br>在命令行中使用ssh-keygen.exe工具来生成密钥对：<br>生成过程中会让你指定生成位置，以及给它再设一个密码。我们使用默认位置，不再设定密码。也就是一路Enter就行<br>生成之后多了两个文件，显然第一个是私钥，第二个.pub是公钥。私钥在自己的设备上存着就可以，别人拿到你的公钥就可以验证你的身份。也可以用你的公钥签发一些数字证书。<br>将生成的公钥添加到Github账户中<br>复制一下生成的公钥，登录Github，点右上角自己的头像，选择Settings，然后在新页面中的左侧边栏选择SSH and GPG Key。给这个ssh公钥起一个名字，然后把公钥复制进去。<br><code>ssh -vT git@github.com</code>命令检查ssh连接是否成功</p>\n<p>报错</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">/usr/bin/bash: line 0: exec: nc: not found</span><br><span class=\"line\">kex_exchange_identification: Connection closed by remote host</span><br><span class=\"line\">Connection closed by UNKNOWN port 65535</span><br></pre></td></tr></table></figure>\n<p>nc是connect.exe这个软件，找不到了，现在的git bash里面都包含了connect.exe这个软件，位置在jmingw&#x2F;bin下，我是添加了环境变量。<br>后面两个报错需要修改<code>.ssh/config</code>，使用如下配置文件：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">  User git</span><br><span class=\"line\">  Port 443</span><br><span class=\"line\">  Hostname ssh.github.com</span><br><span class=\"line\">  IdentityFile &quot;C:\\Users\\Iridescent_zlc\\.ssh\\id_rsa&quot;</span><br><span class=\"line\">  TCPKeepAlive yes</span><br><span class=\"line\"> ProxyCommand connect -S 127.0.0.1:7891 -a none %h %p</span><br><span class=\"line\"></span><br><span class=\"line\">Host ssh.github.com</span><br><span class=\"line\">  User git</span><br><span class=\"line\">  Port 443</span><br><span class=\"line\">  Hostname ssh.github.com</span><br><span class=\"line\">  IdentityFile &quot;C:\\Users\\Iridescent_zlc\\.ssh\\id_rsa&quot;</span><br><span class=\"line\">  TCPKeepAlive yes</span><br><span class=\"line\">  ProxyCommand connect -S 127.0.0.1:7891 -a none %h %p</span><br></pre></td></tr></table></figure>\n<p>443端口，唯一真神（经测试，22端口是不行的）</p>\n<p>参考自 <a href=\"https://gist.github.com/chenshengzhi/07e5177b1d97587d5ca0acc0487ad677?permalink_comment_id=3721523\">git ssh 代理设置</a></p>\n<hr>\n<p>出现<code>fatal: refusing to merge unrelated histories</code><br><img src=\"https://i.postimg.cc/nVwtY40H/1.jpg\"></p>\n<p><a href=\"https://stackoverflow.com/questions/55972713/fail-to-use-git-pull-couldnt-find-remote-ref-allow-unrelated-histories\">遇到过类似的问题</a><br>当执行git中的“git pull origin master –allow-unrelated-histories”命令时，会出现“ couldn’t find remote ref –allow-unrelated-histories”的错误:</p>\n<p><a href=\"https://stackoverflow.com/questions/24357108/updates-were-rejected-because-the-remote-contains-work-that-you-do-not-have-loca\">遇到过类似的问题</a><br>git pull <remote> master:dev将获取remote&#x2F;master分支并将其合并到您的local&#x2F;dev分支中。<br>git pull <remote> dev将获取remote&#x2F;dev分支，并将其合并到您当前的分支中。<br>也可以<a href=\"https://blog.csdn.net/brownsville2/article/details/102246961\">rebase</a></p>\n<hr>\n<p>设置GIT根目录，也就是为了设置git配置文件的路径，方便管理；<br>参考文章<a href=\"https://blog.51cto.com/u_15075507/3641247\">如何修改git的默认路径</a></p>\n<p><a href=\"https://www.cnblogs.com/songzhenhua/p/9312720.html\">Windows下如何解决git bash的默认home目录路径问题</a><br><a href=\"https://blog.csdn.net/nonfuxinyang/article/details/77206486\">合并冲突</a><br><a href=\"https://www.runoob.com/git/git-tutorial.html\">Runoob-Git</a><br><a href=\"https://chinese.freecodecamp.org/news/how-to-make-your-first-pull-request-on-github/\">pull request</a></p>\n<p><a href=\"https://www.aspirantzhang.com/network/git-fatal-unsafe-repository.html\">当前文件夹不安全</a></p>\n","categories":["Git"],"tags":["Git"]},{"title":"搭建hexo博客","url":"/2022/09/07/HIBTB/","content":"<h2 id=\"How-I-bulid-this-blog\"><a href=\"#How-I-bulid-this-blog\" class=\"headerlink\" title=\"How I bulid this blog\"></a>How I bulid this blog</h2><p><strong>hexo</strong>是一个应用非常广泛的，快速且高效的博客框架，我使用的主题是<a href=\"https://github.com/theme-next/hexo-theme-next\">next</a>，网上配置教程非常多，过程繁琐但不难，需要注意的一点是大多数教程是旧版<em>next</em>（仍作参考），新版<em>next</em>有一些不同的地方，修改除_config.yml以外的文件时做好备份。</p>\n<p>本文不是详细的hexo next配置教程，仅仅记录配置过程遇到的问题，详细配置教程见文末链接。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"some-problems\"><a href=\"#some-problems\" class=\"headerlink\" title=\"some problems\"></a>some problems</h3><ol>\n<li><strong>hexo d</strong>失败，<em>fatal：Failed to connect to github.com port 443: Timed out</em></li>\n</ol>\n<blockquote>\n<p>Git设置全局代理<br>1080是代理端口，看代理软件可查，根据自己的实际修改。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --<span class=\"keyword\">global</span> http.proxy <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">1080</span></span><br><span class=\"line\">git config --<span class=\"keyword\">global</span> https.proxy <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">1080</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><strong>hexo s</strong>在本地服务器显示正常，<strong>hexo d</strong>发布结果与本地服务器不同<blockquote>\n<p>解决方法</p>\n<ul>\n<li>使用hexo clean清除缓存，之后hexo g, hexo d重新部署；</li>\n<li>浏览器按F12，看哪些css, js文件没有加载上，进行调试修改；</li>\n<li>清除浏览器缓存</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p><del>3. <strong>hexo archive</strong>(档案)界面滚动条拉到最下方会出现页面不断抖动的情况</del></p>\n<blockquote>\n<p> CSS 控制Html页面高度导致抖动，这类由高度导致页面抖动的问题，其实究其根本原因是滚动条是否显示导致的。在主题下source\\css_common\\scaffolding找到base.styl，添加以下代码:</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>&#123; <span class=\"attribute\">overflow-y</span>:scroll;&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>&#123; <span class=\"attribute\">overflow</span>:scroll; <span class=\"attribute\">min-height</span>:<span class=\"number\">101%</span>;&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">html</span>&#123; <span class=\"attribute\">overflow</span>:-moz-scrollbars-vertical;&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em><strong>成小丑了，被这点坑死了，导致返回顶部按钮和目录都失效了，现在看来页面抖动应该是网络的原因</strong></em></p>\n</blockquote>\n<ol start=\"3\">\n<li><p>返回顶部按钮<br>使用插件<a href=\"https://github.com/jiangtj-lab/hexo-cake-moon-menu\">hexo-cake-moon-menu</a><br>在<code>G:\\blog\\themes\\next\\package.json</code>可以查看 hexo next 的版本</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;hexo-theme-next&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;7.8.0&quot;</span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure>\n<p>使用<code>npm i hexo-cake-moon-menu@2.1.2</code>安装version 2.1.2<br>在主题的_config.yml中添加：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">moon_menu:</span><br><span class=\"line\">  back2top:</span><br><span class=\"line\">    enable: <span class=\"literal\">true</span></span><br><span class=\"line\">    icon: fas fa-chevron-up</span><br><span class=\"line\">    order: <span class=\"number\">-1</span></span><br><span class=\"line\">  back2bottom:</span><br><span class=\"line\">    enable: <span class=\"literal\">true</span></span><br><span class=\"line\">    icon: fas fa-chevron-down</span><br><span class=\"line\">    order: <span class=\"number\">-2</span></span><br></pre></td></tr></table></figure>\n<p>这个返回顶部按钮并不会和 next 自带的返回顶部按钮和阅读百分比冲突，也就是可以同时开启，不过我还是关掉了。</p>\n</li>\n<li><p>设置网页加载进度条<br>参考自<a href=\"https://blog.csdn.net/TomAndersen/article/details/104693194?spm=1001.2014.3001.5506\">加载进度条</a>。<br>这个进度条能够显示网页加载进度，非常好用，对我来说能调高网页浏览体验。</p>\n<ul>\n<li>进入NexT主题文件夹<code>themes/next/</code></li>\n<li>（如果使用CDN可跳过此步骤）克隆Github仓库至<code>themes/next/source/lib</code>路径下:<br> <code>git clone https://github.com/theme-next/theme-next-pace source/lib/pace</code></li>\n<li>配置NexT中的_config.xml，寻找pace选项并开启<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Progress bar in the top during page loading.</span></span><br><span class=\"line\"><span class=\"comment\"># 设置页面加载时顶部进度条</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/theme-next/theme-next-pace</span></span><br><span class=\"line\"><span class=\"comment\"># For more information: https://github.com/HubSpot/pace</span></span><br><span class=\"line\">pace:</span><br><span class=\"line\">  <span class=\"comment\"># enable: false</span></span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  <span class=\"comment\"># Themes list:</span></span><br><span class=\"line\">  <span class=\"comment\"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class=\"line\">  <span class=\"comment\"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class=\"line\">  theme: minimal</span><br></pre></td></tr></table></figure></li>\n<li>在NexT主题的_config.xml文件中找到vendors选项，设置pace的cdn地址（本人设置的进度条为黑色主题，可以在<a href=\"https://www.jsdelivr.com/package/npm/pace-js?path=themes\">jsdelivr</a>中找到对应的样式最新版cdn地址）<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">vendors:</span><br><span class=\"line\">  ...</span><br><span class=\"line\">pace: https:<span class=\"comment\">//cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js</span></span><br><span class=\"line\">pace_css: https:<span class=\"comment\">//cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/orange/pace-theme-loading-bar.css</span></span><br></pre></td></tr></table></figure>\n <strong>CDN</strong>的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何写博客\"><a href=\"#如何写博客\" class=\"headerlink\" title=\"如何写博客\"></a>如何写博客</h3><ol>\n<li>创建博客文章 <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo n <span class=\"string\">&quot;fileName&quot;</span></span><br></pre></td></tr></table></figure>\n 在目录 <code>博客根目录\\source\\_posts</code>会出现文件<code>fileName.md</code>，在该文件中写入你想写入的东西。</li>\n<li>产生(generate)博客内容<br>当你对文件<code>fileName.md</code>进行了更改，并且将它更新到你的博客上，执行此命令。 <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></li>\n<li>在本地查看博客内容 <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n 执行该命令后终端会显示这样的语句 <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">INFO  Hexo <span class=\"keyword\">is</span> running at http://localhost:<span class=\"number\">4000</span>/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>\n 意思是在本地网页<code>http://localhost:4000/</code>可以查看你的博客，你可以看到博客上出现了标题为<code>fileName</code>的文章，你对文件<code>fileName.md</code>的更改也更新到这里了。</li>\n<li>将博客内容部署到远端 <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n 执行此命令后，博客内容便部署到了远端。比如我将博客部署到了github，我在<a href=\"https://iridescent-zhang.github.io/\">iridescent-zhang</a>这里就能看到更新的博客了。</li>\n<li>清除hexo 缓存 <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n <code>hexo g</code>会产生缓存，不清除的话，有时候<code>hexo d</code>达不到预期效果，导致本地和远端显示的博客不一样。另外，<code>hexo d</code>花费较长时间，所以一般先在<code>hexo s</code>查看博客内容，确定没问题之后再部署到远端。</li>\n</ol>\n<h3 id=\"博客移植\"><a href=\"#博客移植\" class=\"headerlink\" title=\"博客移植\"></a>博客移植</h3><p>在新设备安装 hexo <code>cnpm install hexo-cli -g</code> ，<code>cnpm install</code> 安装一下依赖项，将原来本地站点的目录复制过来并替换原来文件即可。</p>\n<h3 id=\"隐藏博客文章\"><a href=\"#隐藏博客文章\" class=\"headerlink\" title=\"隐藏博客文章\"></a>隐藏博客文章</h3><p>参考<a href=\"https://blog.garryde.com/archives/37712.html\">hexo 隐藏博客</a></p>\n<h3 id=\"在博客文章中插入图片\"><a href=\"#在博客文章中插入图片\" class=\"headerlink\" title=\"在博客文章中插入图片\"></a>在博客文章中插入图片</h3><p><a href=\"https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/\">Hexo博客搭建之在文章中插入图片</a></p>\n<ol>\n<li><p>CND引用<br>将图片上传到一些免费的CDN服务中，会生成对应的url地址，直接引用即可；</p>\n</li>\n<li><p>本地引用<br>博客站点的<code>_config.yml</code>文件中设置<code>post_asset_folder: true</code>，执行命令<code>hexo n &quot;test&quot;</code>会在source&#x2F;_posts下生成test.md文件和对应的test文件夹，在test文件中可以存放图片img.jpg，在test.md中引用图片只需要使用语句<code>![](test/img.jpg)</code>，请严格按照格式，不要写成<code>![](/test/img.jpg)</code>。对于next的gemini主题我只找到了使用插件的方法，参考文章如下：</p>\n</li>\n</ol>\n<p>为了解决既能在vscode写博客时预览，上传博客时首页和文章内都能显示图片，以及引用图片的语句不太过逆天，同时使用了两个插件，实际上没有必要，一个个安装看效果是否满足即可。</p>\n<blockquote>\n<p>插件1(<a href=\"https://cloud.tencent.com/developer/article/1736563\">hexo博客中如何插入图片</a>)：<br><code>npm install hexo-renderer-marked</code>命令直接安装<br>站点_config.yml更改配置如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">post_asset_folder: true</span><br><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>插件2(<a href=\"https://cloud.tencent.com/developer/article/1600295?from=article.detail.1736563\">Hexo博客写作与图片处理的经验</a>)<br>这篇文章很厉害，可以好好看看<br><code>npm install hexo-image-link --save</code> 安装插件</p>\n</blockquote>\n<p>2023&#x2F;9&#x2F;29 电脑被黑客攻击后重装系统 重新布置blog<br>设置ssh密钥为123</p>\n<h3 id=\"配置hexo-next详细教程\"><a href=\"#配置hexo-next详细教程\" class=\"headerlink\" title=\"配置hexo next详细教程\"></a>配置hexo next详细教程</h3><p><a href=\"https://minyuchengmin.github.io/2020/02/26/hexo-bo-ke-xin-ban-next-zhu-ti-da-jian/#valine-comments\">主要参考</a><br><a href=\"https://blog.shijy16.cn/2021/05/13/%E9%85%8D%E7%BD%AE/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\">含个人域名重定向和HTTPS</a><br><a href=\"https://blog.garryde.com/archives/37712.html\">hexo 隐藏博客</a></p>\n<h3 id=\"something-else\"><a href=\"#something-else\" class=\"headerlink\" title=\"something else\"></a>something else</h3><p><a href=\"https://unsplash.com/\">unsplash</a><em>里的图片非常清爽，并且提供api服务，从中挑选博客背景图非常合适。</em></p>\n","categories":["blog"],"tags":["hexo"]},{"title":"C++Note","url":"/2023/02/23/C-Note/","content":"<p><strong>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。<br>学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"进入C\"><a href=\"#进入C\" class=\"headerlink\" title=\"进入C++\"></a>进入C++</h1><h2 id=\"C-简介\"><a href=\"#C-简介\" class=\"headerlink\" title=\"C++简介\"></a>C++简介</h2><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。<br>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>\n<p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p>\n<ul>\n<li>封装</li>\n<li>抽象</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<p>标准的 C++ 由三个重要部分组成：</p>\n<ul>\n<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>\n<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>\n<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>\n</ul>\n<p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。<br>由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p>\n<p>基本上每个应用程序领域的程序员都有使用 C++。<br>C++ 通常用于编写<strong>设备驱动程序</strong>和其他<strong>要求实时性地直接操作硬件</strong>的软件。<br>任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的<strong>主要用户接口</strong>是使用 C++ 编写的。</p>\n<p>这里安装 GNU 的 C&#x2F;C++ 编译器，也即GCC（The GNU Compiler Collection）。<br>要知道，GCC 官网提供的 GCC 编译器是无法直接安装到 Windows 平台上的，如果我们想在 Windows 平台使用 GCC 编译器，可以安装 GCC 的移植版本。</p>\n<p>目前适用于 Windows 平台、受欢迎的 GCC 移植版主要有 2 种，分别为 MinGW 和 Cygwin。其中，MinGW 侧重于服务 Windows 用户可以使用 GCC 编译环境，直接生成可运行 Windows 平台上的可执行程序，相比后者体积更小，使用更方便；而 Cygwin 则可以提供一个完整的 Linux 环境，借助它不仅可以在 Windows 平台上使用 GCC 编译器，理论上可以运行 Linux 平台上所有的程序。</p>\n<p>MinGw 全称 Minimalist GNU for Windows，应用于 Windows 平台，可以为我们提供一个功能有限的 Linux 系统环境以使用一些 GNU 工具，比如 GCC 编译器、gawk、bison 等等。</p>\n<h2 id=\"C-基本的输入输出\"><a href=\"#C-基本的输入输出\" class=\"headerlink\" title=\"C++ 基本的输入输出\"></a>C++ 基本的输入输出</h2><p>C++ 的 <strong>I&#x2F;O</strong> 发生在流中，<strong>流是字节序列</strong>。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。</p>\n<p>下列的头文件在 C++ 编程中很重要:</p>\n<ul>\n<li><iostream>: 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</li>\n<li><iomanip>: 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I&#x2F;O 有用的服务。</li>\n<li><fstream>: 该文件为用户控制的文件处理声明服务。</li>\n</ul>\n<h3 id=\"标准输出流（cout）\"><a href=\"#标准输出流（cout）\" class=\"headerlink\" title=\"标准输出流（cout）\"></a>标准输出流（cout）</h3><p><strong>预定义的对象</strong> cout 是 iostream <strong>类</strong>的一个<strong>实例</strong>。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与<strong>流插入运算符 &lt;&lt;</strong> 结合使用的。</p>\n<p>C++ <strong>编译器</strong>根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符<strong>被重载</strong>来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。<br>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如<code>cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;</code>，endl 用于在行末添加一个换行符。</p>\n<h3 id=\"标准输入流（cin）\"><a href=\"#标准输入流（cin）\" class=\"headerlink\" title=\"标准输入流（cin）\"></a>标准输入流（cin）</h3><p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与<strong>流提取运算符 &gt;&gt;</strong> 结合使用的。</p>\n<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>\n<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用语句：<code>cin &gt;&gt; name &gt;&gt; age;</code></p>\n<h3 id=\"标准错误流（cerr）\"><a href=\"#标准错误流（cerr）\" class=\"headerlink\" title=\"标准错误流（cerr）\"></a>标准错误流（cerr）</h3><p>预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流<strong>插入到 cerr</strong> 都会立即输出。</p>\n<p>cerr 也是与流插入运算符 &lt;&lt; 结合使用的，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   cerr &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"标准日志流（clog）\"><a href=\"#标准日志流（clog）\" class=\"headerlink\" title=\"标准日志流（clog）\"></a>标准日志流（clog）</h3><p>预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到<strong>缓冲填满或者缓冲区刷新时</strong>才会输出。</p>\n<p>clog 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   clog &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><p>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">type_name</span> &#123;</span><br><span class=\"line\">member_type1 member_name1;</span><br><span class=\"line\">member_type2 member_name2;</span><br><span class=\"line\">member_type3 member_name3;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125; object_names;</span><br></pre></td></tr></table></figure>\n\n<p>type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量（object_names）。</p>\n<p>访问结构成员可以使用成员访问运算符（.），如<code>object_names.member_name1</code>。<br>对于指向结构的指针，其成员访问方式有变化，可以使用（-&gt;）来访问结构体成员。<br>参考如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">type_name</span> * object_ptr; <span class=\"comment\">//现在，您可以在这里定义的指针变量中存储结构变量的地址，为了查找结构变量的地址，请把 &amp; 运算符放在结构变量的前面</span></span><br><span class=\"line\">object_ptr = &amp;object_names;</span><br><span class=\"line\">object_ptr -&gt; member_name1 <span class=\"comment\">//为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，等效于object_names.member_name1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>另外，在函数参数中使用结构体，需要这样定义：<code>void test( struct type_name object_names )</code>，使用结构体指针也是一样的<code>void test( struct type_name *object_names )</code> 。</p>\n<p>使用 <strong>typedef 关键字</strong>为创建的结构类型取一个”别名”。typedef最后面的是别名，define中间的是别名。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];</span><br><span class=\"line\">   <span class=\"type\">int</span>   book_id;</span><br><span class=\"line\">&#125;alias;</span><br></pre></td></tr></table></figure>\n<p>现在，您<strong>可以直接使用 alias 来定义 struct Books 类型的变量</strong>，而不需要使用 struct 关键字。例如：<br><code>alias Book1, Book2 ;</code><br>还可以使用 typedef 关键字来<strong>定义非结构体类型</strong>，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">int</span> *  pint32;</span><br><span class=\"line\"> </span><br><span class=\"line\">pint32 x, y, z; <span class=\"comment\">//x, y 和 z 都是指向长整型 long int数据 的指针。</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"需要知道的小知识\"><a href=\"#需要知道的小知识\" class=\"headerlink\" title=\"需要知道的小知识\"></a>需要知道的小知识</h2><h3 id=\"malloc-new\"><a href=\"#malloc-new\" class=\"headerlink\" title=\"malloc  new\"></a>malloc  new</h3><p>原型：<code>extern void *malloc(unsigned int num_bytes);</code><br>头文件：<code>#include &lt;malloc.h</code>&gt;</p>\n<p>功能：分配长度为num_bytes<strong>字节</strong>的内存块<br>说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。<br>当内存不再使用时，应使用**free()**函数将内存块释放。</p>\n<p>说明：malloc 向系统申请分配指定size个字节的内存空间。<em><em>返回类型是 void</em> 类型</em><em>。void</em> 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。如：<br><code>p=(char *)malloc(100);  </code></p>\n<h4 id=\"malloc与new的不同点\"><a href=\"#malloc与new的不同点\" class=\"headerlink\" title=\"malloc与new的不同点\"></a>malloc与new的不同点</h4><p>malloc 和 new 至少有两个不同: <strong>new 返回指定类型的指针，并且可以自动计算所需要的字节的数量</strong>。比如：<br><code>int *p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int)即四个字节;</code></p>\n<p>还有：<br><code>int *p = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;</code><br>而 malloc 则<strong>必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针</strong>。</p>\n<p><code>int *p = (int *) malloc (sizeof(int));</code></p>\n<ol>\n<li>malloc 函数返回的是 void * 类型，如果你写成：<code>p = malloc (sizeof(int)); </code>则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换。</li>\n<li>函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成：<br><code>int* p = (int *) malloc (1);</code><br>代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容全部被清空。</li>\n</ol>\n<p>malloc 也可以达到 new [] 的效果，申请出一段连续的内存，方法无非是指定你所需要内存大小。<br>比如想分配100个int类型的空间：<br><code>int* p = (int *) malloc ( sizeof(int)*100 );//分配可以放得下100个整数的内存空间。</code> </p>\n<p>另外有一点不能直接看出的区别是，<strong>malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的</strong>。</p>\n<p>除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致。</p>\n<h4 id=\"new-和-delete\"><a href=\"#new-和-delete\" class=\"headerlink\" title=\"new 和 delete\"></a>new 和 delete</h4><p><strong>给指针初始化指向的数据地址</strong>(这一步很重要)，常见的有两种方式。一种是，直接<strong>将指针指向当前已存在的变量的地址</strong>，另一种就是使用<strong>new</strong>或者C语言中的<strong>malloc</strong>函数<strong>动态分配</strong>的地址。</p>\n<p>两种初始化方式是有很大区别的，主要区别如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">初始化指向变量地址的方法是在程序栈中分配变量的内存；</span><br><span class=\"line\"><span class=\"keyword\">new</span>动态堆内存分配，是在未使用的中分配的，如果内存不够，那么<span class=\"keyword\">new</span>将会返回一个异常处理；</span><br><span class=\"line\"><span class=\"keyword\">new</span>动态分配，需要用<span class=\"keyword\">delete</span>释放内存；</span><br></pre></td></tr></table></figure>\n\n<p><strong>delete的操作一般是和new动态内存分配成对出现的</strong>。delete的作用是将内存释放并归还给内存池，从而高效的使用内存。值得注意的是虽然delete会释放掉指针指向的内存，<strong>但是并不会删除指针</strong>，因此在删除delete指针后，如果代码后面有需要也可一再次给指针分配地址。<br><code>delete p;</code></p>\n<h4 id=\"new-x2F-delete和malloc-x2F-free之间的区别\"><a href=\"#new-x2F-delete和malloc-x2F-free之间的区别\" class=\"headerlink\" title=\"new&#x2F;delete和malloc&#x2F;free之间的区别\"></a>new&#x2F;delete和malloc&#x2F;free之间的区别</h4><p>相同点：都是用了分配和释放动态内存的<br>本质上：new&#x2F;delete是<strong>C++中的运算符</strong>，而malloc&#x2F;free只是其C&#x2F;C++中的某一个库函数<br>类型安全性：new&#x2F;delete是安全的，而malloc&#x2F;free不是安全的:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* a = <span class=\"keyword\">new</span> <span class=\"type\">float</span>; <span class=\"comment\">//这样在编译时就会报错</span></span><br><span class=\"line\"><span class=\"type\">int</span>* a = <span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>)); <span class=\"comment\">//编译器不会报错，因此在程序执行时错误未知</span></span><br></pre></td></tr></table></figure>\n<p>用法：malloc<strong>必须要进行强制类型转换和需要sizeof求出需要的字节数</strong>，且对于<strong>用户自己定义的对象</strong>也不方便用malloc和free来管理，因为不能够执行构造函数和析构函数。而new可以这样用：<br><code>TreeNode *node = new TreeNode(value);</code></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>malloc()函数其实就在内存中找一片指定大小的空间，然后将这个空间的<strong>首地址</strong>赋值给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址，这要看malloc()函数中参数size的具体内容。我们这里malloc分配的内存空间在<strong>逻辑上连续</strong>的，而在物理上可以连续也可以不连续。对于我们程序员来说，我们<strong>关注的是逻辑上的连续</strong>，因为操作系统会帮我们安排内存分配，所以我们使用起来就可以当做是连续的。</p>\n<h3 id=\"memset\"><a href=\"#memset\" class=\"headerlink\" title=\"memset\"></a>memset</h3><p>memset() 函数可以说是初始化内存的“万能函数”，通常为新申请的内存进行初始化工作。它是直接操作内存空间，该函数的原型为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">memset</span><span class=\"params\">(<span class=\"type\">void</span> *s, <span class=\"type\">int</span> c, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>函数的功能是：将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。<em><em>s 是 void</em> 型的指针变量，所以它可以为任何类型的数据进行初始化</em>*。<br>memset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。</p>\n<p>memset 函数的第三个参数 n 的值一般用 sizeof()  获取，这样比较专业。<br>注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万别写成 sizeof(p)，这是新手经常会犯的错误。因为 p 是指针变量，不管 p 指向什么类型的变量，sizeof(p) 的值都是 4。</p>\n<h3 id=\"explicit-关键字\"><a href=\"#explicit-关键字\" class=\"headerlink\" title=\"explicit 关键字\"></a>explicit 关键字</h3><p>首先, C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显式的, 而非隐式的,。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。</p>\n<p><strong>explicit关键字的作用就是防止类构造函数的隐式自动转换。</strong></p>\n<p>google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。<br>　　effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。</p>\n<p><a href=\"https://www.cnblogs.com/rednodel/p/9299251.html\">C++ explicit关键字详解</a></p>\n<h3 id=\"define-和-typedef\"><a href=\"#define-和-typedef\" class=\"headerlink\" title=\"define 和 typedef\"></a>define 和 typedef</h3><p>typedef在前面的<strong>结构体</strong>小节中提到过了。</p>\n<h3 id=\"vscode插件\"><a href=\"#vscode插件\" class=\"headerlink\" title=\"vscode插件\"></a>vscode插件</h3><p>学一下<br>Bookmarks<br>Doxygen Documentation Generator<br>Todo Tree<br>Better Comments<br>ChatGpt类应用</p>\n<h1 id=\"C-高级教程\"><a href=\"#C-高级教程\" class=\"headerlink\" title=\"C++高级教程\"></a>C++高级教程</h1><h2 id=\"cmake\"><a href=\"#cmake\" class=\"headerlink\" title=\"cmake\"></a>cmake</h2><p><code>cmake -G &quot;MinGW Makefiles&quot; ..</code> (这里的 <code>..</code> 指的是上级目录，后面会说)指明让cmake生成 <code>mingw32-make</code> 使用的 makefile 文件，cmake默认会使用 windows 的 nmake 程序（本机没有所以提示找不到nmake）</p>\n<p>mingw32-make 对 makefile 使用 <code>make</code> 命令可以生成可执行程序。</p>\n<p>由于所有MinGW教程都会说将mingw64\\bin目录下的“mingw32-make.exe”复制一份并改名为 “make.exe”，就可以在终端直接使用 “make”指令而不必使用“mingw32-make”指令，我当时安装的时候以为只需要保留一份副本备份就行，所以保留了一个“mingw32-make-副本.exe”，导致cmake找不到“mingw32-make.exe”，进而前面说的cmake命令一直失败。</p>\n<p>使用cmake编译步骤(在源代码文件夹打开终端，这个文件夹中需要包含<strong>CMakeLists.txt</strong>)：</p>\n<ol>\n<li>编写CMakeLists.txt文件</li>\n<li>使用命令 <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir build</span><br><span class=\"line\">cd build</span><br><span class=\"line\">cmake -G “MinGW Makefiles” ..</span><br></pre></td></tr></table></figure>\n 这是因为cmake编译会产生一些文件，为避免污染 源文件 所在的文件夹，建立build文件夹来存放编译文件。</li>\n<li>编译<br> 运行命令<code>make</code>生成可执行程序</li>\n</ol>\n<p><strong>gcc、make、Makefile、CMake 与 CMakeLists</strong></p>\n<p>gcc(<strong>GNU Compiler Collection</strong>)可以看成是GNU编译器套件，可以编译C、C++、Objective-C、Java等多种编程语言。<br>当程序中只有很少个源文件时，可以直接使用gcc进行编译。但是当程序中包含很多个源文件时，使用gcc命令逐个文件编译的工作量很大且容易出错。<br>这时候就可以借助make工具进行<strong>批量编译和链接</strong>。</p>\n<p> <strong>make本身不具有编译和链接的功能</strong>，而是<strong>类似于一个智能的批处理工具</strong>，通过<strong>调用Makefile文件中用户指定的命令</strong>进行编译和链接。</p>\n<p>Makefile文件中<strong>定义了一套调用 gcc 编译源文件的命令</strong>。简单工程的Makefile文件可以手动编写，当工程比较大的时候手动编写Makefile文件也很麻烦，并且<strong>Makefile中的指令是平台相关的，换个平台还需要再修改</strong>。<br>这时候就可以<strong>使用CMake工具自动生成Makefile文件</strong>。</p>\n<p>CMake工具可以<strong>以更加简单的方式自动生成Makefile文件</strong>，跨平台时只需要告诉CMake目标平台类型，就可以自动生成目标平台可使用的Makefile文件。<br>CMake<strong>依赖（或根据）CMakeLists.txt文件</strong>自动生成Makefile。</p>\n<p><strong>CMakeLists.txt需要手动编写</strong>。</p>\n<p>CMake工具和CMakeLists.txt是一对好基友， make工具和Makefile是另一对好基友。</p>\n<p>CMake要解决的问题是<strong>项目要在不同平台不同编译器下都可以依据一个统一的脚本（CMakeLists.txt）进行构建</strong>的问题。忽略不同平台的差异，抽象成为一个一致的环境。<br>make要解决的问题是<strong>在一个特定的平台环境上依据当前平台的脚本</strong>（Makefile），调用gcc（或其他编译器）对<strong>源文件进行批量编译链接</strong>的问题。</p>\n<p>CMake是一个比make更高级的编译配置工具，它可以根据不同平台、不同的编译器，生成相应的Makefile，达到<strong>一个编写</strong>，<strong>多环境下可编译</strong>的效果。</p>\n<p>所以使用CMake编写一个<strong>跨平台的工程</strong>的基本流程是：</p>\n<ol>\n<li>编写代码源文件</li>\n<li>编写CMakeLists.txt（依据CMake的语法规格和格式）</li>\n<li>使用CMake工具根据CMakeLists.txt生成Makefile</li>\n<li>使用make工具根据Makefile，调用gcc编译链接生成可执行目标文件</li>\n</ol>\n<img src=\"/2023/02/23/C-Note/23.png\" class=\"\">\n\n<p>参考自 <a href=\"https://blog.csdn.net/dcrmg/article/details/103918543\">windows下 CMake+MinGW 搭建C&#x2F;C++编译环境</a> 总结的很好</p>\n<h2 id=\"C-类-amp-对象\"><a href=\"#C-类-amp-对象\" class=\"headerlink\" title=\"C++ 类 &amp; 对象\"></a>C++ 类 &amp; 对象</h2><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为<strong>用户定义的类型</strong>。<br><strong>类用于指定对象的形式</strong>，它包含了<strong>数据表示法和用于处理数据的方法</strong>。类中的数据和方法称为<strong>类的成员</strong>。函数在一个类中被称为类的成员。</p>\n<h3 id=\"C-类定义\"><a href=\"#C-类定义\" class=\"headerlink\" title=\"C++ 类定义\"></a>C++ 类定义</h3><p>定义一个类，本质上是<strong>定义一个数据类型的蓝图</strong>。这实际上并没有定义任何数据，但它定义了<strong>类的名称意味着什么</strong>，也就是说，它定义了<strong>类的对象</strong>包括了什么，以及<strong>可以在这个对象上执行哪些操作</strong>。</p>\n<img src=\"/2023/02/23/C-Note/1.png\" class=\"\">\n\n<p>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:<span class=\"comment\">//关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。</span></span><br><span class=\"line\">      <span class=\"type\">double</span> length;   <span class=\"comment\">// 盒子的长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;  <span class=\"comment\">// 盒子的宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;   <span class=\"comment\">// 盒子的高度</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定义-C-对象\"><a href=\"#定义-C-对象\" class=\"headerlink\" title=\"定义 C++ 对象\"></a>定义 C++ 对象</h3><p><strong>类提供了对象的蓝图</strong>，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Box Box1;          <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">Box Box2;          <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\"><span class=\"comment\">//对象 Box1 和 Box2 都有它们各自的数据成员。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"访问数据成员\"><a href=\"#访问数据成员\" class=\"headerlink\" title=\"访问数据成员\"></a>访问数据成员</h3><p><strong>类的对象</strong>的<strong>公共（public）数据成员</strong>可以使用<strong>直接成员访问运算符（.）</strong> 来访问。<br>需要注意的是，<strong>私有的成员和受保护的成员</strong>不能使用直接成员访问运算符 (.) 来直接访问。<br>实例如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;   <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;  <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;   <span class=\"comment\">// 高度</span></span><br><span class=\"line\">      <span class=\"comment\">// 成员函数声明</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set</span><span class=\"params\">( <span class=\"type\">double</span> len, <span class=\"type\">double</span> bre, <span class=\"type\">double</span> hei )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Box::get</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Box::set</span><span class=\"params\">( <span class=\"type\">double</span> len, <span class=\"type\">double</span> bre, <span class=\"type\">double</span> hei)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">    breadth = bre;</span><br><span class=\"line\">    height = hei;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box Box1;        <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;        <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   Box Box3;        <span class=\"comment\">// 声明 Box3，类型为 Box</span></span><br><span class=\"line\">   <span class=\"type\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 用于存储体积</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 1 详述</span></span><br><span class=\"line\">   Box1.height = <span class=\"number\">5.0</span>; </span><br><span class=\"line\">   Box1.length = <span class=\"number\">6.0</span>; </span><br><span class=\"line\">   Box1.breadth = <span class=\"number\">7.0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 2 详述</span></span><br><span class=\"line\">   Box2.height = <span class=\"number\">10.0</span>;</span><br><span class=\"line\">   Box2.length = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">   Box2.breadth = <span class=\"number\">13.0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 1 的体积</span></span><br><span class=\"line\">   volume = Box1.height * Box1.length * Box1.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 2 的体积</span></span><br><span class=\"line\">   volume = Box2.height * Box2.length * Box2.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 3 详述</span></span><br><span class=\"line\">   Box3.<span class=\"built_in\">set</span>(<span class=\"number\">16.0</span>, <span class=\"number\">8.0</span>, <span class=\"number\">12.0</span>); </span><br><span class=\"line\">   volume = Box3.<span class=\"built_in\">get</span>(); </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box3 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类成员函数\"><a href=\"#类成员函数\" class=\"headerlink\" title=\"类成员函数\"></a>类成员函数</h3><p>上面例子中的set()和get()都是类成员函数，类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以<strong>操作类的任意对象</strong>，可以<strong>访问对象中的所有成员</strong>。<br>成员函数可以<strong>定义</strong>在类定义内部，或者单独使用<strong>范围解析运算符</strong>::来定义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度</span></span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Box::getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两种成员函数定义方法等价。需要强调一点，<strong>在 :: 运算符之前必须使用类名</strong>。调用成员函数是<strong>在对象上</strong>使用点运算符（.），这样它就能<strong>操作与该对象相关的数据</strong>。</p>\n<hr>\n<h3 id=\"C-类构造函数-amp-析构函数\"><a href=\"#C-类构造函数-amp-析构函数\" class=\"headerlink\" title=\"C++ 类构造函数 &amp; 析构函数\"></a>C++ 类构造函数 &amp; 析构函数</h3><p><strong>类的构造函数</strong><br>类的构造函数是类的一种特殊的成员函数，它会在<strong>每次创建类的新对象</strong>时执行。<br><strong>构造函数的名称与类的名称是完全相同的</strong>，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Line</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span>;</span><br><span class=\"line\">      <span class=\"built_in\">Line</span>();  <span class=\"comment\">// 这是构造函数</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::<span class=\"built_in\">Line</span>(<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Line::setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Line::getLength</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Line line;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">   line.<span class=\"built_in\">setLength</span>(<span class=\"number\">6.0</span>); </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class=\"built_in\">getLength</span>() &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在<strong>创建对象时就会给对象赋初始值</strong>，这样便可以创造出带初始值的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Line</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span>;</span><br><span class=\"line\">      <span class=\"built_in\">Line</span>(<span class=\"type\">double</span> len);  <span class=\"comment\">// 这是构造函数</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::<span class=\"built_in\">Line</span>( <span class=\"type\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Line::setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Line::getLength</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Line <span class=\"title\">line</span><span class=\"params\">(<span class=\"number\">10.0</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 获取默认设置的长度</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class=\"built_in\">getLength</span>() &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"comment\">// 再次设置长度</span></span><br><span class=\"line\">   line.<span class=\"built_in\">setLength</span>(<span class=\"number\">6.0</span>); </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class=\"built_in\">getLength</span>() &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>类的析构函数</strong></p>\n<p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>\n<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>\n<hr>\n<h3 id=\"类访问修饰符\"><a href=\"#类访问修饰符\" class=\"headerlink\" title=\"类访问修饰符\"></a>类访问修饰符</h3><p><strong>数据封装是面向对象编程的一个重要特点</strong>，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。<strong>关键字 public、private、protected 称为访问修饰符</strong>。<br>一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的<strong>默认访问修饰符是 private</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 公有成员</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 受保护成员</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 私有成员</span></span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>公有（public）成员</strong>：公有成员在<strong>程序中类的外部是可访问的</strong>。您可以<strong>不使用任何成员函数来设置和获取公有变量的值</strong>，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Line</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Line::getLength</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Line::setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Line line;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">   line.<span class=\"built_in\">setLength</span>(<span class=\"number\">6.0</span>); </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class=\"built_in\">getLength</span>() &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置长度</span></span><br><span class=\"line\">   line.length = <span class=\"number\">10.0</span>; <span class=\"comment\">// OK: 因为 length 是公有的</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Length of line : &quot;</span> &lt;&lt; line.length &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>私有（private）成员</strong>: 私有成员<strong>变量或函数在类的外部是不可访问的，甚至是不可查看的</strong>。只有<strong>类内部和友元函数可以访问</strong>私有成员。<br>默认情况下，类的所有成员都是私有的。例如在下面的类中，width 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">double</span> width;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"type\">double</span> wid )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getWidth</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实际操作中，我们一般会在<strong>私有区域定义数据，在公有区域定义相关的函数</strong>，以便在类的外部也可以调用这些函数，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"type\">double</span> wid )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getWidth</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> width;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Box::getWidth</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> width ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Box::setWidth</span><span class=\"params\">( <span class=\"type\">double</span> wid )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box box;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置长度</span></span><br><span class=\"line\">   box.length = <span class=\"number\">10.0</span>; <span class=\"comment\">// OK: 因为 length 是公有的</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Length of box : &quot;</span> &lt;&lt; box.length &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置宽度</span></span><br><span class=\"line\">   <span class=\"comment\">// box.width = 10.0; // Error: 因为 width 是私有的</span></span><br><span class=\"line\">   box.<span class=\"built_in\">setWidth</span>(<span class=\"number\">10.0</span>);  <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Width of box : &quot;</span> &lt;&lt; box.<span class=\"built_in\">getWidth</span>() &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>protected（受保护）成员</strong>:<br>protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在<strong>派生类（即子类）中是可访问</strong>的。</p>\n<p>下面的实例中，我们从父类 Box 派生了一个子类 smallBox。在这里 width 成员可被<strong>派生类(即子类)smallBox 的任何成员函数</strong>访问。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> width;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SmallBox</span>:Box <span class=\"comment\">// SmallBox 是派生类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setSmallWidth</span><span class=\"params\">( <span class=\"type\">double</span> wid )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getSmallWidth</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 子类的成员函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">SmallBox::getSmallWidth</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> width ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmallBox::setSmallWidth</span><span class=\"params\">( <span class=\"type\">double</span> wid )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   SmallBox box;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   box.<span class=\"built_in\">setSmallWidth</span>(<span class=\"number\">5.0</span>);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Width of box : &quot;</span>&lt;&lt; box.<span class=\"built_in\">getSmallWidth</span>() &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承中的特点\"><a href=\"#继承中的特点\" class=\"headerlink\" title=\"继承中的特点\"></a>继承中的特点</h3><p>有public, protected, private三种继承方式，它们相应地改变了基类(父类)成员的访问属性。</p>\n<ul>\n<li><strong>public 继承</strong>：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</li>\n<li><strong>protected 继承</strong>：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</li>\n<li><strong>private 继承</strong>：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</li>\n</ul>\n<p>但无论哪种继承方式，上面两点都没有改变：</p>\n<ul>\n<li>private 成员只能被本类成员（类内）和友元函数访问，不能被派生类访问；</li>\n<li>protected 成员可以被派生类访问。</li>\n</ul>\n<p><strong>注意：C中如果函数未指定返回值类型，则默认为int。C++中如果一个函数没有返回值，返回值类型必须指定为void。但要区别于类的构造函数</strong></p>\n<p><strong>public继承：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">A</span>()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a1 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a2 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a3 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">B</span>(<span class=\"type\">int</span> i)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;       <span class=\"comment\">//正确，public成员</span></span><br><span class=\"line\">    cout &lt;&lt; a1 &lt;&lt; endl;       <span class=\"comment\">//正确，基类的public成员，在派生类中仍是public成员。</span></span><br><span class=\"line\">    cout &lt;&lt; a2 &lt;&lt; endl;       <span class=\"comment\">//正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。</span></span><br><span class=\"line\">    cout &lt;&lt; a3 &lt;&lt; endl;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt; b.a &lt;&lt; endl;</span><br><span class=\"line\">  cout &lt;&lt; b.a1 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  cout &lt;&lt; b.a2 &lt;&lt; endl;   <span class=\"comment\">//错误，类外不能访问protected成员</span></span><br><span class=\"line\">  cout &lt;&lt; b.a3 &lt;&lt; endl;   <span class=\"comment\">//错误，类外不能访问private成员</span></span><br><span class=\"line\">  <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>protected继承：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">A</span>()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a1 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a2 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a3 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">protected</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">B</span>(<span class=\"type\">int</span> i)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;       <span class=\"comment\">//正确，public成员。</span></span><br><span class=\"line\">    cout &lt;&lt; a1 &lt;&lt; endl;       <span class=\"comment\">//正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。</span></span><br><span class=\"line\">    cout &lt;&lt; a2 &lt;&lt; endl;       <span class=\"comment\">//正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。</span></span><br><span class=\"line\">    cout &lt;&lt; a3 &lt;&lt; endl;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt; b.a &lt;&lt; endl;       <span class=\"comment\">//正确。public成员</span></span><br><span class=\"line\">  cout &lt;&lt; b.a1 &lt;&lt; endl;      <span class=\"comment\">//错误，protected成员不能在类外访问。</span></span><br><span class=\"line\">  cout &lt;&lt; b.a2 &lt;&lt; endl;      <span class=\"comment\">//错误，protected成员不能在类外访问。</span></span><br><span class=\"line\">  cout &lt;&lt; b.a3 &lt;&lt; endl;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>private继承：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">A</span>()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a1 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a2 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    cout &lt;&lt; a3 &lt;&lt; endl;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">private</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">B</span>(<span class=\"type\">int</span> i)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;       <span class=\"comment\">//正确，public成员。</span></span><br><span class=\"line\">    cout &lt;&lt; a1 &lt;&lt; endl;       <span class=\"comment\">//正确，基类public成员,在派生类中变成了private,可以被派生类访问。</span></span><br><span class=\"line\">    cout &lt;&lt; a2 &lt;&lt; endl;       <span class=\"comment\">//正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。</span></span><br><span class=\"line\">    cout &lt;&lt; a3 &lt;&lt; endl;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  cout &lt;&lt; b.a &lt;&lt; endl;       <span class=\"comment\">//正确。public成员</span></span><br><span class=\"line\">  cout &lt;&lt; b.a1 &lt;&lt; endl;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  cout &lt;&lt; b.a2 &lt;&lt; endl;      <span class=\"comment\">//错误, private成员不能在类外访问。</span></span><br><span class=\"line\">  cout &lt;&lt; b.a3 &lt;&lt; endl;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意分辨其中区别，如果是public继承，三种成员在派生类中还是不变的，但是<strong>派生类不能访问基类的private成员</strong>；如果是protected继承，基类的public和private变为在派生类中都变为protected成员，因此在类中可以访问，但是类外不行，基类的private成员依然不能访问，无论是类中还是类外；如果是private继承，基类的public和protected成员变为派生类中的private成员，类中可以访问，类外不行，且基类的private成员仍然不能在类中或类外访问。</p>\n<p>如果继承的时候不显式声明是 private，protected，public 继承，则<strong>class 默认是 private 继承</strong>，<strong>struct默认是public继承</strong>。另外，类中不写是什么类型的成员，默认是private。</p>\n<p>总结一下三种继承方式：</p>\n<img src=\"/2023/02/23/C-Note/2.png\" class=\"\">\n\n<h2 id=\"关于C-中的struct和class\"><a href=\"#关于C-中的struct和class\" class=\"headerlink\" title=\"关于C++中的struct和class\"></a>关于C++中的struct和class</h2><p>C++ 中的 struct 对 C 中的 struct 进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。</p>\n<p>struct 能包含成员函数吗？ 能！</p>\n<p>struct 能继承吗？ 能！！</p>\n<p>struct 能实现多态吗？ 能！！！</p>\n<p>既然这些它都能实现，那它和 class 还能有什么区别？</p>\n<p>最本质的一个区别就是默认的访问控制，体现在两个方面：</p>\n<p>1）默认的继承访问权限。struct是public的，class是private的。</p>\n<p>你可以写如下的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">B</span> : A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个时候 B 是 public 继承 A 的。</p>\n<p>如果都将上面的 struct 改成 class，那么 B 是 private 继承 A 的。这就是默认的继承访问权限。</p>\n<p>所以我们在平时写类继承的时候，通常会这样写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br></pre></td></tr></table></figure>\n<p>就是为了指明是 public 继承，而不是用默认的 private 继承。</p>\n<p>当然，到底默认是 public 继承还是 private 继承，取决于子类而不是基类。</p>\n<p>我的意思是，struct 可以继承 class，同样 class 也可以继承 struct，那么默认的继承访问权限是看子类到底是用的 struct 还是 class。如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span>&#123;&#125;; </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : A&#123;&#125;; <span class=\"comment\">//private继承</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">C</span> : B&#123;&#125;; <span class=\"comment\">//public继承</span></span><br></pre></td></tr></table></figure>\n<p>2）struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</p>\n<p>注意我上面的用词，我依旧强调 struct 是一种数据结构的实现体，虽然它是可以像 class 一样的用。我依旧将 struct 里的变量叫数据，class 内的变量叫成员，虽然它们并无区别。</p>\n<p>其实，到底是用 struct 还是 class，完全看个人的喜好，你可以将你程序里所有的 class 全部替换成 struct，它依旧可以很正常的运行。但我给出的最好建议，还是：当你觉得你要做的更像是一种数据结构的话，那么用 struct，如果你要做的更像是一种对象的话，那么用 class。</p>\n<p>当然，我在这里还要强调一点的就是，对于访问控制，应该在程序里明确的指出，而不是依靠默认，这是一个良好的习惯，也让你的代码更具可读性。</p>\n<p>说到这里，很多了解的人或许都认为这个话题可以结束了，因为他们知道 struct 和 class 的“唯一”区别就是访问控制。很多文献上也确实只提到这一个区别。</p>\n<p>但我上面却没有用“唯一”，而是说的“最本质”，那是因为，它们确实还有另一个区别，虽然那个区别我们平时可能很少涉及。那就是：“class” 这个关键字还用于定义模板参数，就像 “typename”。但关键字 “struct” 不用于定义模板参数。这一点在 Stanley B.Lippman 写的 Inside the C++ Object Model 有过说明。</p>\n<p>问题讨论到这里，基本上应该可以结束了。但有人曾说过，他还发现过其他的“区别”，那么，让我们来看看，这到底是不是又一个区别。还是上面所说的，C++ 中的 struct 是对 C 中的 struct 的扩充，既然是扩充，那么它就要兼容过去 C 中 struct 应有的所有特性。例如你可以这样写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> <span class=\"comment\">//定义一个struct</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> c1;</span><br><span class=\"line\">    <span class=\"type\">int</span> n2;</span><br><span class=\"line\">    <span class=\"type\">double</span> db3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">A a=&#123;<span class=\"string\">&#x27;p&#x27;</span>,<span class=\"number\">7</span>,<span class=\"number\">3.1415926</span>&#125;; <span class=\"comment\">//定义时直接赋值</span></span><br></pre></td></tr></table></figure>\n<p>也就是说 struct 可以在定义的时候用 {} 赋初值。那么问题来了，class 行不行呢？将上面的 struct 改成 class，试试看。报错！噢~于是那人跳出来说，他又找到了一个区别。我们仔细看看，这真的又是一个区别吗？</p>\n<p>你试着向上面的 struct 中加入一个构造函数（或虚函数），你会发现什么？</p>\n<p>对，struct 也不能用 {} 赋初值了。</p>\n<p>的确，以 {} 的方式来赋初值，只是用一个初始化列表来对数据进行按顺序的初始化，如上面如果写成 A a&#x3D;{‘p’,7}; 则 c1,n2 被初始化，而 db3 没有。这样简单的 copy 操作，只能发生在简单的数据结构上，而不应该放在对象上。加入一个构造函数或是一个虚函数会使 struct 更体现出一种对象的特性，而使此{}操作不再有效。</p>\n<p>事实上，是因为加入这样的函数，使得类的内部结构发生了变化。而加入一个普通的成员函数呢？你会发现{}依旧可用。其实你可以将普通的函数理解成对数据结构的一种算法，这并不打破它数据结构的特性。</p>\n<p>那么，看到这里，我们发现即使是 struct 想用 {} 来赋初值，它也必须满足很多的约束条件，这些条件实际上就是让 struct 更体现出一种数据机构而不是类的特性。</p>\n<p>那为什么我们在上面仅仅将 struct 改成 class，{} 就不能用了呢？</p>\n<p>其实问题恰巧是我们之前所讲的——访问控制！你看看，我们忘记了什么？对，将 struct 改成 class 的时候，访问控制由 public 变为 private 了，那当然就不能用 {} 来赋初值了。加上一个 public，你会发现，class 也是能用 {} 的，和 struct 毫无区别！！！</p>\n<p>做个总结，从上面的区别，我们可以看出，<strong>struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体</strong>。</p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。<br>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>\n<h3 id=\"访问控制和继承\"><a href=\"#访问控制和继承\" class=\"headerlink\" title=\"访问控制和继承\"></a>访问控制和继承</h3><p><strong>派生类可以访问基类中所有的非私有成员</strong>。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>\n<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>\n<img src=\"/2023/02/23/C-Note/3.png\" class=\"\">\n\n<p>一个派生类<strong>继承了所有的基类方法</strong>，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数</li>\n<li>基类的重载运算符</li>\n<li>基类的友元函数</li>\n</ul>\n<h3 id=\"继承类型\"><a href=\"#继承类型\" class=\"headerlink\" title=\"继承类型\"></a>继承类型</h3><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>\n<p>我们几乎不使用 protected 或 private 继承，<strong>通常使用</strong> public 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul>\n<li>公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li>\n<li>保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li>\n<li>私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li>\n</ul>\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>\n<p>C++ 类可以从多个类继承成员，语法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> &lt;派生类名&gt;:&lt;继承方式<span class=\"number\">1</span>&gt;&lt;基类名<span class=\"number\">1</span>&gt;,&lt;继承方式<span class=\"number\">2</span>&gt;&lt;基类名<span class=\"number\">2</span>&gt;,…</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&lt;派生类类体&gt;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-重载运算符和重载函数\"><a href=\"#C-重载运算符和重载函数\" class=\"headerlink\" title=\"C++ 重载运算符和重载函数\"></a>C++ 重载运算符和重载函数</h2><p>C++ 允许在<strong>同一作用域中</strong>的某个函数和运算符<strong>指定多个定义</strong>，分别称为函数重载和运算符重载。<br>重载声明是指一个与<strong>之前已经在该作用域内声明过的函数或方法</strong>具有<strong>相同名称</strong>的声明，但是它们的参数列表和定义（实现）不相同。<br>当您调用一个<strong>重载函数或重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行<strong>比较</strong>，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>\n<h3 id=\"重载函数\"><a href=\"#重载函数\" class=\"headerlink\" title=\"重载函数:\"></a>重载函数:</h3><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的<strong>形式参数（指参数的个数、类型或者顺序）必须不同</strong>。您不能仅通过返回类型的不同来重载函数。</p>\n<p>下面的实例中，同名函数 print() 被用于输出不同的数据类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">printData</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span>  f)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">char</span> c[])</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   printData pd;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 输出整数</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出浮点数</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">500.263</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出字符串</span></span><br><span class=\"line\">   <span class=\"type\">char</span> c[] = <span class=\"string\">&quot;Hello C++&quot;</span>;</span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(c);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-中的运算符重载\"><a href=\"#C-中的运算符重载\" class=\"headerlink\" title=\"C++ 中的运算符重载\"></a>C++ 中的运算符重载</h3><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>\n<p><strong>重载的运算符是带有特殊名称的函数</strong>，函数名是由<strong>关键字 operator 和其后要重载的运算符符号构成</strong>的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<p><code>Box operator+(const Box&amp;);</code></p>\n<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>\n<p><code>Box operator+(const Box&amp;, const Box&amp;);</code></p>\n<h2 id=\"C-引用\"><a href=\"#C-引用\" class=\"headerlink\" title=\"C++引用\"></a>C++引用</h2><p><code>&amp;</code>引用是 C++ 的新增内容，在实际开发中会经常使用；C++ 用的引用就如同C语言的指针一样重要，但它比指针更加方便和易用，有时候甚至是不可或缺的。</p>\n<p>同指针一样，引用能够减少数据的拷贝，提高数据的传递效率。</p>\n<p><a href=\"https://www.runoob.com/cplusplus/returning-values-by-reference.html\">将引用作为函数的返回参数</a></p>\n<h2 id=\"多态与虚函数\"><a href=\"#多态与虚函数\" class=\"headerlink\" title=\"多态与虚函数\"></a>多态与虚函数</h2><p> 面向对象程序设计语言有<strong>封装、继承和多态</strong>三种机制，这三种机制能够有效提高程序的<strong>可读性、可扩充性和可重用性</strong>。</p>\n<p>“<strong>多态（polymorphism）</strong>”指的是<strong>同一名字的事物可以完成不同的功能</strong>。多态可以分为<strong>编译时的多态</strong>和<strong>运行时的多态</strong>。前者主要是指函数的重载（包括运算符的重载）、对重载函数的调用，在<strong>编译时就能根据实参确定应该调用哪个函数</strong>，因此叫编译时的多态；而后者则和<strong>继承、虚函数</strong>等概念有关，是本章要讲述的内容。本教程后面提及的多态都是指运行时的多态。</p>\n<h2 id=\"模板和泛型程序设计\"><a href=\"#模板和泛型程序设计\" class=\"headerlink\" title=\"模板和泛型程序设计\"></a>模板和泛型程序设计</h2><p>泛型程序设计（generic programming）是一种<strong>算法在实现时不指定具体要操作的数据的类型</strong>的程序设计方法。所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型。泛型程序设计方法的优势在于能够减少重复代码的编写。</p>\n<p>泛型程序设计的概念最早出现于 1983 年的 Ada 语言，其最成功的应用就是 C++ 的标准模板库（STL）。也可以说，泛型程序设计就是大量编写模板、使用模板的程序设计。泛型程序设计在 C++ 中的重要性和带来的好处不亚于面向对象的特性。</p>\n<p>在 C++ 中，<strong>模板分为函数模板和类模板两种</strong>。熟练的 C++ 程序员，在编写函数时都会考虑能否<strong>将其写成函数模板</strong>，编写类时都会考虑能否<strong>将其写成类模板</strong>，以便实现重用。</p>\n<h3 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h3><p>我们知道，<strong>数据的值可以通过函数参数传递</strong>，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。这就是值的参数化。</p>\n<p>在C++中，<strong>数据的类型也可以通过参数来传递</strong>，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。</p>\n<p><strong>值</strong>（Value）和<strong>类型</strong>（Type）是数据的两个主要特征，它们在C++中都可以被参数化。</p>\n<p>所谓函数模板，实际上是建立一个通用函数，它所<strong>用到的数据的类型</strong>（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是<strong>用一个虚拟的类型来代替</strong>（实际上是用一个<strong>标识符来占位</strong>），等发生<strong>函数调用时</strong>再根据传入的实参来逆推出真正的类型。这个通用函数就称为<strong>函数模板（Function Template）</strong>。</p>\n<p>在函数模板中，数据的值和类型都被参数化了，发生函数调用时<strong>编译器会根据传入的实参来推演形参的值和类型</strong>。换个角度说，函数模板除了支持值的参数化，还支持类型的参数化。</p>\n<p>一旦定义了函数模板，就可以将<strong>类型参数</strong>用于函数定义和函数声明了。说得直白一点，原来使用 int、float、char 等内置类型的地方，都可以用<strong>类型参数</strong>来代替。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">Swap</span><span class=\"params\">(T *a, T *b)</span></span>&#123;</span><br><span class=\"line\">    T temp = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换 int 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n1 = <span class=\"number\">100</span>, n2 = <span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(&amp;n1, &amp;n2);</span><br><span class=\"line\">    cout&lt;&lt;n1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;n2&lt;&lt;endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//交换 float 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">float</span> f1 = <span class=\"number\">12.5</span>, f2 = <span class=\"number\">56.93</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(&amp;f1, &amp;f2);</span><br><span class=\"line\">    cout&lt;&lt;f1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;f2&lt;&lt;endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//交换 char 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">char</span> c1 = <span class=\"string\">&#x27;A&#x27;</span>, c2 = <span class=\"string\">&#x27;B&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(&amp;c1, &amp;c2);</span><br><span class=\"line\">    cout&lt;&lt;c1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;c2&lt;&lt;endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//交换 bool 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> b1 = <span class=\"literal\">false</span>, b2 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(&amp;b1, &amp;b2);</span><br><span class=\"line\">    cout&lt;&lt;b1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;b2&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>template</strong>是定义函数模板的<strong>关键字</strong>，它后面紧跟尖括号&lt;&gt;，尖括号包围的是<strong>类型参数</strong>（也可以说是<strong>虚拟的类型</strong>，或者说是<strong>类型占位符</strong>）。<strong>typename</strong>是另外一个<strong>关键字</strong>，用来声明具体的<strong>类型参数</strong>，这里的类型参数就是T，实际上可以随意指定。从整体上看，<strong>template<typename T><strong>被称为</strong>模板头</strong>。</p>\n<p>模板头中包含的类型参数可以用在函数定义的各个位置，包括返回值、形参列表和函数体；本例我们在形参列表和函数体中使用了类型参数T。</p>\n<p>类型参数的命名规则跟其他标识符的命名规则一样，不过使用 T、T1、T2、Type 等已经成为了一种惯例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">Swap</span><span class=\"params\">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class=\"line\">    T temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换 int 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n1 = <span class=\"number\">100</span>, n2 = <span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(n1, n2);</span><br><span class=\"line\">    cout&lt;&lt;n1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;n2&lt;&lt;endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//交换 float 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">float</span> f1 = <span class=\"number\">12.5</span>, f2 = <span class=\"number\">56.93</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(f1, f2);</span><br><span class=\"line\">    cout&lt;&lt;f1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;f2&lt;&lt;endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//交换 char 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">char</span> c1 = <span class=\"string\">&#x27;A&#x27;</span>, c2 = <span class=\"string\">&#x27;B&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(c1, c2);</span><br><span class=\"line\">    cout&lt;&lt;c1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;c2&lt;&lt;endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//交换 bool 变量的值</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> b1 = <span class=\"literal\">false</span>, b2 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Swap</span>(b1, b2);</span><br><span class=\"line\">    cout&lt;&lt;b1&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;b2&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来总结一下定义模板函数的语法：</p>\n<blockquote>\n<p>template &lt;typename 类型参数1 , typename 类型参数2 , …&gt; 返回值类型  函数名(形参列表){<br>    &#x2F;&#x2F;在函数体中可以使用类型参数<br>}</p>\n</blockquote>\n<p>类型参数可以有多个，它们之间以逗号,分隔。类型参数列表以&lt; &gt;包围，形式参数列表以( )包围。</p>\n<p>typename关键字也可以使用class关键字替代，它们没有任何区别。</p>\n<h1 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h1><img src=\"/2023/02/23/C-Note/4.png\" class=\"\">\n\n\n<h2 id=\"STL-容器\"><a href=\"#STL-容器\" class=\"headerlink\" title=\"STL 容器\"></a>STL 容器</h2><p>简单的理解容器，它就是一些<strong>模板类的集合</strong>，但和普通模板类不同的是，容器中封装的是组<strong>织数据的方法（也就是数据结构）</strong>。STL 提供有 2 类标准容器，分别是<strong>序列容器、排序容器和哈希容器</strong>，其中后两类容器有时也统称为关联容器。</p>\n<img src=\"/2023/02/23/C-Note/5.png\" class=\"\">\n\n<p> C++ 11 标准中不同容器指定使用的迭代器类型。</p>\n<img src=\"/2023/02/23/C-Note/6.png\" class=\"\">\n\n\n<h3 id=\"STL-序列容器\"><a href=\"#STL-序列容器\" class=\"headerlink\" title=\"STL 序列容器\"></a>STL 序列容器</h3><p>STL标准库中所有的序列式容器，包括 <strong>array、vector、deque、list 和 forward_list</strong>容器。</p>\n<p>所谓STL序列式容器，其共同的特点是<strong>不会对存储的元素进行排序</strong>，元素排列的顺序取决于<strong>存储它们的顺序</strong>。</p>\n<h4 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector<T></h4><p>vector&lt;T&gt; 容器是包含 T 类型元素的序列容器，和 array&lt;T，N&gt; 容器相似，不同的是 vector&lt;T&gt; 容器的大小可以自动增长，从而可以包含任意数量的元素；因此类型参数 T 不再需要模板参数 N。只要元素个数超出 vector 当前容量，就会自动分配更多的空间。<strong>只能在容器尾部高效</strong>地删除或添加元素。</p>\n<p>vector&lt;T&gt; 容器可以方便、灵活地代替数组。在<strong>大多数</strong>时候，都可以用 vector&lt;T&gt; 代替数组存放元素。只要能够意识到，vector&lt;T&gt; 在<strong>扩展容量，以及在序列内部删除或添加元素时会产生一些开销</strong>；但大多数情况下，代码不会明显变慢。 为了使用 vector&lt;T&gt; 容器模板，需要在代码中包含头文件 vector。</p>\n<p><strong>vector 容器的成员函数，用成员符号 . 调用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">begin</span>()\t返回指向容器中第一个元素的迭代器。</span><br><span class=\"line\"><span class=\"built_in\">end</span>()\t返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 <span class=\"built_in\">begin</span>() 结合使用。</span><br><span class=\"line\"><span class=\"built_in\">size</span>()\t返回实际元素个数。</span><br><span class=\"line\"><span class=\"built_in\">resize</span>()\t改变实际元素的个数。</span><br><span class=\"line\"><span class=\"built_in\">capacity</span>()\t返回当前容量。 <span class=\"comment\">// 注意容量和size的区</span></span><br><span class=\"line\"><span class=\"keyword\">operator</span>[ ]\t重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</span><br><span class=\"line\"><span class=\"built_in\">push_back</span>()\t在序列的尾部添加一个元素。</span><br><span class=\"line\"><span class=\"built_in\">pop_back</span>()\t移出序列尾部的元素。</span><br><span class=\"line\"><span class=\"built_in\">insert</span>()\t在指定的位置插入一个或多个元素，可以用于在数组后面添加另一个数组的某一部分，如<span class=\"built_in\">insert</span>(a.<span class=\"built_in\">begin</span>()+idx, b.<span class=\"built_in\">begin</span>()+x, b.<span class=\"built_in\">begin</span>()+y)。<span class=\"comment\">// 将b的这部分插入到a的idx后面</span></span><br><span class=\"line\"><span class=\"built_in\">copy</span>() 拷贝函数，<span class=\"built_in\">copy</span>(b.<span class=\"built_in\">begin</span>()+x,  b.<span class=\"built_in\">begin</span>()+y, a.<span class=\"built_in\">begin</span>()+idx); <span class=\"comment\">// 将b的这部分从a的dx开始覆盖</span></span><br><span class=\"line\">注意这两个函数的参数顺序有所不同</span><br><span class=\"line\"><span class=\"built_in\">emplace</span>()\t在指定的位置直接生成一个元素。<span class=\"comment\">// 比insert效率高</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">back</span>() 最后一个元素，在二维数组里很好用 vec.<span class=\"built_in\">back</span>().<span class=\"built_in\">push_back</span>( value )</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">vec</span><span class=\"params\">(<span class=\"number\">26</span>)</span>  <span class=\"comment\">// 生成含有26的元素的vector，初始值都是0</span></span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; vec</span>&#123;<span class=\"number\">5</span>，<span class=\"number\">6</span>，<span class=\"number\">7</span>，<span class=\"number\">1</span>，<span class=\"number\">3</span>&#125;   <span class=\"comment\">// 初始的时候直接赋值</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ilist3</span><span class=\"params\">(ilist.begin()+<span class=\"number\">2</span>,ilist.end()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> iter = value.<span class=\"built_in\">begin</span>(); iter  &lt; value.<span class=\"built_in\">end</span>(); iter ++) &#123;</span><br><span class=\"line\">        cout &lt;&lt; *iter  &lt;&lt; <span class=\"string\">&quot; &quot;</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A B 都是 vector&lt;int&gt;  u、v就代表每一个元素，不是迭代器， 用auto也是一样的，也不是迭代器  for (auto u: A)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> u: A) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> v: B)&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个umap的初始化非常好用，不用判断是否这个键是否存在</span></span><br><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; countAB; <span class=\"comment\">// 直接替代传统的for循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> u: A) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> v: B) &#123; </span><br><span class=\"line\">        ++countAB[u + v]; <span class=\"comment\">// countAB[u + v]++一样的，这步一定要学会</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其实迭代器和指针类似，所以如果迭代的是结构体或键值对，可以使用运算符-&gt;来输出值，如下：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (map&lt;string, string&gt;::iterator it = mymap.<span class=\"built_in\">begin</span>(); it != mymap.<span class=\"built_in\">end</span>(); ++it) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// auto 可以直接替换 map&lt;string, string&gt;::iterator</span></span><br><span class=\"line\">        <span class=\"comment\">//输出各个元素中的键和值</span></span><br><span class=\"line\">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class=\"string\">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这两种写法都是可以的 mp和occurrences都是map(unordered_map)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [k, v] : mp) &#123;</span><br><span class=\"line\">        cout &lt;&lt; k &lt;&lt; <span class=\"string\">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; [num, count] : occurrences)</span><br></pre></td></tr></table></figure>\n\n<p><strong>vector可以用 ListNode 或 ListNode* 数据类型，栈也可以</strong></p>\n<blockquote>\n<p><strong>for (int u: A) 和 for(auto &amp;u:A) 的区别</strong>：<br>这里(int u: A) 的int是怎么定的呢， 要看A中的元素的数据类型，比如A是vector&lt;int&gt;，那A中的元素肯定是int型的，u遍历A，那就是int u了。<br>再比如A为string对象，那u肯定是char型，所以(char u : A)、(char &amp;u : A)、(auto u : A)、(auto &amp;u : A)都是可以的。用(string u : A)就不行。<br>在c11标准下可以执行的特殊格式的for循环语句，区别在于引用类型可以改变原来的值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">&gt;</span>&#123;</span><br><span class=\"line\">   <span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:s)</span><br><span class=\"line\"></span><br><span class=\"line\">   c=<span class=\"string\">&#x27;t&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout&lt;&lt;s&lt;&lt;endl;<span class=\"comment\">//结果为hello world</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c:s)</span><br><span class=\"line\"></span><br><span class=\"line\">   c=<span class=\"string\">&#x27;t&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout&lt;&lt;s&lt;&lt;endl; <span class=\"comment\">//结果为ttttttttttt</span></span><br><span class=\"line\">&gt;&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>C++ 的 auto 关键字的使用目的是: 允许编译器推断出变量的类型，例如，像下面这样写code是可行的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector &lt;<span class=\"type\">int</span>&gt; v;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = v.<span class=\"built_in\">begin</span>();</span><br></pre></td></tr></table></figure>\n<p>因为编译器知道 v.begin() 必须返回 vector&lt;int&gt;::iterator 于是就可以创建这种类型的变量, 从而可以省掉 typedef 或少敲键盘。</p>\n<h3 id=\"STL-关联式容器\"><a href=\"#STL-关联式容器\" class=\"headerlink\" title=\"STL 关联式容器\"></a>STL 关联式容器</h3><p><strong>关联式容器</strong>，包括 <strong>map、multimap、set 以及 multiset</strong> 这 4 种容器。</p>\n<p>和序列式容器不同的是，关联式容器在存储元素时还会为每个元素再配备一个键，整体以键值对的方式存储到容器中。相比前者，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素时，默认会根据各元素<strong>键的大小</strong>做<strong>升序</strong>排序。</p>\n<p>无论是哪种序列式容器，其存储的都是 C++ 基本数据类型（诸如 int、double、float、string 等）或使用结构体自定义类型的元素，</p>\n<p>关联式容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，<strong>其本质也是一个 C++ 基础数据类型或自定义类型的元素</strong>），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p>\n<p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ &lt;key,value&gt; ），这是和序列式容器最大的不同。<br>除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会<strong>根据各元素的键值的大小做升序</strong>排序。</p>\n<p>关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了<strong>红黑树</strong>这种数据结构来组织和存储各个键值对。</p>\n<p>C++ STL 标准库提供了 4 种关联式容器，分别为 <strong>map、set、multimap、multiset</strong>：</p>\n<img src=\"/2023/02/23/C-Note/7.png\" class=\"\">\n\n<p>除此之外，C++ 11 还新增了 4 种哈希容器，即 <strong>unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset</strong>。严格来说，它们也属于关联式容器，但哈希容器底层采用的是哈希表，而不是红黑树。</p>\n<p>注意: 基于各个关联式容器存储数据的特点，只有<strong>各个键值对中的键和值全部对应相等</strong>时，才能使用 <strong>set 和 multiset 关联式容器</strong>存储，否则就要选用 map 或者 multimap 关联式容器。</p>\n<p><a href=\"https://c.biancheng.net/view/7173.html\">看到这</a></p>\n<h3 id=\"STL-无序关联式容器\"><a href=\"#STL-无序关联式容器\" class=\"headerlink\" title=\"STL 无序关联式容器\"></a>STL 无序关联式容器</h3><p>无序关联式容器，又称<strong>哈希容器</strong>。和关联式容器一样，此类容器存储的也是键值对元素；不同之处在于，关联式容器默认情况下会对存储的元素做升序排序，而无序关联式容器不会。</p>\n<p>和其它类容器相比，无序关联式容器擅长通过指定键查找对应的值，而遍历容器中存储元素的效率不如关联式容器。</p>\n<p>无序容器是 C++ 11 标准才正式引入到 STL 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p>\n<p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过二者有本质上的不同：</p>\n<ul>\n<li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li>\n<li>无序容器的底层实现采用的是哈希表的存储结构。</li>\n</ul>\n<p>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p>\n<ul>\n<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键；</li>\n<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li>\n</ul>\n<p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 、unordered_multiset。</p>\n<img src=\"/2023/02/23/C-Note/8.png\" class=\"\">\n\n<p>可以看出：C++ 11 标准的 STL 中，在已提供有 4 种关联式容器的基础上，又新增了各自的“unordered”版本（无序版本、哈希版本），提高了查找指定元素的效率。</p>\n<p>总的来说，实际场景中如果涉及大量<strong>遍历</strong>容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p>\n<h4 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h4><p>unordered_map 容器在<unordered_map>头文件中，并位于 std 命名空间中。<br>nordered_map 容器模板的定义如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt; <span class=\"keyword\">class</span> <span class=\"title class_\">Key</span>,                        <span class=\"comment\">//键值对中键的类型</span></span><br><span class=\"line\">           <span class=\"keyword\">class</span> <span class=\"title class_\">T</span>,                          <span class=\"comment\">//键值对中值的类型</span></span><br><span class=\"line\">           <span class=\"keyword\">class</span> <span class=\"title class_\">Hash</span> = hash&lt;Key&gt;,           <span class=\"comment\">//容器内部存储键值对所用的哈希函数</span></span><br><span class=\"line\">           <span class=\"keyword\">class</span> Pred = equal_to&lt;Key&gt;,       <span class=\"comment\">//判断各个键值对键相同的规则</span></span><br><span class=\"line\">           <span class=\"keyword\">class</span> Alloc = allocator&lt; pair&lt;<span class=\"type\">const</span> Key,T&gt; &gt;  <span class=\"comment\">// 指定分配器对象的类型</span></span><br><span class=\"line\">           &gt; <span class=\"keyword\">class</span> unordered_map;</span><br></pre></td></tr></table></figure>\n\n<p>模板类参数：</p>\n<img src=\"/2023/02/23/C-Note/9.png\" class=\"\">\n\n<p>默认哈希函数是对键(key)使用的，而且只适用于基本数据类型(包括string)，而不支持自定义的结构体或类。<br>总的来说，当无序容器中存储键值对的<strong>键</strong>为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</p>\n<p><strong>初始化</strong>：<code>std::unordered_map&lt; Tkey, Tvalue &gt; umap;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">begin</span>()\t返回指向容器中第一个键值对的正向迭代器。</span><br><span class=\"line\"><span class=\"built_in\">end</span>() \t返回指向容器中最后一个键值对之后位置的正向迭代器。</span><br><span class=\"line\"><span class=\"built_in\">cbegin</span>()\t和 <span class=\"built_in\">begin</span>() 功能相同，只不过在其基础上增加了 <span class=\"type\">const</span> 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</span><br><span class=\"line\"><span class=\"built_in\">cend</span>()\t和 <span class=\"built_in\">end</span>() 功能相同，只不过在其基础上，增加了 <span class=\"type\">const</span> 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</span><br><span class=\"line\"><span class=\"built_in\">size</span>()\t返回当前容器中存有键值对的个数。</span><br><span class=\"line\"><span class=\"keyword\">operator</span>[key]\t该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。</span><br><span class=\"line\"><span class=\"built_in\">at</span>(key)\t返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。 </span><br><span class=\"line\"><span class=\"built_in\">find</span>(key)\t查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（即 <span class=\"built_in\">end</span>() 方法返回的迭代器）。</span><br><span class=\"line\"><span class=\"built_in\">count</span>(key)\t在容器中查找以 key 键的键值对的个数。</span><br><span class=\"line\"><span class=\"built_in\">emplace</span>()\t向容器中添加新键值对，效率比 <span class=\"built_in\">insert</span>() 方法高。</span><br><span class=\"line\"><span class=\"built_in\">insert</span>() \t向容器中添加新键值对。</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。举个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建空 umap 容器</span></span><br><span class=\"line\">    unordered_map&lt;string, string&gt; umap;</span><br><span class=\"line\">    <span class=\"comment\">//[] 运算符在 = 右侧</span></span><br><span class=\"line\">    string str = umap[<span class=\"string\">&quot;STL&quot;</span>];</span><br><span class=\"line\">    <span class=\"comment\">//[] 运算符在 = 左侧</span></span><br><span class=\"line\">    umap[<span class=\"string\">&quot;blog&quot;</span>] = <span class=\"string\">&quot;https://iridescent-zhang.github.io/&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> iter = umap.<span class=\"built_in\">begin</span>(); iter != umap.<span class=\"built_in\">end</span>(); ++iter) &#123;</span><br><span class=\"line\">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行结果为：</span><br><span class=\"line\">blog https:<span class=\"comment\">//iridescent-zhang.github.io/</span></span><br><span class=\"line\">STL</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看到，当使用 [ ] 运算符向 unordered_map 容器中添加键值对时，分为 2 种情况：</p>\n<ul>\n<li>当 [ ] 运算符位于赋值号（&#x3D;）右侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为键值对要求的值类型的默认值（string 类型默认值为空字符串）；</li>\n<li>当 [ ] 运算符位于赋值号（&#x3D;）左侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为赋值号右侧的元素。</li>\n</ul>\n<p>unordered_map<strong>修改键值对的值value</strong>直接像数组那样操作就可以了，也可以用迭代器。</p>\n<h4 id=\"unordered-set\"><a href=\"#unordered-set\" class=\"headerlink\" title=\"unordered_set\"></a>unordered_set</h4><p>unordered_set 容器具有以下几个特性：</p>\n<ol>\n<li>不再以键值对的形式存储数据，而是直接存储数据的值；</li>\n<li>容器内部存储的各个元素值都互不相等，且不能被修改；</li>\n<li>不会对内部存储的数据进行排序；</li>\n</ol>\n<p>实现 unordered_set 容器的模板类定义在<unordered_set>头文件。<br>unordered_set 容器的类模板定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt; <span class=\"keyword\">class</span> <span class=\"title class_\">Key</span>,            <span class=\"comment\">//容器中存储元素的类型</span></span><br><span class=\"line\">           <span class=\"keyword\">class</span> <span class=\"title class_\">Hash</span> = hash&lt;Key&gt;,    <span class=\"comment\">//确定元素存储位置所用的哈希函数</span></span><br><span class=\"line\">           <span class=\"keyword\">class</span> Pred = equal_to&lt;Key&gt;,   <span class=\"comment\">//判断各个元素是否相等所用的函数</span></span><br><span class=\"line\">           <span class=\"keyword\">class</span> Alloc = allocator&lt;Key&gt;   <span class=\"comment\">//指定分配器对象的类型</span></span><br><span class=\"line\">           &gt; <span class=\"keyword\">class</span> unordered_set;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2023/02/23/C-Note/10.png\" class=\"\">\n\n<p>注意，如果 unordered_set 容器中存储的元素为自定义的数据类型，则默认的哈希函数 hash<key> 以及比较函数 equal_to<key> 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</p>\n<p><strong>初始化</strong>：<code>std::unordered_set&lt; T &gt; uset;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">begin</span>()\t返回指向容器中第一个元素的正向迭代器。</span><br><span class=\"line\"><span class=\"built_in\">end</span>();\t返回指向容器中最后一个元素之后位置的正向迭代器。</span><br><span class=\"line\"><span class=\"built_in\">size</span>()\t返回当前容器中存有元素的个数。</span><br><span class=\"line\"><span class=\"built_in\">find</span>(key)\t查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（ <span class=\"built_in\">end</span>() 方法返回的迭代器）。</span><br><span class=\"line\"><span class=\"built_in\">count</span>(key)\t在容器中查找值为 key 的元素的个数。</span><br><span class=\"line\"><span class=\"built_in\">emplace</span>()\t向容器中添加新元素，效率比 <span class=\"built_in\">insert</span>() 方法高。</span><br><span class=\"line\"><span class=\"built_in\">insert</span>()\t向容器中添加新元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意，此容器模板类中没有重载 [ ] 运算符，也没有提供 at() 成员方法</strong>。不仅如此，由于 unordered_set 容器内部存储的元素值不能被修改，因此无论使用哪个迭代器方法获得的迭代器，<strong>都不能用于修改容器中元素的值</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历输出 uset 容器存储的所有元素</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> iter = uset.<span class=\"built_in\">begin</span>(); iter != uset.<span class=\"built_in\">end</span>()，++iter) &#123;</span><br><span class=\"line\">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"STL-容器适配器\"><a href=\"#STL-容器适配器\" class=\"headerlink\" title=\"STL 容器适配器\"></a>STL 容器适配器</h2><p>这里是 <em><strong>SGI STL</strong></em> 版本 ！</p>\n<p>容器适配器是一个封装了<strong>序列容器</strong>的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过<strong>适配容器现有的接口</strong>来提供不同的功能。</p>\n<p>主要介绍 2种容器适配器，分别是 <strong>stack、queue</strong>：</p>\n<ol>\n<li>stack<T>：是一个<strong>封装了 deque<T> 容器</strong>的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack<T> 模板定义在头文件 stack 中。</li>\n<li>queue<T>：是一个<strong>封装了 deque<T> 容器</strong>的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。queue<T> 模板定义在头文件 queue 中。</li>\n<li>priority_queue<T>：是一个封装了 <strong>vector<T> 容器</strong>的适配器类模板，默认实现的是一个<strong>会对元素排序，从而保证最大元素总在队列最前面的队列</strong>。priority_queue<T> 模板定义在头文件 queue 中。</li>\n</ol>\n<p>适配器类在基础序列容器的基础上实现了一些自己的操作，显然也可以添加一些自己的操作。它们提供的优势是<strong>简化了公共接口，而且提高了代码的可读性</strong>。</p>\n<hr>\n<p>其实，容器适配器中的“适配器”，和生活中常见的电源适配器中“适配器”的含义非常接近。我们知道，无论是电脑、手机还是其它电器，充电时都无法直接使用 220V 的交流电，为了方便用户使用，各个电器厂商都会提供一个适用于自己产品的电源线，它可以将 220V 的交流电转换成适合电器使用的低压直流电。<br>从用户的角度看，电源线扮演的角色就是将原本不适用的交流电变得适用，因此其又被称为电源适配器。</p>\n<p>容器适配器也是同样的道理，简单的理解容器适配器，其就是将<strong>不适用的序列式容器（包括 vector、deque 和 list）变得适用</strong>。容器适配器的底层实现是通过<strong>封装某个序列式容器</strong>，并<strong>重新组合该容器中包含的成员函数</strong>，使其满足某些特定场景的需要。</p>\n<p>容器适配器本质上还是容器，只不过此容器模板类的实现，利用了<strong>大量</strong>其它基础容器模板类中<strong>已经写好的成员函数</strong>。当然，如果必要的话，容器适配器中也可以自创新的成员函数。</p>\n<p>需要注意的是，<strong>STL 中的容器适配器，其内部使用的基础容器并不是固定的</strong>，用户可以在满足特定条件的多个基础容器中自由选择。</p>\n<p>STL 提供了 3 种容器适配器，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。其中，各适配器所使用的<strong>默认基础容器以及可供用户选择的基础容器</strong>，如下表 所示：</p>\n<img src=\"/2023/02/23/C-Note/11.png\" class=\"\">\n\n<p>不同场景下，由于不<strong>同的序列式容器其底层</strong>采用的数据结构不同，因此容器适配器的执行效率也不尽相同。但通常情况下，使用默认的基础容器即可。</p>\n<h3 id=\"C-STL-stack\"><a href=\"#C-STL-stack\" class=\"headerlink\" title=\"C++ STL  stack\"></a>C++ STL  stack</h3><p>stack 栈适配器是一种<strong>单端开口</strong>的容器，实际上该容器模拟的就是<strong>栈存储结构</strong>，即无论是向里存数据还是从中取数据，都只能从这一个开口实现操作。</p>\n<img src=\"/2023/02/23/C-Note/1.jpg\" class=\"\">\n\n<p>stack 适配器的<strong>开口端通常称为栈顶</strong>。由于数据的存和取只能从栈顶处进行操作，因此对于存取数据，stack 适配器有这样的特性，即每次只能访问适配器中位于最顶端的元素，也只有移除 stack 顶部的元素之后，才能访问位于栈中的元素。</p>\n<p><code>栈中存储的元素满足“后进先出（简称LIFO）”的准则，stack 适配器也同样遵循这一准则。</code></p>\n<h4 id=\"stack容器适配器的创建\"><a href=\"#stack容器适配器的创建\" class=\"headerlink\" title=\"stack容器适配器的创建\"></a>stack容器适配器的创建</h4><p> stack 适配器以模板类 stack&lt;T,Container&#x3D;deque<T>&gt;（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于&lt;stack&gt;头文件中，并定义在 std 命名空间里。</p>\n<p>创建 stack 适配器，大致分为如下几种方式:</p>\n<ol>\n<li>创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器：<br><code>std::stack&lt;int&gt; values;</code><br>上面这行代码，就成功创建了一个可存储 int 类型元素，底层采用 deque 基础容器的 stack 适配器。</li>\n<li>stack&lt;T,Container&#x3D;deque<T>&gt; 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用除 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即可。<br>序列式容器中同时包含这 5 个成员函数的，有 vector、deque 和 list 这 3 个容器。因此，stack 适配器的基础容器可以是它们 3 个中任何一个。例如，下面展示了如何定义一个使用 list 基础容器的 stack 适配器：<br><code>std::stack&lt;int, std::list&lt;int&gt;&gt; values;</code></li>\n<li>可以用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可。例如：<br><code>std::list&lt;int&gt; values &#123;1, 2, 3&#125;;</code><br><code>std::stack&lt;int,std::list&lt;int&gt;&gt; my_stack (values);</code><br>注意，初始化后的 my_stack 适配器中，栈顶元素为 3，而不是 1。另外在第 2 行代码中，stack 第 2 个模板参数必须显式指定为 list&lt;int&gt;（必须为 int 类型，和存储类型保持一致），否则 stack 底层将默认使用 deque 容器，也就无法用 lsit 容器的内容来初始化 stack 适配器。</li>\n<li>还可以用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。例如：<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::list&lt;<span class=\"type\">int</span>&gt; values&#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">std::stack&lt;<span class=\"type\">int</span>, std::list&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">my_stack1</span>(values);</span><br><span class=\"line\">std::stack&lt;<span class=\"type\">int</span>, std::list&lt;<span class=\"type\">int</span>&gt;&gt; my_stack=my_stack1;</span><br><span class=\"line\"><span class=\"comment\">//std::stack&lt;int, std::list&lt;int&gt;&gt; my_stack(my_stack1);</span></span><br></pre></td></tr></table></figure>\n<strong>注意</strong>：第 3、4 种初始化方法中，my_stack 适配器的数据是经过拷贝得来的，也就是说，操作 my_stack 适配器，并不会对 values 容器以及 my_stack1 适配器有任何影响；反过来也是如此。</li>\n</ol>\n<h4 id=\"stack容器适配器支持的成员函数\"><a href=\"#stack容器适配器支持的成员函数\" class=\"headerlink\" title=\"stack容器适配器支持的成员函数\"></a>stack容器适配器支持的成员函数</h4><p>和其他序列容器相比，stack 是一类存储机制简单、提供成员函数较少的容器。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">empty</span>()\t当 stack 栈中没有元素时，该成员函数返回 <span class=\"literal\">true</span>；反之，返回 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"built_in\">size</span>()\t返回 stack 栈中存储元素的个数。</span><br><span class=\"line\"><span class=\"built_in\">top</span>()\t返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</span><br><span class=\"line\"><span class=\"built_in\">push</span>(<span class=\"type\">const</span> T&amp; val)\t先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 <span class=\"built_in\">push_back</span>() 函数完成的。</span><br><span class=\"line\"><span class=\"built_in\">pop</span>()\t弹出栈顶元素。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//构建 stack 容器适配器</span></span><br><span class=\"line\">    list&lt;<span class=\"type\">int</span>&gt; values&#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>, list&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">my_stack</span>(values);</span><br><span class=\"line\">    <span class=\"comment\">//查看 my_stack 存储元素的个数</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;size of my_stack: &quot;</span> &lt;&lt; my_stack.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">//将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!my_stack.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        cout &lt;&lt; my_stack.<span class=\"built_in\">top</span>() &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"comment\">//将栈顶元素弹栈</span></span><br><span class=\"line\">        my_stack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"C-STL-queue\"><a href=\"#C-STL-queue\" class=\"headerlink\" title=\"C++ STL  queue\"></a>C++ STL  queue</h3><p>和 stack 栈容器适配器不同，queue 容器适配器有 2 个开口，其中一个开口专门用来输入数据，另一个专门用来输出数据，如下：</p>\n<img src=\"/2023/02/23/C-Note/2.jpg\" class=\"\">\n\n<p>这种存储结构最大的特点是，最先进入 queue 的元素，也可以最先从 queue 中出来，即用此容器适配器存储数据具有“<strong>先进先出</strong>（简称 “FIFO” ）”的特点，因此 queue 又称为<strong>队列适配器</strong>。</p>\n<p>STL queue 容器适配器模拟的就是队列这种存储结构，因此对于任何需要用队列进行处理的序列来说，使用 queue 容器适配器都是好的选择。</p>\n<h4 id=\"queue容器适配器的创建\"><a href=\"#queue容器适配器的创建\" class=\"headerlink\" title=\"queue容器适配器的创建\"></a>queue容器适配器的创建</h4><p>queue 容器适配器以模板类 queue&lt;T,Container&#x3D;deque<T>&gt;（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于&lt;queue&gt;头文件中，并定义在 std 命名空间里。</p>\n<p>queue容器的创建与stack非常类似。</p>\n<ol>\n<li>创建一个空的 queue 容器适配器，其底层使用的基础容器选择默认的 deque 容器：<br><code>std::queue&lt;int&gt; values;</code></li>\n<li>也可以手动指定 queue 容器适配器底层采用的基础容器类型，queue 容器适配器底层容器可以选择 deque 和 list。<br>下面创建了一个使用 list 容器作为基础容器的空 queue 容器适配器：<br><code>std::queue&lt;int, std::list&lt;int&gt;&gt; values;</code><br>在手动指定基础容器的类型时，<strong>其存储的数据类型</strong>必须和 queue 容器适配器<strong>存储的元素类型</strong>保持一致。</li>\n<li>可以用基础容器来初始化 queue 容器适配器，只要该容器类型和 queue 底层使用的基础容器类型相同即可。例如：<br><code>std::deque&lt;int&gt; values&#123;1,2,3&#125;;</code><br><code>std::queue&lt;int&gt; my_queue(values);</code><br>由于 my_queue 底层采用的是 deque 容器，和 values 类型一致，且存储的也都是 int 类型元素，因此可以用 values 对 my_queue 进行初始化。</li>\n<li>直接通过 queue 容器适配器来初始化另一个 queue 容器适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。例如:<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::deque&lt;<span class=\"type\">int</span>&gt; values&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"function\">std::queue&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">my_queue1</span><span class=\"params\">(values)</span></span>;</span><br><span class=\"line\"><span class=\"function\">std::queue&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">my_queue</span><span class=\"params\">(my_queue1)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//或者使用</span></span><br><span class=\"line\"><span class=\"comment\">//std::queue&lt;int&gt; my_queue = my_queue1;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"queue容器适配器支持的成员函数\"><a href=\"#queue容器适配器支持的成员函数\" class=\"headerlink\" title=\"queue容器适配器支持的成员函数\"></a>queue容器适配器支持的成员函数</h4><p><em>和 stack 一样，queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过<strong>不断移除</strong>访问过的元素，去访问下一个元素。</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">empty</span>()\t如果 queue 中没有元素的话，返回 <span class=\"literal\">true</span>。</span><br><span class=\"line\"><span class=\"built_in\">size</span>()\t返回 queue 中元素的个数。</span><br><span class=\"line\"><span class=\"built_in\">front</span>()\t返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span><br><span class=\"line\"><span class=\"built_in\">back</span>()\t返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span><br><span class=\"line\"><span class=\"built_in\">push</span>(<span class=\"type\">const</span> T&amp; obj)\t在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 <span class=\"built_in\">push_back</span>() 来完成的。</span><br><span class=\"line\"><span class=\"built_in\">pop</span>()\t删除 queue 中的第一个元素。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//构建 queue 容器适配器</span></span><br><span class=\"line\">    std::deque&lt;<span class=\"type\">int</span>&gt; values&#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    <span class=\"function\">std::queue&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">my_queue</span><span class=\"params\">(values)</span></span>;<span class=\"comment\">//&#123;1,2,3&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//查看 my_queue 存储元素的个数</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;size of my_queue: &quot;</span> &lt;&lt; my_queue.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">//访问 my_queue 中的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!my_queue.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; my_queue.<span class=\"built_in\">front</span>() &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"comment\">//访问过的元素出队列</span></span><br><span class=\"line\">        my_queue.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://juejin.cn/post/7217648572535701562\">ChatGpt注册</a></p>\n","categories":["Language"],"tags":["C++","Leetcode"]},{"title":"学习JS","url":"/2022/09/19/JsNote/","content":"<p><strong>JavaScript</strong></p>\n<span id=\"more\"></span>\n\n<p>JavaScript 是脚本语言<br>JavaScript 是可插入 HTML 页面的编程代码。<br>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p>\n<p>在HTML 输出流中使用 document.write，相当于在原有html代码中添加一串html代码。而如果在文档加载后使用（如使用函数，即函数中含有document.write，并且调用这个函数），会覆盖整个文档。</p>\n<p>JavaScript 能够对事件作出反应。比如对按钮的点击：onclick事件<br>在标签中填写 onclick 事件调用函数时，不是 onclick&#x3D;”函数名”， 而是 onclick&#x3D;”函数名+()”</p>\n<p>JavaScript：改变 HTML 内容<br>您会经常看到 document.getElementById(“some id”)。这个方法是 HTML DOM 中定义的。<br>DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。<br>JavaScript 能够改变任意 HTML 元素的大多数属性，而不仅仅是图片元素的src属性。</p>\n<p>JavaScript：改变 HTML 元素的样式</p>\n<p>HTML 中的 Javascript 脚本代码必须位于 &lt;script&gt; 与 &lt;&#x2F;script&gt; 标签之间。<br>Javascript 脚本代码可被放置在 HTML 页面的 &lt;body&gt; 和 &lt;head&gt; 部分中。<br>浏览器会解释并执行位于 &lt;script&gt; 和 &lt;&#x2F;script&gt;之间的 JavaScript 代码 </p>\n<p>通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。<br>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。<br>其他 JavaScript 语句，会在页面加载时执行。</p>\n<p>您可以在 HTML 文档中放入不限数量的脚本。<br>通常的做法是把函数放入 &lt;head&gt; 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>\n<p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。<br>外部 JavaScript 文件的文件扩展名是 .js。<br>如需使用外部文件，请在 &lt;script&gt; 标签的 “src” 属性中设置该 .js 文件：<br><code>&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;</code><br>外部 javascript 文件不使用 &lt;script&gt; 标签，直接写 javascript 代码。</p>\n<p>Chrome snippets（代码段） 小脚本</p>\n<h3 id=\"JavaScript-输出\"><a href=\"#JavaScript-输出\" class=\"headerlink\" title=\"JavaScript 输出\"></a>JavaScript 输出</h3><p>JavaScript 没有任何打印或者输出的函数。</p>\n<blockquote>\n<p>JavaScript 显示数据</p>\n<ul>\n<li>使用 window.alert() 弹出警告框。</li>\n<li>使用 document.write() 方法将内容写到 HTML 文档中。</li>\n<li>使用 innerHTML 写入到 HTML 元素。</li>\n<li>使用 console.log() 写入到浏览器的控制台。</li>\n</ul>\n</blockquote>\n<p>innerHTML则是DOM页面元素的一个属性，代表该元素的html内容。</p>\n<p>如果您的浏览器支持调试，你可以使用 console.log() 方法在浏览器中显示 JavaScript 值。<br>浏览器中使用 F12 来启用调试模式， 在调试窗口中点击 “Console” 菜单。</p>\n<p>当用引号时会认为引号中是字符串，从而直接将引号中的内容打印出来。</p>\n<p>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。<br>JSON 它其实是来自JavaScript对对象(Object)的定义。但是它作为数据格式来使用的时候，和JavaScript没有任何关系，它只是参照了JavaScript对对象定义的数据格式。<br>json是一种与语言无关的数据交换的格式，它很易于操作，没有什么复杂的程序，也可以服务于任何语言</p>\n<h3 id=\"JavaScript-语法\"><a href=\"#JavaScript-语法\" class=\"headerlink\" title=\"JavaScript 语法\"></a>JavaScript 语法</h3><p>JavaScript 是一个程序语言。语法规则定义了语言结构。<br>数组（Array）字面量 定义一个数组：<br>[40, 100, 1, 5, 25, 10]<br>对象（Object）字面量 定义一个对象：<br>{firstName:”John”, lastName:”Doe”, age:50, eyeColor:”blue”}<br>函数（Function）字面量 定义一个函数：<br>function myFunction(a, b) { return a * b;}</p>\n<p>JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值：<br>JavaScript是弱类型编程语言,定义变量都使用 var 定义,与 Java 这种强类型语言有区别.<br>在定义后可以通过 typeOf() 来获取JavaScript中变量的数据类型（但无法区分数组和对象）。</p>\n<p>在 HTML 中，JavaScript 语句用于向浏览器发出命令。<br>语句是用分号分隔：</p>\n<p>不是所有的 JavaScript 语句都是”命令”。双斜杠 &#x2F;&#x2F; 后的内容将会被浏览器忽略：</p>\n<p>JavaScript 对大小写是敏感的。</p>\n<p>JavaScript 使用 Unicode 字符集。</p>\n<p>JavaScript 中，常见的是驼峰法的命名规则，如 lastName (而不是lastname)，getElementById。</p>\n<p>var firstName&#x3D;’king’;&#x2F;&#x2F;小驼峰<br>var FirstName&#x3D;’queen’;&#x2F;&#x2F;大驼峰<br>var first_name&#x3D;’maizi’;&#x2F;&#x2F;下划线法</p>\n<h3 id=\"JavaScript-语句\"><a href=\"#JavaScript-语句\" class=\"headerlink\" title=\"JavaScript 语句\"></a>JavaScript 语句</h3>","categories":["Language"],"tags":["JS"]},{"title":"InternetBasicsNote","url":"/2024/04/01/InternetBasicsNote/","content":"<p><em><strong>无志之人常立志，有志之人立常志</strong></em></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java-后端\"><a href=\"#Java-后端\" class=\"headerlink\" title=\"Java 后端\"></a>Java 后端</h1><h2 id=\"知识框架\"><a href=\"#知识框架\" class=\"headerlink\" title=\"知识框架\"></a>知识框架</h2><p>Web开发：主要是Web开发相关的内容，包括HTML&#x2F;CSS&#x2F;js(前端页面)、 Servlet&#x2F;JSP(J2EE)以及MySQL(数据库)相关的知识。它们的学习顺序应该是从前到后，因此最先学习的应该是HTML&#x2F;CSS&#x2F;JS(前端页面)。<br>　　J2EE：你需要学习的是Servlet&#x2F;JSP(J2EE)部分，这部分是Java后端开发必须非常精通的部分，因此这部分是这三部分中最需要花精力的。关于Servlet&#x2F;Jsp部分视频的选择，业界比较认可马士兵的视频。<br>　　最后一步，你需要学会使用数据库：mysql是个不错的入门选择，而且Java领域里主流的关系型数据库就是mysql。这部分一般在你学习Servlet&#x2F;Jsp的时候，就会接触到的，其中的JDBC部分就是数据库相关的部分。<br>　　你不仅要学会使用JDBC操作数据库，还要学会使用数据库客户端工具，比如navicat，sqlyog，二选一即可。<br>　　开发框架：目前比较主流的是SSM框架，即spring、springmvc、mybatis。你需要学会这三个框架的搭建，并用它们做出一个简单的增删改查的Web项目。<br>　　你可以不理解那些配置都是什么含义，以及为什么要这么做，这些留着后面你去了解。但你一定要可以快速的利用它们三个搭建出一个Web框架，你可以记录下你第一次搭建的过程，相信我，你一定会用到的。<br>　　还要提一句的是，你在搭建SSM的过程中，可能会经常接触到一个叫maven的工具。<br>　　这个工具也是你以后工作当中几乎是必须要使用的工具，所以你在搭建SSM的过程中，也可以顺便了解一下maven的知识。在你目前这个阶段，你只需要在网络上了解一下maven基本的使用方法即可，一些高端的用法随着你工作经验的增加，会逐渐接触到的。<br>　　你需要去看一些JDK中的类的源码，也包括你所使用的框架的源码。这些源码能看懂的前提是，你必须对设计模式非常了解。否则的话，你看源码的过程中，永远会有这样那样的疑问，这段代码为什么要这么写?<br>　　为什么要定义这个接口，它看起来好像很多余?由此也可以看出，这些学习的过程是环环相扣的，如果你任何一个阶段拉下来了，那么你就真的跟不上了，或者说是一步慢步步慢。而且我很负责的告诉你，我在这个阶段的时候，所学习的东西远多于这里所罗列出来的。<br>　　总而言之，这个阶段，你需要做的是深入了解Java底层和Java类库(比如并发那本书就是Java并发包Java.concurrent的内容)，也就是JVM和JDK的相关内容。而且还要更深入的去了解你所使用的框架，方式比较推荐看源码或者看官方文档。<br>　　再总而言之，就是 学习、学习、再学习~活到老，学到老</p>\n<p>1、面向对象的知识<br>java是一种面向对象的开发语言，因此熟悉面向对象对学习java很有必要，你需要了解：什么是对象，什么是类，什么是封装，什么是多态，什么是继承，什么是抽象类，什么是接口。理解以上概念后，还需要知道这些概念是如何体现的，如类和对象有什么区别?类是如何封装的?</p>\n<p>2、java语言<br>Java 是一门纯粹的面向对象的编程语言，所以除了基础语法之外，必须得弄懂它的 oop 特性：封装、继承、多态。此外还有泛型、反射 的特性，很多框架的技术都依赖它，比如 Spring 核心的 Ioc 和 AOP，都用到了反射，而且 Java 自身的动态代理也是利用反射实现的。 此外还有 Java 一些标准库也是非常常见，比如集合、I&#x2F;O、并发，几乎在 Web 开发中无处不在，也是面试经常会被问到的，所以在学 Java 后端之前，不妨先打好这些基础，另外还有 Java8 的一些新特性，也要重点关注，比如 Lambda 表达式、集合的 Stream 流操作、全新的 Date API 等等，关于新特性。</p>\n<p>3、JSP和HTML<br>在我国的绝大多数公司，做java程序开发都少不了和JSP以及HTML打交道。所以，要熟悉java程序开发就要熟悉JSP和HTML，较好能知道JSP的几个内置对象，如Session，Request，Reponse，，以及常用的JSP标签，如include,userBean等。尽管一些工具会帮你生成HTML代码，但还是要熟悉比如title，等。如果再熟悉一下JS和CSS就更好了，那会使做出的页面更友好。</p>\n<p>4、数据库<br>后端开发免不了与数据库打交道，所以掌握Java的数据库操作是一个基本要求。Java操作数据库涉及到的内容有JDBC、JNDI、RMI、DAO等内容，其中使用RMI+JDBC是构建java数据库开发的一个常见的解决方案，而JNDI则是对各种资源的定义。</p>\n<p>5、Web Server<br>熟悉一种Web Server，比如：TOMCAT，RESIN等。您要熟悉如何发布你的应用，如何利用Web Server的数据库资源等。</p>\n<p>6、Servlet<br>Servlet技术是Java后端的重要技术之一，作为Java Web开发的核心组件，Servlet承担了Web MVC结构中的核心作用（功能导航）。传统的Model2结构（Servlet+JavaBean+JSP）虽然在目前已经很少使用了，但是Web开发的基本结构依然没有改变。Servlet技术的应用涉及到Web容器、会话（HttpSession）、安全、同步、Web应用部署等相关内容。</p>\n<p>7、Web主流框架<br>熟悉一种框架其实是java程序开发的一种可选知识，但目前开发B&#x2F;S结构的应用的开发小组，都差不多会采用一种框架来构建自己的应用系统。框架都会有许多可重用的代码，良好的层次关系和业务控制逻辑，基于框架的开发使你可以省出很多的开发成本。目前比较流行的框架有Struts和Spring等。</p>\n<p>Spring+SpringMVC+MyBatis是目前一个比较常见的后端开发方案，Spring的原理就是构建了一个“业务组件容器”，SpringMVC则是Web MVC的一个具体实现框架，而MyBatis则是一个基于DAO的实现框架。从性能的角度来说，Spring是EJB的轻量级解决方案，得到了广大Java程序员的欢迎。</p>\n<p>网络协议是为计算机网络中进行数据交换而建立的规则、标准或约定的集合。没有网络协议就根本不可能上网，任何和互联网有关的操作都离不开网络协议。我们开发的软件网络是不可缺少的，因此计算机协议的相关知识也是不可或缺的。</p>\n<p>尤其是要学习<strong>http</strong>协议，浏览器与服务器通过http协议交互，其实就是相互之间传递一串特定格式的字符串。get参数，post参数，url，和cookie等信息其实都包含在这字符串里面。所以说http协议是一个重要的存在，也是我们学习后端开发一个必不可少的要点</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><h3 id=\"J2EE-JSP-Java的区别\"><a href=\"#J2EE-JSP-Java的区别\" class=\"headerlink\" title=\"J2EE,JSP,Java的区别\"></a>J2EE,JSP,Java的区别</h3><p>JSP就是用来做动态页面的,可以归属到J2EE系列中。Java 这个词的概括可能更广一些 ,因为Java包含3个领域,分别是: J2EE: 企业级开发，J2ME :嵌入式开发，J2SE :图形界面开发。</p>\n<p>java包含三大分支:</p>\n<p>J2SE –java standard edition–标准版本，这个是下面两个的基础!一般是位于客户端的应用; J2ME–java Micro edition —般位于嵌入式应用，例如手机游戏J2EE –java Enterprise Editon —般为服务器端程序的应用。J2EE的全称是Java 2 Platform Enterprise Edition。</p>\n<p>java通俗的说是一个统称了， 他包括了javase(j2se) javaee(j2ee) javame(j2me)</p>\n<p>javase是java的基础,涵盖基本语法结构,IO,集合等,反正看成是java的基石就对了</p>\n<p>javaee是企业开发的规范,里面是一大堆的接口,但是自 己也不实现这一套规范, 他需要各大企业或者组织去实现，比如tomcatjboss等,然后开发者在javaee的规范下开发web程序,部署到web容器(tomcat等)中，就可以运行了</p>\n<p>javaee里面最基本的就是Servlet,他接收请求，返回响应,对网页开发的应用来说,需要在Servlet里面拼接Html代码，然后使用PrintWriter进行输出</p>\n<p>Servlet的开发难度太高也不友好后来就出现了MVC概念,让Servlet作为控制层复杂业务中转,JSP就去做前台的显示层和ASP异曲同工，因为JSP开发也可以像HTML开发-样, 所见即所得可视化开发,并组可以把html直接转换成jsp,大大提高开发效率</p>\n<p>最后说下关系, j2ee需要用到javase才能运行, Servlet是j2ee里面的一个组成部分，负责处理请求转发,JSP其实就是Servlet,只是比Servlet的开发难度低一点，对开发者更加友好</p>\n<h3 id=\"后端和前端有什么区别\"><a href=\"#后端和前端有什么区别\" class=\"headerlink\" title=\"后端和前端有什么区别\"></a>后端和前端有什么区别</h3><p>后端和前端的区别是：1、定义不同；2、展示方式不同；3、所需的技能不同；4、思考角度不同；5、入门难度不同。其中，<strong>前端统称为客户端开发</strong>，在应用程序或网站的屏幕上看到的所有内容都属于前端的工作范畴。后端称为“<strong>服务器端开发</strong>”，属于在系统“后面”所发生的事情。</p>\n<p>1、定义不同<br>前端统称为”客户端开发“，在应用程序或网站的屏幕上看到的所有内容，都是<strong>由浏览器解析、处理、渲染</strong>相关HTML、CSS、JAVASCRIPT文件后呈现出来，都属于前端的工作范畴。</p>\n<p>后端称为“服务器端开发”，属于在系统“后面”所发生的事情。在后端服务器和浏览器或应用程序之间<strong>存储网站、应用数据和中间媒介</strong>的服务器都在后端的工作范畴内。在应用程序或网站屏幕上看不到的东西基本上都是后端。</p>\n<p>2、展示方式不同<br>前端的工作是<strong>制作网页</strong>，后端是<strong>结合数据库实现一些代码的功能逻辑</strong>。也就是说前端开发人员在应用程序中创建一个界面，上面有一个按钮，通过按下按钮可以获取客户的数据。</p>\n<p>后端开发人员负责写出按钮工作的代码，通过指出从数据库中提取哪些数据并将其传回到前端(且最终显示在那个位置)。</p>\n<p>3、所需的技能不同<br>前端开发需要具备的技能：对美学、艺术和设计有较好的理解、了解各种 CMS，如 WordPress，Joomla 或 Drupal、直观的用户需求、PHP 和 OOP 知识(面向对象编程)、专业的质量保证、能够使用 PhotoShop，Sketch 或 Figma 等设计工具、网络托管基础知识等。</p>\n<p>后端开发需要具备的技能：全面深入了解第三方附加组件、关于如何调试代码的批判性理解、将客户的业务需求转换为功能代码、了解 Web 服务器配置、兼容外部系统(支付处理，社交媒体网站)、批判性思维技巧、设计用户交互系统等。</p>\n<p>4、思考角度不同<br>前端主要是考虑怎么能让用户觉得用起来更舒服，考虑页面布局、交互效果、页面加载速度等，主要是偏向用户看得见的部分。</p>\n<p>后端更多是考虑<strong>业务逻辑、数据库表结构、服务器配置、负载均衡、数据的存储</strong>、跨平台API设计等等。更多的是考虑用户看不到的部分，保证业务逻辑处理数据的谨慎，保证数据吞吐的性能。</p>\n<p>5、入门难度不同<br>前端开发入门简单初期容易后期难，能看到自己做出来的展示界面会很有成就感。</p>\n<p>后端开发入门难，想要深入则更难，后端枯燥乏味没有太大成就感，平时工作就是看一堆业务逻辑代码。</p>\n<h2 id=\"SSM\"><a href=\"#SSM\" class=\"headerlink\" title=\"SSM\"></a>SSM</h2><p>Java的SSM是什么？</p>\n<p>Java的SSM是指使用Spring、SpringMVC和MyBatis这三个开源框架进行软件开发的一种架构模式。这三个框架分别代表了Java开发生态中的不同领域，通过它们的组合，可以实现更加高效、灵活和可维护的软件开发。</p>\n<p>首先，让我们来看看每个框架的作用和特点。</p>\n<p>Spring是一个轻量级的Java开发框架，提供了诸多功能和特性，如依赖注入、面向切面编程、事务管理等。它的核心思想是通过控制反转（IoC，也叫依赖注入，Dependency Injection，简称DI）和面向切面编程（AOP）来解耦和管理应用程序的各个组成部分。使用Spring，可以实现代码的模块化和解耦，提高代码的可测试性和可维护性。</p>\n<p>SpringMVC是基于Spring的Web开发框架，它使用了MVC（Model-View-Controller）的架构模式，将应用程序的逻辑、数据和视图进行分离。SpringMVC提供了强大的请求映射、数据绑定、异常处理等功能，同时也支持RESTful风格的Web服务开发。使用SpringMVC，可以快速构建响应式、可扩展和可定制化的Web应用程序。</p>\n<p>MyBatis是一个优秀的持久层框架，它很好地解决了Java应用程序与关系型数据库之间的交互问题。MyBatis通过提供简洁的SQL映射和灵活的SQL查询方式，将数据库操作与Java代码进行了解耦。与传统的ORM框架相比，MyBatis更加灵活，可以更好地控制SQL查询和结果映射过程，提高数据访问层的性能和可维护性。</p>\n<p>将Spring、SpringMVC和MyBatis结合起来使用，可以构建一个完整的Java应用程序。使用SSM架构，可以实现前后端的分离、模块化的开发方式，提高团队的协作效率和开发效率。</p>\n<p>在使用SSM进行开发时，首先需要配置好每个框架的环境和依赖关系。可以使用Maven或Gradle等构建工具来管理这些依赖。接下来，需要编写相应的配置文件，如Spring的配置文件、MyBatis的映射文件等。通过这些配置文件，可以定义应用程序的各种组件和配置项。</p>\n<p>在开发过程中，可以使用Spring的依赖注入和AOP来实现代码的解耦和模块化。可以使用SpringMVC的注解和请求映射机制来处理用户请求并返回相应的结果。可以使用MyBatis的注解和XML配置文件来定义数据库操作和查询。</p>\n<p>使用SSM进行开发，有很多优势。首先，它能够提高开发效率和代码的可维护性。通过使用这些成熟的框架，可以避免重复造轮子，减少开发工作量。其次，它能够提供更好的性能和扩展性。这些框架都经过了大量的实践和优化，能够提供高性能、高并发的支持。最后，它能够提供更好的开发体验和生态支持。这些框架都有庞大而活跃的社区，提供了丰富的文档、示例和解决方案。</p>\n<p>总之，Java的SSM是指使用Spring、SpringMVC和MyBatis这三个开源框架进行软件开发的架构模式。它的优势在于提高开发效率、提供更好的性能和扩展性，并且有庞大的社区支持。通过使用SSM，可以构建出高效、灵活和可维护的Java应用程序。</p>\n<h1 id=\"数据库基础和原理\"><a href=\"#数据库基础和原理\" class=\"headerlink\" title=\"数据库基础和原理\"></a>数据库基础和原理</h1><h2 id=\"SQL-DB-关系型数据库是如何工作的\"><a href=\"#SQL-DB-关系型数据库是如何工作的\" class=\"headerlink\" title=\"SQL DB - 关系型数据库是如何工作的\"></a>SQL DB - 关系型数据库是如何工作的</h2><p>这里关注的不是知识点，而是<strong>知识点之间的关联</strong>。</p>\n<h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p>是大多数 MySQL <strong>存储引擎</strong>的默认索引类型。</p>\n<p>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为<strong>一页</strong>(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>\n<p>我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p>\n<p>B+树通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序， 其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入。</p>\n<p>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶（孩子节点数）的B+树和m阶的B-树的差异在于：</p>\n<ol>\n<li><p>有n棵子树的节点中含有n个关键字(即每个关键字对应一棵子树)；</p>\n</li>\n<li><p><strong>所有叶子节点</strong>中包含了<strong>全部关键字</strong>的信息， 及指向含这些关键字记录的指针，且叶子节点<strong>本身依关键字的大小自小而大顺序链接</strong>；</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>所有的非终端节点可以看成是索引部分，节点中仅含有其所有子树（根节点）中的最大（或最小关键字</li>\n</ol>\n<ol start=\"4\">\n<li>除根节点外，其他<strong>所有</strong>节点中所含<strong>关键字</strong>的个数必须&gt;&#x3D;⌈m&#x2F;2⌉(注意： B-树是除根以外的所有<strong>非终端节点(非叶子节点)<strong>至少有⌈m&#x2F;2⌉棵</strong>子树</strong>)</li>\n</ol>\n<p>下图是所示为一棵3阶的B+树，通常在B+树上有两个指针头， 一个指向根节点，另一个指向<strong>关键字最小的叶子节点</strong>。因此，可以对B+树进行两种查找运算： 一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/1.png\" class=\"\">\n\n<img src=\"/2024/04/01/InternetBasicsNote/2.png\" class=\"\">\n\n<p>各种资料上B+树的定义各有不同，一种定义方式是关键字个数和孩子结点个数相同。这里我们采取维基百科上所定义的方式，即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。下图就是一颗阶数为4的B+树。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/3.png\" class=\"\">\n\n<p>除此之外B+树还有以下的要求:</p>\n<p>B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。</p>\n<p>B+树与B树最大的不同是<strong>内部结点不保存数据</strong>，<strong>只用于索引</strong>，<strong>所有数据</strong>（或者说记录）<strong>都保存在叶子结点中</strong>。</p>\n<p>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了<strong>叶子结点最多存储m-1个记录</strong>。</p>\n<p>内部结点中的key<strong>都按照从小到大的顺序排列</strong>，对于内部结点中的一个<strong>key</strong>，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</p>\n<p>每个叶子结点都<strong>存有相邻叶子结点的指针</strong>，叶子结点本身依关键字的大小自小而大顺序链接。</p>\n<p>B+树的特性</p>\n<p>所有关键字都出现在<strong>叶子节点的链表中</strong>（稠密索引），且链表中的关键字恰好是有序的；</p>\n<p>非叶子节点相当于<strong>叶子节点的索引</strong>（稀疏索引），叶子节点相当于是存储（关键字）数据的<strong>数据层</strong>；</p>\n<p>B+树的查找</p>\n<p>对B+树可以进行两种查找运算：</p>\n<ol>\n<li><p>从最小关键字起顺序查找；</p>\n</li>\n<li><p>从根节点开始，进行随机查找</p>\n</li>\n</ol>\n<p>在查找时，若非终端节点上的关键字等于给定值，并不终止，而是继续向下直到叶子节点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。其余同B-树的查找类似。</p>\n<p>B+树的插入</p>\n<p>插入比较复杂，只要是由底至上，归并的过程。</p>\n<p>参考<a href=\"https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree#3-b%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5\">B+树详解</a></p>\n<p>与B-树的比较</p>\n<p>一棵m阶的B+树和m阶的B树的异同点在于：</p>\n<p>所有的叶子节点中包含了全部关键字的信息，即指向含有这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大的顺序链接。（而B-树的叶子节点并没有包括全部需要查找的信息）</p>\n<p>所有的非终端节点可以看成是索引部分，节点中仅含有其子树根节点中最大（或最小）关键字。（而B-树的非终节点也包含需要查找的有效信息）</p>\n<p>B+树用途</p>\n<p>B+树主要适用于索引操作。为什么说B+树比B-树更适合实际应用于操作系统的文件索引和数据库索引？</p>\n<p>B+树的磁盘读写代价更低: B+树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对B-树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。举个例子：假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes, 一个关键字具体信息指针2bytes。一棵9阶B-树（一个节点最多8个关键字）的内部节点需要2个盘块。而B+树内部节点只需要1个盘块。当需要把内部节点读入内存的时候，B-树就比B+树多一次盘块查找时间（在磁盘中就是盘片旋转时间）</p>\n<p>B+树的查询效率更加稳定: 由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/4.png\" class=\"\">\n\n<p><strong>这段话很重要</strong>。</p>\n<p>浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，<strong>P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块</strong>。<strong>真实的数据存在于叶子节点</strong>即3、5、9、10、13、15、28、29、36、60、75、79、90、99。<strong>非叶子节点不存储真实的数据，只存储指引搜索方向的数据项</strong>，如17、35并不真实存在于数据表中。</p>\n<p>b+树的查找过程</p>\n<p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>\n<p>b+树性质</p>\n<ol>\n<li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h&#x3D;㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m &#x3D; 磁盘块的大小 &#x2F; 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>\n<li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>\n</ol>\n<p><strong>慢查询优化</strong><br>关于MySQL索引原理是比较枯燥的东西，大家只需要有一个感性的认识，并不需要理解得非常透彻和深入。我们回头来看看一开始我们说的慢查询。</p>\n<p>总结：</p>\n<p>MySQL采用B+树原因<br>MySQL等数据库普遍都采用B+树，而不是B-树。主要有如下原因：</p>\n<ol>\n<li><p>B-树和B+树最重要的一个区别就是B+树只有叶子节点存放数据，其余节点用来索引。而B-树是每个索引节点都会有data域。这就决定了B+树更适合用来存储外部数据。也就是所谓的磁盘数据。</p>\n</li>\n<li><p>从MySQL InnoDB的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系型数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会存储在磁盘上。</p>\n</li>\n<li><p>B+树的磁盘读写代价更低。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B-树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>\n</li>\n<li><p>B+树的查询效率更加稳定。由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>\n</li>\n<li><p>B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问了。</p>\n</li>\n</ol>\n<p>聚簇索引与非聚簇索引（应该就是聚集索引和非聚集索引）</p>\n<p>在《数据库原理》里面，对聚簇索引的解释是： 聚簇索引的顺序就是数据的物理存储顺序； 而对非聚簇索引的解释是： 索引顺序与数据物理排列无关。正是因为如此，所以一个表最多只能有一个聚簇索引。直观上来说，聚簇索引的叶子节点就是数据节点； 而非聚簇索引的叶子节点仍然是索引节点，只不过是指向对应数据块的指针。<strong>不懂</strong></p>\n<h2 id=\"Java-连接-Workbench-创建的数据库\"><a href=\"#Java-连接-Workbench-创建的数据库\" class=\"headerlink\" title=\"Java 连接 Workbench 创建的数据库\"></a>Java 连接 Workbench 创建的数据库</h2><p>首先需要在 MySQL Workbench 中创建一个 <strong>连接Connection</strong>，接着在这个连接里创建一个 <strong>数据库database</strong>，接着建表，复制下该 Connection 的<strong>JDBC链接</strong></p>\n<img src=\"/2024/04/01/InternetBasicsNote/7.png\" class=\"\">\n\n<p>Java的<strong>数据库编程</strong>：JDBC<br><strong>JDBC</strong>，即Java Database Connectivity，java数据库连接。是一种<strong>用于执行SQL语句的Java API</strong>，它是Java中的数据库连接规范。这个API由 java.sql.,javax.sql. 包中的一些类和接口组成，它为Java开发人员操作数据库提供了一个标准的API，可以为多种关系数据库提供统一访问。</p>\n<p>JDBC<strong>优势</strong>：<br>Java语言访问数据库操作<strong>完全面向抽象接口</strong>编程<br>开发数据库应用不用限定在特定数据库厂商的API<br>程序的可移植性大大增强</p>\n<p>创建 Java 文件，在源文件夹下创建 lib 文件夹并在这里导入 <strong>依赖</strong><code>mysql-connector-j-8.3.0.jar</code>，新建lib文件夹而不是将依赖放在 libraries中的原因是防止将文件发给别人后里面的依赖不见了。</p>\n<p>之后配置依赖，两种方式：<br>第一种方式：直接<strong>将lib文件夹设置为library</strong></p>\n<img src=\"/2024/04/01/InternetBasicsNote/8.png\" class=\"\">\n\n<p>第二种方式：<br>项目左边栏右键空白处之后选择： <code>Open Module Settings</code>，点击 + 号选择<code>Jars or Directories</code>选项并导入之前创建的 lib 文件夹即可完成配置。</p>\n<p>数据库连接代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.sql.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Conn</span> &#123; <span class=\"comment\">// 创建类Conn</span></span><br><span class=\"line\">    Connection con; <span class=\"comment\">// 声明Connection对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String user;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  String password;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> &#123; <span class=\"comment\">// 建立返回值为Connection的方法</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; <span class=\"comment\">// 加载数据库驱动类</span></span><br><span class=\"line\">            Class.forName(<span class=\"string\">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据库驱动加载成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        user = <span class=\"string\">&quot;root&quot;</span>;<span class=\"comment\">//数据库登录名</span></span><br><span class=\"line\">        password = <span class=\"string\">&quot;123456&quot;</span>;<span class=\"comment\">//密码</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; <span class=\"comment\">// 通过访问数据库的URL获取数据库连接对象</span></span><br><span class=\"line\">            con = DriverManager.getConnection(<span class=\"string\">&quot;jdbc:mysql://127.0.0.1:3306/?user=root&quot;</span>, user, password);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据库连接成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> con; <span class=\"comment\">// 按方法要求返回一个Connection对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> SQLException &#123; <span class=\"comment\">// 主方法，测试连接</span></span><br><span class=\"line\">        <span class=\"type\">Conn</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Conn</span>(); <span class=\"comment\">// 创建本类对象</span></span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> c.getConnection(); <span class=\"comment\">// 调用连接数据库的方法</span></span><br><span class=\"line\"><span class=\"comment\">//        4.执行SQL对象Statement，执行SQL的对象</span></span><br><span class=\"line\">        <span class=\"type\">Statement</span> <span class=\"variable\">statement</span> <span class=\"operator\">=</span> connection.createStatement();</span><br><span class=\"line\"><span class=\"comment\">//        5.执行SQL的对象去执行SQL，返回结果集</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;SELECT * FROM databasejdbc.student;&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">ResultSet</span> <span class=\"variable\">resultSet</span> <span class=\"operator\">=</span> statement.executeQuery(sql);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(resultSet.next())&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Id=&quot;</span>+resultSet.getString(<span class=\"string\">&quot;id&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;name=&quot;</span>+resultSet.getString(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;score=&quot;</span>+resultSet.getString(<span class=\"string\">&quot;score&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        6.释放连接</span></span><br><span class=\"line\">        resultSet.close();</span><br><span class=\"line\">        statement.close();</span><br><span class=\"line\">        connection.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Mysql\"><a href=\"#Mysql\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h2><p><a href=\"https://zhuanlan.zhihu.com/p/373515920\">MySQL 5.7史上最详细下载安装配置教程</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1533580\">MySQL之source命令</a></p>\n<p>用 zip 安装的 mysql 5.7 版本，root是<strong>用户名</strong>， <strong>密码</strong>为 123465。<br>mysql -u root -p</p>\n<p>GRANT USAGE ON <em>.</em> TO ‘user01‘@’localhost’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;</p>\n<p>用户：user01，密码：123456</p>\n<p>CREATE USER ‘laowang‘@’localhost’ IDENTIFIED BY ‘123456’;<br>授予账户权限的方法如下：</p>\n<p>GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON <em>.</em> TO ‘laowang‘@’localhost’;<br>授予所有权限：</p>\n<p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘laowang‘@’localhost’；<br>查看用户权限：</p>\n<p>show grants for ‘laowang‘@’localhost’;</p>\n<h1 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h1><p>SQL 是用于访问和处理数据库的标准的计算机语言。</p>\n<p>SQL (Structured Query Language:<strong>结构化查询语言</strong>) 是用于管理<strong>关系数据库管理系统</strong>（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>\n<p>RDBMS 指关系型数据库管理系统，全称 Relational Database Management System。</p>\n<p>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。</p>\n<p>RDBMS 中的数据存储在被称为<strong>表</strong>的数据库对象中。</p>\n<p>表是相关的数据项的集合，它由列和行组成。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>列（column） - 表中的一个<strong>字段</strong>。所有表都是由<strong>一个或多个列</strong>组成的。<br><strong>行</strong>（row） - 表中的一个<strong>记录</strong>（行是一个完整的记录）。<br><strong>主键</strong>（primary key） - <strong>一列</strong>（或<strong>一组列</strong>），其值能够唯一标识表中每一行。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/5.png\" class=\"\">\n\n<p>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。SQL 语句可以写成一行，也可以分写为多行。</p>\n<p>SQL <strong>对大小写不敏感</strong>：SELECT 与 select 是相同的，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。</p>\n<p>某些数据库系统要求在每条 SQL 语句的末端<strong>使用分号</strong>。</p>\n<p>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 一行 SQL 语句</span><br><span class=\"line\">UPDATE user SET username=&#x27;robot&#x27;, password=&#x27;robot&#x27; WHERE username = &#x27;root&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 多行 SQL 语句</span><br><span class=\"line\">UPDATE user</span><br><span class=\"line\">SET username=&#x27;robot&#x27;, password=&#x27;robot&#x27;</span><br><span class=\"line\">WHERE username = &#x27;root&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">## 注释1</span><br><span class=\"line\">-- 注释2</span><br><span class=\"line\">/* 注释3 */</span><br></pre></td></tr></table></figure>\n\n<p><strong>一些最重要的 SQL 命令</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT - 从数据库中提取数据</span><br><span class=\"line\">UPDATE - 更新数据库中的数据</span><br><span class=\"line\">DELETE - 从数据库中删除数据</span><br><span class=\"line\">INSERT INTO - 向数据库中插入新数据</span><br><span class=\"line\">CREATE DATABASE - 创建新数据库</span><br><span class=\"line\">ALTER DATABASE - 修改数据库</span><br><span class=\"line\">CREATE TABLE - 创建新表</span><br><span class=\"line\">ALTER TABLE - 变更（改变）数据库表</span><br><span class=\"line\">DROP TABLE - 删除表</span><br><span class=\"line\">CREATE INDEX - 创建索引（搜索键）</span><br><span class=\"line\">DROP INDEX - 删除索引</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"SQL-分类\"><a href=\"#SQL-分类\" class=\"headerlink\" title=\"SQL 分类\"></a>SQL 分类</h2><p>数据定义语言（Data Definition Language，<strong>DDL</strong>）是 SQL 语言集中负责<strong>数据结构定义与数据库对象定义</strong>的语言。<br>DDL 的核心指令是 <code>CREATE、ALTER、DROP</code>。</p>\n<p>数据操纵语言（Data Manipulation Language, <strong>DML</strong>）是用于<strong>数据库操作</strong>，对数据库中的对象和数据<strong>运行访问工作</strong>的编程语句。<br>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是<strong>以读写数据库为主</strong>。<br>DML 的核心指令是 <code>INSERT、UPDATE、DELETE、SELECT</code>。这四个指令合称 <code>CRUD(Create, Read, Update, Delete)</code>，即<strong>增删改查</strong>。</p>\n<p>事务控制语言（Transaction Control Language, <strong>TCL</strong>）用于<strong>管理数据库中的事务</strong>。这些用于管理由 <strong>DML</strong> 语句所做的更改。它还允许将语句分组为逻辑事务。<br>TCL 的核心指令是 <code>COMMIT、ROLLBACK</code>。</p>\n<p>数据控制语言（Data Control Language, <strong>DCL</strong>）是一种可<strong>对数据访问权进行控制的指令</strong>，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等<strong>数据库对象</strong>的<strong>控制权</strong>。<br>DCL 的核心指令是 <code>GRANT、REVOKE</code>。<br>DCL 以<strong>控制用户的访问权限为主</strong>，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES</code>。<br>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>\n<h2 id=\"常用语句\"><a href=\"#常用语句\" class=\"headerlink\" title=\"常用语句\"></a>常用语句</h2><p>上下分别为 test_table, new_table。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/6.png\" class=\"\">\n<img src=\"/2024/04/01/InternetBasicsNote/10.png\" class=\"\">\n\n<p>注意语句结束时需要分号，同时注意什么时候是语句结束。</p>\n<h3 id=\"SQL-SELECT-语句\"><a href=\"#SQL-SELECT-语句\" class=\"headerlink\" title=\"SQL SELECT 语句\"></a>SQL SELECT 语句</h3><p>SELECT 语句用于从数据库中选取数据，获取结果集。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT column1, column2, ...</span><br><span class=\"line\">FROM table_name;</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT * FROM table_name;  <span class=\"comment\">// 选择全部字段</span></span><br></pre></td></tr></table></figure>\n<p>column1, column2, …：要选择的<strong>字段</strong>（列）名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。<br>table_name：要查询的表名称。</p>\n<p>SQL SELECT <strong>DISTINCT</strong> 语句<br>在表中，<strong>一个列可能会包含多个重复值</strong>，此语句用于去重。<br>当选择多个列时，只有所有列的值都相同才算相同。</p>\n<h3 id=\"SQL-WHERE-子句\"><a href=\"#SQL-WHERE-子句\" class=\"headerlink\" title=\"SQL WHERE 子句\"></a>SQL WHERE 子句</h3><p>WHERE 子句用于<strong>提取那些满足指定条件的记录</strong>。</p>\n<p>注意： SELECT 的关键是<strong>影响 结果集 中有哪些列</strong>，比如<strong>显示</strong>出来哪些列，并不是说 WHERE 查询的列一定得在 SELECT 选择的列里面。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT column1, column2, ...</span><br><span class=\"line\">FROM table_name</span><br><span class=\"line\">WHERE condition;</span><br></pre></td></tr></table></figure>\n\n<p>如：<code>SELECT * FROM Websites WHERE name=&#39;zlc&#39;;</code>使用<code>SELECT * FROM Websites WHERE name=&#39;zlc&#39;;</code>同样会只选择 name&#x3D;’zlc’ 的行，但选择的结果只显示 id 。</p>\n<p>SQL 使用<strong>单引号来环绕文本值</strong>（大部分数据库系统也接受双引号）。<br>在上个实例中 ‘zlc’ 文本字段使用了单引号。<br>如果是<strong>数值字段</strong>，<strong>请不要使用引号</strong>。（MySQL Workbench 好像对数值用单引号也可以）</p>\n<p>WHERE 子句中的运算符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">=\t等于</span><br><span class=\"line\">&lt;&gt;\t不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != </span><br><span class=\"line\">&gt;\t大于</span><br><span class=\"line\">&lt;\t小于</span><br><span class=\"line\">&gt;=\t大于等于</span><br><span class=\"line\">&lt;=\t小于等于</span><br><span class=\"line\">and or not 逻辑运算，再加入括号组成复合表达式，如：WHERE age &gt; 15 AND (name=&#x27;zlc&#x27; OR score&gt;90);</span><br><span class=\"line\">BETWEEN\tand 在某个范围内 between lowLimit and highLimit 包含上下界</span><br><span class=\"line\">IN\t指定针对某个列的多个可能值   in(a,b,c..)罗列值</span><br><span class=\"line\">LIKE\t搜索某种模式（模糊查询即为不全信息查询） 只有字段是文本值时才使用 LIKE，通配符 % 表示任何字符出现任意次数，_ 下划线表示任何字符出现一次，如：</span><br><span class=\"line\">  M% : 正则表达式，表示的意思为模糊查询信息为 M 开头的。</span><br><span class=\"line\">  %M% : 表示查询包含M的所有内容。</span><br><span class=\"line\">  %M_ : 表示查询以M在倒数第二位的所有内容。</span><br><span class=\"line\">  不要滥用通配符，通配符位于开头处匹配会非常慢</span><br><span class=\"line\">  例如 WHERE name LIKE &#x27;%s%&#x27;; 能匹配 &#x27;sjl&#x27; &#x27;sxr&#x27;</span><br><span class=\"line\">IS NULL 以及 IS NOT NULL 用来查找列中带有 NULL 值和不带有 Null 值的记录，</span><br><span class=\"line\">请始终使用 IS NULL 来查找 NULL 值。如 where id is null。</span><br><span class=\"line\">另外：工作中一般建表的时候一般会禁止使用 NULL 的，不利于代码维护。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SQL-ORDER-BY-关键字\"><a href=\"#SQL-ORDER-BY-关键字\" class=\"headerlink\" title=\"SQL ORDER BY 关键字\"></a>SQL ORDER BY 关键字</h3><p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序，默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT column1, column2, ...</span><br><span class=\"line\">FROM table_name</span><br><span class=\"line\">ORDER BY column1, column2, ... ASC|DESC;</span><br><span class=\"line\"></span><br><span class=\"line\">column1, column2, ...：要排序的字段名称，可以为多个字段。</span><br><span class=\"line\">ASC：表示按升序排序。</span><br><span class=\"line\">DESC：表示按降序排序。</span><br></pre></td></tr></table></figure>\n\n<p>选择多列的时候先按前列排序，前列相同的情况下再按后面的列排序。并且desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序，如：order by A desc,B   这个时候 A 降序，B 升序排列。</p>\n<h3 id=\"LIMIT-和-OFFSET-用法\"><a href=\"#LIMIT-和-OFFSET-用法\" class=\"headerlink\" title=\"LIMIT 和 OFFSET 用法\"></a>LIMIT 和 OFFSET 用法</h3><p>MySQL 里<strong>分页</strong>一般用 LIMIT 来实现:</p>\n<p><strong>限制返回的行数</strong>。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>\n<p>当 LIMIT 后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量，例如：<code>select* from article LIMIT 1,3</code> 就是跳过 1 条数据，从第 2 条数据开始取，取 3 条数据，也就是取 2、3、4 三条数据。</p>\n<p>当 LIMIT 后面跟一个参数的时候，该参数表示要取的数据的数量。例如 <code>select* from article LIMIT 3</code> 表示直接取前三条数据，类似 sqlserver 里的 top 语法。</p>\n<p>当 LIMIT 和 OFFSET 组合使用的时候，LIMIT 后面只能有一个参数，表示要取的的数量，OFFSET表示要跳过的数量 。例如<code> select * from article LIMIT 3 OFFSET 1</code> 表示跳过 1 条数据，从第 2 条数据开始取，取3条数据，也就是取 2、3、4 三条数据。</p>\n<h3 id=\"SQL-INSERT-INTO-语句\"><a href=\"#SQL-INSERT-INTO-语句\" class=\"headerlink\" title=\"SQL INSERT INTO 语句\"></a>SQL INSERT INTO 语句</h3><p>INSERT INTO 语句用于向表中插入新记录（行）。</p>\n<p>INSERT INTO 语句可以有<strong>两种</strong>编写形式。</p>\n<ol>\n<li>第一种形式<strong>无需指定要插入数据的列名</strong>，只需提供<strong>被插入的值</strong>即可：<br><code>INSERT INTO table_name  VALUES (value1,value2,value3,...);</code><br>如：<code>insert into test_table values(5,&#39;sxr&#39;,18,80);</code></li>\n<li>第二种形式需要<strong>指定列名及被插入的值</strong>：<br><code>INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...);</code><br>如<code>insert into test_table (id,name,age,score) values(6,&#39;myz&#39;,45,74);</code></li>\n</ol>\n<p>table_name：需要插入新记录的表名。<br>column1, column2, …：需要插入的<strong>字段名</strong>。<br>value1, value2, …：需要插入的<strong>字段值</strong>。</p>\n<p>也可以<strong>在指定的列插入数据</strong>。<br>下面的 SQL 语句将插入一个新行，但是只在 “name”、”age” 和 “score” 列插入数据（id 字段会自动更新，前提是在 table 属性里设置 id 列<strong>自增</strong>）：<br><code>insert into test_table (name,age,score) values(&#39;yyy&#39;,95,12);</code><br>需要注意的是：<strong>没有列出列名的</strong> insert into 写法得把新插入行的每个数据都列出来。</p>\n<h3 id=\"SQL-UPDATE-语句\"><a href=\"#SQL-UPDATE-语句\" class=\"headerlink\" title=\"SQL UPDATE 语句\"></a>SQL UPDATE 语句</h3><p>UPDATE 语句用于<strong>更新表中已存在的记录</strong>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE table_name</span><br><span class=\"line\">SET column1 = value1, column2 = value2, ...</span><br><span class=\"line\">WHERE condition;</span><br></pre></td></tr></table></figure>\n<p>table_name：要修改的表名称。<br>column1, column2, …：要修改的<strong>字段名称</strong>，可以为多个字段。<br>value1, value2, …：要修改的值，可以为多个值。<br>condition：修改条件，用于指定哪些数据要修改。<br><strong>WHERE</strong> 子句规定哪条记录或者哪些记录需要更新。如果您<strong>省略</strong>了 WHERE 子句，<strong>所有的记录都将被更新</strong>！<br>WHERE 应该是需要对 关键列(<strong>主键</strong>) 进行选择(MySQL Workbench)。</p>\n<p>Update 警告！<br>在更新记录时要格外小心！如果我们省略了 WHERE 子句，会更新所有数据。执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。</p>\n<p>在 MySQL 中可以通过设置 sql_safe_updates 这个自带的参数来解决，当该参数开启的情况下，你必须在update 语句后携带 where 条件，否则就会报错。</p>\n<p><code>set sql_safe_updates=1</code>; 表示开启该参数<br><code>set sql_safe_updates=0; </code> 关闭安全模式</p>\n<p>如果设置了 sql_safe_updates&#x3D;1，那么 <strong>update</strong> 语句必须满足如下条件之一才能执行成功：</p>\n<ol>\n<li>使用 where 子句, 并且 where 子句中列必须为 <strong>prefix</strong>(<strong>主键 key column</strong>) 索引列。</li>\n<li>使用 limit。</li>\n<li>同时使用 where 子句和 limit (此时 where 子句中列可以不是索引列)。</li>\n</ol>\n<p><strong>delete</strong> 语句必须满足如下条件之一才能执行成功。</p>\n<ol>\n<li>使用 where 子句, 并且 where 子句中列必须为 <strong>prefix</strong> 索引列。</li>\n<li>同时使用 where 子句和 limit (此时 where 子句中列可以不是索引列)。</li>\n</ol>\n<h3 id=\"SQL-DELETE-FROM-语句\"><a href=\"#SQL-DELETE-FROM-语句\" class=\"headerlink\" title=\"SQL DELETE FROM 语句\"></a>SQL DELETE FROM 语句</h3><p>DELETE 语句用于删除表中的记录（行）。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">DELETE FROM table_name</span><br><span class=\"line\">WHERE condition;</span><br></pre></td></tr></table></figure>\n<p>table_name：要删除的表名称。<br>condition：删除条件，用于<strong>指定哪些数据要删除</strong>。<br><strong>WHERE</strong> 子句规定哪条记录或者哪些记录需要删除。如果您<strong>省略了 WHERE 子句</strong>，<strong>所有的记录都将被删除</strong>！</p>\n<p>可以在不删除表的情况下，删除表中所有的行。这意味着<strong>表结构、属性、索引将保持不变</strong>：<br><code>DELETE FROM table_name;</code></p>\n<p>SQL关于删除的三个语句：<strong>DROP、TRUNCATE、 DELETE</strong> 的区别。</p>\n<p><strong>DROP</strong>:<br>DROP test;<br>删除表test，并释放空间，将test<strong>删除的一干二净</strong>，<strong>没有备份表之前要慎用</strong>。</p>\n<p><strong>TRUNCATE</strong>:<br>TRUNCATE test;<br>删除表test里的内容，<strong>表的结构(定义)还在</strong>，并释放空间，没有备份表之前要慎用。</p>\n<p><strong>DELETE</strong>:<br>1、删除指定数据<br>删除表test中年龄等于30的且国家为US的数据<br><code>DELETE FROM test WHERE age=30 AND country=&#39;US&#39;;</code></p>\n<p>2、删除整个表<br>仅删除表test内的所有内容，保留表的定义，<strong>不释放空间</strong>，<strong>可以回滚恢复</strong>。<br><code>DELETE FROM test</code> 或者 <code>DELETE * FROM test;</code></p>\n<h3 id=\"SQL-INSERT-INTO-SELECT-语句\"><a href=\"#SQL-INSERT-INTO-SELECT-语句\" class=\"headerlink\" title=\"SQL INSERT INTO SELECT 语句\"></a>SQL INSERT INTO SELECT 语句</h3><p>INSERT INTO SELECT 语句<strong>从一个表复制数据</strong>，然后把数据<strong>插入到一个已存在的表中</strong>，目标表中任何已存在的行都不会受影响。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">INSERT INTO new_table</span><br><span class=\"line\">SELECT * FROM origin__table;</span><br></pre></td></tr></table></figure>\n<p>或者我们可以只复制<strong>指定的列</strong>（多列）插入到另一个已存在的表中：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">INSERT INTO new_table</span><br><span class=\"line\">(column_name(s))</span><br><span class=\"line\">SELECT column_name(s)</span><br><span class=\"line\">FROM origin__table;</span><br></pre></td></tr></table></figure>\n\n<p>如：<code>INSERT INTO new_table (id,name) SELECT id,name FROM test_table;</code> <strong>注意格式</strong>，括号也不能多写。<br>可以进一步用 where 选择。</p>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p>子查询是嵌套在较大查询中的 SQL 查询。子查询也称为<strong>内部查询或内部选择</strong>，而包含子查询的语句也称为外部查询或外部选择。</p>\n<p>子查询可以嵌套在 SELECT，INSERT，UPDATE 或 DELETE 语句内或另一个子查询中。</p>\n<p>子查询<strong>通常</strong>会在另一个 SELECT 语句的 <strong>WHERE</strong> 子句中添加。</p>\n<p>子查询<strong>必须</strong>被圆括号 () 括起来。</p>\n<p><strong>内部查询首先在其父查询之前执行</strong>，以便可以将内部查询的结果传递给外部查询。</p>\n<h3 id=\"连接-JOIN\"><a href=\"#连接-JOIN\" class=\"headerlink\" title=\"连接 JOIN\"></a>连接 JOIN</h3><p>上下分别为 test_table, new_table。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/12.png\" class=\"\">\n<img src=\"/2024/04/01/InternetBasicsNote/13.png\" class=\"\">\n\n<p><strong>连接</strong>（JOIN）</p>\n<p>SQL join 用于把来自<strong>两个或多个表的行</strong>结合起来，基于这些表之间的<strong>共同字段</strong>。</p>\n<p>LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法:</p>\n<img src=\"/2024/04/01/InternetBasicsNote/9.png\" class=\"\">\n\n<p>最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN <strong>从多个表中</strong>返回满足 JOIN 条件的<strong>所有行</strong>。</p>\n<p><strong>INNER JOIN</strong>语法</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT column1, column2, ...</span><br><span class=\"line\">FROM table1</span><br><span class=\"line\">JOIN table2 ON condition;</span><br></pre></td></tr></table></figure>\n<p>column1, column2, …：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。<br>table1：要连接的第一个表（左表）。<br>table2：要连接的第二个表（右表）。<br>condition：<strong>连接条件</strong>，用于指定连接方式。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">select test_table.id,test_table.name,new_table.height,test_table.score </span><br><span class=\"line\">from test_table inner JOIN new_table ON </span><br><span class=\"line\">test_table.id=new_table.id;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，”test_table” 表中的 “id” 列指向 “new_table” 表中的字段 “id”。上面这两个表是通过 “id” 列联系起来的。并且注意，没有要求两个字段要完全一样，比如我可以定义 “new_table” 表中是”new_id”，只要  ON 后面设置连接那就可以。</p>\n<p>效果是将行组合起来了，注意看列的顺序也是我们在上面代码中指定的：</p>\n<img src=\"/2024/04/01/InternetBasicsNote/11.png\" class=\"\">\n\n<p>不同的 SQL JOIN：<br><strong>INNER JOIN</strong>：如果表中<strong>有至少一个匹配</strong>，则返回行<br><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行<br><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行<br><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行（MySQL中不支持）</p>\n<p>首先，连接的结果可以在<strong>逻辑</strong>上看作是由 SELECT 语句<strong>指定的列</strong>组成的新表。</p>\n<p><strong>左连接与右连接</strong>的<strong>左右</strong>指的是<strong>以两张表中的哪一张为基准</strong>，它们都是<strong>外连接</strong>。</p>\n<p><strong>外连接</strong>就好像是<strong>为非基准表</strong>添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行<strong>左连接</strong>，左表是基准表，<strong>左表的所有行都出现在结果中</strong>，右表则可能因为无法与基准表匹配而出现是<strong>空值</strong>的字段。</p>\n<p><strong>得到的结果数</strong>：<br>inner join &lt;&#x3D; left join, right join<br>full join &gt;&#x3D; left join, right join<br>当 inner join &lt; left join, right join 时， full join &gt; left join, right join</p>\n<p>SQL LEFT JOIN 关键字从<strong>左表</strong>（table1）返回所有的行，即使右表（table2）中没有匹配。<strong>如果右表中没有匹配，则结果为 NULL</strong>。</p>\n<p><strong>INNER JOIN</strong>语法（只要将上面代码的 INNER 改成 LEFT 就行）</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT column_name(s)</span><br><span class=\"line\">FROM table1</span><br><span class=\"line\">LEFT JOIN table2</span><br><span class=\"line\">ON table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>\n<img src=\"/2024/04/01/InternetBasicsNote/15.png\" class=\"\">\n\n<p>运行代码</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">select test_table.id,test_table.name,new_table.height,test_table.score </span><br><span class=\"line\">from test_table left JOIN new_table ON </span><br><span class=\"line\">test_table.id=new_table.id</span><br><span class=\"line\">ORDER BY new_table.height DESC;</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<img src=\"/2024/04/01/InternetBasicsNote/14.png\" class=\"\">\n\n<p>可以理解为：返回左边所有的人以及他们的身高(<strong>如果有的话</strong>)。</p>\n<p>注释：LEFT JOIN 关键字从左表（test_table）返回所有的行，即使右表（new_table）中没有匹配。</p>\n<p>SQL RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。<br>注意：这里哪些显示为 NULL 是由上面 <strong>SELECT</strong> <strong>如何选择列字段来决定的</strong>！</p>\n<p>SQL RIGHT JOIN 语法</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT column_name(s)</span><br><span class=\"line\">FROM table1</span><br><span class=\"line\">RIGHT JOIN table2</span><br><span class=\"line\">ON table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>\n<img src=\"/2024/04/01/InternetBasicsNote/16.png\" class=\"\">\n\n<p>运行代码</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">select test_table.id,test_table.name,new_table.height,test_table.score </span><br><span class=\"line\">from test_table right JOIN new_table ON </span><br><span class=\"line\">test_table.id=new_table.id</span><br><span class=\"line\">ORDER BY new_table.height DESC;</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<img src=\"/2024/04/01/InternetBasicsNote/17.png\" class=\"\">\n\n<p>这是因为 new_table 里有 test_table 里没有的 id&#x3D;5，左表没有对应的数据，<strong>加上</strong> SELECT 那里选择的是 test_table.name 等，所以只有 new_table.height 显示了，如果我 SELECT 那里选择的是 new_table.name ，那么便有：</p>\n<img src=\"/2024/04/01/InternetBasicsNote/18.png\" class=\"\">\n\n<p>注释：RIGHT JOIN 关键字从右表（access_log）返回所有的行，即使左表（Websites）中没有匹配。</p>\n<p>SQL FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。</p>\n<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果，即并集。</p>\n<p>MySQL中并没有直接支持FULL JOIN的语法，但可以使用UNION操作符和LEFT JOIN、RIGHT JOIN语法组合实现FULL JOIN的功能。 具体来说，可以将LEFT JOIN和RIGHT JOIN联合起来，使用UNION操作符将它们的结果合并，就可以实现FULL JOIN。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT test_table.id,test_table.name,new_table.height,test_table.score</span><br><span class=\"line\">FROM test_table</span><br><span class=\"line\">LEFT JOIN new_table ON test_table.id = new_table.id</span><br><span class=\"line\"></span><br><span class=\"line\">UNION</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT test_table.id,test_table.name,new_table.height,test_table.score</span><br><span class=\"line\">FROM test_table</span><br><span class=\"line\">RIGHT JOIN new_table ON test_table.id = new_table.id</span><br></pre></td></tr></table></figure>\n<img src=\"/2024/04/01/InternetBasicsNote/19.png\" class=\"\">\n\n\n<h3 id=\"组合-UNION\"><a href=\"#组合-UNION\" class=\"headerlink\" title=\"组合 UNION\"></a>组合 UNION</h3><p><strong>求并集</strong>。</p>\n<p>SQL UNION 操作符合并两个或多个 SELECT 语句的结果集。</p>\n<p>请注意，UNION 内部的每个 SELECT 语句必须拥有<strong>相同数量的列</strong>。列也必须拥有<strong>相似的数据类型</strong>。同时，每个 SELECT 语句中的<strong>列的顺序必须相同</strong>。</p>\n<p>SQL UNION 语法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT <span class=\"title function_\">column_name</span><span class=\"params\">(s)</span> FROM table1</span><br><span class=\"line\">UNION</span><br><span class=\"line\">SELECT <span class=\"title function_\">column_name</span><span class=\"params\">(s)</span> FROM table2;</span><br></pre></td></tr></table></figure>\n<p>注释：默认地，UNION 操作符选取<strong>不同的值</strong>（DISTINCT）。如果需要<strong>重复</strong>的值，请使用 UNION ALL。</p>\n<p>如：选取所有不同的 name（只有不同的值）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT id,name FROM test_table</span><br><span class=\"line\">UNION</span><br><span class=\"line\">SELECT id,name FROM new_table</span><br><span class=\"line\">order by id;</span><br></pre></td></tr></table></figure>\n<img src=\"/2024/04/01/InternetBasicsNote/20.png\" class=\"\">\n\n\n<h3 id=\"SQL-别名-AS\"><a href=\"#SQL-别名-AS\" class=\"headerlink\" title=\"SQL 别名  AS\"></a>SQL 别名  AS</h3><p>通过使用 SQL，可以为<strong>表</strong>名称或<strong>列</strong>名称指定别名。</p>\n<p>基本上，创建别名是为了让列名称的可读性更强。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 列的 SQL 别名语法</span></span><br><span class=\"line\">SELECT column_name AS alias_name</span><br><span class=\"line\">FROM table_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表的 SQL 别名语法</span></span><br><span class=\"line\">SELECT <span class=\"title function_\">column_name</span><span class=\"params\">(s)</span></span><br><span class=\"line\">FROM table_name AS alias_name;</span><br></pre></td></tr></table></figure>\n<p>如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT id as number, concat(name,<span class=\"string\">&#x27;,&#x27;</span>,age,<span class=\"string\">&#x27;,&#x27;</span>,score) as data</span><br><span class=\"line\">FROM runoob.test_table;</span><br></pre></td></tr></table></figure>\n<p>创建 number 作为 id 的别名，concat 将这三个列的数据结合在一块，并以 data 作为别名，</p>\n<p>通过为表取别名，使用 select 查询时就要可以让 SQL 简短很多（在创建表的别名时就可以使用这个别名来选择这个表的列）</p>\n<p>另外，在下面的情况下，使用别名很有用：<br>在查询中涉及<strong>超过一个表</strong><br>在查询中使用了函数<br>列名称很长或者可读性差<br>需要把两个列或者多个列结合在一起</p>\n<h3 id=\"创建数据库、表\"><a href=\"#创建数据库、表\" class=\"headerlink\" title=\"创建数据库、表\"></a>创建数据库、表</h3><p>SQL CREATE DATABASE 语句用于创建数据库。</p>\n<p><code>CREATE DATABASE dbname;</code> 创建名为 “dbname” 的数据库。</p>\n<p>SQL CREATE TABLE 语句用于创建数据库中的表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">table_name</span></span><br><span class=\"line\"><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">column_name1 data_type(size)</span>,</span><br><span class=\"line\">column_name2 <span class=\"title function_\">data_type</span><span class=\"params\">(size)</span>,</span><br><span class=\"line\">column_name3 <span class=\"title function_\">data_type</span><span class=\"params\">(size)</span>,</span><br><span class=\"line\">....</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>data_type 参数规定<strong>列的数据类型</strong>（例如 varchar、integer、decimal、date 等等）。</p>\n<p>size 参数规定表中列字段的最大长度。</p>\n<h3 id=\"SQL-约束（Constraints）\"><a href=\"#SQL-约束（Constraints）\" class=\"headerlink\" title=\"SQL 约束（Constraints）\"></a>SQL 约束（Constraints）</h3><p>SQL 约束（Constraints）用于<strong>规定表中的数据规则</strong>。</p>\n<p>如果存在违反约束的数据行为，行为会被约束终止。</p>\n<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>\n<p>SQL CREATE TABLE + <strong>CONSTRAINT</strong> 语法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">table_name</span></span><br><span class=\"line\"><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">column_name1 data_type(size)</span> constraint_name,</span><br><span class=\"line\">column_name2 <span class=\"title function_\">data_type</span><span class=\"params\">(size)</span> constraint_name,</span><br><span class=\"line\">column_name3 <span class=\"title function_\">data_type</span><span class=\"params\">(size)</span> constraint_name,</span><br><span class=\"line\">....</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>在 SQL 中，我们有如下约束：</p>\n<ul>\n<li>NOT NULL - 指示该列不能存储 NULL 值。</li>\n<li>UNIQUE - 保证该列的每行必须有唯一的值（不能有重复值）。</li>\n<li><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保该列（或两个列多个列的结合）<strong>有唯一标识</strong>，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><strong>FOREIGN</strong> KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><strong>CHECK</strong> - 保证列中的值符合指定的条件。</li>\n<li>DEFAULT - 规定没有给列赋值时的默认值。</li>\n</ul>\n<p>在默认的情况下，表的列接受 NULL 值。<br>NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"title function_\">Persons</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    ID <span class=\"type\">int</span> NOT NULL,</span></span><br><span class=\"line\"><span class=\"params\">    LastName varchar(<span class=\"number\">255</span>)</span> NOT NULL,</span><br><span class=\"line\">    FirstName <span class=\"title function_\">varchar</span><span class=\"params\">(<span class=\"number\">255</span>)</span> NOT NULL,</span><br><span class=\"line\">    Age <span class=\"type\">int</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>在一个已创建的表添加和删除 NOT NULL 约束，注意，列名后面需要跟数据类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE Persons</span><br><span class=\"line\">MODIFY Age <span class=\"type\">int</span> NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">ALTER TABLE Persons</span><br><span class=\"line\">MODIFY Age <span class=\"type\">int</span> NULL;</span><br></pre></td></tr></table></figure>\n\n\n<p>UNIQUE 约束<strong>唯一标识</strong>数据库表中的每条记录。</p>\n<p>UNIQUE 和 PRIMARY KEY 约束均为<strong>列或列集合</strong>提供了唯一性的保证。</p>\n<p><strong>PRIMARY KEY</strong> 约束拥有<strong>自动定义</strong>的 UNIQUE 约束。</p>\n<p>SQL PRIMARY KEY 约束</p>\n<p>每个表<em><strong>都应该有一个主键</strong></em>，并且每个表<strong>只能有一个主键</strong>。注意：只有有一个主键<strong>不是说只有一列是主键</strong>，可以是这个主键设置为包含了很多列（为多个列创建 PRIMARY KEY 约束）。<br>如：<code>CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)</code><br>注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID 主键名）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。</p>\n<p><strong>Auto-increment</strong> 会在新记录插入表中时生成一个唯一的数字。</p>\n<p>我们<strong>通常</strong>希望在每次插入新记录时，<strong>自动地创建主键字段</strong>的值。</p>\n<p>我们可以在表中创建一个 auto-increment 字段。</p>\n<h4 id=\"SQL-FOREIGN-KEY-约束\"><a href=\"#SQL-FOREIGN-KEY-约束\" class=\"headerlink\" title=\"SQL FOREIGN KEY 约束\"></a>SQL FOREIGN KEY 约束</h4><p>一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY(唯一约束的键)。</p>\n<p>FOREIGN KEY 约束用于<strong>预防破坏表之间连接的行为</strong>。</p>\n<p>FOREIGN KEY 约束也能防止<strong>非法数据插入外键列</strong>，因为它必须是它<strong>指向的那个表中的值之一</strong>。</p>\n<p><strong>略微复杂</strong>，之后再来吧。</p>\n<h3 id=\"SQL-CREATE-INDEX-语句\"><a href=\"#SQL-CREATE-INDEX-语句\" class=\"headerlink\" title=\"SQL CREATE INDEX 语句\"></a>SQL CREATE INDEX 语句</h3><p>CREATE INDEX 语句用于在表中<strong>创建索引</strong>。</p>\n<p>在<strong>不读取整个表</strong>的情况下，索引使数据库应用程序可以更快地查找数据。</p>\n<p>通过在表中创建索引，以便更加快速高效地查询数据。</p>\n<p><strong>用户无法看到索引</strong>，它们只能被用来加速搜索&#x2F;查询。</p>\n<p>注释：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是<strong>仅仅在常常被搜索的列</strong>（以及表）上面创建索引。</p>\n<p>在表上创建一个简单的索引，允许使用重复的值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE INDEX index_name</span><br><span class=\"line\">ON <span class=\"title function_\">table_name</span> <span class=\"params\">(column_name)</span></span><br></pre></td></tr></table></figure>\n\n<p>SQL CREATE UNIQUE INDEX 语法<br>在表上创建一个唯一的索引。不允许使用重复的值：<strong>唯一的索引</strong>意味着两个行不能拥有相同的索引值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE UNIQUE INDEX index_name</span><br><span class=\"line\">ON <span class=\"title function_\">table_name</span> <span class=\"params\">(column_name)</span></span><br></pre></td></tr></table></figure>\n<p>注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。</p>\n<p>CREATE INDEX 实例<br>下面的 SQL 语句在 “Persons” 表的 “LastName” 列上创建一个名为 “PIndex” 的索引：</p>\n<p><code>CREATE INDEX PIndex ON Persons (LastName)</code></p>\n<p>如果您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：</p>\n<p><code>CREATE INDEX PIndex ON Persons (LastName, FirstName)</code></p>\n<h3 id=\"DROP\"><a href=\"#DROP\" class=\"headerlink\" title=\"DROP\"></a>DROP</h3><p>DROP INDEX 语句<br>索引是一种优化数据库查询性能的结构，但有时候可能需要删除某个索引，例如当索引不再需要或需要替换为新的索引时。<br>DROP INDEX 语句用于删除表中的索引。<br><code>DROP INDEX [IF EXISTS] index_name ON TABLE_NAME;</code></p>\n<p>DROP TABLE 语句<br>DROP TABLE 语句用于删除表。<br>删除表将同时删除表的结构以及存储在其中的所有数据。因此，在执行DROP TABLE语句之前，请确保您真的希望永久删除表及其所有数据，因为此操作是不可逆的。<br><code>DROP TABLE [IF EXISTS] TABLE_NAME;</code></p>\n<p>DROP DATABASE 语句<br>DROP DATABASE 语句用于删除数据库，包括其中的<strong>所有表、视图、存储过程</strong>等<strong>数据库对象</strong>。<br>DROP DATABASE 是一个非常强大和危险的操作，因为它会永久删除整个数据库及其所有相关数据，因此在执行之前务必要慎重考虑并确保你真的希望执行此操作。<br><code>DROP DATABASE [IF EXISTS] database_name;</code><br>在执行 <code>DROP DATABASE</code> 之前，请确保你已经备份了数据库中的重要数据，并且你确实有权限执行这个操作，因为删除数据库通常需要管理员或超级用户的权限。此外，执行此类操作之前最好先确认没有其他用户正在使用该数据库。</p>\n<p>TRUNCATE TABLE 语句(表示<strong>清空表</strong>的操作)<br>如果我们仅仅需要<strong>删除表内的数据</strong>，但并不删除表本身，那么我们该如何做呢？<br>在 SQL 中，TRUNCATE TABLE 语句用于快速删除表中的所有数据，但保留表的结构（列、约束等），与 DELETE 语句相比，TRUNCATE TABLE <strong>通常更快</strong>，因为它是通过删除表中的所有行而不是逐行删除实现的。</p>\n<p>然而，需要注意的是，<code>TRUNCATE TABLE</code><strong>不会触发触发器</strong>，而且无法在事务中进行回滚。</p>\n<p>请使用 TRUNCATE TABLE 语句：<br><code>TRUNCATE TABLE TABLE_NAME;</code></p>\n<p>当使用 TRUNCATE TABLE 清除数据时，表的<strong>主键自增值</strong>将被重置为默认的起始值，通常是从 1 开始。这意味着下一次插入数据时，主键将从 1 开始递增。与之不同的是，使用 DELETE 语句删除数据并不会重置主键自增值，而是保留当前的自增值。</p>\n<h3 id=\"SQL-视图（Views）\"><a href=\"#SQL-视图（Views）\" class=\"headerlink\" title=\"SQL 视图（Views）\"></a>SQL 视图（Views）</h3><p>视图是<strong>可视化的表</strong>。</p>\n<p>本章讲解如何创建、更新和删除视图。</p>\n<p>SQL CREATE VIEW 语句（<strong>创建</strong>）<br>在 SQL 中，视图是<strong>基于</strong> SQL 语句的<strong>结果集</strong>的可视化的表。<br>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>\n<p>您可以<strong>向视图添加</strong> SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，<strong>就像这些数据来自于某个单一的表一样</strong>。</p>\n<p>SQL CREATE VIEW 语法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE VIEW view_name AS</span><br><span class=\"line\">SELECT column1, column2, ...</span><br><span class=\"line\">FROM table_name</span><br><span class=\"line\">WHERE condition;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：<br>CREATE VIEW: 声明你要创建一个视图。<br>view_name: 指定视图的名称。<br>AS: 指定<strong>关键字</strong>，<strong>表示视图的定义开始</strong>。<br>SELECT column1, column2, …: 指定<strong>视图中包含的列</strong>，可以是表中的列或计算列。<br>FROM table_name: 指定视图从哪个表中获取数据。<br>WHERE condition: 可选部分，用于指定筛选条件，限制<strong>视图</strong>中的行。<br>注释：视图<strong>总是显示最新的数据</strong>！每当用户查询视图时，数据库<strong>引擎</strong>通过使用视图的 SQL 语句重建数据。</p>\n<p>比如我通过如下代码创建视图：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">create view highScore AS select id,name,age,score </span><br><span class=\"line\">from test_table where score&gt;<span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure>\n<p>现在就可以将视图当作一个普通表一样操作，比如查询：<br><code>SELECT * FROM highScore;</code><br>这将返回所有 score 高于 50 的学生的信息，而不需要每次都编写相同的筛选条件。</p>\n<p>值得注意的是，<strong>视图本质上是一个虚拟的表</strong>，<strong>它并不存储数据</strong>，而是基于基础表的查询结果生成。因此，如果<strong>基础表的数据发生变化</strong>，视图的内容也会相应地<strong>更新</strong>。（正如前文所提到的一样）</p>\n<p>SQL <strong>更新视图</strong><br>在 SQL 中，你不能直接使用 UPDATE 语句来更新视图，因为视图是<strong>基于查询结果生成的虚拟表</strong>，而<strong>不是实际存储数据的表</strong>。</p>\n<p>更新视图的实质是通过<strong>更新视图所基于的表中的数据</strong>（通过讲过的 update 语句），然后视图会反映这些变化，不需要且<strong>不能重新创建视图</strong>。</p>\n<p>SQL <strong>撤销视图</strong></p>\n<p>在 SQL 中，撤销（或删除）视图是通过使用 <code>DROP VIEW</code> 语句来实现的。</p>\n<p>DROP VIEW 语句用于从数据库中删除一个已存在的视图。语法如下：</p>\n<p><code>DROP VIEW [IF EXISTS] view_name;</code></p>\n<p>参数说明：<br>DROP VIEW: 表示你要删除一个视图。<br>IF EXISTS: 可选部分，<strong>用于检查视图是否存在</strong>。如果存在，则执行删除操作；如果不存在，不会发生错误。在某些数据库系统中，这是可选的。<br>view_name: 指定要删除的视图的名称。</p>\n<p>请注意，这<strong>并不影响基础表中的数据</strong>，只是<strong>删除了视图的定义</strong>。</p>\n<p>在使用 DROP VIEW 语句时，请确保你真的想要删除该视图，因为一旦删除，将无法恢复视图的定义。</p>\n<p>视图的<strong>作用</strong>：</p>\n<ol>\n<li>视图<strong>隐藏了底层的表结构</strong>，简化了数据访问操作，客户端不再需要知道底层表的结构及其之间的关系。</li>\n<li>视图提供了一个<strong>统一访问数据的接口</strong>。（即可以允许用户<strong>通过视图访问数据</strong>的安全机制，而不授予用户直接访问底层表的权限）从而加强了安全性，使用户只能看到视图所显示的数据。</li>\n<li>视图还可以被嵌套，一个视图中可以嵌套另一个视图。</li>\n</ol>\n<h2 id=\"MySQL-数据类型\"><a href=\"#MySQL-数据类型\" class=\"headerlink\" title=\"MySQL 数据类型\"></a>MySQL 数据类型</h2><p>SQL 通用数据类型<br>数据库表中的每个列都要求有名称和数据类型。SQL 开发人员<strong>必须</strong>在<strong>创建</strong> SQL 表时<strong>决定表中的每个列将要存储的数据的类型</strong>。数据类型是一个<strong>标签</strong>，是便于 SQL 了解每个列期望存储什么类型的数据的指南，它也标识了 SQL 如何与存储的数据进行交互。</p>\n<p>在 MySQL 中，有三种主要的类型：Text（文本）、Number（数字）和 Date&#x2F;Time（日期&#x2F;时间）类型。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/21.png\" class=\"\">\n\n<img src=\"/2024/04/01/InternetBasicsNote/22.png\" class=\"\">\n<p>注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如 int(4) 并不是只能存储4个长度的数字。实际上int(size)占多少存储空间和 size 大小并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。<br>区别就是在<strong>显示给用户的方式</strong>有点不同。<br>例如：<br>1、int的值为10<br>int（9）显示结果为000000010<br>int（3）显示结果为010<br>就是显示的长度不一样而已 都是占用四个字节的存储空间</p>\n<img src=\"/2024/04/01/InternetBasicsNote/23.png\" class=\"\">\n<p>即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。</p>\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性（英语：Durability_(database_systems)）的键值对存储数据库。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis-server  // 启动 redis 服务器（必须先启动 redis 服务）</span><br><span class=\"line\">redis-cli  // 连接本地的 redis 服务 27.0.0.1:6379</span><br><span class=\"line\">PING // 该命令用于检测 redis 服务是否启动</span><br><span class=\"line\"></span><br><span class=\"line\">如果需要在远程 redis 服务上执行命令，同样使用的也是 redis-cli :</span><br><span class=\"line\">redis-cli -h host -p port -a password</span><br><span class=\"line\">如连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务</span><br><span class=\"line\">redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>Redis支持五种数据类型：<strong>string</strong>（字符串），<strong>hash</strong>（哈希），<strong>list</strong>（列表），<strong>set</strong>（集合）及<strong>zset</strong>(sorted set：有序集合)。</p>\n<p>基本命令语法都是 <code>COMMAND KEY_NAME</code>，<code>KEY_NAME</code>是键的名字。</p>\n<h3 id=\"string（字符串）\"><a href=\"#string（字符串）\" class=\"headerlink\" title=\"string（字符串）\"></a>string（字符串）</h3><p>和 java 中的字符串一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SET key value</span><br><span class=\"line\">设置指定 key 的值。</span><br><span class=\"line\"></span><br><span class=\"line\">GET key</span><br><span class=\"line\">获取指定 key 的值。</span><br></pre></td></tr></table></figure>\n\n<p>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</p>\n<h3 id=\"list（列表）\"><a href=\"#list（列表）\" class=\"headerlink\" title=\"list（列表）\"></a>list（列表）</h3><p>Redis列表是简单的<strong>字符串列表</strong>，每个值都是一个字符串，按照<strong>插入顺序排序</strong>。你可以添加一个元素到列表的<strong>头部</strong>（左边）或者<strong>尾部</strong>（右边），两端都可进行 push 和 pop 操作，读取单个或多个元素，根据 值 查找和删除元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">LPUSH key value1 [value2]</span><br><span class=\"line\">将一个或多个值插入到列表头部</span><br><span class=\"line\"></span><br><span class=\"line\">LPOP key</span><br><span class=\"line\">移出并获取列表的第一个元素</span><br><span class=\"line\"></span><br><span class=\"line\">RPOP key</span><br><span class=\"line\">移除列表的最后一个元素，返回值为移除的元素。</span><br><span class=\"line\"></span><br><span class=\"line\">RPUSH key value1 [value2]</span><br><span class=\"line\">在列表中添加一个或多个值到列表尾部</span><br><span class=\"line\"></span><br><span class=\"line\">LLEN key</span><br><span class=\"line\">获取列表长度</span><br><span class=\"line\"></span><br><span class=\"line\">LRANGE key start stop</span><br><span class=\"line\">获取列表指定范围内的元素</span><br></pre></td></tr></table></figure>\n\n<p>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</p>\n<h3 id=\"set（集合）\"><a href=\"#set（集合）\" class=\"headerlink\" title=\"set（集合）\"></a>set（集合）</h3><p><strong>字符串</strong>的无序集合，集合成员是唯一的，这就意味着集合中不能出现重复的数据。包含集合常见的操作方法，计算交并差集。</p>\n<p>Redis 中集合是通过<strong>哈希表</strong>实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SADD key member1 [member2]</span><br><span class=\"line\">向集合添加一个或多个成员</span><br><span class=\"line\"></span><br><span class=\"line\">SCARD key</span><br><span class=\"line\">获取集合的成员数</span><br><span class=\"line\"></span><br><span class=\"line\">SISMEMBER key member</span><br><span class=\"line\">判断 member 元素是否是集合 key 的成员</span><br><span class=\"line\"></span><br><span class=\"line\">SMEMBERS key</span><br><span class=\"line\">返回集合中的所有成员</span><br><span class=\"line\"></span><br><span class=\"line\">SREM key member1 [member2]</span><br><span class=\"line\">移除集合中一个或多个成员</span><br></pre></td></tr></table></figure>\n\n<p>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</p>\n<h3 id=\"hash（哈希散列表）\"><a href=\"#hash（哈希散列表）\" class=\"headerlink\" title=\"hash（哈希散列表）\"></a>hash（哈希散列表）</h3><p>包含键值对的无序散列表。</p>\n<p>Redis hash 是一个 <strong>string</strong> 类型的 <strong>field</strong>（字段） 和 <strong>value</strong>（值） 的映射表，hash 特别适合用于存储对象。一个键 key 可以由很多个字段 field，每个字段都有相对应的 value。对 hash 的操作基本都要带上 键 key，如果操作精细到 field 就加上 field 字段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HSET key field value</span><br><span class=\"line\">将哈希表 key 中的字段 field 的值设为 value 。</span><br><span class=\"line\"></span><br><span class=\"line\">HGET key field</span><br><span class=\"line\">获取存储在哈希表中指定字段的值。</span><br><span class=\"line\"></span><br><span class=\"line\">HMSET key field1 value1 [field2 value2 ]</span><br><span class=\"line\">同时将多个 field-value (域-值)对设置到哈希表 key 中。</span><br><span class=\"line\"></span><br><span class=\"line\">HMGET key field1 [field2]</span><br><span class=\"line\">获取所有给定字段的值</span><br><span class=\"line\"></span><br><span class=\"line\">HEXISTS key field</span><br><span class=\"line\">查看哈希表 key 中，指定的字段是否存在。</span><br><span class=\"line\"></span><br><span class=\"line\">HGETALL key</span><br><span class=\"line\">获取在哈希表中指定 key 的所有字段和值</span><br></pre></td></tr></table></figure>\n\n<p>Hash 类型：缓存对象、购物车等。</p>\n<h3 id=\"zset-sorted-set：有序集合\"><a href=\"#zset-sorted-set：有序集合\" class=\"headerlink\" title=\"zset (sorted set：有序集合)\"></a>zset (sorted set：有序集合)</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且<strong>不允许重复的成员</strong>。<br>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。<br>有序集合的成员是唯一的,但<strong>分数</strong>(score)却<strong>可以重复</strong>。</p>\n<p>有序集合是通过<strong>哈希表</strong>实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ZADD key score1 member1 [score2 member2]</span><br><span class=\"line\">向有序集合添加一个或多个成员，或者 更新 已存在成员的分数</span><br><span class=\"line\"></span><br><span class=\"line\">ZCARD key</span><br><span class=\"line\">获取有序集合的成员数</span><br><span class=\"line\"></span><br><span class=\"line\">ZRANGE key start stop [WITHSCORES]</span><br><span class=\"line\">通过 索引区间 返回有序集合指定区间内的成员 <span class=\"comment\">// 不是分数区间，有序集合，索引有意义</span></span><br><span class=\"line\"></span><br><span class=\"line\">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</span><br><span class=\"line\">通过分数返回有序集合指定区间内的成员</span><br></pre></td></tr></table></figure>\n\n<p>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</p>\n<h2 id=\"Redis-发布订阅\"><a href=\"#Redis-发布订阅\" class=\"headerlink\" title=\"Redis 发布订阅\"></a>Redis 发布订阅</h2><p>Redis <strong>发布订阅</strong> (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>\n<p>Redis 客户端可以订阅任意数量的频道。</p>\n<p>当有新消息通过 PUBLISH 命令发送给频道 channel 时， 这个消息就会被发送给<strong>订阅它</strong>的 所有客户端：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SUBSCRIBE channel [channel ...]</span><br><span class=\"line\">订阅给定的一个或多个频道的信息。</span><br><span class=\"line\"></span><br><span class=\"line\">PUBLISH channel message</span><br><span class=\"line\">将信息发送到指定的频道。</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Redis-事务\"><a href=\"#Redis-事务\" class=\"headerlink\" title=\"Redis 事务\"></a>Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>\n<p>批量操作在<strong>发送</strong> <strong>EXEC</strong> 命令前被<strong>放入队列缓存</strong>。<br><strong>收到</strong> <strong>EXEC</strong> 命令后进入事务执行，事务中任意命令执行失败，其余的命令<strong>依然被执行</strong>。<br>在事务执行过程，其他客户端提交的命令请求<strong>不会插入到事务执行命令序列</strong>中。</p>\n<p>一个事务从开始到执行会经历以下三个阶段：<br>开始事务。<br>命令入队。<br>执行事务。</p>\n<p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将<strong>多个命令入队到事务中</strong>， 最后由 <strong>EXEC</strong> 命令<strong>触发事务</strong>， <strong>一并执行事务中的所有命令</strong>：事务就像储存命令的容器。</p>\n<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>\n<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DISCARD</span><br><span class=\"line\">取消事务，放弃执行事务块内的所有命令。</span><br><span class=\"line\"></span><br><span class=\"line\">EXEC</span><br><span class=\"line\">执行事务块内的所有命令。</span><br><span class=\"line\"></span><br><span class=\"line\">MULTI</span><br><span class=\"line\">标记一个事务块的开始。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Redis-脚本\"><a href=\"#Redis-脚本\" class=\"headerlink\" title=\"Redis 脚本\"></a>Redis 脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>\n<p>Eval 命令的基本语法如下：</p>\n<p><code>redis 127.0.0.1:6379&gt; EVAL script numkeys key [key ...] arg [arg ...]</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class=\"line\">执行 **Lua** 脚本。</span><br><span class=\"line\"></span><br><span class=\"line\">redis <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; EVAL <span class=\"string\">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> <span class=\"number\">2</span> key1 key2 first second</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">&quot;key1&quot;</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">&quot;key2&quot;</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">&quot;first&quot;</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">&quot;second&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Redis-GEO\"><a href=\"#Redis-GEO\" class=\"headerlink\" title=\"Redis GEO\"></a>Redis GEO</h2><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作。</p>\n<p>Redis GEO 操作方法有：</p>\n<p>geoadd：添加地理位置的坐标。<br>geopos：获取地理位置的坐标。<br>geodist：计算两个位置之间的距离。<br>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。<br>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。<br>geohash：返回一个或多个位置对象的 geohash 值。</p>\n<p><strong>geoadd</strong><br>geoadd 用于存储指定的<strong>地理空间位置</strong>，可以将一个或多个<strong>经度</strong>(longitude)、<strong>纬度</strong>(latitude)、位置名称(member)添加到指定的 key 中。</p>\n<p>geoadd 语法格式如下：<br><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></p>\n<p><strong>geopos</strong><br>geopos 用于从给定的 key 里返回所有<strong>指定名称</strong>(member)的位置（经度和纬度），不存在的返回 nil。</p>\n<p>geopos 语法格式如下：<br><code>GEOPOS key member [member ...]</code></p>\n<p><strong>geodist</strong><br>geodist 用于返回两个给定位置之间的距离。</p>\n<p>geodist 语法格式如下：<br><code>GEODIST key member1 member2 [m|km|ft|mi]</code></p>\n<p>member1 member2 为两个地理位置。</p>\n<p>最后一个距离单位参数说明：<br>m ：米，默认单位。<br>km ：千米。<br>mi ：英里。<br>ft ：英尺。</p>\n<p><strong>georadius、georadiusbymember</strong><br><strong>georadius</strong> 以给定的经纬度为中心， 返回键包含的位置元素中与中心的距离不超过给定最大距离的所有位置元素。</p>\n<p><strong>georadiusbymember</strong> 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的<strong>中心点</strong>是由<strong>给定的位置元素决定</strong>的， <strong>而不是使用经度和纬度来决定中心点</strong>。</p>\n<p>georadius 与 georadiusbymember 语法格式如下：</p>\n<p><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p>\n<p><code>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p>\n<p>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。<br>WITHCOORD: 将位置元素的经度和纬度也一并返回。<br>COUNT 限定返回的记录数。<br>ASC: 查找结果根据距离从近到远排序。<br>DESC: 查找结果根据从远到近排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">GEOADD Sicily <span class=\"number\">13.361389</span> <span class=\"number\">38.115556</span> <span class=\"string\">&quot;Palermo&quot;</span> <span class=\"number\">15.087269</span> <span class=\"number\">37.502669</span> <span class=\"string\">&quot;Catania&quot;</span> <span class=\"number\">13.583333</span> <span class=\"number\">37.316667</span> <span class=\"string\">&quot;Agrigento&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">GEOPOS Sicily Palermo Catania</span><br><span class=\"line\"></span><br><span class=\"line\">GEODIST Sicily Palermo Catania</span><br><span class=\"line\"></span><br><span class=\"line\">GEORADIUS Sicily <span class=\"number\">15</span> <span class=\"number\">37</span> <span class=\"number\">200</span> km WITHDIST WITHCOORD ASC</span><br><span class=\"line\"></span><br><span class=\"line\"> GEORADIUSBYMEMBER Sicily Agrigento <span class=\"number\">200</span> km</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Redis-Stream\"><a href=\"#Redis-Stream\" class=\"headerlink\" title=\"Redis Stream\"></a>Redis Stream</h2><p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p>\n<p>Redis Stream 主要用于<strong>消息队列</strong>（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p>\n<p>简单来说发布订阅 (pub&#x2F;sub) <strong>可以分发消息</strong>，但无法记录历史消息。</p>\n<p>而 Redis Stream 提供了消息的持久化和<strong>主备复制</strong>功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>\n<p>Redis Stream 的结构如下所示，它有一个<strong>消息链表</strong>，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容：</p>\n<img src=\"/2024/04/01/InternetBasicsNote/24.png\" class=\"\">\n\n<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p>\n<p>Consumer Group ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。</p>\n<p>last_delivered_id ：游标，<strong>每个消费组</strong>会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前（Stream direction）移动。</p>\n<p>pending_ids ：消费者(Consumer)的<strong>状态变量</strong>，作用是维护<strong>消费者的未确认的 id</strong>。 pending_ids 记录了当前已经被客户端<strong>读取</strong>的消息，但是还没有 ack （Acknowledge character：确认字符）。</p>\n<p>消息队列相关命令：<br>XADD - 添加消息到末尾<br>XTRIM - 对流进行修剪，限制长度<br>XDEL - 删除消息<br>XLEN - 获取流包含的元素数量，即消息长度<br>XRANGE - 获取消息列表，会自动过滤已经删除的消息<br>XREVRANGE - 反向获取消息列表，ID 从大到小<br>XREAD - 以阻塞或非阻塞方式获取消息列表</p>\n<p>消费者组相关命令：<br>XGROUP CREATE - 创建消费者组<br>XREADGROUP GROUP - 读取消费者组中的消息<br>XACK - 将消息标记为”已处理”<br>XGROUP SETID - 为消费者组设置新的最后递送消息ID<br>XGROUP DELCONSUMER - 删除消费者<br>XGROUP DESTROY - 删除消费者组<br>XPENDING - 显示待处理消息的相关信息<br>XCLAIM - 转移消息的归属权<br>XINFO - 查看流和消费者组的相关信息；</p>\n<p><strong>XADD</strong><br>使用 XADD 向队列添加消息，如果指定的队列不存在，则创建一个队列（key），XADD 语法格式：<br><code>XADD key ID field value [field value ...]</code><br>key ：队列名称，如果不存在就创建<br>ID ：消息 id，我们使用 * 表示由 redis <strong>帮我们生成合适的ID</strong>，可以自定义，但是要自己保证递增性。使用 * 执行命令之后返回的就是 消息 id，其他命令可能要用的这个 ID。<br>field value ： 记录。<br>每次在消息队列中添加的都是一条消息，一条消息可以包含很多内容。</p>\n<p><strong>XTRIM</strong><br>使用 XTRIM 对流进行修剪，限制长度， 语法格式：<br><code>XTRIM key MAXLEN [~] count</code><br>key ：队列名称<br>MAXLEN ：长度<br>count ：数量</p>\n<p><strong>XDEL</strong><br>使用 XDEL 删除消息，语法格式：<br><code>XDEL key ID [ID ...]</code><br>key：队列名称<br>ID ：消息 ID</p>\n<p><strong>XRANGE</strong><br>使用 XRANGE 获取消息列表，会自动过滤已经删除的消息 ，语法格式：<br><code>XRANGE key start end [COUNT count]</code><br>key ：队列名<br>start ：开始值， <strong>-</strong> 表示<strong>最小值</strong><br>end ：结束值， <strong>+</strong> 表示<strong>最大值</strong><br>count ：数量</p>\n<p><strong>XREVRANGE</strong><br>使用 XREVRANGE 获取<strong>反向</strong>消息列表，会自动过滤已经删除的消息 ，语法格式：<br><code>XREVRANGE key end start [COUNT count]</code><br>key ：队列名<br>end ：结束值， + 表示最大值<br>start ：开始值， - 表示最小值<br>count ：数量</p>\n<p><strong>XREAD</strong><br>使用 XREAD 以<strong>阻塞或非阻塞</strong>方式获取消息列表 ，语法格式：<br><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</code><br>count ：数量<br>milliseconds ：可选，阻塞毫秒数，没有设置就是非阻塞模式<br>key ：队列名<br>id ：消息 ID</p>\n<p><strong>XGROUP CREATE</strong><br>使用 XGROUP CREATE 创建消费者组，语法格式：<br><code>XGROUP [CREATE key groupname id-or-$]</code><br>key ：队列名称，如果不存在就创建<br>groupname ：组名。<br><code>$</code>： 表示从 <strong>尾部开始消费</strong> ，只接受新消息，当前 Stream 消息会全部忽略。<br>从头开始消费:<br><code>XGROUP CREATE mystream consumer-group-name 0-0  </code></p>\n<p>从尾部开始消费:<br><code>XGROUP CREATE mystream consumer-group-name $</code></p>\n<p><strong>XREADGROUP GROUP</strong><br>使用 XREADGROUP GROUP <strong>读取消费组中的消息</strong>，语法格式：</p>\n<p><code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code><br>group ：消费组名<br>consumer ：消费者名。<br>count ： 读取数量。<br>milliseconds ： 阻塞毫秒数。<br>key ： 队列名。<br>ID ： 消息 ID。<br><code>XREADGROUP GROUP consumer-group-name consumer-name COUNT 1 STREAMS mystream &gt;</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">XADD mystream * name Sara surname OConnor</span><br><span class=\"line\"></span><br><span class=\"line\">XADD mystream * field1 value1 field2 value2 field3 value3</span><br><span class=\"line\"></span><br><span class=\"line\">XLEN mystream</span><br><span class=\"line\"></span><br><span class=\"line\">XRANGE mystream - +</span><br><span class=\"line\"></span><br><span class=\"line\"> XTRIM mystream MAXLEN <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">XGROUP CREATE mystream consumer-group-name <span class=\"number\">0</span>-<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">XREADGROUP GROUP consumer-group-name consumer-name COUNT <span class=\"number\">1</span> STREAMS mystream &gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Redis-数据备份与恢复\"><a href=\"#Redis-数据备份与恢复\" class=\"headerlink\" title=\"Redis 数据备份与恢复\"></a>Redis 数据备份与恢复</h2><p>Redis SAVE 命令用于创建当前数据库的备份。<br>该命令将在 redis 安装目录中创建dump.rdb文件。</p>\n<p>恢复数据<br>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 <code>CONFIG GET dir</code> 命令。</p>\n<p>以上命令 <code>CONFIG GET dir</code> 输出 redis 安装目录&#x3D;。</p>\n<h2 id=\"Redis-安全\"><a href=\"#Redis-安全\" class=\"headerlink\" title=\"Redis 安全\"></a>Redis 安全</h2><p>我们可以通过 redis 的<strong>配置文件</strong>设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p>\n<p><code>CONFIG get requirepass</code>查看<strong>是否设置了密码验证</strong>：</p>\n<p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p>\n<p>你可以通过以下命令来修改该参数：<br><code>CONFIG set requirepass &quot;password&quot;</code><br>设置密码后，客户端连接 redis 服务就需要<strong>密码验证</strong>，否则无法执行命令。</p>\n<p>使用 <code>AUTH password</code> 命令进行密码验证。</p>\n<h2 id=\"Redis-客户端连接\"><a href=\"#Redis-客户端连接\" class=\"headerlink\" title=\"Redis 客户端连接\"></a>Redis 客户端连接</h2><p>Redis 通过<strong>监听</strong>一个 <strong>TCP</strong> 端口或者 Unix <strong>socket</strong> 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p>\n<p>首先，客户端 socket 会被设置为<strong>非阻塞模式</strong>，因为 Redis 在网络事件处理上采用的是<strong>非阻塞多路复用</strong>模型。<br>然后为这个 socket 设置 <strong>TCP_NODELAY</strong> 属性，禁用 Nagle 算法<br>然后创建一个<strong>可读的文件事件</strong>用于监听这个客户端 socket 的数据发送</p>\n<p>最大连接数 maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p>\n<p><code>config get maxclients</code> 查看最大连接数。</p>\n<p><code>CLIENT LIST</code> 返回连接到 redis 服务的客户端列表。</p>\n<h2 id=\"Redis-管道技术\"><a href=\"#Redis-管道技术\" class=\"headerlink\" title=\"Redis 管道技术\"></a>Redis 管道技术</h2><p>Redis是一种基于 <strong>客户端-服务端</strong> 模型以及 <strong>请求&#x2F;响应</strong> 协议 的<strong>TCP</strong>服务。这意味着通常情况下一个请求会遵循以下步骤：</p>\n<p>客户端向服务端发送一个查询请求，并<strong>监听Socket返回</strong>，通常是以<strong>阻塞模式</strong>，等待服务端响应。<br>服务端处理命令，并将结果返回给客户端。</p>\n<p><strong>阻塞模式</strong><br>阻塞模式（Blocking Mode）是一种在编程中常见的同步模式，它指的是在某些操作无法立即完成时，线程会被阻塞（暂停执行），直到操作完成或者达到一定的条件后再继续执行。阻塞模式通常与同步机制（如锁、信号量）结合使用，用于实现线程间的协调和数据同步。</p>\n<p>在阻塞模式下，线程会在以下情况被阻塞：</p>\n<p>I&#x2F;O 操作：当线程进行 I&#x2F;O 操作时，如果操作无法立即完成（例如读取文件、网络通信等），线程会被阻塞，直到数据就绪或超时。<br>等待条件：当线程需要等待某个条件的满足时，如果条件尚未达到，线程会被阻塞，直到条件满足或超时。<br>获取锁：当线程试图获取某个锁时，如果锁已被其他线程持有，线程会被阻塞，直到锁可用或超时。<br>阻塞模式与非阻塞模式相对应。在非阻塞模式下，线程不会等待操作的完成或条件的满足，而是立即返回，通常会周期性地进行轮询或通过回调函数来检查操作或条件是否已完成。</p>\n<p>在编程中，阻塞模式通常适用于那些需要等待外部事件或资源就绪后才能继续执行的场景，例如<strong>网络编程、多线程同步、事件驱动编程</strong>等。然而，过度使用阻塞模式可能会导致资源浪费和性能下降，因此需要根据具体情况综合考虑选择合适的同步模式。</p>\n<p><strong>回调函数</strong><br>回调函数（Callback Function）是一种常见的编程模式，用于实现异步编程。它是指在某个操作完成后，通过调用预先注册的函数（回调函数），来<strong>通知调用方</strong>或<strong>处理结果</strong>。</p>\n<p>回调函数通常用于以下几种情况：</p>\n<p>事件处理：当某个事件发生时，调用预先注册的回调函数来处理事件，例如点击按钮时触发的点击事件、接收到网络请求时触发的数据到达事件等。<br>异步操作：当进行耗时的异步操作（如文件读取、网络请求）时，通过回调函数来处理操作完成后的结果，以避免阻塞线程。<br>错误处理：当发生错误或异常时，通过回调函数来处理错误信息，例如异步操作失败时的错误处理。<br>回调函数通常作为参数传递给异步操作的函数或方法，当操作完成后，将<strong>回调函数作为参数</strong>调用，<strong>传递操作的结果或错误信息</strong>。在编程中，回调函数可以是函数指针、匿名函数、Lambda 表达式等形式。</p>\n<p>回调函数的优点是它能够实现<strong>非阻塞的异步编程</strong>，提高了程序的响应速度和并发性。然而，回调函数也有一些缺点，例如代码可读性较差、回调地狱（Callback Hell）等问题，因此在使用时需要注意适当的设计和组织。</p>\n<p><strong>Redis 管道技术</strong><br>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并<strong>最终一次性读取所有服务端的响应</strong>。</p>\n<p>管道技术最显著的优势是提高了 redis 服务的性能。</p>\n<h2 id=\"Redis-分区\"><a href=\"#Redis-分区\" class=\"headerlink\" title=\"Redis 分区\"></a>Redis 分区</h2><p>分区是<strong>分割数据</strong>到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>\n<p>分区的优势<br>通过利用多台计算机内存的和值，允许我们构造更大的数据库。<br>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</p>\n<p>分区的不足<br>redis的一些特性在分区方面表现的不是很好：</p>\n<ol>\n<li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>\n<li>涉及多个key的redis事务不能使用。</li>\n<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb&#x2F;aof文件，并且从多个实例和主机备份持久化文件。</li>\n<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li>\n</ol>\n<p>分区类型<br>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有两种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射<strong>某个key到某个Redis服务</strong>。</p>\n<ol>\n<li>范围分区</li>\n<li>哈希分区<br>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：<br>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。<br>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 &#x3D; 2，就是说key foobar应该被存到R2实例中。</li>\n</ol>\n<h2 id=\"Java-使用-Redis-Jedis\"><a href=\"#Java-使用-Redis-Jedis\" class=\"headerlink\" title=\"Java 使用 Redis (Jedis)\"></a>Java 使用 Redis (Jedis)</h2><p>Jedis是Java最常用的Redis客户端，它的使用方法参数与Redis重合度非常高，这意味着对于Java开发人员来说不会增加新的学习成本，颇有一种开箱即用的味道。</p>\n<p><a href=\"https://github.com/redis/jedis\">jedis</a></p>\n<p>首先在 <a href=\"https://mvnrepository.com/artifact/redis.clients/jedis\">Maven仓库</a>下载 Jedis.jar 包，在源文件夹 src 下建立 lib 文件夹，项目左边栏右键空白处之后选择： <code>Open Module Settings</code>，点击 + 号选择<code>Jars or Directories</code>选项并导入lib 文件夹导入第三方库文件，再根据 Jedis 给出的 Maven 配置方式修改 Pom，成功导入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//连接本地的 Redis 服务</span></span><br><span class=\"line\">        <span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果 Redis 服务设置了密码，需要下面这行，没有就不需要</span></span><br><span class=\"line\">        <span class=\"comment\">// jedis.auth(&quot;password&quot;);</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;连接成功&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//查看服务是否运行</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置 redis 字符串数据</span></span><br><span class=\"line\">        jedis.set(<span class=\"string\">&quot;runoobkey&quot;</span>, <span class=\"string\">&quot;www.runoob.com&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取存储的数据并输出</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;redis 存储的字符串为: &quot;</span>+ jedis.get(<span class=\"string\">&quot;runoobkey&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//存储数据到列表中</span></span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;site-list&quot;</span>, <span class=\"string\">&quot;Runoob&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;site-list&quot;</span>, <span class=\"string\">&quot;Google&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;site-list&quot;</span>, <span class=\"string\">&quot;Taobao&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取存储的数据并输出</span></span><br><span class=\"line\">        List&lt;String&gt; list = jedis.lrange(<span class=\"string\">&quot;site-list&quot;</span>, <span class=\"number\">0</span> ,<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;列表项&quot;</span>+ i + <span class=\"string\">&quot;:&quot;</span> + list.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取所有的键</span></span><br><span class=\"line\">        Set&lt;String&gt; keys = jedis.keys(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        Iterator&lt;String&gt; it=keys.iterator() ;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">            System.out.println(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.csdn.net/tengdazhang770960436/article/details/18006127\">slf4j-api、slf4j-log4j12以及log4j之间什么关系？</a></p>\n<p>在Java世界中，日志记录是一项重要的功能，它帮助我们了解应用程序的运行情况，并在出现问题时提供调试信息。在这个过程中，SLF4J（Simple Logging Facade for Java）、Log4j和SLF4J-Log4j12扮演着关键的角色。</p>\n<p>首先，我们来看看SLF4J。SLF4J，即Simple Logging Facade for Java，是一个用于Java的简单日志记录门面。它本身并不实现日志记录功能，而是提供了一个统一的接口，让开发者能够轻松地更换日志记录框架。这意味着，如果您的项目中使用了SLF4J，您可以随时将Log4j替换为Logback或其他日志记录框架，而无需修改代码中的日志记录部分。</p>\n<p>接下来，我们来看看Log4j。Log4j是一个功能强大的日志记录框架，它实现了SLF4J接口。这意味着，您可以将Log4j作为SLF4J的实现来使用。Log4j提供了丰富的日志记录功能，包括不同级别的日志记录、日志消息格式化、异步日志记录等。此外，Log4j还支持各种日志输出目标，如控制台、文件、数据库等。</p>\n<p>最后，我们来看看SLF4J-Log4j12。这是一个特殊的库，它将SLF4J与Log4j 1.2版本桥接起来。由于Log4j 1.2是最早版本的Log4j，并且仍然在许多项目中广泛使用，因此SLF4J-Log4j12为这些项目提供了一个从SLF4J到Log4j 1.2的桥梁。通过引入SLF4J-Log4j12，您可以在使用Log4j 1.2的项目中享受SLF4J带来的便利，例如轻松地更换日志记录框架等。</p>\n<p>在实际项目中，我们经常会看到SLF4J、Log4j和SLF4J-Log4j12一起使用。通常情况下，项目会首先引入SLF4J和SLF4J-Log4j12，然后通过配置文件将SLF4J的日志记录委托给Log4j 1.2。这样，项目就可以享受到Log4j 1.2的丰富功能，同时还保留了通过SLF4J更换日志记录框架的灵活性。</p>\n<p>总之，SLF4J、Log4j和SLF4J-Log4j12是Java日志记录领域中的关键组件。它们之间的关系可以概括为：SLF4J是一个日志记录门面，Log4j是一个实现了SLF4J接口的日志记录框架，而SLF4J-Log4j12则是将SLF4J与Log4j 1.2桥接起来的特殊库。通过了解这些组件之间的关系和作用，您将能够更好地理解和应用Java日志记录技术。</p>\n<p><a href=\"https://blog.csdn.net/wang465745776/article/details/80384210\">使用SLF4J时的一个错误Failed to load class org.slf4j.impl.StaticLoggerBinder</a><br>也有遇到这个问题，配置依赖时 scope 的影响。</p>\n<p>在实际使用中，为避免<strong>多线程带来的并发</strong>问题，以及<strong>反复创建销毁Redis连接</strong>带来的性能消耗，我们通常会使用<strong>池化</strong>的思想——使用Jedis连接池。（就是一个大池子，随取随用，不用就归还，对并发有好处，和线程池、常量池是一个道理，Jedis连接池应该就属于数据库连接池的一种）</p>\n<p><a href=\"https://blog.csdn.net/qq_44614137/article/details/120046675\">什么是池，Java中的池有哪些？</a> 这篇不错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置连接池</span></span><br><span class=\"line\"><span class=\"type\">JedisPoolConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JedisPoolConfig</span>();</span><br><span class=\"line\">config.setMaxTotal(<span class=\"number\">20</span>);</span><br><span class=\"line\">config.setMaxIdle(<span class=\"number\">10</span>);</span><br><span class=\"line\">config.setMinIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建连接池</span></span><br><span class=\"line\"><span class=\"type\">JedisPool</span> <span class=\"variable\">jedisPool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JedisPool</span>(config, <span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> jedisPool.getResource();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用jedis进行操作</span></span><br><span class=\"line\">jedis.set(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;otherNameVal&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用完之后，一定要手动关闭连接（归还给连接池）</span></span><br><span class=\"line\">jedis.close();</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/260661680\">如何在Java中优雅的使用Redis</a><br>提到使用连接池的时候如果连接没有成功关闭，最后就会造成阻塞和死机，所以需要使用 try catch final 来解决，同时使用了更进阶的写法。</p>\n<p><a href=\"https://www.cnblogs.com/-beyond/p/10991139.html\">使用Jedis操作Redis</a> 有基础用法，也有讲使用Jedis连接Redis集群。<br><a href=\"https://www.cnblogs.com/-beyond/p/9660582.html\">集群搭建</a></p>\n<h1 id=\"SSM-1\"><a href=\"#SSM-1\" class=\"headerlink\" title=\"SSM\"></a>SSM</h1><h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><p>组件（bean）：可以复用的 Java 对象。什么叫复用呢，比如就是赋值为全局变量的对象，比如 BookServlet 多次调用 BookService 服务就不需要多次 new 一个 BookService 对象，直接用 IOC 里面保存的可以复用的对象就好了。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/31.png\" class=\"\">\n\n<img src=\"/2024/04/01/InternetBasicsNote/32.png\" class=\"\">\n\n<p>spring 核心容器的 两大功能<br>IoC 控制反转 ：将对象的控制权交给 spring<br>DI 依赖注入 ：维护容器中对象的引用或依赖关系<br>所以核心容器也常叫 IoC容器</p>\n<img src=\"/2024/04/01/InternetBasicsNote/33.png\" class=\"\">\n\n<p>所以就是用三种配置方式（XML、注解、配置类，现在主流是<strong>配置类</strong>和<strong>注解</strong>配合使用）去实现 IoC、DI（DI有三种实现方式：构造函数注入、setter 方法注入、接口注入）</p>\n<h2 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h2><p><a href=\"https://developer.aliyun.com/article/1205428\">IDEA版SpringBoot全教程 01 快速入门</a></p>\n<p>这篇文章学到了不少，包括 yml 的基础语法和配置，几个注解配置等。</p>\n<h2 id=\"mybatis\"><a href=\"#mybatis\" class=\"headerlink\" title=\"mybatis\"></a>mybatis</h2><h1 id=\"一些重要知识点\"><a href=\"#一些重要知识点\" class=\"headerlink\" title=\"一些重要知识点\"></a>一些重要知识点</h1><h2 id=\"Nginx-代理和负载均衡\"><a href=\"#Nginx-代理和负载均衡\" class=\"headerlink\" title=\"Nginx 代理和负载均衡\"></a>Nginx 代理和负载均衡</h2><p><strong>负载均衡</strong>：负载均衡服务器通过一定的调度算法将客户端的<strong>流量分发</strong>到不同的应用服务器上面，以实现性能的水平扩展及避免单点故障出现。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/26.png\" class=\"\">\n\n<p>正向代理是指通过<strong>代理服务器</strong> 代理 浏览器&#x2F;客户端 去重定向请求访问到目标服务器。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/27.png\" class=\"\">\n\n\n<p>反向代理  – 跨域<br>反向代理，指以<strong>代理服务器</strong>来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>\n<img src=\"/2024/04/01/InternetBasicsNote/28.png\" class=\"\">\n\n<p>代理的意思可以理解为：为某人出面，成为某人某物的门面，所以代理的意义是<strong>隐藏</strong>。</p>\n<p>感觉就有点像：正向代理是 代理 浏览器&#x2F;客户端，重定向它们的请求去访问目标服务器，在这个过程中，目标服务器是与代理服务器通信，所以目标服务器看不到它真正的访问源，所以正向代理是能保护 浏览器&#x2F;客户端 的网络安全的。<br>而反向代理的 代理服务器是 代理 目标服务器，替目标服务器接收来自互联网的连接请求，然后再把请求转发给内部网络上的服务器，这个过程还能实现负载均衡，之后将得到的结果返回给请求连接的客户端。此时这个代理服务器对 客户端 而言是不是就像一个普通的服务器一样，也就是说：反向代理的话代理服务器是成为了目标服务器的门面。此时目标服务器对客户端而言是透明的，这才是代理的真正意义。</p>\n<p>这应该就是正反代理的区别。注意：它们的共同点是都通过代理服务器来转发请求流量，都通过它来通信。</p>\n<hr>\n<p>反向代理（Reverse Proxy）和负载均衡（Load Balancing）是常见的网络架构模式，用于提高网络服务的可用性、性能和安全性。</p>\n<p>反向代理：<br>反向代理是指代理服务器位于服务端，它接收客户端的请求，然后将请求转发给一个或多个后端服务器，并将后端服务器的响应返回给客户端。客户端并不直接与后端服务器通信，而是通过反向代理与后端服务器交互，因此客户端对于后端服务器是透明的。<br>反向代理常用于隐藏真实的服务器架构、提供负载均衡、缓存静态资源、提供安全防护等。常见的反向代理软件包括 Nginx、Apache HTTP Server、HAProxy 等。<br>负载均衡：<br>负载均衡是指将网络流量分配到多个服务器上，以平衡服务器的负载，提高系统的性能和可用性。负载均衡器位于客户端和服务器之间，根据一定的算法（如轮询、加权轮询、最少连接数等）将请求分发给多个后端服务器，以达到均衡负载的目的。<br>负载均衡器可以是硬件设备，也可以是软件实现。常见的负载均衡软件包括 Nginx、HAProxy、F5 等。<br>反向代理和负载均衡通常结合使用，以提供高可用性和性能的服务架构。反向代理可以作为负载均衡器的一部分，将流量分发到多个后端服务器上，并提供一些额外的功能，如<strong>缓存</strong>（某些情况Nginx缓存访问结果可以直接返回，不需要再次访问服务器）、SSL 终止、Web 应用防火墙等。通过结合使用反向代理和负载均衡，可以构建可靠、高效、安全的网络服务架构。</p>\n<hr>\n<p>nginx 反向代理的好处：</p>\n<p>提高访问速度<br>因为nginx本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。</p>\n<p>进行负载均衡<br>所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。</p>\n<p>保证后端服务安全<br>因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把nginx作为请求访问的入口，请求到达nginx后转发到具体的服务中，从而保证后端服务的安全。</p>\n<p>可以看<a href=\"https://www.cnblogs.com/szlsay/p/17737747.html\">苍穹外卖第一章项目介绍</a>里面有讲一些Nginx代理。</p>\n<h2 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h2><p>Docker 是一种开源的容器化平台，用于将应用程序和其依赖项打包到一个<strong>称为容器</strong>的可移植的、可部署的单元中。Docker 使用<strong>容器</strong>来<strong>封装应用程序和所有运行时环境</strong>，包括代码、运行时、系统工具、系统库等，从而实现了轻量级、快速、一致的应用程序交付和部署。</p>\n<p>Docker 是开源的应用容器引擎，可以让开发者打包应用及其依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 或 Windows 机器上，也可以实现虚拟化。容器完全使用沙箱机制，相互之间不会有任何接口。<br>下面对 Docker 的作用和基本用法做个简单介绍：<br>Docker 的作用：<br>降低系统部署难度和复杂性：Docker 可以将应用和服务包装在”容器”中进行部署，所有的依赖都包含在同一容器内，避免了在部署过程中由于环境问题导致的各种冲突和错误。<br>提高系统扩展性：对于需要频繁扩展和缩小的服务，Docker 可以在几秒钟内启动或关闭容器，非常适合微服务架构。<br>提高开发效率：Docker 可以保证开发、测试、预发布和生产环境的一致性，使开发人员更加专注于功能开发。<br>节省资源：相比虚拟机技术，一个相同应用的 Docker 容器镜像都能够运行在同一个机器上，由于容器直接运行于宿主的内核，不需要模拟整个操作系统，因此可以节省大量的系统资源。</p>\n<p><strong>运维</strong>（Operations，简称Ops）是指<strong>运营和维护系统</strong>的一系列工作，旨在确保系统的稳定性、安全性和高可用性。</p>\n<p>运维工作是保障系统稳定运行的关键，需要具备丰富的系统知识、故障排除能力和快速响应的能力。随着<strong>云计算和 DevOps</strong> 等新技术的发展，运维工作也在不断演变和发展，越来越多地倾向于自动化、自助式和云原生的方向。</p>\n<h2 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h2><p><a href=\"https://www.iteye.com/blog/globeeip-1236167\">RBAC新解：基于资源的权限管理(Resource-Based Access Control)</a></p>\n<h2 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h2><p>微服务（Microservices）是一种软件架构模式，将一个大型应用程序拆分成一组更小、更灵活的服务，每个服务都围绕着特定的业务功能进行构建和部署。每个服务都是一个独立的应用，可以单独开发、部署和扩展，通过轻量级的通信机制（通常是 HTTP 或消息队列）进行交互。</p>\n<p>微服务架构的主要特点包括：</p>\n<p>服务拆分：将应用程序拆分成多个小服务，每个服务负责一个特定的业务功能。服务之间通过定义良好的接口进行通信。<br>独立部署：每个微服务都可以独立部署，不受其他服务的影响，降低了部署的风险和复杂度。<br>技术多样性：不同的微服务可以使用不同的技术栈和编程语言来实现，选择最适合特定任务的技术。<br>自动化运维：通过自动化工具和容器技术（如 Docker、Kubernetes(K8s) ），可以实现微服务的自动化部署、扩展和管理。<br>弹性和可伸缩性：由于每个微服务都是独立的，可以根据负载情况对特定服务进行扩展，从而提高整个系统的弹性和可伸缩性。<br>分布式数据管理：每个微服务都有自己的数据存储，可能会使用不同的数据库或数据存储技术，需要通过异步通信或分布式事务来实现数据一致性。<br>服务治理：需要实现服务注册与发现、负载均衡、断路器等机制来保证服务的可用性和稳定性。<br>微服务架构适用于复杂的、大型的应用系统，特别是需要频繁迭代和快速发布的场景。它可以带来更灵活的开发和部署、更高的可扩展性和可靠性，但同时也带来了更多的复杂性和管理成本。因此，在采用微服务架构时，需要根据具体情况进行合理的架构设计和管理实践。</p>\n<h2 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h2><p>分布式事务是指<strong>涉及多个参与者的分布式系统中的事务操作</strong>，保证这些事务操作的一致性和可靠性是一个复杂的问题。在传统的单体系统中，事务管理是相对简单的，因为所有的事务操作都在同一个数据库事务中执行。但在分布式系统中，涉及到多个独立的服务或数据库，事务的一致性变得更加复杂。</p>\n<p>分布式事务的一致性保障了事务的原子性、一致性、隔离性和持久性（ACID 属性）。</p>\n<p>以下是实现分布式事务的几种常见方法：</p>\n<p><strong>两阶段提交</strong>（Two-Phase Commit，2PC）：<br><strong>2PC</strong> 是最经典的分布式事务协议之一。它通过两个阶段来确保所有参与者<strong>都同意</strong>提交或回滚事务。<br>第一阶段（准备阶段）：协调者询问所有参与者是否准备好提交事务。如果<strong>所有</strong>参与者都准备好，则协调者发送提交请求；否则，发送回滚请求。<br>第二阶段（提交&#x2F;回滚阶段）：根据第一阶段的结果，协调者发送提交或回滚请求给所有参与者。</p>\n<p><strong>补偿事务</strong>（Compensating Transaction）：<br>补偿事务是一种基于回滚机制的分布式事务处理方法。当发生某个参与者的操作失败时，会执行相应的<strong>补偿</strong>操作来恢复到一致状态。</p>\n<p><strong>本地消息表</strong>（Local Message Table）：<br>使用<strong>消息队列</strong>实现分布式事务，将<strong>事务操作和消息</strong>发送放入同一个事务中，并使用<strong>本地消息表</strong>记录消息的发送状态。如果事务提交成功但消息发送失败，则<strong>重试发送</strong>消息。</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列（Message Queue）是一种常见的<strong>分布式系统架构模式</strong>，用于在<strong>应用程序之间</strong>传递消息。它允许<strong>不同的应用程序或服务之间进行异步通信</strong>，解耦了系统中不同组件的耦合度，提高了系统的可扩展性、可靠性和灵活性。</p>\n<p>消息队列的主要组成部分包括：</p>\n<p><strong>消息</strong>：消息是在不同应用程序之间传递的<strong>数据单元</strong>，通常包括一些业务数据和元数据。消息队列可以传递各种类型的消息，如文本、JSON、XML 等。<br>消息<strong>生产者</strong>：消息生产者是<strong>产生消息并发送</strong>到消息队列中的应用程序或服务。<br>消息队列：消息队列是一个存<strong>储消息的中间件</strong>，负责接收、存储和分发消息。<br>消息消费者：消息消费者是从消息队列中<strong>接收消息并处理</strong>的应用程序或服务。</p>\n<p>消息队列的特点包括：<br><strong>异步通信</strong>：消息生产者和消息消费者之间的通信是异步的，消息发送后生产者不需要等待消费者处理完毕即可继续执行。<br>解耦：通过消息队列，消息生产者和消费者之间的耦合度降低，它们可以独立进行开发、部署和维护。<br>可靠性：消息队列提供了<strong>消息持久化</strong>、<strong>消息确认</strong>、<strong>重试机制</strong>等功能，确保消息能够安全可靠地传递。<br>削峰填谷：消息队列可以作为<strong>缓冲层</strong>，平滑处理系统的<strong>峰值流量</strong>，防止系统过载。</p>\n<p>常见的消息队列系统包括 <strong>RabbitMQ、Kafka、Redis</strong>、ActiveMQ、Amazon SQS（Simple Queue Service）等。选择合适的消息队列取决于具体的业务需求、系统架构和性能要求。</p>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p>缓存击穿（Cache Miss）是指在使用缓存系统时，某个热点数据缓存失效后，大量请求同时涌入，导致请求直接访问数据库或其他存储系统，使得数据库或存储系统负载剧增，甚至崩溃的情况。</p>\n<p>缓存击穿通常发生在以下情况下：</p>\n<p>热点数据失效：某个频繁访问的热点数据在缓存中过期或被删除，导致缓存失效。<br>高并发请求：大量并发请求同时涌入，请求未命中缓存，直接访问底层数据库或存储系统。<br>缓存击穿可能会导致以下问题：</p>\n<p>数据库负载激增：大量请求直接访问数据库，导致数据库负载剧增，甚至引起数据库宕机。<br>响应时间增加：由于请求直接访问数据库，导致响应时间增加，影响系统性能。<br>为了避免缓存击穿，可以采取以下几种方法：</p>\n<p>加锁或互斥机制：使用分布式锁或互斥机制，确保只有一个线程去加载数据，其他线程等待结果。<br>设置热点数据永不过期：对于热点数据，设置永不过期或者设置一个较长的过期时间，以保证不会因为缓存过期而导致缓存击穿。<br>使用互斥体：使用互斥体的方式来防止数据库穿透。当一个请求发现缓存失效时，首先获得一个互斥锁(Mutex)，然后再去请求数据库，请求返回后再释放锁。<br>预加载：在缓存失效之前，提前预加载热点数据到缓存中，保证缓存不会空出。可以通过定时任务或者异步加载来实现。<br>失败重试：在缓存失效时，通过设置短暂的短期过期时间，再次尝试获取数据。如果再次失败，可以逐渐增加等待时间，直到获取到数据或达到最大等待时间。<br>以上方法可以有效地防止缓存击穿问题的发生，提高系统的稳定性和性能。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><h2 id=\"Mysql-1\"><a href=\"#Mysql-1\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h2><p><a href=\"https://cloud.tencent.com/developer/article/2094819\">Mysql Workbench使用教程</a></p>\n<p><a href=\"https://blog.csdn.net/qq_52050769/article/details/118095034\">Java连接mysql数据库方法</a></p>\n<h2 id=\"SQL-1\"><a href=\"#SQL-1\" class=\"headerlink\" title=\"SQL\"></a>SQL</h2><p><a href=\"https://www.runoob.com/sql/sql-syntax.html\">SQL 菜鸟教程</a></p>\n<p><a href=\"https://www.runoob.com/sql/sql-quickref.html\">SQL 快速参考</a></p>\n<h2 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B 树\"></a>B 树</h2><p><a href=\"https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree#7-mysql%E4%B8%ADb%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\">B+树详解</a></p>\n<p><a href=\"https://blog.51cto.com/u_14643435/2853946\">什么是B-树、B树、B+树、B*树？</a><br>注：B-树是很烂的音译，会让人产生误解，实际上B-树就是B树。</p>\n<p><a href=\"https://pdai.tech/md/algorithm/alg-basic-tree-redblack.html\">树 - 红黑树(R-B Tree)</a>  这篇还没看</p>\n<h2 id=\"Redis-1\"><a href=\"#Redis-1\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p><a href=\"https://www.cnblogs.com/yiwangzhibujian/p/7053840.html\">Redis和同类产品的比较</a></p>\n<p><a href=\"https://www.runoob.com/redis/redis-intro.html\"> Redis 教程 Runoob</a></p>\n"},{"title":"学习Markdown","url":"/2022/09/07/MarkdownNote/","content":"<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><p>这些是 John Gruber 的原始设计文档中列出的元素，所有 Markdown 应用程序都支持。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://img-blog.csdnimg.cn/2021080722171071.png\" alt=\"basic\"></p>\n<h3 id=\"基本语法细节\"><a href=\"#基本语法细节\" class=\"headerlink\" title=\"基本语法细节\"></a>基本语法细节</h3><ol>\n<li><p>细节1<br> <img src=\"https://i.postimg.cc/hvnhM3k2/1.jpg\"><br> 这样用的时候在<code>Get-History</code>和<code>&gt;</code>中间需要有个空格，才能达到这样的效果：</p>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Get-History</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>细节2<br> 如果整个代码块想要作为列表元素的一部分，则需要四个空格。如：<br> <img src=\"https://i.postimg.cc/yxTxGyBs/2.jpg\"></p>\n<blockquote>\n<ol>\n<li>举个栗子<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Get-History</span><br></pre></td></tr></table></figure></li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"扩展语法\"><a href=\"#扩展语法\" class=\"headerlink\" title=\"扩展语法\"></a>扩展语法</h2><p>并非所有 Markdown 应用程序都支持这些元素。<br><img src=\"https://img-blog.csdnimg.cn/20210807221747578.png\" alt=\"extend\"></p>\n<h3 id=\"扩展语法细节\"><a href=\"#扩展语法细节\" class=\"headerlink\" title=\"扩展语法细节\"></a>扩展语法细节</h3><ol>\n<li>脚注第二行的[^1]后面一定要跟英文冒号: </li>\n<li>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</li>\n</ol>\n<p><code>&lt;!--more--&gt;</code>: 隐藏博客首页文章大部分内容。</p>\n<h3 id=\"VSCode-Markdown-ALL-in-One使用\"><a href=\"#VSCode-Markdown-ALL-in-One使用\" class=\"headerlink\" title=\"VSCode Markdown ALL in One使用\"></a>VSCode Markdown ALL in One使用</h3><p>Markdown ALL in One插件支持很多快捷键，在vscode中可以使用CTRL+SHIFT+P之后输出markdown选择要使用的命令。</p>\n<h3 id=\"VS-Code主题\"><a href=\"#VS-Code主题\" class=\"headerlink\" title=\"VS Code主题\"></a>VS Code主题</h3><p><a href=\"https://cloud.tencent.com/developer/article/2122340\">18个VS Code主题推荐</a></p>\n<h3 id=\"VS-Code-配置Markdown\"><a href=\"#VS-Code-配置Markdown\" class=\"headerlink\" title=\"VS Code 配置Markdown\"></a>VS Code 配置Markdown</h3><p><a href=\"https://blog.cxplay.org/works/vscode-to-markdown-editor/\">将 VS Code 打造成一个体验舒适的 Markdown 编辑器</a></p>\n<p>注意：在setting.json中设置markdown的字体是影响VS Code代码编辑区部分，也就是Markdown源码。要修改渲染后的Markdown字体要在Markdown Preview Enhanced插件的style.less中进行修改，打开命令面板，输入Customize CSS，便打开 style.less 文件</p>\n<h2 id=\"文档参考\"><a href=\"#文档参考\" class=\"headerlink\" title=\"文档参考\"></a>文档参考</h2><p><a href=\"https://www.markdown.xyz/\">Markdown指南</a><br><a href=\"https://www.runoob.com/markdown/md-tutorial.html\">RUNOOB</a></p>\n","categories":["Language"],"tags":["Markdown"]},{"title":"TCP Note","url":"/2023/10/27/TCP-Note/","content":"<p><strong>已经完全理解TCP&#x2F;IP协议的网络传输过程了</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，<strong>传输控制协议&#x2F;互联网协议</strong>）是互联网的基本协议，也是国际互联网络的基础。</p>\n<p>TCP&#x2F;IP 不是指一个协议，也不是 TCP 和 IP 这两个协议的合称，而是一个<strong>协议族</strong>，包括多个网络协议，比如 IP、ICMP（Internet Control Message Protocol，互联网控制报文协议）、TCP、UDP(User Datagram Protocol，用户数据报协议)、HTTP（Hyper Text Transfer Protocol，超文本传输协议）、FTP（File Transfer Protocol，文件传输协议）、POP3（Post Office Protocol version 3，邮局协议）等。</p>\n<h2 id=\"TCP-x2F-IP的分层结构\"><a href=\"#TCP-x2F-IP的分层结构\" class=\"headerlink\" title=\"TCP&#x2F;IP的分层结构\"></a>TCP&#x2F;IP的分层结构</h2><p>TCP&#x2F;IP 协议族按照层次由上到下分成 4 层，分别是应用层（Application Layer）、传输层（Transport Layer）、网络层（Internet Layer，或称网际层）和网络接口层（Network Interface Layer，或称数据链路层和网络访问层）</p>\n<p><strong>应用层</strong>包含所有的高层协议，比如 Telnet（Telecommunications Network，远程登录协议）、FTP、SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）、DNS（Domain Name Service，域名服务）、NNTP（Net News Transfer Protocol，网络新闻传输协议）和 HTTP 等。Telnet 允许一台机器上的用户登录远程机器进行工作，FTP 提供将文件从一台机器上移到另一台机器上的有效方法，SMTP用于电子邮件的收发，DNS 用于把主机名映射到网络地址，NNTP 用于新闻的发布、检索和获取，HTTP 用于在 WWW(World Wide Web，万维网) 上获取主页。</p>\n<p>应用层的下面一层是<strong>传输层</strong>，著名的 <strong>TCP 和 UDP</strong>（<strong>User Datagram Protocol，用户数据报协议</strong>）就在这一层。<strong>TCP 是面向连接的协议</strong>，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。<strong>UDP 是面向无连接的不可靠传输协议</strong>，主要用于不需要TCP的排序和流量控制等功能的应用程序。</p>\n<p>传输层的下面一层是<strong>网络层</strong>，该层是<strong>整个 TCP&#x2F;IP 体系结构的关键部分</strong>，其功能是使主机可以把数据包（Packet，也称 分组，指的是 <strong>在传输时被分割的数据</strong>）发往任何网络，并使分组独立地传向目标。这些分组经由不同的网络到达的顺序和发送的顺序可能不同。网络层使用的协议有 <strong>IP</strong>。</p>\n<p>网络层的下面是<strong>数据链路层</strong>，该层是整个体系结构的基础部分，负责接收 IP 层的 IP 数据报，通过网络向外发送，或接收从网络上来的物理帧，抽出 IP 数据报，向 IP 层发送。<strong>该层是主机与网络的实际连接层</strong>。</p>\n<img src=\"/2023/10/27/TCP-Note/1.png\" class=\"\">\n\n<p>数据链路层下面就是<strong>实体线路</strong>（比如以太网络、光纤网络等）。数据链路层有以太网、令牌环网等标准，负责网卡设备的驱动、帧同步（就是从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。<br><strong>交换机</strong>可以在不同的数据链路层的网络之间（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间）转发数据帧，由于不同数据链路层的帧格式不同，交换机要将进来的数据包拆掉包头重新封装之后再转发。</p>\n<p><strong>PDU(Protocol Data Unit)：协议数据单元 是指对等层次之间传递的数据单位。</strong><br>不同的协议层对PDU有不同的称谓，在传输层叫作数据段(TCP-Segment)或数据报(UDP-Datagram)，在网络层叫作数据包(packet)，在数据链路层叫作数据帧(Frame)，在物理层是数据位(bit 比特流)，在传输层以上的层次叫作数据(data)。<br><strong>这东西似乎很难有统一的定义</strong>，有几篇文章可能有用：<br><a href=\"https://www.cnblogs.com/my_life/articles/1949972.html\">数据帧frame，数据包packet，数据报datagram和数据段segment</a><br><a href=\"https://blog.csdn.net/ywy2090/article/details/11730865\">PDU（协议数据单元）</a><br><a href=\"https://blog.csdn.net/qq_25606103/article/details/51295965\">帧、数据报、数据包的区别和联系</a></p>\n<p>数据封装成帧后发送到物理传输介质上，到达目的主机后，每层协议再剥掉相应的包头，最后将应用层数据交给应用程序处理。</p>\n<p><a href=\"https://c.biancheng.net/view/9831.html\">TCP&#x2F;IP协议介绍(c.biancheng.net)</a> 讲的还可以，就是各个协议层的PDU分的不是很清楚。</p>\n<hr>\n<p><a href=\"https://www.cnblogs.com/jojop/p/14111160.html\">详解TCP协议</a>这篇讲的很不错，一些小瑕疵可以忽略。</p>\n<p><strong>还有几篇有一定的可读性</strong><br><a href=\"https://hit-alibaba.github.io/interview/basic/network/TCP.html\">计算机网络</a> 包含计算机许多内容的个人博客<br><a href=\"https://baijiahao.baidu.com/s?id=1663133611194990028&wfr=spider&for=pc\">35 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a><br><a href=\"https://www.coonote.com/tcpip/tcp-ip-basic-knowledge.html\">菜鸟笔记</a><br><a href=\"https://www.xiaolincoding.com/network/1_base/tcp_ip_model.html#%E5%BA%94%E7%94%A8%E5%B1%82\">TCP&#x2F;IP 网络模型有哪几层</a>关于计算机网络的个人博客</p>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p>三次握手(Three-way Handshake)是指建立一个TCP连接时，需要客户端和服务器总共发送三个包。</p>\n<p>三次握手的目的是连接服务器指定端口，建立TCP连接，同步双方的序列号和确认号并交换TCP窗口大小信息，在socket编程中，客户端执行connect()时触发三次握手。</p>\n<ul>\n<li>第一次握手：客户端发送一个TCP的SYN标志位 置一的数据包指明客户打算连接的fu’wu</li>\n</ul>\n<p>TCP&#x2F;IP 定义了计算机<strong>操作系统如何连入互联网</strong>，以及<strong>数据传输</strong>的标准。<br>TCP&#x2F;IP 是<strong>为了解决不同系统的计算机之间的传输通信而提出的一个标准</strong>，不同系统的计算机采用了同一种协议后，就能相互通信，从而能够建立网络连接，实现资源共享和网络通信。</p>\n<h1 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h1><p><strong>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</strong></p>\n<p><img src=\"https://static.runoob.com/images/mix/v2-854e3df8ea850c977c30cb1deb1f64db_r.jpg\"></p>\n","categories":["Network"],"tags":["TCP/IP"]},{"title":"Network","url":"/2022/09/09/NetworkNote/","content":"<p><strong>Network</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Routing\"><a href=\"#Routing\" class=\"headerlink\" title=\"Routing\"></a>Routing</h1><p>路由器（router）：路由器与我们的设备进行连接，路由与路由之间连接构成巨大的“网络”。<br>路由器是提供 Wi-Fi 的设备，通常连接到调制解调器。它将信息从互联网发送到个人设备，如电脑、手机和平板电脑。您家中的这些联网设备构成了您的局域网(LAN)。一旦调制解调器从互联网引入信息，路由器就会将此数据分发到您的个人设备。</p>\n<p>LAN：局域网（local area network）<br>WAN：广域网（Wide Area Network）</p>\n<p><strong>调制解调器（modem）：</strong> 电话这种基础设施将你和外部的世界连在一起，我们通过一种叫调制解调器的设备连接到电话这种网络。modem将网络信息和电话设施可以处理的信息进行转换。</p>\n<blockquote>\n<p><a href=\"https://support.google.com/googlenest/answer/6274112?hl=en&ref_topic=6287511\">什么是调制解调器？</a><br>调制解调器是一种在外界或广域网 (WAN)与您的家之间发送信息的设备。<br>调制解调器将您的入站连接（同轴电缆、电话线、光纤线或其他）转换为以太网连接，然后允许 Wi-Fi 路由器连接到 Internet。<br>调制解调器通常由您的Internet 服务提供商 (ISP) 提供。您的路由器应使用以太网电缆连接到调制解调器。<br>调制解调器和路由器组合设备（网关）<br>许多 ISP 提供的设备包括调制解调器和路由器功能（内置WiFi功能）。将您的 Nest Wifi 路由器连接到这些类型的组合网关设备是可以的。但为了获得最佳设置，您可能需要调整组合设备上的设置，<a href=\"https://support.google.com/googlenest/answer/6277579\">了解有关双重 NAT</a></p>\n</blockquote>\n<p>来自<a href=\"https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8\">wiki</a> 调制解调器（英语：modem，modulator-demodulator的缩写）俗称猫，是一个将数字信号调变到模拟信号上进行传输，并解调收到的模拟信号为数字信号的电子设备。它的目标是产生能够方便传输的模拟信号并且能够通过解码还原原来的数字信号。根据不同的应用场合，调制解调器可以<strong>使用不同的方法来传送模拟信号</strong>，比如使用光纤，射频无线电或<strong>电话线</strong>等。<br>使用<strong>普通电话线音频波段进行数据通信</strong>的电话调制解调器是人们最常接触到的调制解调器。</p>\n<p>其他常见的调制解调器还包括用于<strong>宽带数据接入</strong>的有线电视电缆调制解调器、ADSL调制解调器和光纤调制解调器。<strong>数字式移动电话（手机）</strong> 实际上也是一种无线方式的调制解调器。现代电信传输设备是为了在不同的介质上远距离的传输大量信息，因此也都以调制解调器的功能为核心。其中，微波调制解调器速率可以达上百万比特每秒；而使用光纤作为传输介质的 <strong>光调制解调器</strong> 可以达到几十Gbps以上，是现在电信传输的骨干。</p>\n<p><strong>宽带调制解调器</strong><br>DSL (数字用户回路)数 据机是一种调制解调器是通过铜线或者本地电话网提供数字连接的一种技术。<br>ADSL（非对称用户数字线路）调制解调器也是一种调制解调器，俗称宽带猫主要区别在于它不止局限在普通电话使用的语音载波的频段。 现在的ADSL调制解调器使用编码正交频分调变。.<br>VDSL (超高速数字用户回路) 数据机也是一种调制解调器，VDSL允许客户端利用现有铜线获得高带宽服务而不必采用光纤。VDSL和ADSL一样</p>\n<p><strong>光学调制解调器</strong><br>（Optical modem）或光modem，中国俗称光猫，指通过光纤介质传输信号，并将光信号调制解调为其他信号的调制解调器。常见于光纤到户的设备。</p>\n<p>猫是调制解调器，是用来通过电话线上网的（包括ADSL宽带和普通电话线上网），而路由器是用来组建局域网（包括无线和有线的），也可以与猫一起使用达到一条电话线多台电脑同时上网。直接连猫的速度要快。大部分在连接路由器后的有线连接的速度衰减很小可以忽略不计，无线的速度没有有线的快。</p>\n<p><strong>域名</strong>：每个网络中的设备都有独一无二的ip地址，为方便，给ip地址取了一个“域名”，我们变可以通过域名通过网络连接到这些电脑。</p>\n<p><strong>互联网（internet）和网络（web）的区别：</strong><br>互联网是一种基础的技术，它允许我们将成千上万的设备连在一起。在这些设备中，有一些我们称为网络服务器的设备可以发送文件并在我们设备的浏览器上显示，这便构成了网络。互联网是基础设施，网络是建立在这种基础设施上的服务，除了网络，还有一些服务，比如邮箱和IRC也是运行在互联网之上的。</p>\n<h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><p>每个计算机必须有一个 IP 地址才能够连入因特网。<br>每个 IP 包必须有一个地址才能够发送到另一台计算机。<br>TCP&#x2F;IP 使用 <strong>32 个比特</strong>或者 4 组 0 到 255 之间的数字来为计算机编址，每组数字（一个字节，八个比特）之间由<strong>点号</strong>隔开，比如：<strong>192.168.1.60</strong>。</p>\n<h3 id=\"IPV6\"><a href=\"#IPV6\" class=\"headerlink\" title=\"IPV6\"></a>IPV6</h3><p>IPv6 是 “Internet Protocol Version 6” 的缩写，也被称作下一代互联网协议。</p>\n<p>在 RFC1884 中（ Request for Comments document TCP&#x2F;IP协议的标准文档 ），规定的标准语法建议把 IPv6 地址的 <strong>128 位</strong>（16 个字节）写成 8 个 16 位的无符号整数，每个整数用 4 个十六进制位表示，这些数之间用 <strong>冒号（:）</strong> 分开，例如：<br><code>686E：8C64：FFFF：FFFF：0：1180：96A：FFFF</code></p>\n<p>冒号十六进制记法允许<strong>零压缩，即一串连续的0可以用一对冒号取代</strong>，例如：<br><code>FF05：0：0：0：0：0：0：B3可以定成：FF05：：B3</code></p>\n<p>为了保证零压缩有一个清晰的解释，建议中规定，在任一地址中，只能使用一次零压缩。</p>\n<p>冒号十六进制记法结合有点十进制记法的后缀。这种结合在IPv4向IPv6换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法：<br><code>0：0：0：0：0：0：128.10.1.1</code><br>再使用零压缩即可得出：<br> <code>：：128.10.1.1</code></p>\n<h3 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h3><p>四组数字很难记忆。使用一个名称更容易。<br>用于 TCP&#x2F;IP 地址的名字被称为域名，runoob.com 就是一个域名。<br>当你键入一个像 <a href=\"http://www.runoob.com/\">http://www.runoob.com</a> 这样的域名，域名会被一种 <strong>DNS 程序</strong>翻译为数字。</p>\n<p>在全世界，数量庞大的 DNS 服务器被连入因特网。</p>\n<p>DNS 服务器负责将域名翻译为 TCP&#x2F;IP 地址，同时负责使用新的域名信息更新彼此的系统。</p>\n<p>当一个新的域名连同其 TCP&#x2F;IP 地址一起注册后，全世界的 DNS 服务器都会对此信息进行更新。</p>\n<h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p>HTTP 代理只能解释和处理 HTTP 和 HTTPS 网页，而 SOCKS5 代理可以处理任何流量。<br>Shadowsocks 和 SSR 都是当作 SOCKS5 代理服务器来突破防火长城 GFW 的限制。<br>代理和 VPN 的主要区别在于：VPN 会对传输流量进行加密，而代理不会加密流量。VPN 提供更稳定的连接，而代理断线的频率较高。</p>\n<p>网页，网站，网络服务器和搜索引擎的区别？</p>\n<blockquote>\n<p>网页是一份显示在网络浏览器上的HTML文档，这种网页文档可以插入各种各样不同类型的资源，例如：</p>\n<ul>\n<li>css样式信息–控制页面观感</li>\n<li>脚本–为页面添加交互性</li>\n<li>多媒体–图像，音频，视频</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>网站，也称作”site”（站点），是共享唯一域名的相互链接的网页的集合。访问网站时，输入域名，浏览器将会显示该网站的<strong>主要网页或主页</strong>。</p>\n</blockquote>\n<blockquote>\n<p>网络服务器：互联网上托管了许多网站的计算机。托管的意思即所有的网页和它们的支持文件在该服务器上都可用，当浏览器发起请求时，服务器将任意网页从托管的网站发送到任意用户的浏览器。</p>\n</blockquote>\n<blockquote>\n<p>搜索引擎是一个用来帮你找其他网页的<strong>网站</strong>。浏览器是一个接收并显示网页的软件！搜索引擎则是一个帮助用户从其他网站寻找网页的网站。搜索引擎（谷歌，必应）的主页面经常是我们使用的浏览器（谷歌浏览器）的默认开始页面，所以容易搞混，需要分清基础设施（浏览器）和服务（搜索引擎）。</p>\n</blockquote>\n<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_web_server#%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9\">什么是网络服务器</a></p>\n<h2 id=\"内外网\"><a href=\"#内外网\" class=\"headerlink\" title=\"内外网\"></a>内外网</h2><p>内网即局域网是指在某一区域内由多台计算机互联成的计算机组，一般是方圆几千米以内。<br><strong>内网IP地址就是私有IP地址</strong>，不允许在公网上面传递，只能供内部使用。内网使用了私有地址无法访问internet 会用到<strong>NAT-地址转换技术</strong>，将内部的私有地址转换为可以访问internet的外网地址让内部可以上网。外网IP地址就是除了私有地址和被保留的地址外的所有地址，需要申请才能使用。<br>如何查电脑局域网IP(内网IP):</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">ipconfig /<span class=\"built_in\">all</span></span><br></pre></td></tr></table></figure>\n\n<p>外网即广域网 ，<del>又称公网</del> 局域网通过一台服务器或是一个路由器对外连接的网络，这个IP地址是唯一的是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。广域网并不等同于互联网。<br>外网IP是全世界唯一的IP地址，仅分配给一个网络设备。而内网IP是由路由器分配给每一部内部使用的设备的IP地址，而内网的所有用户都是通过同一个外网IP地址进行上网的，而内网的IP地址每个人的都不一样，Internet上的用户也无法直接访问到内网用户。简单来说呢，外网IP就是标示了您在整个互联网上的地址，就相当于小区的地址，而内网IP呢，就是标识着您在局域网里面的地址，也就是小区内的几栋几楼几号房子。<br>如何查电脑外网IP: 上网查，如<a href=\"https://tool.lu/ip/\">IP地址查询</a>。<br>注意，ip查询网站只是获得到你本地出口的IP，即使它是经过转发的IP。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>一般内网有自己的IP号段，也不会和互联网号段冲突，内网就是从路由器以下开始的，而且IP都是以192开头的IP。外网Ip一般都是用于公司企业，学校等机构的。</p>\n<p>内网的ip可以经常换，可以自己定义规则；而外网的ip一般都是固定的，你装好宽带的时候，你的ip就固定下来了。</p>\n<p>你家里装了宽带，为了多个人可以用同一个宽带，你买路由器，这时候，所有连接在路由器上的电脑、连接路由器放出来的wifi上的电脑、手机，他们则属于同一个局域网内，你查看他们的网络连接，就会发现都是192开头的，ip的前3个网段数字都是一样的，只有最后一个不一样。这些手机、电脑用的就是内网，但是如果他们都去访问互联网的网址，那么他们对外的ip地址，就是你宽带的ip地址，所有手机和电脑对外都是同一个ip地址，这就是外网。</p>\n<p>在局域网中，每台电脑都可以自己分配自己的IP，这个IP只在局域网中有效。而如果你将电脑连接到互联网，你的网络提供商（ISP）的服务器会为你分配一个IP地址，这个IP地址才是你在外网的IP。两个IP同时存在，一个对内，一个对外。</p>\n<p>你在内网的机子在上网时，都是在向网关发出请求，再由网关（一般为路由器）用外网IP转到INT网上，接受数据后，再分发到你的内网IP上。</p>\n<blockquote>\n<p>IPv4地址分为A、B、C、D、E五类，除去特殊作用的D、E两类，剩下的A、B、C三类地址是我们常见的IP地址段。A类地址的容量最大，可以容纳16777214个主机，B类地址可以容纳65534个主机，C类地址可以容纳254个主机。<br>在这三类地址中，绝大多数的IP地址都是公有地址，需要向国际互联网信息中心申请注册。但是在IPv4地址协议中预留了3个IP地址段，<strong>作为私有地址，供组织机构内部使用</strong>。<br>这三个地址段分别位于A、B、C三类地址内：</p>\n<ul>\n<li>A类地址：10.0.0.0–10.255.255.255</li>\n<li>B类地址：172.16.0.0–172.16.255.255</li>\n<li>C类地址：192.168.0.0–192.168.255.255<br>所以局域网在选取使用私有地址时，一般会按照实际需要容纳的主机数来选择私有地址段。常见的局域网由于容量小，一般选择C类的192.168.0.0作为地址段使用，一些大型企业就需要使用B类甚至A类地址段作为内部网络的地址段。<br>最后需要补充说明的是，由于NAT和子网掩码的存在，实际在使用中，一个C类大小的局域网也可以选择A类的10.0.0.0网段作为自己的IP地址段。大多数局域网之所以仍然选择192.168.0.0&#x2F;24或者192.168.1.0&#x2F;24作为自己的IP地址段，更多的是因为约定成俗或者说网管个人习惯的关系。<br>我们常见的路由器默认的IP以及我们部以太网时，网关的默认IP都是192.168.1.1主要是因为192.168.0.0-192.168.255.255是一个私有IP范围。</li>\n</ul>\n</blockquote>\n<p><a href=\"https://www.jianshu.com/p/0cbfdcf4261b\">搞不清的内网、外网、私网、公网</a><br><strong>内网和外网</strong><br>这一组概念是相对于某个组织而言的，如果你在一个局域网内（比如学校、公司等），那局域网外部的网络都叫外网， 你自己所在的网络就是内网。内网和外网只是一个相对的概念。实际上并不存在。公网和私网才是真实存在的。</p>\n<p><strong>私网和公网</strong><br>公网就是人人都能访问的网络，比如<a href=\"www.baidu.com\">百度</a>。<br>私网顾名思义，私有网络，未经授权无法访问的网络。局域网也是某种意义上的私网。私网地址产生的一个原因是因为公网地址非常缺乏，大家不得不使用同一个公网IP地址上网。</p>\n<p><strong>宽泛而言，内网≈私网 外网≈公网，不过这也得看具体场景。</strong></p>\n<p>公有地址(Public address)：由 Inter NIC(Internet Network Information Center 因特网信息中心)负责。这些 IP 地址分配给注册并向Inter NIC提出申请的组织机构，公有 IP 全球唯一，通过它直接访问因特网(直接能上网)。</p>\n<p>私有地址(Private address)：属于非注册地址，专门为组织机构内部使用，说白了，私有 IP 不能直接上网。</p>\n<p>而我们平时通过运营商(电信、移动、联通宽带等)上网，家里面通过路由器分出来的 IP 都是私有 IP(局域网 IP)，<br>运营商买了一些公有 IP，然后通过这些公有 IP 分出来，再分给一个一个的用户使用。这个过程有点类似于，我们去安装了宽度，通过路由器分出几个 IP，让好几个人都能上网，当然运营商通过公有 IP 分出来的过程肯定比这个复杂多了。所以，我们平时上网用的 IP 是私有 IP，真正拥有公有 IP 的是运营商(当然，我们可以租用一个公有 IP )。所以，A 家庭的局域网 IP 和 B 家庭的局域网 IP 相同很正常，但是，最终 A 和 B 能上网(数据走出去)还是通过运营商的公有 IP，毕竟，公有 IP 的资源有限，这一片区域的用户使用的很有可能(实际上就是这样的)是同一个公有 IP。</p>\n<p>公有IP地址：也叫全局地址，是指合法的IP地址，它是由NIC（网络信息中心）或者ISP(网络服务提供商)分配的地址，对外代表一个或多个内部局部地址，是全球统一的可寻 址的地址。</p>\n<p>私有IP地址：也叫内部地址，属于非注册地址，专门为组织机构内部使用。因特网分配编号委员会（IANA）保留了3块IP地址做为私有IP地址。</p>\n<p><strong>以下参考自</strong><a href=\"https://www.cnblogs.com/ranyonsue/p/9713992.html\">内网和外网之间的通信（端口映射原理）</a><br> 你在内网的机子在上网时，都是在向网关发出请求，再由网关（一般为路由器）用外网IP转到INT网上，接受数据后，再分发到你的内网IP上。</p>\n<p>我们平时通过运营商(电信、移动、联通宽带等)上网，家里面通过路由器分出来的 IP 都是私有 IP(局域网 IP)，但是我们可以上网啊，怎么会是私有 IP 呢？租用(申请)公有 IP 是需要钱的。 运营商买了一些公有 IP，然后通过这些公有 IP 分出来，再分给一个一个的用户使用。这个过程有点类似于，我们去安装了宽度，通过路由器分出几个 IP，让好几个人都能上网，当然运营商通过公有 IP 分出来的过程肯定比这个复杂多了。所以，我们平时上网用的 IP 是私有 IP，真正拥有公有 IP 的是运营商(当然，我们可以租用一个公有 IP )。所以，A 家庭的局域网 IP 和 B 家庭的局域网 IP 相同很正常，但是，最终 A 和 B 能上网(数据走出去)还是通过运营商的公有 IP，毕竟，公有 IP 的资源有限，这一片区域的用户使用的很有可能(实际上就是这样的)是同一个公有 IP，这样的话，假如 A 和 B 的局域网 IP 相同(192.168.31.11)，当他们同时访问百度服务器的时候，百度服务器如何区分哪个是 A，哪个是 B 呢?</p>\n<h3 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h3><p>端口映射是 NAT 的一种，它将外网主机的 IP 地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该 IP 的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。</p>\n<p>我们平时经过路由器，通过宽带，最终去到运营商那边，数据是从运营商出去，最终数据是回到运营商那边，运营商再把数据发送到用户的电脑。</p>\n<p>　路由器，至少有两个端口：WAN 口和 LAN 口。</p>\n<p>WAN：接外部 IP 地址用，通常指的是出口，转发来自内部 LAN 接口的 IP 数据包，这个口的 IP 是唯一的。<br>LAN：接内部 IP 地址用，LAN 内部是交换机。</p>\n<p>这里，我们简化这个过程，我们把运营商当做一个 NAT 设备。<br><img src=\"https://img-blog.csdn.net/20150603162431053\"></p>\n<blockquote>\n<p>A 电脑的 IP 是局域网 IP(192.168.31.11)，这个 IP(192.168.31.11)是从路由器的 lan口分配的。<br>当我们上百度的时候，经过路由器的 wan口，进行相应的IP、端口转化：192.168.31.11:80 -&gt; 10.221.0.24:8080,所以，从 wan口出去的地址为：10.221.0.24:8080。<br><img src=\"https://img-blog.csdn.net/20150603162755367\"><br>最后，经过运营商，运营商那边会做相应的端口映射(而且是动态端口映射)，子网 IP(10.221.0.24:8080)转化为公网 IP(128.0.0.1:8888)，通过这个公网 IP 去访问百度服务器。<br><img src=\"https://img-blog.csdn.net/20150603162836192\"><br>通过这样的层层端口映射，最终保证地址(IP + 端口)的唯一性。A 和 B 访问百度服务器，尽管它们的局域网 IP 是一样的，但是最终它们访问百度的地址(IP + 端口)是唯一的，所以，百度服务器回复时，原路返回时能够区分到底给谁回。</p>\n</blockquote>\n<h1 id=\"NAT-网络地址转换\"><a href=\"#NAT-网络地址转换\" class=\"headerlink\" title=\"NAT 网络地址转换\"></a>NAT 网络地址转换</h1><p><em><strong>本节转载自</strong></em><a href=\"https://blog.csdn.net/qq_21125183/article/details/86487747\">计算机网络：NAT基本原理</a></p>\n<p>NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术</p>\n<p>当主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信时，可使用NAT方法。<br><img src=\"https://img-blog.csdnimg.cn/20190115095442520.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70\"><br>NAT就是在局域网中使用内部地址，而当内部节点要与外部网络进行通讯时，就在网关处，将内部地址替换成公用地址，从而在外部公网（internet）上正常使用，NAT可以使多台计算机共享Internet连接，这一功能很好地解决了公共 IP地址紧缺的问题。通过这种方法，可以只申请一个合法IP地址，就把整个局域网中的计算机接入Internet中。这时，NAT屏蔽了内部网络，所有内部网计算机对于公共网络来说是不可见的，而内部网计算机用户通常不会意识到NAT的存在。如下图所示。这里提到的内部地址，是指在内部网络中分配给节点的私有IP地址，这个地址只能在内部网络中使用，不能被路由转发。</p>\n<h2 id=\"NAT分类\"><a href=\"#NAT分类\" class=\"headerlink\" title=\"NAT分类\"></a>NAT分类</h2><p>NAT可以分为三种类型：分别是静态NAT(Static NAT)、动态地址NAT(Pooled NAT)、网络地址端口转换NAPT（Port-Level NAT）。<br><img src=\"https://img-blog.csdnimg.cn/20190115095452124.jpg\"></p>\n<h3 id=\"静态NAT\"><a href=\"#静态NAT\" class=\"headerlink\" title=\"静态NAT\"></a>静态NAT</h3><p>静态转换是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备(如服务器)的访问。<br>对于以下网络拓扑图，当内网主机 192.168.1.2如果要与外网的主机202.20.65.4通信时，主机（IP：192.168.1.2）的数据包经过路由器时，路由器通过查找NAT table 将IP数据包的源IP地址（192.168.1.2）改成与之对应的全局IP地址（202.20.65.4），而目标IP地址202.20.65.4保持不变，这样，数据包就能到达202.20.65.4。而当主机HostB(IP:202.20.65.4) 响应的数据包到达与内网相连接的路由器时，路由器同样查找NAT table，将IP数据包的目的IP 地址改成192.168.1.2，这样内网主机就能接收到外网主机发过来的数据包。在静态NAT方式中，内部的IP地址与公有IP地址是一种一一对应的映射关系，所以，采用这种方式的前提是，机构能够申请到足够多的全局IP地址。<br><img src=\"https://img-blog.csdnimg.cn/20190115095447544.jpg\"></p>\n<h3 id=\"动态NAT\"><a href=\"#动态NAT\" class=\"headerlink\" title=\"动态NAT\"></a>动态NAT</h3><p>动态转换（亦称NAT pool）是指不建立内部地址和全局地址的一对一的固定对应关系。而通过共享NAT地址池的IP地址动态建立NAT的映射关系。当内网主机需要进行NAT地址转换时，路由器会在NAT地址池中选择空闲的全局地址进行映射，每条映射记录是动态建立的，在连接终止时也被收回。<br><img src=\"https://img-blog.csdnimg.cn/20190115100054829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70\"><br>动态NAT方式适合于 当机构申请到的全局IP地址较少，而内部网络主机较多的情况。内网主机IP与全局IP地址是多对一的关系。当数据包进出内网时，具有NAT功能的设备对IP数据包的处理与静态NAT的一样，只是NAT table表中的记录是动态的，若内网主机在一定时间内没有和外部网络通信，有关它的IP地址映射关系将会被删除，并且会把该全局IP地址分配给新的IP数据包使用，形成新的NAT table映射记录。</p>\n<h3 id=\"网络地址端口转换NAPT\"><a href=\"#网络地址端口转换NAPT\" class=\"headerlink\" title=\"网络地址端口转换NAPT\"></a>网络地址端口转换NAPT</h3><p>网络地址端口转换NAPT（Network Address Port Translation）则是把内部地址映射到外部网络的一个IP地址的不同端口上。它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与 动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的端口号。<br>NAPT是使用最普遍的一种转换方式，它又包含两种转换方式：SNAT和DNAT。</p>\n<blockquote>\n<ul>\n<li>源NAT（Source NAT，SNAT）：修改数据包的源地址。源NAT改变第一个数据包的来源地址，它永远会在数据包发送到网络之前完成，数据包伪装就是一具SNAT的例子。</li>\n<li>修改数据包的目的地址。Destination NAT刚好与SNAT相反，它是改变第一个数据包的目的地地址，如平衡负载、端口转发和透明代理就是属于NAT。</li>\n</ul>\n</blockquote>\n<h2 id=\"NAT-基本原理\"><a href=\"#NAT-基本原理\" class=\"headerlink\" title=\"NAT 基本原理\"></a>NAT 基本原理</h2><p>NAT的基本工作原理是，当私有网主机和公共网主机通信的IP包经过NAT网关时，将IP包中的源IP或目的IP在私有IP和NAT的公共IP之间进行转换。</p>\n<h3 id=\"地址转换（静态NAT）\"><a href=\"#地址转换（静态NAT）\" class=\"headerlink\" title=\"地址转换（静态NAT）\"></a>地址转换（静态NAT）</h3><p>NAT的基本工作原理是，当私有网主机和公共网主机通信的IP包经过NAT网关时，将IP包中的源IP或目的IP在私有IP和NAT的公共IP之间进行转换。</p>\n<p>如下图所示，NAT网关有2个网络端口，其中公共网络端口的IP地址是统一分配的公共 IP，为202.20.65.5；私有网络端口的IP地址是保留地址为192.168.1.1。私有网中的主机192.168.1.2向公共网中的主机202.20.65.4发送了1个IP包(Dst&#x3D;202.20.65.4,Src&#x3D;192.168.1.2)。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190115100043490.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70\"><br>当IP包经过NAT网关时，NAT Gateway会将IP包的源IP转换为NAT Gateway的公共IP并转发到公共网，此时IP包（Dst&#x3D;202.20.65.4，Src&#x3D;202.20.65.5）中已经不含任何私有网IP的信息。由于IP包的源IP已经被转换成NAT Gateway的公共IP，Web Server发出的响应IP包（Dst&#x3D; 202.20.65.5,Src&#x3D;202.20.65.4）将被发送到NAT Gateway。</p>\n<p>这时，NAT Gateway会将IP包的目的IP转换成私有网中主机的IP，然后将IP包（Des&#x3D;192.168.1.2，Src&#x3D;202.20.65.4）转发到私有网。对于通信双方而言，这种地址的转换过程是完全透明的。转换示意图如下。<br><img src=\"https://img-blog.csdnimg.cn/2019011510012250.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70\"></p>\n<h3 id=\"连接跟踪\"><a href=\"#连接跟踪\" class=\"headerlink\" title=\"连接跟踪\"></a>连接跟踪</h3><p>在上述过程中，NAT Gateway在收到响应包后，就需要判断将数据包转发给谁。此时如果子网内仅有少量客户机，可以用静态NAT手工指定；但如果内网有多台客户机，并且各自访问不同网站，这时候就需要连接跟踪（connection track）。如下图所示：<br><img src=\"https://img-blog.csdnimg.cn/20190115100126627.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70\"></p>\n<h3 id=\"端口转换（网络地址端口转换NAPT）\"><a href=\"#端口转换（网络地址端口转换NAPT）\" class=\"headerlink\" title=\"端口转换（网络地址端口转换NAPT）\"></a>端口转换（网络地址端口转换NAPT）</h3><p>以上述客户机访问服务器为例，当仅有一台客户机访问服务器时，NAT Gateway只须更改数据包的源IP或目的IP即可正常通讯。但是如果Client A和Client B同时访问Web Server，那么当NAT Gateway收到响应包的时候，就无法判断将数据包转发给哪台客户机，如下图所示:<br><img src=\"https://img-blog.csdnimg.cn/20190115100131757.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70\"><br>此时，NAT Gateway会在Connection Track中加入端口信息加以区分。如果两客户机访问同一服务器的源端口不同，那么在Track Table里加入端口信息即可区分，如果源端口正好相同，那么在实行SNAT和DNAT的同时对源端口也要做相应的转换，如下图所示:<br><img src=\"https://img-blog.csdnimg.cn/20190115100137744.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>NAT技术无可否认是在ipv4地址资源的短缺时候起到了缓解作用；在减少用户申请ISP服务的花费和提供比较完善的负载平衡功能等方面带来了不少好处。但是在ipv4地址在以后几年将会枯竭，NAT技术不能改变ip地址空间不足的本质。然而在安全机制上也潜在着威胁，在配置和管理上也是一个挑战。如果要从根本上解决ip地址资源的问题，ipv6才是最根本之路。在ipv4转换到ipv6的过程中，NAT技术确实是一个不错的选择，相对其他的方案优势也非常明显<br>NAT模式包括三种类型：静态NAT(网关中含有多个外网IP地址)、动态NAT(共享网关中的地址池实现网络地址转换)、网络地址端口转换NPAT(连接跟踪，使用端口转换)</p>\n<hr>\n<p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。<br><img src=\"https://camo.githubusercontent.com/30269c605eac9bc8baba56e12beb83934b9641968af6a5b24bc43a2e399f20c4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6e6574776f726b2d6f662d6e6574776f726b732e676966\"></p>\n<hr>\n<h3 id=\"ISP\"><a href=\"#ISP\" class=\"headerlink\" title=\"ISP\"></a>ISP</h3><p>互联网服务提供商（internet serve provider）：ISP是一家可以管理一些特殊的路由器的公司，这些路由器连接其他 ISP 的路由器。你的网络消息可以被 ISP 捕获并发送到相应的网络。</p>\n<p>ISP主要的功能是要将你家里的电脑与网际网路之间搭起连线的桥梁，所以其实你会发现ISP公司其实是在网际网路的专线上，而你家里的电脑则透过电话线与ISP的电脑连接，当电话拨通时，ISP会随机(Random)的给你一组IP，以便你在Internet 上熬游。</p>\n<p>您的互联网服务提供商（ISP）是您付费以访问互联网的公司。 无论是互联网接入（有线，DSL，拨号），ISP都可以为您或您的企业提供一条更大的管道到互联网。</p>\n<p>所有连接互联网的设备都通过ISP运行每个请求，以访问服务器以下载网页和文件，而这些服务器本身只能通过自己的ISP为您提供这些文件。</p>\n<p>几台计算机连接起来，互相可以看到其他人的文件，这叫局域网，整个城市的计算机都连接起来，就是城域网，把城市之间连接起来的网就叫骨干网。这些骨干网是国家批准的可以直接和国外连接的互联网。其他有接入功能的ISP（互联网服务提供商）想连到国外都得通过这些骨干网。</p>\n<p>骨干网（Backbone Network）是用来连接多个区域或地区的高速网络。每个骨干网中至少有一个和其他骨干网进行互联互通的连接点。不同的网络供应商都拥有自己的骨干网，用以连接其位于不同区域的网络。</p>\n<blockquote>\n<p>您的互联网服务提供商（ISP）是您付费以访问互联网的公司。 无论是互联网接入（有线，DSL，拨号），ISP都可以为您或您的企业提供一条更大的管道到互联网。<br>所有连接互联网的设备都通过ISP运行每个请求，以访问服务器以下载网页和文件，而这些服务器本身只能通过自己的ISP为您提供这些文件。<br>一些ISP的例子包括AT＆T，Comcast，Verizon，Cox，NetZero等等。 他们可能直接连接到家庭或企业，或通过卫星或其他技术无线发射。<br>假设您在家中使用笔记本电脑访问此页面。 您的网络浏览器首先使用设备上设置的DNS服务器将“”域名转换为与其相关的正确IP地址。<br>您要访问的IP地址然后从您的路由器发送到您的ISP，ISP将该请求转发给使用的ISP。<br>在这一点上，ISP可以发送这个https：&#x2F;&#x2F; www。 &#x2F; internet-service-provider-isp-2625924文件发回给您自己的ISP，它将数据转发到您的家庭路由器并返回到您的笔记本电脑。<br>所有这些都很快完成 - 通常在几秒钟内完成，这实际上非常了不起。<br>如何隐藏来自ISP的Internet通信<br>由于互联网服务提供商提供了所有互联网流量的路径，因此他们可以监控或记录您的互联网活动。 如果这是您的担忧，避免完成此操作的一种常用方法是使用虚拟专用网络（VPN） 。<br>基本上，VPN 通过您的设备通过您的ISP提供加密隧道到不同的 ISP，从而有效地隐藏您的直接ISP的所有流量，并允许您使用的VPN服务查看您的所有流量（他们通常不会监视器或日志）。<br>你可以在<a href=\"https://www.whatismyisp.com/\">whatismyisp</a>查看你的ISP。</p>\n</blockquote>\n<hr>\n<h3 id=\"校园组网\"><a href=\"#校园组网\" class=\"headerlink\" title=\"校园组网\"></a>校园组网</h3><p>一些公寓楼和宿舍不需要调制解调器来进行宽带连接。如果是这种情况，您可以将路由器直接插入可用的墙壁以太网端口。</p>\n<blockquote>\n<p>以下转载自<a href=\"https://www.zhihu.com/question/419283390/answer/1465715167\">xw Lee的回答</a><br>光猫是实现光电转换功能，需要光猫的前提是有光纤接入。<br>额外补充一点，光猫一般来说是没得购买，都是向三大运营商申请宽带的时候运营商提供的。当然你会在淘宝上查到各种光猫在买，其实都是通过非法途径套取运营商光猫在网上卖的；还有一点，光猫不等同于路由器，它的调测过程是需要跟运营商后台系统进行交互的，如果没有运营商的师傅上门使用专用的工具是没法调通的。<br>一般校园网络的组网模式，都是宿舍每层楼均有一个或多台汇聚交换机，每间房间均有一根或多根网线连接交换机，在房间里面就留有对应的网口面板或网线，理论上一根网线接上电脑，输入学校提供的上网账号密码即可上网，这些网口也就是以太网。<br>如果您房间只有一根网线，需要满足6人同时有线上网，网线连接一台多口交换机，交换机后再连接6根网线到6台电脑上即可。如果需要整个房间都有WIFI覆盖，买一台无线路由器即可，墙上网线接路由器，交换机接在路由器后面，即可满足有线上网又可以满足WIFI上网。当然交换机不是必须的，路由器LAN口内部就是交换机，连接网线到电脑也能用。<br>开启WIFI 5G频段，手机连接WIFI 5G频段才有好的体验。</p>\n</blockquote>\n<p>校园宽带都是在宿舍内留光纤，然后用光猫进行光电转换的。以XDU为例，大三学校在每个宿舍房间安装了一个光猫（应该是），并且这个光猫自带无线功能，从此在宿舍便能连接校园wifi了。</p>\n<blockquote>\n<p><a href=\"https://zhidao.baidu.com/question/472689094.html\">局域网为什么不用调制解调器？</a><br>传输模拟信号时，可以实现远距离传送，比如常用的电话线，几公里远是很正常的。传输数字信号时，距离就很短，比如常用的网线，连100米的实用距离都很难突破。短距离局域网中传输的都是数字信号，不是模拟信号。有些大型局域网，比如几万台终端、覆盖几平方公里的大型局域网络，也有使用调制解调器的。<br>局域网范围较大的话，它中间有用交换机中转的，无线也可以用无线AP中转的。所以它仍然不会使用模拟信号。模拟信号的特点是抗干扰性强，但它速率较慢。一般局域网中都不会用模拟信号传输，或尽量避免使用模拟信号传输。<br>大学校园很可能会覆盖几平方公里，所以在长距离网络布线中都要使用交换机中转。但交换机又有一个缺陷：它在一条线路上最多只能连续串联5个交换机。串的交换机太多了，信号就损耗严重，不能满足网络传输需要。所以，在四个或五个交换机之后，又要加一个路由器才行。有了这个路由器，它又可以再串联五个交换机了。用这种方式，网线可以拉到几千米远去。但事实上，这么长距离布线是没人使用双绞线的，除非沿途都有计算机节点。一般在大型局域网中，网络主干都会使用光纤。比如大学校园网，都是光纤到每一栋楼，连接一台光电转换器（光猫）；光电转换器连接骨干交换机，然后再用小交换机接到各个楼层。</p>\n</blockquote>\n<hr>\n<h3 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h3><blockquote>\n<p>参考自<a href=\"https://www.vpndada.com/what-is-vpn-cn/\">VPN是什么？(史上最好懂版本)</a><br><strong>VPN是什么（一句话概括）</strong>：<br>VPN是一种网络通讯方式，最早主要用于<strong>保证网络通讯的安全和私密</strong>，如今也经常用于突破网络封锁（俗称“翻墙”）</p>\n<p><strong>VPN本来是干什么用的？</strong><br>VPN这种东西被发明出来，最早并不是用来翻墙的。<br>VPN的英文全称是“Virtual Private Network”，翻译成中文是“虚拟专用网络”。要明白VPN的最初用途，就让我们来先去掉“虚拟”这两个字，来谈一谈“专用网络”。<br>假如你在一家跨国大企业工作，你每天在公司里通过互联网干活，你公司电脑里的的资料可能都是价值连城的商业秘密，如果一旦泄露，公司可能会受到巨大损失。怎么解决这个问题呢？在大公司内部，员工使用的互联网其实是“专用网络”，或者叫“专线”，这个网络和公司外面的公共网络并不直接连接（或者有严密的关卡），所以公司外面的黑客无法进入这个网络，这样，公司的数据就是安全的。<br>那么问题来了：假如公司员工到外地出差，必须用酒店的WIF远程工作，不可能用公司的专线，那怎样保证网络传输中的数据安全呢？这种情况下，公司会建议员工使用VPN。VPN虽然不是“专线网络”，却是“虚拟专线网络”，也就是说连了VPN以后，员工即使不在公司内部，上网时也可以相当于在公司内部上网。</p>\n<p><strong>VPN的工作原理</strong><br>让我们接着上面的例子来讲，对于出差的员工，公司的IT部门会在他们的电脑上装上VPN软件。这个VPN软件可以连接到一台由公司内部控制的电脑服务器上，叫“VPN服务器”（VPN Server）。出差员工连上VPN以后，他上网时就不再直接访问公共互联网，而是通过VPN服务器间接访问。<br><img src=\"https://www.vpndada.com/wp-content/uploads/2018/11/how-vpn-works-1.png\"><br>举例来说，这个人想要打开Google，如果不用VPN，他的电脑就直接去连Google的网站。而开启VPN以后，如果他想打开Google，他的电脑就不再直接连接Google网站，而是去连接VPN服务器，并给VPN服务器发一条指令——“我要访问Google”。VPN服务器接到指令后，自己去访问Google，收到Google网页的内容，再把内容回传给员工，这样使用VPN的员工最终就能看到Google网站的内容了。也就是说，使用VPN时，这个员工的所有网上访问都通过<strong>VPN服务器代理完成</strong>的。<br>此外，VPN还有一个<strong>重要特点：VPN用户和VPN服务器之间的通讯是加密的</strong>，这样就不会被黑客盗取内容。</p>\n<p>有了这些特点，我们就可以理解为什么使用VPN能保证用户的网络安全：用户所有的网络访问都不直接完成，而是通过VPN服务器作为中间人传递内容，而用户和VPN服务器之间的所有连接都是加密的，这样黑客就无法拦截破解VPN用户的网络访问内容。你只与VPN服务器通信来获取网页内容，并且你们的通讯是加密的，别人自然无法破解你的网络访问内容。</p>\n<p><strong>VPN有什么用：</strong></p>\n<ol>\n<li><strong>VPN可以提高上网的安全性</strong><br>因为使用VPN时所用的网络访问都是加密进行的，所以使用VPN上网，安全性就更高，黑客很难截取用户的重要信息。如果你使用公共WIFI上网（例如在咖啡馆上网）时，需要做安全性强的操作（比如使用网上银行或网上投资账户），那么建议你连上VPN（ExpressVPN，NordVPN），因为这样会大大提高安全性。</li>\n<li><strong>VPN可以隐藏上网者的身份</strong><br>因为VPN用户访问任何网站都是通过VPN服务器间接访问的，所以被访问的网站看到的访问者是VPN服务器，而不是VPN用户本人的电脑，这样VPN用户就能对要访问的网站隐藏自己的真正身份。</li>\n<li><strong>VPN可以突破网站的地域限制</strong><br>很多网站都有地域限制，比如视频网站Netflix在不同国家提供不同的内容，美国用户访问Netflix时看到的是美国版的内容，德国用户看到的是德国版的内容。网站的这种功能是通过查看访问者的IP地址属于哪个国家来实现的。而VPN可以用来突破这种IP限制。比如：德国的用户想要看到美国版Netflix的内容，可以先连接到一台位于美国的VPN服务器。这样Netflix网站就会以为访问者来自美国，而提供美国版的内容给VPN服务器，之后VPN服务器再将网页内容发送给用户。同理，使用日本VPN可以以日本用户的身份访问日本网站和服务，使用德国VPN可以以德国用户的身份上网。基于同样的道理，海外华人可以通过VPN翻墙回国，观看仅限国内用户观看的视频内容。另外，VPN还可以用来在网上购物时省钱，因为一些酒店和机票网站对不同国家有不同的价格，通过VPN换成不同国家的IP往往可以省钱。</li>\n<li><strong>突破网络封锁（翻墙）</strong><br>为什么VPN可以用来翻墙呢？先让我们看看网站是如何被墙的。当用户在中国大陆直接访问被封网站（比如Google）时，网络监控发现你要连接到被墙网站，直接就把你拦截了。而如果你通过VPN访问这个网站，我们前面提到，VPN用户访问任何网站都是通过VPN服务器代为访问的，用户连接的其实是VPN服务器，而不是Google，你只是告诉VPN服务器你要访问Google，然后VPN服务器去连接Google，把Google的内容回传给你。这样的话，网络监控看到的是你在连接VPN服务器，而不是在连接Google，同时因为VPN传输是加密的，网络监控也无法破解你和VPN服务器之间在传输什么信息，所以，（除非VPN服务器也在被墙网址之内，这种情况下你无法连接上VPN）网络监控就不会切断你的连接，于是你就成功翻墙了。<br><img src=\"https://www.vpndada.com/wp-content/uploads/2018/11/how-vpn-works.png\"><br>因为VPN具有翻墙功能，所以现在大家提到VPN，想到的第一件事就是翻墙软件。</li>\n</ol>\n<p><strong>有了VPN就可以翻墙了吗？</strong><br>不是。事实上大部分VPN都已经被封或者被干扰，在中国大陆根本无法使用。免费VPN大部分都已被封，从2017年开始中国政府发布条令，宣布禁止私自提供VPN服务，翻墙面临违法的危险，接着大部分国内VPN服务（如GreenVPN）都无法使用了。国外VPN服务商虽然不被中国政府控制，但也经常受到干扰，很多国际老牌知名VPN在国内也无法使用。所以，要选用翻墙VPN，必须事先知道这个VPN在中国大陆是否好用。</p>\n<p><strong>VPN有哪些替代品？</strong><br>虽然VPN目前可能是最流行的翻墙工具，但除传统VPN之外，最近几年出现了一些其它的翻墙工具，其中很多也很受欢迎，大家可以试用：</p>\n<ul>\n<li>Shadowsocks：可参考这篇<a href=\"https://www.vpndada.com/shadowsocks-tutorial-cn/\">Shadowsocks教程</a></li>\n<li>V2Ray：可参考这篇<a href=\"https://www.vpndada.com/v2ray-tutorial-cn/\">V2Ray教程</a></li>\n</ul>\n</blockquote>\n<h3 id=\"Shadowsocks\"><a href=\"#Shadowsocks\" class=\"headerlink\" title=\"Shadowsocks\"></a>Shadowsocks</h3><blockquote>\n<p>参考自<a href=\"https://www.vpndada.com/shadowsocks-tutorial-cn/\">Shadowsocks（影梭）教程</a><br>在翻墙变得越来越难、好用的VPN越来越少、翻墙有可能因违法被抓的今天，很多人开始尝试使用Shadowsocks（影梭，特别是SSR）V2Ray这样的翻墙软件来翻墙。<em>比起传统的VPN，Shadowsocks（尤其是SSR）具有一定的优势，比如不容易被网络监控系统发现和干扰，等等。</em></p>\n<p><strong>Shadowsocks简介</strong><br>Shadowsocks本质上并不是一个软件或品牌，而是<strong>一种用于翻墙的技术协议</strong>。Shadowsocks背后也并没有一家公司在支持，而是由志愿者免费开发，并开源提供给大家使用的。Shadowsocks有不同的分支，目前<strong>最流行的是SSR（ShadowsocksR）</strong>，这里主要介绍ShadowsocksR（SSR）。</p>\n<p><strong>SSR翻墙系统的组成部分：</strong></p>\n<ul>\n<li>SSR服务器（Server）：<ul>\n<li>SSR服务器搭建在位于墙外（国外）的电脑服务器（如VPS）上。</li>\n<li>可以为多个用户、多种设备提供翻墙服务。</li>\n<li>可以自己搭建，也有公司出售服务（提供用于连接的IP、密码等）。</li>\n</ul>\n</li>\n<li>SSR客户端软件（Client）:<ul>\n<li>运行在不同的设备上：如电脑、手机（苹果、安卓）等。</li>\n<li>可以免费下载。</li>\n<li>使用时连接到Shadowsocks服务器上，达到翻墙的作用。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Shadowsocks的不同版本：</strong><br>Shadowsocks目前有两个不同的版本：原始版本的Shadowsocks（SS）和 ShadowsocksR（SSR），前者是最早的Shadowsocks版本，仍然可用，但功能有限。后者在SS版本上做了一些改进，增加了一些功能，如用于反干扰的混淆协议等，在国内更好用。<br><strong>代理模式的设置:</strong></p>\n<ul>\n<li>全局模式（Global）：访问所有网站都通过Shadowsocks，如果平时大部分时间访问国外网站，选用这种模式即可。</li>\n<li>PAC模式（PAC）：通过PAC文件里的规则列表控制哪些流量走SS，哪些不走（比如国内流量不走）。注：在Windows版本的SSR客户端，这个功能已经可以被“代理规则”（Proxy Rule）设置代替（除非使用gfwlist），因此在Windows版本的SSR客户端一般不建议用这一模式。</li>\n<li>直连模式（Disable System Proxy）：基本可以理解为关掉Shadowsocks。</li>\n</ul>\n</blockquote>\n<p><strong>机场</strong>指的是我们平时翻墙所用的 Shadowsocks、V2ray、Trojan <strong>翻墙节点服务商</strong>，和VPN有所不同，机场是最适应中国国内翻墙环境的最新一代翻墙方案，</p>\n<hr>\n<h3 id=\"拨号连线\"><a href=\"#拨号连线\" class=\"headerlink\" title=\"拨号连线\"></a>拨号连线</h3><p>拨号连线，或称拨接上网，是指通过本地电话线经由调制解调器连接互联网，于1990年代网络刚兴起时比较普及，但因收费昂贵、速度慢，渐被ADSL连线取代。根据国际通信联盟（International Telecommunication Union）的统计数字，到2005年底，全球互联网用户中有56%通过宽带上网。<br>拨号上网时，电话公司和互联网服务提供商通常都会分别收费。</p>\n<p>当时技术不允许电话线上有不同的载波信号，拨号上网依赖于音频通信。</p>\n<p>调制解调器将从计算机中获取数字数据，将其调制成音频信号，并将其发送到接收调制解调器，这种方式和与某人打电话相似。</p>\n<p>接收调制解调器将模拟噪声信号解调成数字数据，供计算机处理。而且在通话结束之前，用户无法通过电话线与他人打电话。使用该技术的互联网速度可降至21.6 kbit&#x2F;s或更低。原因是线路状况差、噪声水平高等因素。因此，它通常被称为21600综合征。</p>\n<h2 id=\"ADSL\"><a href=\"#ADSL\" class=\"headerlink\" title=\"ADSL\"></a>ADSL</h2><p>非对称数字用户线路（英语：Asymmetric Digital Subscriber Line）又称非对称数字用户环路（Asymmetric Digital Subscriber Loop），简称ADSL。</p>\n<p>ADSL是一个依靠铜质电话线的数据传输技术比传统的调制器更快。ADSL因为上行（从用户到电信服务提供商方向，如上传动作）和下行（从电信服务提供商到用户的方向，如下载动作）带宽不对称（即上行和下行的速率不相同）因此称为非对称数字用户线路。它采用频分多路复用技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰。通常ADSL在不影响正常电话通信的情况下可以提供最高3.5Mbps的上行速度和最高24Mbps的下行速度。</p>\n<p>ADSL是一种<strong>异步传输模式（ATM）</strong>。</p>\n<p>在电信服务提供商端，需要将每条开通ADSL业务的电话线路连接在数字用户线路访问多路复用器（DSLAM）上。而在用户端，用户需要使用一个ADSL终端（和传统的调制解调器（Modem）类似）来连接电话线路。由于ADSL使用高频信号，所以在两端还都要使用ADSL信号分离器（splitter）将ADSL数据信号和普通音频电话信号分离出来，避免打电话的时候出现噪音干扰。</p>\n<p>通常的ADSL终端有一个电话Line-In，一个以太网口，有些终端集成了ADSL信号分离器，还提供一个连接的Phone接口。</p>\n<p>由于受到传输高频信号的限制，ADSL需要电信服务提供商端接入设备和用户终端之间的距离不能超过5公里，也就是用户的电话线连到电话局的距离不能超过5公里。</p>\n<p>ADSL通常提供三种网络登录方式：</p>\n<ul>\n<li>桥接，直接提供静态IP</li>\n<li>PPPoA，基于ATM的端对端协议</li>\n<li>PPPoE，基于以太网的端对端协议<br>后两种通常不提供静态IP，而是动态的给用户分配网络地址。</li>\n</ul>\n<h3 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h3><p>桥接器（英语：network bridge），又称网桥，一种网络设备，负责网络桥接（network bridging）。桥接器将网络的多个网段在数据链路层（OSI模型第2层）连接起来（即桥接）。</p>\n<p>桥接器有别于路由器。路由器允许多网络之间的独立通信，但又保持区隔，而桥接器则是将两个独立的网络连接起来，就如同单一网络。如果所桥接的网络有一个以上的区段是无线网络，则该设备称为无线桥接器。<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e8/Network_Bridging.png\"></p>\n<h3 id=\"PPPoA\"><a href=\"#PPPoA\" class=\"headerlink\" title=\"PPPoA\"></a>PPPoA</h3><p>PPPoA是异步传输模式上的点对点协议（Point-to-Point Protocol over Asynchronous Transfer Mode）的简称，是OSI模型中数据链接层的协议，常用来透过电话线链接家用的宽带Modem和网络服务供应商（ISP）。</p>\n<h3 id=\"PPPoE\"><a href=\"#PPPoE\" class=\"headerlink\" title=\"PPPoE\"></a>PPPoE</h3><p>PPPoE（英语：Point-to-Point Protocol over Ethernet），以太网上的点对点协议，是将点对点协议（PPP）封装在以太网（Ethernet）框架中的<strong>一种网络隧道协议</strong>。由于协议中集成PPP协议，所以实现出传统以太网不能提供的身份验证、加密以及压缩等功能，也可用于缆线调制解调器（cable modem）和数字用户线路（DSL）等以以太网协议向用户提供接入服务的协议体系。本质上，它是一个允许在以太网广播域中的两个以太网接口间创建点对点隧道的协议。</p>\n<h3 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h3><p>以太网（英语：Ethernet）是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问控制的内容。以太网是目前应用最普遍的局域网技术，取代了其他局域网标准如令牌环、FDDI和ARCNET。</p>\n<p>以太网的标准拓扑结构为总线型拓扑，但目前的快速以太网（100BASE-T、1000BASE-T标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机（Switch hub）来进行网络连接和组织。如此一来，以太网的拓扑结构就成了星型；但在逻辑上，以太网仍然使用总线型拓扑和CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection，即载波多重访问&#x2F;碰撞侦测）的总线技术。</p>\n<p>以太网实现了网络上无线电系统多个节点发送信息的想法，每个节点必须获取电缆或者信道才能传送信息，有时也叫作以太（Ether）。这个名字来源于19世纪的物理学家假设的电磁辐射媒体——光以太。每一个节点有全球唯一的48位地址也就是制造商分配给网卡的MAC地址，以保证以太网上所有节点能互相鉴别。由于以太网十分普遍，许多制造商把以太网卡直接集成进计算机主板。</p>\n<h3 id=\"宽带\"><a href=\"#宽带\" class=\"headerlink\" title=\"宽带\"></a>宽带</h3><p>宽带（英语：Broadband）在基本电子和电子通信上，是描述电子线路能够同时处理较宽的频率范围。宽带是一种相对的描述方式，频带的范围愈大，也就是带宽愈高时，能够发送的资料也相对增加。譬如说在无线电通信上，频率范围比较窄的带宽只能发送摩尔斯电码，发送高质量的音乐就需要较大的带宽。电视天线的宽带代表能够接收数量较多的信道。在资料发送方面，同样是以电话线作为信号传递的介质，目前光纤电缆则愈来愈普及，拨号上网最快速度仅为54Kbps，<strong>宽带的ADSL和光纤</strong>能够提供更高的发送速率。</p>\n<ul>\n<li>OECD于2006年报告称，任何传输速率在256Kbps以上的互联网连接，可称为宽带。</li>\n<li>FCC于2015年发布解释，下载速率25Mbps以上，上传速率3Mbps以上的互联网，可称为宽带。<br>在这里宽带是一个形容词。</li>\n</ul>\n<p><strong>宽带因特网连接</strong>，简称“宽带”，是相对于通过拨号访问的56千比特率速度而言的高速率因特网访问。一般低速率宽带范围是64千比特率到2兆比特率。</p>\n<p>目前使用最多的宽带技术为光纤和ADSL。</p>\n<ul>\n<li>光纤</li>\n<li>ADSL</li>\n<li>专线</li>\n<li>卫星网络</li>\n</ul>\n<h3 id=\"电话线\"><a href=\"#电话线\" class=\"headerlink\" title=\"电话线\"></a>电话线</h3><p>电话线或电话线路是一个单用户电话通信电路系统。电话线是一种物理线路或者说是一种将用户电话设备连接到电信网路的媒介，并且通常每个用户有一个电话号码来进行计费。电话线路是用来提供固定电话服务和数字用户线(DSL)互联网服务的前提。电话线接入到公共交换电话网络中。</p>\n<h3 id=\"DSL\"><a href=\"#DSL\" class=\"headerlink\" title=\"DSL\"></a>DSL</h3><p>数字用户线路（Digital Subscriber Line，缩写：DSL）是通过铜线或者本地电话网提供数字连接的一种技术。它的历史要追溯到1988年，贝尔实验室一位工程师设计了一种方法可以让数字信号加载到电话线路未使用频段，这就实现了不影响话音服务的前提下在普通电话线上提供数据通信。但是贝尔的管理层对这个并不热心，因为如果用户安装两条线路会带来更多的利润。这一状况直到1990年代晚期有线电视公司开始推销宽带互联网访问时才得到改善。当意识到大多数用户绝对会放弃安装两条电话线访问互联网，贝尔公司才搬出他们已经讨论了10年的DSL技术，来争夺有线电视网络公司的宽带市场份额。</p>\n<p>电话系统设计之初，主要用来传送话音调用，出于经济的考虑，电话系统设计传送频率范围在300Hz到3.4kHz范围的信号（尽管人的话音可以到15kHz，但是这个范围内还是很容易辨别对方的）</p>\n<p>然而本地电话网到最终用户的铜缆实际上可以提供更高的带宽，至少从最低频率到200-800kHz不等，这取决于电路质量和设备的复杂度（一般认为到最终用户分线器之间接头越少越有利于提高带宽，线路传输路过的环境，电子干扰越小越有益于提高线路带宽）。</p>\n<p>DSL服务通过利用电话线的附加频段成功克服了在话音频带上传送大量数据的难题（参看香农定理）。</p>\n<p>DSL服务通常保留0.3-4kHz这个范围的频段给话音服务，也就是所谓的<strong>普通老式电话服务（POTS）</strong>使用的频段，使用这个范围以外的频率传送数据。</p>\n<p>DSL连接在用户设备DSL调制解调器和电话交换机之间创建，然后交换机通过一些其他的协议与用户真正要连接的（典型的）ISP创建连接。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/Comparison_of_DSL_and_dial-up_connections.svg/1920px-Comparison_of_DSL_and_dial-up_connections.svg.png\"></p>\n<p>用户终端设备是DSL调制解调器。</p>\n<p>很多DSL技术在低水平比特流的ATM层实现，以保证不同的技术能够在相同的链路上实现。</p>\n<p>DSL设备通常可以作为桥接器或路由器。在桥接器模式，一组用户的计算机可以方便的连接到一个子网。早期的设备使用DHCP服务来分配提供一些配置细节例如网卡的IP地址，基于MAC地址的认证或者分配主机名。 后来的的设备一般使用<strong>PPPoE（以太网上的PPP）或者PPPoA（ATM网上的点到点协议）</strong>，验证的时候使用用户名和密码，然后使用PPP原理去分配网络配置（IP地址，子网掩码，网关（默认网关），DNS等）。</p>\n<p>可达范围（从电话交换中心到用户的线路长度）与数据速率成反比，例如VDSL（超高速数字用户线）这样的技术只能提供短距离链路。</p>\n","categories":["Network"],"tags":["NAT"]},{"title":"cmd","url":"/2022/09/20/cmdNote/","content":"<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>环境变量是操作系统用来指定运行环境的一些参数。当你运行某些程序时，除了在当前文件夹中寻找外，还会到这些环境变量中去查找，比如“path”就是一个变量，里面存储了一些常用的命令所存放的目录路径。</p>\n<span id=\"more\"></span>\n<p>当启动cmd命令行窗口调用某一命令的时候，经常会出现“xxx不是内部或外部命令，也不是可运行的程序或批处理文件”，如果你的拼写没有错误，同时计算机中确实存在这个程序，那么出现这个提示就是你的path变量没有设置正确，因为你的path路径，也就是默认路径里没有你的程序，同时你又没有给出你程序的绝对路径（因为你只是输入了命令或程序的名称而已），这时操作系统不知道去哪儿找你的程序，就会提示这个问题。<br>比如：当你在path中添加<code>C:\\Program Files (x86)\\Notepad++</code>时，在cmd或powershell终端输入**notepad++**，便会运行该路径下的notepad++.exe程序。</p>\n<p><strong>我做了这样一件事，使我可以在终端输入自定义的命令打开指定的程序。</strong> 首先，我创建了一个文件夹，就我而言：<em>D:\\CmdFiles</em>，并且我将该文件夹的路径添加到path环境变量中，Windows 现在会在文件夹<em>D:\\CmdFiles</em>中查找命令，您可以轻松地向该文件夹添加新命令或批处理文件！之后，在此文件夹中，我建立了批处理(.bat)文件，（举个栗子）文件np.bat里面有这样的命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@echo off</span></span><br><span class=\"line\">start <span class=\"string\">&quot;&quot;</span> <span class=\"string\">&quot;C:\\Program Files (x86)\\Notepad++\\notepad++.exe&quot;</span> %*</span><br></pre></td></tr></table></figure>\n<p>代码注释 [^代码注释]<br>[^代码注释]:  &gt; @echo off阻止命令打印到命令提示符，引号之间的链接可以引用任何可执行文件；**%*** 将确保您在np命令之后键入的任何内容 （例如<code>test.txt</code> ）都将放在引号中的原始命令之后。<code>np test.txt</code>将用notepad++打开test.txt。</p>\n<p>也可以创建clash.cmd文件，文件内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@echo off</span></span><br><span class=\"line\"><span class=\"string\">&quot;H:\\ClashforWindows\\Clash.for.Windows-0.15.2-win\\Clash for Windows.exe&quot;</span> %*</span><br></pre></td></tr></table></figure>\n<p>在终端输入clash便可以运行Clash for Windows.exe。<br>在powershell和cmd中运行结果不同。</p>\n<h2 id=\"cmd命令\"><a href=\"#cmd命令\" class=\"headerlink\" title=\"cmd命令\"></a>cmd命令</h2><blockquote>\n<ol>\n<li>查看某个环境变量：输入 “set 变量名”即可，比如想查看path环境变量的值，即输入 set path</li>\n<li>修改环境变量 ：输入 “set 变量名&#x3D;变量内容”即可，比如set path&#x3D;”c”，查看path路径的时候，其值为”c:&quot;，即覆盖以前的内容</li>\n<li>给变量追加内容：输入“set 变量名&#x3D;%变量名%;变量内容”。如，为path添加一个新的路径，输入<code>set PATH=%PATH%;C:\\Program Files (x86)\\Notepad++</code>即可将<code>C:\\Program Files (x86)\\Notepad++</code>添加到path中<br><strong>注意所有的在cmd命令行下对环境变量的修改只对当前窗口有效，不是永久性的修改。也就是说当关闭此cmd命令行窗口后，将不再起作用。</strong><br>在高级系统设置中的环境变量里添加了新路径之后，若你之前打开的应用程序没关掉重启（在你没重启电脑的情况下），那你这个应用程序也可能读取不到该系统变量，所以你关掉重启该应用就好了。如果还是不行，打开cmd，输入命令 <code>set PATH=c</code>，这个命令是使你写在path中的变量立即生效，然后重启cmd验证</li>\n</ol>\n</blockquote>\n<p>有几个关于右键打开cmd 终端的网页，以后再看吧。<br>首先<code>cmd.exe /s /k pushd &quot;%V&quot;</code>这是你右键打开cmd的命令。<br><a href=\"https://zhidao.baidu.com/question/549082128.html\">cmd.exe &#x2F;s &#x2F;k pushd “%V”是什么意思</a><br><a href=\"https://zhidao.baidu.com/question/441785422.html\">%Userprofile%\\ 这个文件在哪里</a><br><a href=\"http://www.bathome.net/thread-26433-1-1.html\">右键打开CMD&#x2F;命令提示符&#x2F;命令窗口</a></p>\n","categories":["Shell"],"tags":["Cmd"]},{"title":"Windows-Terminal美化","url":"/2022/10/09/Windows-Terminal%E7%BE%8E%E5%8C%96/","content":"<p><strong>颜值就是生产力</strong></p>\n<span id=\"more\"></span>\n<h2 id=\"美化PowerShell\"><a href=\"#美化PowerShell\" class=\"headerlink\" title=\"美化PowerShell\"></a>美化PowerShell</h2><ol>\n<li><p>升级 Windows Terminal<br> 到 <a href=\"https://github.com/microsoft/terminal/releases\">Microsoft&#x2F;Terminal</a> 找最新的的版本下载，双击安装。</p>\n<blockquote>\n</blockquote>\n</li>\n<li><p>安装powershell最新版<br> 到 <a href=\"https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2\">Microsoft&#x2F;Powershell</a>寻找下载方法，我用的是：<code>winget</code></p>\n</li>\n<li><p>安装 Oh My Posh<br>最好以管理员身份运行powershell。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">winget install JanDeDobbeleer.OhMyPosh -s winget</span><br></pre></td></tr></table></figure>\n<p>这个下载内容包括两个东西:</p>\n<ul>\n<li>oh-my-posh.exe-Windows executable<br>这个是基于Windows系统的oh-my-posh的可执行文件, 但是点击运行没有用, 必须要在Powershell中执行。在Powershell输入oh-my-posh可以运行程序，如果报错，查看path环境变量是否包含</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://i.postimg.cc/15QHCpYd/1.jpg\"></p>\n<p>如果包含的话，说明该环境变量在当前程序不起作用，重启终端即可。<br>    查看oh-my-posh版本<br>        <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">oh-my-posh version</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>theme<br>   oh-my-posh的主题。<br>   查看环境变量是否包含：</li>\n</ul>\n<pre><code>[官方文档](https://ohmyposh.dev/docs/installation/windows)给出了oh-my-posh的更新命令, 如果是刚刚下载的那么就不需要更新了。\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">winget upgrade JanDeDobbeleer.OhMyPosh -s winget</span><br></pre></td></tr></table></figure>\n</code></pre>\n<ol>\n<li>配置主题<br> 在对powershell进行个性化配置oh-my-posh的时候，powershell需要运行配置脚本文件$PROFILE，由于win11默认防止执行不信任的脚本文件，导致配置过程无法正常进行。<br> 参考<a href=\"https://blog.csdn.net/ahahayaa/article/details/125470163\">博客</a><br> 执行命令:<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">set-ExecutionPolicy RemoteSigned </span><br></pre></td></tr></table></figure></li>\n<li>使用以下这行命令进行主题的初始化, 其中jandedobbeleer是主题的名字<br> <code>oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot;</code><br>1. 主题的更换要依托于一个PROFILE脚本文件来进行<br>基于PROFILE脚本文件涉及到 创建、打开、填充配置语句、执行脚本文件 四条命令<br>- 创建PROFILE文件<br>  <code>New-Item -Path $PROFILE -Type File -Force</code><br>- 打开PROFILE文件<br>  <code>notepad $PROFILE</code><br>- 在PROFILE文件中添加以下内容<br>  <code>oh-my-posh init pwsh | Invoke-Expression</code><br>- 执行PROFILE脚本文件, 通过以下这条命令<br>  <code>. $PROFILE</code> &#x2F;&#x2F;执行脚本文件命令<br> 更换主题，修改<code>$profile</code>文件对应主题名即可。</li>\n</ol>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">oh-my-posh init pwsh --config ~\\AppData\\Local\\Programs\\oh-my-posh\\themes\\atomic.omp.json | Invoke-Expression</span><br></pre></td></tr></table></figure>\n\n<p><strong>建议</strong>按照这个流程来，之前我在装了win11的新电脑配置oh-my-posh的时候，与3、4两步配置流程上有点差异(但是同样的配置方法在我win10的电脑上是有效的)，导致配置完成非常怪，显示的主题无法更改且并非默认主题，并且pwsh启动时间长达5s，之后按照3、4流程走一遍还是达到了预期效果。</p>\n<ol start=\"5\">\n<li>修改字体<br> Oh My Posh 的部分主题需要相应的字体支持，否则会出现乱码。<br> 安装<code>Nerd Font</code>系列字体。<a href=\"https://www.nerdfonts.com/font-downloads\">字体下载地址</a><br> 我安装的是<code>Caskaydia Cove Nerd Font</code>。<br> 在shell的配置中选择字体：<br> <img src=\"https://i.postimg.cc/sX7BgQCv/1.jpg\"><br> <strong>顺便说一下</strong>，这里的配色方案就是Windows Terminal配置文件中的scheme，也是可以自己配置的。</li>\n</ol>\n<p> <strong>安装插件可以参考</strong><a href=\"https://www.kwchang0831.dev/dev-env/pwsh/oh-my-posh\">安裝新版 Oh My Posh 與插件</a></p>\n<ol start=\"6\">\n<li><p>安裝 Scoop<br> Scoop 就像Mac 的 Homebrew 一样让可以我们更快速地用指令行安装软件。<br> pwsh 输入</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br><span class=\"line\">Invoke-WebRequest get.scoop.sh | Invoke-Expression</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装插件posh-git<br>   &#x2F;&#x2F; 注： 如果不用scope安装，用常规方法可能很难装，这时候可以用管理员模式打开pwsh执行命令<br> posh-git 让 Git 的指令可以用 Tab 补全。<br> pwsh 输入</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">scoop bucket add extras</span><br><span class=\"line\">scoop install posh-git</span><br><span class=\"line\">Add-PoshGitToProfile</span><br></pre></td></tr></table></figure>\n<p> 在 <code>$Profile</code> 档案最后一行新增以下指令：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Import-Module posh-git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装插件ZLocation<br> ZLocation 类似于 autojump 或是 Zsh-z 的插件，<br>可以用关键字直接跳到想去的资料夹，比使用 <code>cd</code> 更快速。<br> 用PowerShell 输入以下指令：</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Install-Module ZLocation -Scope CurrentUser</span><br></pre></td></tr></table></figure>\n<p>  输入[A] Yes to All ，全部同意。<br>  在 $Profile 档案最后一行新增以下指令，</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Import-Module ZLocation</span><br></pre></td></tr></table></figure>\n<p> ZLocation 使用方式:</p>\n<ul>\n<li>查看已知的文件夹位置，指令：<code>z</code></li>\n<li>进入包含字符串<code>string</code>的文件夹（不是文件夹路径包含字符串），可以用 Tab 来选择结果，指令：<code>z string</code></li>\n<li>回到之前的文件夹，指令：<code>z -</code></li>\n</ul>\n</li>\n<li><p>(选用) 安装NeoFetch<br> NeoFetch 用来显示电脑配置。</p>\n</li>\n</ol>\n<p>如果过去用<code>Install-Module</code> 的方式安装<code>Oh My Posh</code>，即使用<code>Install-Module oh-my-posh -Scope CurrentUser</code>，需要删除旧版本，用命令<code>Uninstall-Module oh-my-posh -AllVersions</code>，并且删除<code>$Profile</code>里的 <code>Import-Module oh-my-posh</code>，按前面的方法重新安装。</p>\n<p> <strong>注意：</strong> 在<code>$Profile</code>中添加的内容越多，对应的shell启动时间越慢</p>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><p> 查看shell的配置文件的文件地址 </p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$</span><span class=\"language-bash\">profile</span></span><br></pre></td></tr></table></figure>\n\n<p> 在pwsh输入命令可以直接用vsc打开配置文件</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">code $profile</span><br></pre></td></tr></table></figure>\n\n<p> Windows PowerShell <code>$profile</code> 地址<br> <code>~\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1</code><br> <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">oh-my-posh --init --shell pwsh --config ~\\AppData\\Local\\Programs\\oh-my-posh\\themes\\craver.omp.json | Invoke-Expression</span><br></pre></td></tr></table></figure></p>\n<p> PowerShell 7 <code>$profile</code> 地 <code>~\\PowerShell\\Microsoft.PowerShell_profile.ps1</code><br> <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">oh-my-posh --init --shell pwsh --config ~\\AppData\\Local\\Programs\\oh-my-posh\\themes\\jandedobbeleer.omp.json | Invoke-Expression</span><br></pre></td></tr></table></figure></p>\n<p> 让<code>$profile</code>配置立即生效</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">. $profile</span><br></pre></td></tr></table></figure>\n\n<p> 下载的 Oh My Posh 主题在文件夹<code>~\\AppData\\Local\\Programs\\oh-my-posh\\themes</code>，里面有包括<code>craver.omp.json 、jandedobbeleer.omp.json</code>在内的许多<code>.omp.json</code>文件，修改<code>$profile</code>对应位置即可修改主题。<br> 预览主题在 <a href=\"https://ohmyposh.dev/docs/themes\">Oh my posh 官网</a><br> 也可以输入命令查看</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Get-PoshThemes</span><br></pre></td></tr></table></figure>\n\n<p><strong>profile.ps1 格式</strong></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Import-Module ZLocation</span><br><span class=\"line\">Import-Module posh-git</span><br><span class=\"line\">oh-my-posh init pwsh --config $env:POSH_THEMES_PATH\\if_tea.omp.json | Invoke-Expression</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">推荐几个theme</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">if_tea</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">jandedobbeleer</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">jv_sitecorian</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"> quick-term</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">atomic</span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"我的-windows-terminal-配置文件\"><a href=\"#我的-windows-terminal-配置文件\" class=\"headerlink\" title=\"我的 windows terminal 配置文件\"></a>我的 windows terminal 配置文件</h3><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;$help&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://aka.ms/terminal-documentation&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;$schema&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://aka.ms/terminal-profiles-schema&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;actions&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">    <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;paste&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;keys&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ctrl+v&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;action&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;copy&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;singleLine&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;keys&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ctrl+c&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;find&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;keys&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ctrl+shift+f&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;action&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;splitPane&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;split&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;auto&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;splitMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;duplicate&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;keys&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;alt+shift+d&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;copyFormatting&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;copyOnSelect&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;defaultProfile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;profiles&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;defaults&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;startingDirectory&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">null</span></span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;list&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">        <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImage&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Users\\\\ASUS\\\\Pictures\\\\PowershellBG\\\\kalen.jpg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImageOpacity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0.7</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;colorScheme&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cyberpunk&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;font&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">                <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;face&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Cascadia Code&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;guid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;hidden&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Windows PowerShell&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;guid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;hidden&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cmd&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;guid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;hidden&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Azure Cloud Shell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;source&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Windows.Terminal.Azure&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImage&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Users\\\\ASUS\\\\Pictures\\\\PowershellBG\\\\kalen.jpg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImageOpacity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0.7</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;font&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">                <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;face&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;DejaVu Sans Mono for Powerline&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;guid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;2c4de342-38b7-51cf-b940-2309a097f518&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;hidden&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Ubuntu&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;source&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Windows.Terminal.Wsl&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImage&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Users\\\\ASUS\\\\Pictures\\\\PowershellBG\\\\kalen.jpg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImageOpacity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0.7</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;colorScheme&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cyberpunk&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;commandline&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Git\\\\Git\\\\bin\\\\bash.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;guid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;11606d4b-0660-5aa9-861e-dfce500b7054&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;icon&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Git\\\\Git\\\\mingw64\\\\share\\\\git\\\\git-for-windows.ico&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Git Bash&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImage&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Users\\\\ASUS\\\\Pictures\\\\PowershellBG\\\\benjamin.jpg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;backgroundImageOpacity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0.8</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;colorScheme&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cyberpunk&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;font&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">                <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;face&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;CaskaydiaCove Nerd Font&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;guid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;hidden&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;PowerShell 7&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;source&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Windows.Terminal.PowershellCore&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;startingDirectory&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">null</span></span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;schemes&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">    <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0C0C0C&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0C0C0C&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0037DA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#767676&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#3B78FF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#61D6D6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#16C60C&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#B4009E&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E74856&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#F2F2F2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#F9F1A5&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#3A96DD&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CCCCCC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#13A10E&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Campbell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#881798&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C50F1F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CCCCCC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C19C00&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#012456&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0C0C0C&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0037DA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#767676&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#3B78FF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#61D6D6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#16C60C&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#B4009E&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E74856&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#F2F2F2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#F9F1A5&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#3A96DD&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CCCCCC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#13A10E&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Campbell Powershell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#881798&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C50F1F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CCCCCC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C19C00&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#1F1F1F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#3A3D43&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#4F76A1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#368BFA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#428FFA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#2E706D&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0F722F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FB0067&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EB001F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FDFFB9&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EEF107&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#578FA4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#B9BCBA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#879A3B&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;DimmedMonokai&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#855C8D&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#BE3F48&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#B9BCBA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C5A635&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#282C34&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#282C34&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#61AFEF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#5A6374&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#61AFEF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#56B6C2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#98C379&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C678DD&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E06C75&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#DCDFE4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E5C07B&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#56B6C2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#DCDFE4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#98C379&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;One Half Dark&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C678DD&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E06C75&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#DCDFE4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E5C07B&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FAFAFA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#383A42&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0184BC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#4F525D&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#61AFEF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#56B5C1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#98C379&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C577DD&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#DF6C75&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E4C07A&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#4F525D&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0997B3&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#383A42&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#50A14F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;One Half Light&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#A626A4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E45649&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FAFAFA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C18301&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#002B36&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#002B36&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#268BD2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#073642&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#839496&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#93A1A1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#586E75&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#6C71C4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CB4B16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FDF6E3&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#657B83&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#2AA198&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#839496&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#859900&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Solarized Dark&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#D33682&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#DC322F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EEE8D5&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#B58900&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FDF6E3&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#002B36&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#268BD2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#073642&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#839496&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#93A1A1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#586E75&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#6C71C4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CB4B16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FDF6E3&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#657B83&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#002B36&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#2AA198&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#657B83&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#859900&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Solarized Light&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#D33682&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#DC322F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EEE8D5&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#B58900&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#3465A4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#555753&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#729FCF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#34E2E2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#8AE234&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#AD7FA8&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EF2929&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EEEEEC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FCE94F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#06989A&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#D3D7CF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#4E9A06&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Tango Dark&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#75507B&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CC0000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#D3D7CF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C4A000&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#3465A4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#555753&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#729FCF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#34E2E2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#8AE234&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#AD7FA8&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EF2929&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#EEEEEC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FCE94F&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#06989A&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#555753&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#4E9A06&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Tango Light&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#75507B&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#CC0000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#D3D7CF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C4A000&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000080&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#808080&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#0000FF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#00FFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#00FF00&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FF00FF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FF0000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFF00&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#008080&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C0C0C0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#008000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Vintage&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#800080&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#800000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#C0C0C0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#808000&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#332A57&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;black&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#000000&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;blue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#00BFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlack&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#647DA1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightBlue&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#1BCCFD&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightCyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#99D6FC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightGreen&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#21F6BC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightPurple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E6AEFE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightRed&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FF8AA4&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightWhite&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;brightYellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFF787&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cursorColor&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cyan&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#86CBFE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;foreground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#E5E5E5&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;green&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#00FBAC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cyberpunk&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;purple&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#DF95FF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;red&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FF7092&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;selectionBackground&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;white&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;yellow&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFA6A&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;themes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"powershell-常用命令\"><a href=\"#powershell-常用命令\" class=\"headerlink\" title=\"powershell 常用命令\"></a>powershell 常用命令</h2><blockquote>\n<p>获取当前窗口命令历史记录。  </p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Get-History</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>显示上一个、下一个命令。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">UpArrow DownArrow 方向键</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>查找<br><code>ctrl+shift+F</code></p>\n<blockquote>\n<p>查看powershell版本</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$</span><span class=\"language-bash\">PSVersionTable</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://sspai.com/post/69911\">Oh My Posh：全平台终端提示符个性化工具</a><br><a href=\"https://www.kwchang0831.dev/dev-env/pwsh/oh-my-posh\">安裝新版 Oh My Posh 與插件</a><br><a href=\"https://chaisw.cn/blog/1912.html\">有讲到Tabby</a><br><a href=\"https://blog.csdn.net/ahahayaa/article/details/125470204\">3，4步骤来源</a></p>\n","categories":["Shell"],"tags":["Powershell"]},{"title":"LeetCodeNote","url":"/2024/03/05/LeetCodeNote/","content":"<p><em><strong>立志欲坚不欲锐，成功在久不在速</strong></em></p>\n<span id=\"more\"></span>\n\n<h1 id=\"leetcode\"><a href=\"#leetcode\" class=\"headerlink\" title=\"leetcode\"></a>leetcode</h1><p>原地算法基本就是：双指针加反转。</p>\n<h2 id=\"必会知识点\"><a href=\"#必会知识点\" class=\"headerlink\" title=\"必会知识点\"></a>必会知识点</h2><p>原来如此，既然<strong>ArrayDeque</strong>是双端队列，那我如果只对一端进行操作那不就变成了栈了，管它是队列头还是队列尾，也就是说如果想当成栈操作，则各个操作要在同一端<br>比如 peek、pop、push、poll都在队列头部操作   getLast、removeLast、offer&#x2F;add都在队列尾部操作   所以这两种方式都可以模拟成栈</p>\n<p>PriorityQueue&lt;int[]&gt; queue &#x3D; new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[0]-o2[0]); &#x2F;&#x2F; 这样的话就是小根堆</p>\n<p><code>int[][] prerequisites， Arrays.sort(prerequisites, (o1, o2) -&gt; o1[0]-o2[0]); </code><br>通过调用 Arrays.sort(prerequisites, (o1, o2) -&gt; o1[0] - o2[0]);，你正在对二维数组 prerequisites 进行排序。具体来说，它会按照每个子数组（即 prerequisites 中的每一个一维数组）的第一个元素（o1[0] 和 o2[0]）进行升序排序</p>\n<p><strong>PriorityQueue 默认是最小堆，Comparator (a, b) -&gt; a - b 也会导致元素以升序排列</strong>。</p>\n<p><a href=\"https://www.cnblogs.com/crazymakercircle/p/16320430.html\">红黑树好文</a><br>左旋：选择一个pivot节点，其父节点（root）左旋为自己的左子树，然后自己的原左子树变为原root节点的右子树，其他不变。（能这样旋转说明pivot原先是root的右子树，也就是右边高度太大了）<br>右旋：选择一个pivot节点，其父节点（root）右旋为自己的右子树，然后自己的原右子树变为原root节点的左子树，其他不变。（能这样旋转说明pivot原先是root的左子树，也就是左边高度太大了）</p>\n<p>在 Java 中，所有的整数都是以二进制「补码」的形式存储的（PS：正数补码是本身，负数补码是对应正数带上符号位一块取反，然后加一）<br>比如-2^31是1000….000，实际上就是最高位（第32位的1，也即符号位1）本身就是代表-2^31，所以后面我们想要哪些负数，就在这个基础上加”正数”就好了，比如我加一个2^31-1即0111…111，那就得到了-1即1111…111。</p>\n<p>在 Java 中，&gt;&gt; 是「带符号右移」操作符，它会将所有位向右移动指定的位数，「左边」空出的位「用原来的符号位」填充。这里注意：假如一个负数右移十位，实际上是在左边补了10个1。</p>\n<img src=\"/2024/03/05/LeetCodeNote/8.png\" class=\"\">\n<p><a href=\"https://juejin.cn/post/6844904025880526861\">想研究可以在看看这篇</a></p>\n<p>在 Java 中，&gt;&gt;&gt; 是无符号右移操作符，它会将所有位向右移动指定的位数，左边空出的位用 0 填充，不论原来的数是正数还是负数。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p><strong>二维数组</strong>用的时候不能直接push_back()一个元素，要往某一维上push一个元素先要往这个二维数组里push一个一维数组，like this:<br><code>ret.push_back(vector &lt;int&gt; ());</code><br>或者先建立一维数组来存放值，再push进二维数组。<br>或者动态resize二维数组的大小。</p>\n<h3 id=\"n数之和\"><a href=\"#n数之和\" class=\"headerlink\" title=\"n数之和\"></a>n数之和</h3><p>经典题，用哈希表会非常难写，虽然也可以做到O(n^2)的时间复杂度，但是很难去重。</p>\n<p>这题比较好的解法是排序加双指针，<strong>排序后的双指针非常好用</strong>。</p>\n<h3 id=\"912-排序数组\"><a href=\"#912-排序数组\" class=\"headerlink\" title=\"912 排序数组\"></a>912 排序数组</h3><p>经典排序题</p>\n<p><a href=\"https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/\">复习基础排序算法</a><br>这篇题解写的非常好，将排序算法讲的很通透。</p>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>来一波二分查找的总结吧。</p>\n<p>二分查找有两种题（目前做到的）<br>第一种：你的目标一定存在，你一定能找到唯一一个数符合你的目标，比如<a href=\"https://leetcode.cn/problems/guess-number-higher-or-lower/description/\">374. 猜数字大小</a> 这种题随便写，可以用我后面重点说的通用解法，也可以用在循环里分(&lt;、&gt;、 &#x3D;&#x3D;)三种情况，都很好写。<br>第二种题：你的目标不一定存在，你可能要找你的理论目标最近的一个数，可能是 小于等于target的最大数 或 大于等于target的最小数。比如<a href=\"https://leetcode.cn/problems/search-insert-position/solutions/333632/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/\">35. 搜索插入位置</a>、<a href=\"https://leetcode.cn/problems/first-bad-version/\">278. 第一个错误的版本</a>、<a href=\"https://leetcode.cn/problems/sqrtx/description/\"> 69. x 的平方根</a>、（注：这种平方题可以用二分迭代法做）<a href=\"https://leetcode.cn/problems/valid-perfect-square/description/\">367. 有效的完全平方数</a> 等都是要找离目标最近的数，并且大多数不止要让你返回 true or false，还要你返回索引。</p>\n<p>接下来重点介绍通用二分模板：<br>以<a href=\"https://leetcode.cn/problems/valid-perfect-square/description/\">367. 有效的完全平方数</a> 为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">low</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, high = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>, mid = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(low&lt;high) &#123;</span><br><span class=\"line\">    mid = (high-low)/<span class=\"number\">2</span>+low;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid*mid&gt;=num) high = mid;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid*mid&lt;num) low = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> high*high==num;</span><br></pre></td></tr></table></figure>\n\n<p>首先，用 <code>mid=(low+high)/2</code> 可以，但是用 <code>(high-low)/2+low</code> 更好（这俩是一模一样的），因为 <code>(low+high)</code> 可能超出 int 的范围。</p>\n<p>其次，用 <code> while(low&lt;high)</code> 更好。根据这里我们可以找<strong>第一个平方大于等于目标数</strong>的数（当然也可以找<strong>最后一个平方小于等于目标数</strong>的数），并且注意到<code>(mid*mid&gt;=num) high = mid</code> 也就是说high始终有可能就是<strong>第一个平方大于等于目标数</strong>的数，而<code>(mid*mid&lt;num)</code>是mid很明显不是我们想要的，所以我们让<code>low = mid+1</code>，能不能让<code>low=mid</code>也不动，绝对不行！因为这里的mid已经确定不符合题意，<strong>一定要有一个逼近的过程</strong>，即使逼近程度只有1，否则等<code>low high</code>很接近的时候一定会死循环。<br>这样有什么好处？我的目标就是，始终让<strong>第一个平方大于等于目标数</strong>的数就在<code>[low,high]</code>中间，这里是<strong>闭区间</strong>，那么当<code>low==high</code>的时候左右两区间重合就可以自动退出循环，并且<code>low or high</code>就是我们想要的，后续所有的判断都可以根据这两个数来。这里又体现一个好处，退出循环的时候一定是<code>low==high</code>（因为两个数加起来一次循环也只会变化1），如果用的是<code> while(low&lt;=high)</code>退出的时候还要去想诶，到底<code>low or high or mid</code>哪个是有价值的数据，很折磨的。</p>\n<p>还有一个<strong>很重要的问题</strong>，如果我找<strong>最后一个平方小于等于目标数</strong>的数，是不是只需要修改以下两个关键语句就可以呢？也就是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(low&lt;high) &#123;</span><br><span class=\"line\">    mid = (high-low)/<span class=\"number\">2</span>+low;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid*mid&gt;num) high = mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid*mid&lt;=num) low = mid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>错误</strong>！为什么？<br>细想，当low high 只差1的时候，mid是不是等于low，如果此时的low*low&lt;&#x3D;num是不是死循环了，low又等于mid，mid永远等于low，high根本没判断过呢，万一high才是<strong>最后一个平方小于等于目标数</strong>的数呢。<br>所以关键就是：low可能不动，所以要让mid去等于high（当然是low high 只差1的情况），也就是得这样<code>mid = (high-low+1)/2+low;</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(low&lt;high) &#123;</span><br><span class=\"line\">    mid = (high-low+<span class=\"number\">1</span>)/<span class=\"number\">2</span>+low;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid*mid&gt;num) high = mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid*mid&lt;=num) low = mid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结下来：low和high中一个不动，计算mid的时候一定要等于另一个，不然low high相邻的时候就会死循环。</p>\n<p>目前来看，所有二分查找都可以用这个模板，灵活变通吧。</p>\n<h3 id=\"多数元素\"><a href=\"#多数元素\" class=\"headerlink\" title=\"多数元素\"></a>多数元素</h3><p><a href=\"https://leetcode.cn/problems/majority-element/description/\">169. 多数元素</a><br>被简单题薄纱(加进阶是真难)<br>这题有很多解法：随机化（第一次见这种抽象解法）、分治、Boyer-Moore 投票算法</p>\n<p>分治的关键在于：将数组分成两个子数组之后，数组的主要元素一定是两个子数组主要元素之中的一个，因为如果数组的主要元素不是两个子数组主要元素之一，那这个主要元素出现次数一定小于数组一半(反证法)。<br>分治法还要考虑到最小子问题才能成型，也就是长度为1的数组的主要元素就是其中唯一的数。<br>分支法还能解决问题：<strong>数组中出现次数最多的数字</strong>，不会受到题目中的限制（超过半数）。<br>merge过程中都是要再遍历一次数组的，两个子问题加上n，总的时间复杂度就是O(nlgn)。</p>\n<p>Boyer-Moore 投票算法：同归于尽消杀法</p>\n<h3 id=\"448-找到所有数组中消失的数字\"><a href=\"#448-找到所有数组中消失的数字\" class=\"headerlink\" title=\"448. 找到所有数组中消失的数字\"></a>448. 找到所有数组中消失的数字</h3><p><a href=\"https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/solutions/601946/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/\">448. 找到所有数组中消失的数字</a><br>利用数组当哈希表（原地），巧妙利用数据的宽度，结合取模在保有原数据信息的同时加入了新的信息。</p>\n<h3 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数\"></a>4. 寻找两个正序数组的中位数</h3><p><a href=\"https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/?envType=study-plan-v2&envId=top-100-liked\">4. 寻找两个正序数组的中位数</a></p>\n<p>二分查找 真的难 写不出来。二分简单，但关键是怎么把问题抽象成二分，像这题转换为找第K数，然后每次减半，我就没想到这个转换，麻了。</p>\n<p>二分法我思路差不多呀，但我想的是大的那个数的右边也要删，两边都删然后向中间靠拢，然后破防了太难整了。转换成第K数真的太关键了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length1</span> <span class=\"operator\">=</span> nums1.length, length2 = nums2.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">totalLength</span> <span class=\"operator\">=</span> length1 + length2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalLength % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">midIndex</span> <span class=\"operator\">=</span> totalLength / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">median</span> <span class=\"operator\">=</span> getKthElement(nums1, nums2, midIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> median;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">midIndex1</span> <span class=\"operator\">=</span> totalLength / <span class=\"number\">2</span> - <span class=\"number\">1</span>, midIndex2 = totalLength / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">median</span> <span class=\"operator\">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class=\"number\">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class=\"number\">1</span>)) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> median;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getKthElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class=\"line\"><span class=\"comment\">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class=\"line\"><span class=\"comment\">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length1</span> <span class=\"operator\">=</span> nums1.length, length2 = nums2.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index1</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">kthElement</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 边界情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index1 == length1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums2[index2 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index2 == length2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums1[index1 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 正常情况</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">half</span> <span class=\"operator\">=</span> k / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newIndex1</span> <span class=\"operator\">=</span> Math.min(index1 + half, length1) - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newIndex2</span> <span class=\"operator\">=</span> Math.min(index2 + half, length2) - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">pivot1</span> <span class=\"operator\">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class=\"line\">                k -= (newIndex1 - index1 + <span class=\"number\">1</span>);</span><br><span class=\"line\">                index1 = newIndex1 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                k -= (newIndex2 - index2 + <span class=\"number\">1</span>);</span><br><span class=\"line\">                index2 = newIndex2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h2><h3 id=\"计数质数\"><a href=\"#计数质数\" class=\"headerlink\" title=\"计数质数\"></a>计数质数</h3><p><a href=\"https://leetcode.cn/problems/count-primes/solutions/507273/ji-shu-zhi-shu-by-leetcode-solution/\">埃氏筛</a></p>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p><strong>位运算很重要，有些题很有技巧性</strong></p>\n<img src=\"/2024/03/05/LeetCodeNote/1.png\" class=\"\">\n<img src=\"/2024/03/05/LeetCodeNote/2.png\" class=\"\">\n<p><strong>注意观察规律</strong>，A 到 Z 的低六位是 1 到 26，也就是 000001 到 011010。<br>而 a 到 z 的 低六位 是 33 到 58，也就是 100001 到 111010。<br>相差刚好是 倒数第六位的二进制 1 ，也就是 32（97-65），应该ascii码就是这么设计的，这样的话 <code>(A |= 1&lt;&lt;5)==a</code>，| 运算在这里<strong>等效于加法</strong>。<br>并且 A 到 Z 、a 到 z 的 低六位各不一样，分布在 1 到 64内，可以直接用 一个64bit 的long型整数<strong>压缩存储</strong>A 到 Z 、a 到 z，如：<a href=\"https://leetcode.cn/problems/jewels-and-stones/solutions/2356253/ben-ti-zui-you-jie-xian-xing-shi-jian-ch-ddw3/\">771. 宝石与石头</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> ch;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; (ch&amp;<span class=\"number\">63</span>);</span><br></pre></td></tr></table></figure>\n<p>这样每个 A 到 Z 、a 到 z 都可以用 mask 的 1 bit 来存储。<br>上面提到的两种用法都是在题里面见到过的。</p>\n<h3 id=\"只出现一次的数字\"><a href=\"#只出现一次的数字\" class=\"headerlink\" title=\"只出现一次的数字\"></a>只出现一次的数字</h3><p><a href=\"https://leetcode.cn/problems/single-number/solutions/242211/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/\">只出现一次的数字</a></p>\n<p>对于这道题，可使用异或运算 ^。异或运算有以下三个性质。<br>任何数和 0 做异或运算，结果仍然是原来的数。<br>任何数和其自身做异或运算，结果是 0。<br>异或运算满足交换律和结合律。</p>\n<p><a href=\"https://leetcode.cn/problems/single-number-ii/description/\">137. 只出现一次的数字 II</a><br>这题是真难。<br>其实关键就是：数电的方法优化在<strong>利用位运算的并行性</strong>，直接使用32个状态机（每个二进制位都当作一个状态机），而方法二只使用了一个状态机，所以时间复杂度多了一个logC。</p>\n<img src=\"/2024/03/05/LeetCodeNote/1.jpg\" class=\"\">\n\n\n<h3 id=\"二进制求和\"><a href=\"#二进制求和\" class=\"headerlink\" title=\"二进制求和\"></a>二进制求和</h3><p><a href=\"https://leetcode.cn/problems/add-binary/solutions/299667/er-jin-zhi-qiu-he-by-leetcode-solution/\">二进制求和</a></p>\n<p>两个二进制数 异或^ 可以视作忽略进位的求和，但之后要补上进位。<br>怎么补呢？用 与&amp; ，&amp;完之后还需要左移一位（能理解吧），之后迭代重复以上步骤直到进位变为0。</p>\n<p>同时注意：java里数字异或不需要转为二进制数，用十进制数来异或是正确的。<br>Integer.parseInt(String 2)将字符串a按二进制解析其内容(解析成10进制数)，Integer.toBinaryString(int n)将十进制数转为<strong>二进制字符串</strong>。</p>\n<h3 id=\"颠倒二进制位\"><a href=\"#颠倒二进制位\" class=\"headerlink\" title=\"颠倒二进制位\"></a>颠倒二进制位</h3><p><a href=\"https://leetcode.cn/problems/reverse-bits/solutions/685436/dian-dao-er-jin-zhi-wei-by-leetcode-solu-yhxz/\">190. 颠倒二进制位</a><br>这个分治解法太骚了，翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。<br>上面的是正常解法，是自顶向下的。<br>但是，注意到位运算的特殊性，并且左右两边的计算方法相同，<strong>并且</strong>已知是32位的二进制数，所以我们可以直接自底向上（到这里总算开始理解了自底向上，其实自底向上并不总是用在递归中，用在这里或者用在动态规划就像作弊一样，关键点就在你要知道底在哪里，并且向上的过程要很清楚）。<br>这里直接定义4个常数M1234，他们的意思分别就是最后一层(只颠倒奇偶)、倒数第二层(将颠倒奇偶之后的按两位一组分成奇偶组，接着颠倒奇偶组)、倒数第三层、倒数第四层。</p>\n<p>另外注意的是，在某些语言（如Java）中，<strong>没有无符号整数类型</strong>，因此对 n 的右移操作应使用<strong>逻辑右移</strong> <code>&gt;&gt;&gt;</code>。</p>\n<p>同样的分治解法还有数1的个数<a href=\"https://leetcode.cn/problems/number-of-1-bits/solutions/\">191. 位1的个数</a></p>\n<h3 id=\"4的幂\"><a href=\"#4的幂\" class=\"headerlink\" title=\"4的幂\"></a>4的幂</h3><p><a href=\"https://leetcode.cn/problems/power-of-four/solutions/798268/4de-mi-by-leetcode-solution-b3ya/\">342. 4的幂</a><br><code>n &amp; (n - 1)==0 </code>判断 n 是否是 2 的幂，&#x3D;&#x3D;0就是2的幂，2 的幂是一个很严格的条件。5*2^6并不是2的幂，2的幂和4的幂真的就差一点，补充条件即可。</p>\n<h3 id=\"2的幂\"><a href=\"#2的幂\" class=\"headerlink\" title=\"2的幂\"></a>2的幂</h3><p><a href=\"https://leetcode.cn/problems/power-of-two/solutions/796201/2de-mi-by-leetcode-solution-rny3/\">2的幂</a></p>\n<p>一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1。</p>\n<p>因此我们可以考虑使用位运算，将 <strong>n 的二进制表示中最低位的那个 1</strong> 提取出来，再判断剩余的数值是否为 0 即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。</p>\n<p>关键就是只管最低位的1。</p>\n<p><strong>n &amp; (n - 1)&#x3D;&#x3D;0</strong> 注意，<code>n = n &amp; (n - 1)</code>操作可以将任意整数 n 的最后一位1变为0，由于2的幂只有一位1，所以最后一位1变为0之后结果如果是0则n为2的幂。</p>\n<p><strong>n &amp; (-n)&#x3D;&#x3D;n</strong> 能够直接提取最低位的1，其他位都变为0。</p>\n<p>那么 n 就是 2 的幂。</p>\n<p>还有剑招：用2的最大幂除n，能整除则true。</p>\n<h3 id=\"比特位计数\"><a href=\"#比特位计数\" class=\"headerlink\" title=\"比特位计数\"></a>比特位计数</h3><p><a href=\"https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/\">338. 比特位计数</a> 有库函数法(Integer.bitCount())、动态规划解法，也可以用Brian Kernighan 算法，原理就是利用前面说过的<code>n = n &amp; (n - 1)</code>操作可以将任意整数 n 的最后一位二进制 1 变为 0 ，那么对 x 重复该操作，直到 x变成 0，则操作次数即为 x 的「一比特数」。</p>\n<h3 id=\"错误的集合\"><a href=\"#错误的集合\" class=\"headerlink\" title=\"错误的集合\"></a>错误的集合</h3><p><a href=\"https://leetcode.cn/problems/set-mismatch/solutions/857255/cuo-wu-de-ji-he-by-leetcode-solution-1ea4/\">645. 错误的集合</a></p>\n<p>这个位运算解法还不错，</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h3 id=\"环形链表2\"><a href=\"#环形链表2\" class=\"headerlink\" title=\"环形链表2\"></a>环形链表2</h3><p><strong>哈希表</strong><br> unordered_set&lt;ListNode *&gt; visited;<br>  unordered_set可以用 ListNode * 数据类型</p>\n<p><strong>快慢指针</strong>一定在环内相遇，根据数学来找到开始入环的第一个节点。</p>\n<p><a href=\"https://blog.csdn.net/xiaoquantouer/article/details/51620657\">Floyd 判圈算法</a><br>Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。</p>\n<h3 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160. 相交链表\"></a>160. 相交链表</h3><p>被简单题薄纱（没有题感说实话）<br><a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists/description/\">相交链表</a></p>\n<h3 id=\"148-排序链表\"><a href=\"#148-排序链表\" class=\"headerlink\" title=\"148. 排序链表\"></a>148. 排序链表</h3><p><a href=\"https://leetcode.cn/problems/sort-list/solutions/492301/pai-xu-lian-biao-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked\">148. 排序链表</a></p>\n<p>自底向上归并排序（用迭代不用递归），第一次见归并竟然没用递归然后做到了O(1)，真牛啊自底向上。<br>难哟。<br>以后可以尝试写一下，其实思路和递归归并是一样的，不过要在循环里控制长度sublength进行手动分组，记得分组完要切断其与前后的联系，相当于独立出两个小链表，然后合并(O(n)时间和O(1)空间)。</p>\n<h2 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h2><p>在<strong>字符匹配的题里尽量用数组代替哈希表</strong>。这个<strong>很重要很重要</strong></p>\n<p><strong>哈希表的 value 可以是一个数组</strong>，见<a href=\"https://leetcode.cn/problems/degree-of-an-array/description/\">697. 数组的度</a><br><strong>这个用法真的很重要</strong>。如java：<br><code> Map&lt;Integer, int[]&gt; map = new HashMap&lt;Integer, int[]&gt;();</code></p>\n<p>在实际代码中，我们使用哈希表实现该功能，<strong>每一个数映射到一个长度为 3 的数组</strong>，数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。</p>\n\n\n\n\n<h3 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202  快乐数\"></a>202  快乐数</h3><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>\n<p>要找是否存在环(循环)的题都可以用 快慢指针 这种思想。<br>本题还可以使用哈希表unordered_set。</p>\n<h3 id=\"设计哈希集合\"><a href=\"#设计哈希集合\" class=\"headerlink\" title=\"设计哈希集合\"></a>设计哈希集合</h3><p><a href=\"https://leetcode.cn/problems/design-hashset/description/\">705. 设计哈希集合</a></p>\n<p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：</p>\n<p><strong>哈希函数</strong>：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。<br><strong>冲突处理</strong>：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：</p>\n<ul>\n<li>链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</li>\n<li>开放地址法：当发现哈希值 h 处产生冲突时，根据某种策略，从 h 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,… 这些整数对应的位置。</li>\n<li>再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</li>\n</ul>\n<p><strong>扩容</strong>：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</p>\n<blockquote>\n<p>质数取模，其实是利用了同余的概念：当元素是个有规律的等差数列时，并且和基数（数组大小）最大公约数不为1时，就会造成哈希映射时冲突变高（数组某些位置永远不会有值）。比如数列0,6,12,18,24,30…，</p>\n<p>base为10，取模(0,6,2,8,4,0…)后，放入哈希表中位置将只能在0,2,4,6,8这几个数组位置上；<br>但我们如果把base取7（数组大小甚至比10小），同样数列取模后(0,6,5,4,3,2,1,0,…)，可以分布在哈希表中的0,1,2,3,4,5,6所有位置上；<br>后续：若x和y的最大公约为z，x和y的最小公倍数就为(xy)&#x2F;z，很明显，若z为1，也就是俩数的最大公约数为1的时候，那么俩数的最小公倍数就为xy。</p>\n<p>那么当一个数为质数时，除了其自身的倍数外，其余数和其的最大公约数都将是1，这时，步长选任何数（除了倍数）都可以满足桶的均匀分布。</p>\n<p>所以，以取模计算哈希值在桶中的位置是，用一个质数当作基数时可以使得哈希表中每个位置都“有用武之地”。</p>\n</blockquote>\n<blockquote>\n<p>Hash表为什么需要使用mod素数？</p>\n<p>从素数定理出发，我们可以知道素数有如下性质 素数定理：在初等数学中有一个基本定理，任意一个大于1的自然数，要么本身就是质数，要么可以分解为几个质数之积，这种分解本身，具有唯一性</p>\n<p>在知道素数的性质后，回过头来看Hash表，我们将元素放在Hash表当中，需要解决的一个问题就是尽量解决冲突。</p>\n<p>给出一份实验，结论表明：模数的因子会影响数列的冲突，而且因子越多，冲突的可能性就越大。而素数的因子恰好只有1和其本身,就非常适合用于解决冲突。<br>比如 2 4 6 8 10 12这6个数，如果对 6 取余 得到 2 4 0 2 4 0 只会得到3种HASH值，6的因子有1，2，6。冲突会很多。如果对 7 取余 得到 2 4 6 1 3 5 得到6种HASH值，而7的因子只有1，7。</p>\n<p>由3可知，即使1的因子最小，但是在实际中并不用，因为mod1相当于不解决冲突。而初始化的的数组就会非常大。</p>\n</blockquote>\n<h3 id=\"原地哈希-41-缺失的第一个正数\"><a href=\"#原地哈希-41-缺失的第一个正数\" class=\"headerlink\" title=\"原地哈希 41. 缺失的第一个正数\"></a>原地哈希 41. 缺失的第一个正数</h3><p> <a href=\"https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked\">41. 缺失的第一个正数</a> 被原地哈希薄纱了，之前也遇到过<strong>原地哈希</strong>的。也是在数组的值上动手脚让它能够和其他值区分开来，但这题由于数值不限，所以直接把无用的负值置0，然后用取负值做标志位。</p>\n<h3 id=\"Rabin-Karp-算法\"><a href=\"#Rabin-Karp-算法\" class=\"headerlink\" title=\"Rabin-Karp 算法\"></a>Rabin-Karp 算法</h3><p>有一题字符串的题也用的这个解法，哪题我忘记了，好像是快乐字符串什么的困难题，还有另一题也用这个，所以这是第三次遇到这个解法。</p>\n<p><a href=\"https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/\">718. 最长重复子数组</a></p>\n<p>Rabin-Karp 算法将一个序列 S 计算为哈希值，首先指定基数 base（最好是个质数），将序列 S 看作 base 进制的数求得哈希值，为防哈希冲突可以再哈希等等，不过也够用了。由于这个值一般会非常大，因此会将它对另一个素数 mod 取模。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p><strong>字符串匹配问题可以多尝试再复制一份母串</strong>，可能会有奇效， 如<a href=\"https://leetcode.cn/problems/rotate-string/description/\">796. 旋转字符串</a></p>\n<p><strong>C++ 中的 String 类</strong><br>C++ 标准库提供了 string 类类型。</p>\n<p>string类提供了一系列成员函数，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">append</span>() -- 在字符串的末尾添加字符(单字符也可以) <span class=\"comment\">// 也可以使用+和+=运算符对 string 对象执行字符串的连接操作</span></span><br><span class=\"line\"><span class=\"built_in\">append</span>()相比于+和<span class=\"built_in\">push_back</span>()有更强的功能，可以加入一个string对象的子串，如下;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;123&quot;</span>)</span>, <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">&quot;abc&quot;</span>)</span></span>;</span><br><span class=\"line\">s1.<span class=\"built_in\">append</span>(s2);  <span class=\"comment\">// s1 = &quot;123abc&quot;</span></span><br><span class=\"line\">s1.<span class=\"built_in\">append</span>(s2, <span class=\"number\">1</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// s1 = &quot;123abcbc&quot;</span></span><br><span class=\"line\">s1.<span class=\"built_in\">append</span>(<span class=\"number\">3</span>, <span class=\"string\">&#x27;K&#x27;</span>);  <span class=\"comment\">// s1 = &quot;123abcbcKKK&quot;</span></span><br><span class=\"line\">s1.<span class=\"built_in\">append</span>(<span class=\"string\">&quot;ABCDE&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// s1 = &quot;123abcbcKKKCDE&quot;，添加 &quot;ABCDE&quot; 的子串(2, 3)</span></span><br><span class=\"line\">这里子串(n, m)是指从原字符串下标 n 开始、长度为 m 的字符串</span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">find</span>() -- 在字符串中查找字符串</span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">insert</span>() -- 插入字符</span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">length</span>() -- 返回字符串的长度 <span class=\"comment\">// 用size()也可以</span></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">replace</span>() -- 替换字符串</span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"built_in\">substr</span>(pos, n) -- 返回s中从<span class=\"built_in\">pos</span>(索引)开始的n个字符的拷贝，可以只有pos，这时返回从pos开始的剩余的所有字符</span><br><span class=\"line\"><span class=\"number\">7.</span> <span class=\"built_in\">erase</span>() -- 删除<span class=\"function\">zi</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class=\"line\">s1.<span class=\"built_in\">erase</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>);  <span class=\"comment\">//删除子串(1, 3)，此后 s1 = &quot;R Steel&quot;</span></span><br><span class=\"line\">s1.<span class=\"built_in\">erase</span>(<span class=\"number\">5</span>);  <span class=\"comment\">//删除下标5及其后面的所有字符，此后 s1 = &quot;R Ste&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::string 类本身就提供了类似「入栈」和「出栈」的接口，因此我们可以直接将字符串作为栈使用。类似的成员函数有：</span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">empty</span>()</span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">back</span>()  <span class=\"comment\">// 相当于top()  取出最后一个元素</span></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">pop_back</span>() <span class=\"comment\">// 相当于pop()</span></span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">push_back</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">front</span>()  <span class=\"comment\">// 取出第一个元素</span></span><br><span class=\"line\">string类重载了[]运算符像数组一样直接访问元素</span><br><span class=\"line\"></span><br><span class=\"line\">判断相等直接用==就可以了，但是！要注意string对象不能和<span class=\"string\">&#x27;单字符&#x27;</span>比较，一定要和<span class=\"string\">&quot;字符串&quot;</span>比较。</span><br><span class=\"line\">和单字符比较时也一定要用双引号<span class=\"string\">&quot;&quot;</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">string数字怎么转换为真正的数字，如<span class=\"string\">&quot;-123&quot;</span>-&gt;<span class=\"number\">-123</span></span><br><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"built_in\">atoi</span>( str.<span class=\"built_in\">c_str</span>() ) <span class=\"comment\">// C风格</span></span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"built_in\">stoi</span>( str )              <span class=\"comment\">// C++风格 直接用就完事</span></span><br><span class=\"line\"></span><br><span class=\"line\">atoi 可以将字符数组转换为数字，并且可以加号和负号一同变为数字。</span><br><span class=\"line\">string str = <span class=\"string\">&quot;-100&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"built_in\">atoi</span>(str); <span class=\"comment\">// 这样是不行的，因为atoi不支持直接把c++的字符串改为数字，只能先变为字符数组才行</span></span><br><span class=\"line\">通过c_str将string变为字符数组，再用atoi来变为数字</span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"built_in\">atoi</span>(str.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">algorithm库中的<span class=\"built_in\">reverse</span>()函数可以直接反转字符串, 对vector也适用</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(s.begin(),s.end())</span></span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(s[i]m s[j])</span>；swap方法可以交换两个元素</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"151-翻转字符串里的单词\"><a href=\"#151-翻转字符串里的单词\" class=\"headerlink\" title=\"151 翻转字符串里的单词\"></a>151 翻转字符串里的单词</h3><p><strong>真的好题，确实难</strong>双指针的极致应用</p>\n<p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p>\n<p>O(1)空间复杂度的解法确实想不出来。<br>整个字符串翻转，再翻转各个单词。思路太难想了吧。<br>其实想不出来也应该把删除所有多余空格这一步弄出来，一步步做题。之后没准就想出来了。其实还是字符串不熟，没用过erase()；<br>但是erase()是O(n)的时间复杂度，所以不能用。<br>用前后快慢指针删除vector&#x2F;string的某一种元素，如果是相向指针会改变顺序，所以得用前后快慢指针来删除空格。</p>\n<h3 id=\"28-实现-strStr\"><a href=\"#28-实现-strStr\" class=\"headerlink\" title=\"28. 实现 strStr()\"></a>28. 实现 strStr()</h3><p><strong>KMP算法经典问题， 找字串</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getNext</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; next, <span class=\"type\">const</span> string&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        next[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> k = next[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            <span class=\"comment\">// 找到子对称字符串为止</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>( s[i] != s[k] &amp;&amp; k&gt;<span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">                k = next[k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 下面这段代码有更常见的形式，其实是一模一样的</span></span><br><span class=\"line\">            <span class=\"comment\">// if( s[i]==s[k] )&#123;</span></span><br><span class=\"line\">            <span class=\"comment\">//     next[i] = k + 1;</span></span><br><span class=\"line\">            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">            <span class=\"comment\">// else</span></span><br><span class=\"line\">            <span class=\"comment\">//     next[i] = 0;</span></span><br><span class=\"line\">            <span class=\"comment\">// 退出循环只有两种情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( s[i]==s[k] )&#123;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next[i] = k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.csdn.net/yearn520/article/details/6729426\">KMP算法的前缀next数组最通俗的解释</a> 这篇文章讲的不错。</p>\n<p>很重要的一点就是，匹配失败的时候要找<strong>已经匹配的字符串内部</strong>对称的子字符串，这也是KMP的内核，当一个字符串的对称程度越高，KMP算法效果越好。这里的对称不是指一次对称，而是像这样的:<br>0123456789<strong>1011</strong><br>abtab <strong>g</strong>abtab<strong>t</strong>3<br>00012012345<br>t无法继承（如果这个字符没有失配，配哪个呢，索引就是前一个字符的next值，那它的next就是前一个字符的next加一）前一个字符的next对应值因为这里失配了，即t&#x3D;s[i]，这时候s[i]不等于s[(k&#x3D;next[i-1]&#x3D;next[b]&#x3D;5)]&#x3D;g。<br>那这时候t的next值怎么看，开始找匹配好的字符串里面的子对称字符串，并且t一定要和那个子对称的下一个字符相同。<br>更新k &#x3D; next[k - 1]&#x3D;next[4]&#x3D;2;这时候的k代表已经匹配好的字符串里的子对称的长度，你看abtab里面的ab。ab就是我们要找的子对称字符串，它的下一个字符是不是t，这时候就匹配了可以退出循环，next[t]&#x3D;k+1；<br>那为什么更新k &#x3D; next[k - 1]呢，这一步挺关键的。<br>原来的k是5，是什么意思？这个5&#x3D;next[t-1]是t前一个字符b的next，表示这个字符和它前四个字符也就是长度为5的后缀与长度为5的前缀相同。<br>那我要找这个匹配好的长为5的字符串的子对称字符串怎么找，那当然是next[4](索引是长度-1)直接查前缀就行。<br>有更复杂的情况<br>abtab<em>abtab</em>  <strong>g</strong> abtab<em>abtab</em><strong>t</strong><br>0001212345<strong>0</strong>123456789<strong>10</strong>3<br><strong>这种才是真正的对称</strong><br>更新k &#x3D; next[k - 1]你要更新两次才能找到，找到什么？<strong>匹配好的字符串里面的子对称字符串，并且t一定要和那个子对称的下一个字符相同</strong>。<br>刚开始：k &#x3D; 10；<br>更新：k&#x3D;next[k-1]&#x3D;next[9]&#x3D;5<br>这不是找到abtababtab长为5的对称子串了吗？但是，这个字串的下一个字符是a，不等于t就，也就是while循环里的判断条件，还得更新。<br>更新：k&#x3D;next[k-1]&#x3D;next[4]&#x3D;2<br>这时候终于找到了，所以next[t]&#x3D;k+1&#x3D;3;<br>k&#x3D;0当然就没意思了，说明没有对称子串了，因为k即next代表相同的前后缀的长度，零的话我直接比较s[i]和s[0](也是s[k])不就好了。</p>\n<p>时间复杂度O(m+n)，空间复杂度O(m)  n是主串长度，m是模式串长度</p>\n<p><a href=\"https://quant67.com/post/algorithms/kmp/kmp.html\">字符串匹配算法: kmp和bm算法</a></p>\n<h3 id=\"459-重复的子字符串\"><a href=\"#459-重复的子字符串\" class=\"headerlink\" title=\"459.重复的子字符串\"></a>459.重复的子字符串</h3><p><strong>上限很高的简单题</strong></p>\n<p>要理解一个关键原理:<br>长度为 n 的字符串 s 是字符串 t&#x3D;s+s 的子串，并且 s 在 t 中的起始位置不为 0 或 n，当且仅当 s 满足题目的要求(给定一个非空的字符串s，可以通过由它的一个子串重复多次构成。)，即为充要条件。<br>可以用string类自带的find函数查找索引，之所以要求索引不为0或n，是因为第一个删除了s+s的第一个和最后一个”子串”，两个s都不完整，由于子串长度至少大于1，所以删除前后各一个字符。<br>当然也可以用<strong>KMP实现自己的查找函数</strong>。</p>\n<p>这题还能进一步优化。<br>符合要求的字符串，最后一位的next值&#x3D;n-i;<br>其中n为字符串长度，i为重复的子串的长度。<br>所以 i &#x3D; n-next[n-1]<br>又有<code>gcd(n,i) = i </code> <strong>n肯定整除i，并且i为最小的起始位置。</strong><br>所以只要判断n是否能整除i(n-next[n-1])即可，能整除则true。</p>\n<h2 id=\"队列与栈\"><a href=\"#队列与栈\" class=\"headerlink\" title=\"队列与栈\"></a>队列与栈</h2><p><strong>匹配问题都是栈的强项。</strong></p>\n<h3 id=\"232-用栈实现队列\"><a href=\"#232-用栈实现队列\" class=\"headerlink\" title=\"232 用栈实现队列\"></a>232 用栈实现队列</h3><p>就差一点就能更优化，应该再多想想不要急。画个图就能发现，用来输出的第二个栈的元素不用再倒回去。<br>基本就是输入输出栈完全分开了。</p>\n<h3 id=\"150-逆波兰表达式求值\"><a href=\"#150-逆波兰表达式求值\" class=\"headerlink\" title=\"150. 逆波兰表达式求值\"></a>150. 逆波兰表达式求值</h3><p>这不仅仅是一道好题，也展现出计算机的思考方式</p>\n<p>为什么要将看似简单的中缀表达式转换为复杂的逆波兰式？原因就在于这个简单是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。相对的，逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普<strong>遍采用的内存结构是栈式结构</strong>，它执行先进后出的顺序。</p>\n<h3 id=\"239-滑动窗口最大值\"><a href=\"#239-滑动窗口最大值\" class=\"headerlink\" title=\"239. 滑动窗口最大值\"></a>239. 滑动窗口最大值</h3><p>我用的哈希表加剪枝，以临界时间通过，如果题目数据大一点就不容易通过了。</p>\n<p>很难很好的题。<br>学到很多：优先队列(堆)，单调队列(由deque实现，满足单调性的双端队列)，通常并不是单独使用的，还有分块加预处理(很有意思的解法，类似稀疏表，其实和线段树有一丢丢像，像53题的线段树也维护最大前缀和、最大后缀和，这里是维护最大前缀最大后缀)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">emplace</span>(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; ans = &#123;q.<span class=\"built_in\">top</span>().first&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">emplace</span>(nums[i], i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (q.<span class=\"built_in\">top</span>().second &lt;= i - k) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(q.<span class=\"built_in\">top</span>().first);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/\">解法</a></p>\n<h3 id=\"数据流中的第-K-大元素-优先队列\"><a href=\"#数据流中的第-K-大元素-优先队列\" class=\"headerlink\" title=\"数据流中的第 K 大元素 优先队列\"></a>数据流中的第 K 大元素 优先队列</h3><p><a href=\"https://leetcode.cn/problems/kth-largest-element-in-a-stream/solutions/600598/shu-ju-liu-zhong-de-di-k-da-yuan-su-by-l-woz8/\">703. 数据流中的第 K 大元素</a></p>\n<p><strong>小顶堆</strong><br>直接当普通队列使用即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java</span></span><br><span class=\"line\">PriorityQueue&lt;Integer&gt; pq = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;Integer&gt;();</span><br><span class=\"line\">pq.offer(val);</span><br><span class=\"line\">pq.poll();</span><br><span class=\"line\">pq.peek();</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"347-前-K-个高频元素-优先队列\"><a href=\"#347-前-K-个高频元素-优先队列\" class=\"headerlink\" title=\"347. 前 K 个高频元素 优先队列\"></a>347. 前 K 个高频元素 优先队列</h3><p>好题。<br><strong>优先队列</strong> ，要知道堆的操作时间复杂度是和堆总元素数有关的，如果堆大小至多为k，则每次堆操作需要O(logk)的时间，操作N次的话就是O(Nlogk) 的时间。<br>还学到了自定义排序规则：<br>注意定义优先队列的排序时是反过来的，比如&gt;号是小根堆，&lt;号是大根堆。以下的例子都是小根堆，默认创建时为大根堆。<br>并且注意调用时候的用法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">const</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//自定义的比较函数，按第一个元素从小到大排序，如果第一个元素相同，则按第二个元素从小到大排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.first == b.first)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.second &gt; b.second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.first &gt; b.first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;, <span class=\"keyword\">decltype</span>(&amp;cmp)&gt; <span class=\"built_in\">pq</span>(cmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优先队列常用成员函数</span></span><br><span class=\"line\">q.<span class=\"built_in\">emplace</span>(a,b); <span class=\"comment\">// pair&lt;int,int&gt;</span></span><br><span class=\"line\">q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp; m, pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m.second &gt; n.second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用内置greater函数就是小根堆，默认的less是大根堆；</span></span><br><span class=\"line\">priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;, greater&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; &gt; q;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>priority_queue 对象的第一个模板参数是 pair&lt;int, int&gt;，表示队列中的元素类型为 pair。第二个模板参数是 vector&lt;pair&lt;int, int&gt;&gt;，表示使用 vector 作为底层容器。第三个模板参数是自定义的比较函数 cmp 的<strong>类型</strong>，使用 <strong>decltype(&amp;cmp)</strong> 来<strong>获取函数指针的类型</strong>。</p>\n<p>读者需要掌握自己实现堆的方法，包括「建堆」、「调整」和「删除」的过程。<br>可以再看看912排序数组，用了堆排序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 大根堆  堆就是完美二叉树并且存储在数组中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个函数的作用是调整 O(lgn)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">maxHeapify</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">int</span> i, <span class=\"type\">int</span> heapSize)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">// 左右子节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> l = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>；</span><br><span class=\"line\">        <span class=\"type\">int</span> r = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> largest = i;</span><br><span class=\"line\">        <span class=\"comment\">// 找到两个子节点的较大值 将其与父节点交换，换完之后要对这个父节点往下递归，也就是下沉，因为有可能这个父节点很小(至少比换位置后新的子节点小)，要一直往下沉</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class=\"line\">            largest = l;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class=\"line\">            largest = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(a[i], a[largest]);</span><br><span class=\"line\">            <span class=\"built_in\">maxHeapify</span>(a, largest, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    其实是调整前半个堆，为什么？因为堆是一个完美二叉树，而且只对所有父节点有要求，要求每个父节点大于其所有子节点，</span></span><br><span class=\"line\"><span class=\"comment\">    而所有树的父节点数(非叶子节点)不会超过树总结点数的一半，而且在maxHeapify里会判断子节点是否存在，所以这样写没有问题。</span></span><br><span class=\"line\"><span class=\"comment\">    也就是说，建堆过程是至多调整前半个堆，也就是前半个数组，循环调用maxHeapify来把nums[i]调整到合适的位置</span></span><br><span class=\"line\"><span class=\"comment\">    O(n*lgn)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">buildMaxHeap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">int</span> heapSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = heapSize / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">maxHeapify</span>(a, i, heapSize);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> heapSize = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">buildMaxHeap</span>(nums, heapSize); <span class=\"comment\">// 建好了整个大根堆 准备pop K-1次，堆顶的值就是第K最大</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*删除操作的完成是这样的：</span></span><br><span class=\"line\"><span class=\"comment\">        1. 将堆顶(nums[0])与堆最后一个节点(nums[heap.size()-1])交换，令记录的堆大小减一，实际上并没有改变vector的大小，相当于删除当前的堆尾，也就是刚刚pop的堆首；</span></span><br><span class=\"line\"><span class=\"comment\">        2. 调整当前的堆，也就是对调整新堆首到合适的位置，由于maxHeapify中的递归，能将整个堆调整好。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= nums.<span class=\"built_in\">size</span>() - k + <span class=\"number\">1</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[<span class=\"number\">0</span>], nums[i]);</span><br><span class=\"line\">            --heapSize;</span><br><span class=\"line\">            <span class=\"built_in\">maxHeapify</span>(nums, <span class=\"number\">0</span>, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>还有<strong>快速选择</strong>法(基于快速排序的选择方法)，通过每次都只在其中一个分支进行递归，能够将算法的平均复杂度降低到O(N)。<br>快排可以通过在每次递归的开始<em><strong>随机选取中枢元素</strong></em>来降低出现最坏情况的概率。还可以使用双指针的方法，这种方法可以较好的应对各种数据。<br><strong>再做一题K大数</strong>：</p>\n<h3 id=\"215-数组中的第K个最大元素\"><a href=\"#215-数组中的第K个最大元素\" class=\"headerlink\" title=\"215. 数组中的第K个最大元素\"></a>215. 数组中的第K个最大元素</h3><p>字节真的考过这个，还是得实现O(n)的时间复杂度，所以用堆是不行的。得用快速选择：</p>\n<p>根据快排的原理我们知道，在递归一次的时候我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1]中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r]中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l⋯q−1]和 a[q+1⋯r]是否是有序的，我们不关心。</p>\n<p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以<strong>把原来递归两个区间变成只递归一个区间</strong>，提高了时间效率。这就是「快速选择」算法。</p>\n<p><strong>基于快速排序的选择方法</strong><br>只讨论大量相同的数据的情况，如果只是选择随机数的话是无效选择，基本就是快排的最坏情况即冒泡排序。用双指针版快排则可以有O(nlgn)的时间复杂度因为每次都可以跑到最中间，（顺便说一下，快排有三指针的优化）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">quickselect</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[k];</span><br><span class=\"line\">        <span class=\"type\">int</span> partition = nums[l], i = l - <span class=\"number\">1</span>, j = r + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> i++; <span class=\"keyword\">while</span> (nums[i] &lt; partition);</span><br><span class=\"line\">            <span class=\"keyword\">do</span> j--; <span class=\"keyword\">while</span> (nums[j] &gt; partition);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; j)</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[i], nums[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt;= j)<span class=\"keyword\">return</span> <span class=\"built_in\">quickselect</span>(nums, l, j, k);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">quickselect</span>(nums, j + <span class=\"number\">1</span>, r, k);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，双指针是应对大量重复数据的，这也是为什么用 do while ，如果很多数据，则 i j 索引指的数据都相同，这时候 i j 交换完数据后会同时减，这样 i j 碰头的时候基本就在中间，后面只递归一次的时候基本可以少递归一半的重复数组。</p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><p><strong>好难的二叉树( 迭代 递归 都难 )</strong></p>\n<h3 id=\"树的种类\"><a href=\"#树的种类\" class=\"headerlink\" title=\"树的种类\"></a>树的种类</h3><p><strong>满二叉树</strong></p>\n\n\n<p><strong>完全二叉树</strong></p>\n<p>完全二叉树的定义如下：在完全二叉树中，除了最后一层其它层全部填满，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p>\n<p>优先级队列其实是一个堆，<strong>堆就是一棵完全二叉树</strong>，同时保证父子节点的顺序关系。</p>\n\n\n<p><strong>二叉搜索树</strong></p>\n<p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>\n<li>它的左、右子树也分别为二叉排序树<br>（严格递增）</li>\n</ul>\n<p>如：</p>\n\n\n<p><strong>平衡二叉搜索树</strong></p>\n<p>平衡二叉搜索树：又被称为<strong>AVL</strong>（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵<strong>空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过1</strong>，<strong>并且左右两个子树都是一棵平衡二叉树</strong>。</p>\n<p>C++中map、set、multimap，multiset的底层实现都是<strong>平衡二叉搜索树</strong>(红黑树)，所以map、set的<strong>增删操作时间时间复杂度是logn</strong>，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set，因为它们的底层实现是哈希表。</p>\n\n\n\n<h3 id=\"二叉树的存储方式\"><a href=\"#二叉树的存储方式\" class=\"headerlink\" title=\"二叉树的存储方式\"></a>二叉树的存储方式</h3><p><strong>链式存储</strong>与<strong>顺序存储</strong></p>\n<p>链式存储方式就用<strong>指针</strong>， 顺序存储的方式就是用<strong>数组</strong>。</p>\n<p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>\n\n\n\n\n<p>用数组来存储二叉树如何遍历的呢？</p>\n<p>如果<strong>父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2</strong>。</p>\n<h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><p>二叉树主要有两种遍历方式：</p>\n<ol>\n<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>\n<li>广度优先遍历：一层一层的去遍历。</li>\n</ol>\n<h4 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h4><p><strong>深度优先遍历</strong></p>\n<ul>\n<li>前序遍历（递归法，迭代法）</li>\n<li>中序遍历（递归法，迭代法）</li>\n<li>后序遍历（递归法，迭代法）</li>\n</ul>\n<p>前中后序遍历的前中后，其实指的就是<strong>中间节点的遍历顺序</strong>，只要记住 前中后序 指的就是中间节点的位置就可以了。</p>\n<p><strong>中间节点的顺序就是所谓的遍历方式（左子树一定在右子树之前）</strong></p>\n<ul>\n<li>前序遍历：中左右</li>\n<li>中序遍历：左中右</li>\n<li>后序遍历：左右中<br>这里的左右理解为左右子树更好，同时左右子树也要保持相同的遍历顺序。</li>\n</ul>\n\n\n<p>做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。<br>讲栈与队列的时候，就说过<strong>栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p>\n<p>而<strong>广度优先遍历一般使用队列来实现</strong>，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"DFS-递归\"><a href=\"#DFS-递归\" class=\"headerlink\" title=\"DFS 递归\"></a>DFS 递归</h5><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  递归  前序遍历  中序后序同理，修改顺序即可</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traversal</span><span class=\"params\">(TreeNode* cur, vector&lt;<span class=\"type\">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        vec.<span class=\"built_in\">push_back</span>(cur-&gt;val);    <span class=\"comment\">// 中</span></span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(cur-&gt;left, vec);  <span class=\"comment\">// 左</span></span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(cur-&gt;right, vec); <span class=\"comment\">// 右</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(root, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"DFS-迭代\"><a href=\"#DFS-迭代\" class=\"headerlink\" title=\"DFS 迭代\"></a>DFS 迭代</h5><p><strong>二叉树</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 官解的迭代写的真的好</span></span><br><span class=\"line\"><span class=\"comment\">// 中序</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        stack&lt;TreeNode *&gt; stk;</span><br><span class=\"line\">        TreeNode* node = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>( !stk.<span class=\"built_in\">empty</span>() || node ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(node) &#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">                node = node-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(node-&gt;val);</span><br><span class=\"line\">            node = node-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前序</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;TreeNode *&gt; stk;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        TreeNode *node = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.<span class=\"built_in\">empty</span>()||node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(node) &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(node-&gt;val);</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">                node = node-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            node = node-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后序</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;TreeNode *&gt; stk;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        TreeNode *node = root;</span><br><span class=\"line\">        TreeNode *prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.<span class=\"built_in\">empty</span>()||node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(node) &#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">                node = node-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( node-&gt;right==<span class=\"literal\">nullptr</span>||node-&gt;right==prev ) &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(node-&gt;val);</span><br><span class=\"line\">                stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                prev = node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">            node = node-&gt;right;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prev&amp;&amp;(node==prev-&gt;right))</span><br><span class=\"line\">                node = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 官解后序</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        stack&lt;TreeNode *&gt; stk;</span><br><span class=\"line\">        TreeNode *prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">nullptr</span> || !stk.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">emplace</span>(root);</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">emplace_back</span>(root-&gt;val);</span><br><span class=\"line\">                prev = root;</span><br><span class=\"line\">                root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">emplace</span>(root);</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 官解后序</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">prev</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right == <span class=\"literal\">null</span> || root.right == prev) &#123;</span><br><span class=\"line\">                res.add(root.val);</span><br><span class=\"line\">                prev = root;</span><br><span class=\"line\">                root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>N叉树</strong></p>\n<p><a href=\"https://leetcode.cn/problems/n-ary-tree-preorder-traversal/solutions/1317175/n-cha-shu-de-qian-xu-bian-li-by-leetcode-bg99/\">589. N 叉树的前序遍历</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorder</span><span class=\"params\">(Node root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;Node&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;Node&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            res.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> node.children.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">                stack.push(node.children.get(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.cn/problems/n-ary-tree-postorder-traversal/solutions/1327327/n-cha-shu-de-hou-xu-bian-li-by-leetcode-txesi/\">590. N 叉树的后序遍历</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用 HashSet 标记是否把子节点放进来了，第二次访问才能读取它的 val</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorder</span><span class=\"params\">(Node root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        Set&lt;Node&gt; hset = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Node&gt;();</span><br><span class=\"line\">        Stack&lt;Node&gt; stk = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;Node&gt;();</span><br><span class=\"line\">        stk.push(root);</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.empty()) &#123;</span><br><span class=\"line\">            node = stk.peek();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.children.size() == <span class=\"number\">0</span> || hset.contains(node)) &#123;</span><br><span class=\"line\">                list.add(node.val);</span><br><span class=\"line\">                hset.remove(node);</span><br><span class=\"line\">                stk.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hset.add(node);</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> node.children.size()-<span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                    stk.push(node.children.get(i));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h4><p><strong>广度优先一定要想到队列</strong></p>\n<p><strong>二叉树层序遍历 也即 广度优先遍历</strong>，图的广度优先也是要用队列，出队入队等。</p>\n<ul>\n<li>层次遍历（迭代法）</li>\n</ul>\n<p>需要借用一个辅助数据结构即<strong>队列</strong>来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p>\n<p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; que;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        TreeNode *idx = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root)</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> i = que.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 每次new一个一位vector，存完之后再push进res里比较好</span></span><br><span class=\"line\">            res.<span class=\"built_in\">resize</span>(res.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &gt; <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">                idx = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                res[cnt].<span class=\"built_in\">push_back</span>(idx-&gt;val); </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(idx-&gt;left) que.<span class=\"built_in\">push</span>(idx-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(idx-&gt;right) que.<span class=\"built_in\">push</span>(idx-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"二叉树的最近公共祖先\"><a href=\"#二叉树的最近公共祖先\" class=\"headerlink\" title=\"二叉树的最近公共祖先\"></a>二叉树的最近公共祖先</h3><p>体会递归的自顶向下和自底向上<br>本题时间复杂度是自顶向下(n^2)和自底向上(n)。</p>\n<p>自底向上是这样的：要求出当前的值，我先去求子值也即缩小问题规模，不断缩小，再有得出来的一个个小问题的解来构建当前的值并根据题意做出相应的操作。实际上是怎么实现的？那便是二话不说直接往下递归，当然子问题的解你肯定要保留下来，得到了子问题的解边进行你要的操作。放在本题就是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span>  <span class=\"title\">Verify</span><span class=\"params\">(TreeNode *root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">bool</span> flag1 = <span class=\"built_in\">Verify</span>(root-&gt;left, p, q);</span><br><span class=\"line\">        <span class=\"type\">bool</span> flag2 = <span class=\"built_in\">Verify</span>(root-&gt;right, p, q);</span><br><span class=\"line\">        <span class=\"comment\">// if(((root==q||root==p)&amp;&amp;(flag1||flag2))||(flag1&amp;&amp;flag2))</span></span><br><span class=\"line\">        <span class=\"comment\">//     node =  root;</span></span><br><span class=\"line\">        <span class=\"comment\">// if(root==p||root==q)</span></span><br><span class=\"line\">        <span class=\"comment\">//     return true;</span></span><br><span class=\"line\">        <span class=\"comment\">// return flag1||flag2;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>除了第一句判断root存在否以外，直接就往下递归并保留下子问题的解。</p>\n<p>而自顶向下是我往下递归，如果我需要当前问题的解来进行后序的操作，那我一定要现在立刻马上获得，比如这里为了获得flag1 2，我甚至用了Verify这个递归的函数来求解，那肯定带了许多重复运算。那便是O(n^2)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Verify</span><span class=\"params\">(TreeNode *root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==p||root==q)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Verify</span>(root-&gt;left, p, q) || <span class=\"built_in\">Verify</span>(root-&gt;right, p, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"type\">bool</span> flag1 = <span class=\"built_in\">Verify</span>(root-&gt;left, p, q);</span><br><span class=\"line\">        <span class=\"type\">bool</span> flag2 = <span class=\"built_in\">Verify</span>(root-&gt;right, p, q);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// if((root==q||root==p)&amp;&amp;(flag1||flag2))</span></span><br><span class=\"line\">        <span class=\"comment\">//     return root;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// if(flag1&amp;&amp;flag2)</span></span><br><span class=\"line\">        <span class=\"comment\">//     return root;</span></span><br><span class=\"line\">        <span class=\"comment\">// else if(flag1)</span></span><br><span class=\"line\">        <span class=\"comment\">//     return lowestCommonAncestor(root-&gt;left, p, q);</span></span><br><span class=\"line\">        <span class=\"comment\">// else </span></span><br><span class=\"line\">        <span class=\"comment\">//     return lowestCommonAncestor(root-&gt;right, p, q);</span></span><br><span class=\"line\">        <span class=\"comment\">// return nullptr;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我认为自顶向下和自底向上最核心的区别就是自底向上一定先会递归到底再求解问题。而自顶向下不一定会到底(这里考虑的肯定是递归的主函数，而不是Verify)，通过在每个节点都立刻算出当前的值，只要问题的解存在，那想必在递归的过程中就已经把问题解决了。</p>\n<p>还有一个原因是我没想到可以用全局变量，没必要让递归来返回TreeNode*。</p>\n<h3 id=\"两数之和-IV-输入二叉搜索树\"><a href=\"#两数之和-IV-输入二叉搜索树\" class=\"headerlink\" title=\"两数之和 IV - 输入二叉搜索树\"></a>两数之和 IV - 输入二叉搜索树</h3><p><a href=\"https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/description/\">653. 两数之和 IV - 输入二叉搜索树</a></p>\n<p>这题的方法四还是挺厉害的。</p>\n<p>具体地，我们对于每个指针新建一个栈。<strong>初始，我们让左指针移动到树的最左端点</strong>，并将路径保存在栈中，接下来我们可以依据栈来 O(1) 地计算出左指针的下一个位置。右指针也是同理。</p>\n<p>计算下一个位置时，我们首先将位于<strong>栈顶的当前节点从栈中弹出</strong>，此时首先判断当前节点是否存在右子节点，如果存在，那么我们将<strong>右子节点的最左子树</strong>加入到栈中；否则我们就完成了当前层的遍历，无需进一步修改栈的内容，直接回溯到上一层即可。</p>\n<p>实现起来有点像 头尾双指针 遍历 树。<br>在很多题都可以用，记得在对称二叉树那里也可以用。</p>\n<p><strong>两个栈</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> root, right = root;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; leftStack = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; rightStack = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        leftStack.push(left);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            leftStack.push(left.left);</span><br><span class=\"line\">            left = left.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rightStack.push(right);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            rightStack.push(right.right);</span><br><span class=\"line\">            right = right.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left != right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left.val + right.val == k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left.val + right.val &lt; k) &#123;</span><br><span class=\"line\">                left = getLeft(leftStack);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                right = getRight(rightStack);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">getLeft</span><span class=\"params\">(Deque&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> root.right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node);</span><br><span class=\"line\">            node = node.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">getRight</span><span class=\"params\">(Deque&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> root.left;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node);</span><br><span class=\"line\">            node = node.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"另一棵树的子树\"><a href=\"#另一棵树的子树\" class=\"headerlink\" title=\"另一棵树的子树\"></a>另一棵树的子树</h3><p><strong>难死了</strong></p>\n<p><a href=\"https://leetcode.cn/problems/subtree-of-another-tree/solutions/233896/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/\">572. 另一棵树的子树</a></p>\n<p><strong>方法一</strong>：<br>深度优先搜索暴力匹配<br>做两次深度优先，对每个节点的子树做一次暴力匹配。</p>\n<p><strong>方法二</strong>：深度优先搜索序列上做串匹配</p>\n<p>因为一棵子树上的点在 先、中、后序 遍历下是连续的，所以可以判断 串2 是否是 串1 的子串。<br>我想到这个了，<strong>但是</strong>，这只是一个必要条件，并不充分。<br>可以通过引入节点的两个空值 leftNull 和 rightNull 节点来进行标记，这样子串就能唯一匹配。</p>\n<p>可以用 KMP 来进行匹配判断。（KMP不知可以用来对字符串进行匹配，也可以用来对数组匹配）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">kmp</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sLen</span> <span class=\"operator\">=</span> sOrder.size(), tLen = tOrder.size();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] fail = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[tOrder.size()];</span><br><span class=\"line\">        Arrays.fill(fail, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, j = -<span class=\"number\">1</span>; i &lt; tLen; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j != -<span class=\"number\">1</span> &amp;&amp; !(tOrder.get(i).equals(tOrder.get(j + <span class=\"number\">1</span>)))) &#123;</span><br><span class=\"line\">                j = fail[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tOrder.get(i).equals(tOrder.get(j + <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fail[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, j = -<span class=\"number\">1</span>; i &lt; sLen; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j != -<span class=\"number\">1</span> &amp;&amp; !(sOrder.get(i).equals(tOrder.get(j + <span class=\"number\">1</span>)))) &#123;</span><br><span class=\"line\">                j = fail[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sOrder.get(i).equals(tOrder.get(j + <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == tLen - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>方法三</strong>： <strong>树哈希</strong></p>\n<p>很牛的方法，字节面过要求写出这个，估计是故意为难人的。</p>\n<p>自定义哈希函数，把每个子树都映射成一个唯一的数。</p>\n<p>本质就是每个子树的哈希值要考虑每个节点的值，子树哈希值，子树大小，以及左右子树拥有不同权值，这样出现冲突的几率比较小。如果还怕出现冲突，可以设计两个哈希函数，由这两个哈希函数生成第三个哈希函数，这就是<strong>双哈希</strong>。</p>\n<p>这里求素数再用上之前学过的 <strong>埃氏筛法</strong>（此处为欧拉筛）。</p>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><p><strong>讲道理，遇到回溯题，自己把递归树稍微画一下</strong>。</p>\n<p>回溯本质就是暴力枚举，通过递归来实现。</p>\n<p><strong>尽量多用全局变量</strong>（就算<strong>集合也可以用全局</strong>），可以省内存，但要注意。<br>不管什么写法（用全局还是传下来的集合参数），添加结果的时候都一定要<strong>拷贝一份</strong>，不然结果会出错，因为 Java 是 pass by reference。如：<code>ans.add(new ArrayList&lt;&gt;(temp));</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回溯的第二种经典写法 即：不选走一次，选的话也走一次</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">第一种经典写法是用 for 循环，也就是回溯里用for循环表示层内遍历，</span></span><br><span class=\"line\"><span class=\"comment\">而递归本身是纵向遍历。 这种写法能更好地理解回溯，</span></span><br><span class=\"line\"><span class=\"comment\">回溯相当于树的深度，而for循环本身是树的宽度， 我常用这种写法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; t = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">subsets</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> cur, <span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == nums.length) &#123;</span><br><span class=\"line\">            ans.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;(t));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t.add(nums[cur]);</span><br><span class=\"line\">        dfs(cur + <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">        t.remove(t.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(cur + <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"二进制手表\"><a href=\"#二进制手表\" class=\"headerlink\" title=\"二进制手表\"></a>二进制手表</h3><p><a href=\"https://leetcode.cn/problems/binary-watch/description/\">401. 二进制手表</a></p>\n<p>这是这题的回溯解法，其实就是<strong>罗列所有</strong>  1 的位数等于 turnedOn 的10位二进制数，进一步判断是否题意( 即 <code>private String convert(int num)</code>中所列的，当不满足时返回空串)，所以明确回溯的目标和难点就是<strong>罗列所有</strong>  1 的位数等于 turnedOn 的10位二进制数（这也是我不会的，毕竟第一次做回溯，后面肯定拿下）。</p>\n<p>turnedOn( 1 的总位数 )肯定是关键，分散到十位二进制数的每一位看就是 <strong>这一位取0还是取1</strong> 的小问题，取了 0，剩余位数一定要满足一共有 <code>turnedOn</code> 个 1 ，取了 1 ，剩余位数一定要满足一共有 <code>turnedOn-1</code> 个 1 ，那很明显了，这就是递归，我们用num保存这个结果传递给两个子递归。剩余 1 的总位数一定要传递，还有个关键就是记录当前走到这个十位二进制数的哪一位了，也就是 参数 <code>idx</code>。</p>\n<p>说到递归一定要想到 递归的底是什么，底当然是 turnedOn递减为0，这时候的 数(num) 才能符合第一个要求，这时候就交给<code>private String convert(int num)</code>函数了。</p>\n<p>还要注意对回溯剪枝，毕竟回溯是暴力解法，适当的剪枝能提高程序性能，结合我们的<br><strong>参数 idx 表示走到哪一位了，参数 turnedOn 表示剩余位数还需要取几个1，还有这一定是一个十位二进制数</strong>，剪枝呼之欲出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( (turnedOn+idx)&gt;<span class=\"number\">10</span> ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">readBinaryWatch</span><span class=\"params\">(<span class=\"type\">int</span> turnedOn)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        backtrace(<span class=\"number\">0</span>, <span class=\"number\">0</span>, turnedOn, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrace</span><span class=\"params\">(<span class=\"type\">int</span> num, <span class=\"type\">int</span> idx, <span class=\"type\">int</span> turnedOn, List&lt;String&gt; res)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (turnedOn == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> convert(num);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"string\">&quot;&quot;</span>.equals(r)) &#123;</span><br><span class=\"line\">            res.add(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//剪枝  现在有的位数加上你还需要的1的数目超过了10位，那这个肯定不是你要的数了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (turnedOn+idx)&gt;<span class=\"number\">10</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//选和不选</span></span><br><span class=\"line\">    backtrace(num, idx + <span class=\"number\">1</span>, turnedOn, res);</span><br><span class=\"line\">    num |= (<span class=\"number\">1</span> &lt;&lt; idx);</span><br><span class=\"line\">    backtrace(num, idx + <span class=\"number\">1</span>, turnedOn - <span class=\"number\">1</span>, res);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">convert</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">hour</span> <span class=\"operator\">=</span> (num &amp; <span class=\"number\">0b1111000000</span>) &gt;&gt; <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">minute</span> <span class=\"operator\">=</span> (num &amp; <span class=\"number\">0b111111</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hour &gt;= <span class=\"number\">12</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minute &gt; <span class=\"number\">59</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    sb.append(hour + <span class=\"string\">&quot;:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minute &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sb.append(minute);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"77-组合\"><a href=\"#77-组合\" class=\"headerlink\" title=\"77. 组合\"></a>77. 组合</h3><p><a href=\"https://leetcode.cn/problems/combinations/description/\">77. 组合</a></p>\n<p>非递归（<strong>字典序法</strong>）实现组合型枚举 <strong>看不懂，好难</strong></p>\n<h3 id=\"40-组合总和-II\"><a href=\"#40-组合总和-II\" class=\"headerlink\" title=\"40. 组合总和 II\"></a>40. 组合总和 II</h3><p>前提：去重一定要排序。</p>\n<p><a href=\"https://leetcode.cn/problems/combination-sum-ii/description/\">40. 组合总和 II</a><br>第一次做要去重的题，我真的麻了，<strong>仅仅是因为不确定局部变量在递归时候的变化</strong>（实际上递归时是会进行<strong>压栈保存环境</strong>的，当你递归出来的时候数据是完全不会变的，看了这么多理论竟然不会用，我真的服了你了），仅仅把preval定成全局的，没有去思考定成局部的数据并付诸行动导致失败，各种尝试都做不出来，离成功就差一点。真的服了你了。</p>\n<p>看看人家的：<br>去重就是，dfs的<strong>同一层第二次遍历到一个数</strong>，那么就是重复的，保证<strong>每一层一种数只会遍历到一次</strong>，又因为进入dfs前数组经过了排序（相同数一定相邻），所以去重只需要在每一层遍历一个数时，判断上一个数是否和当前数相同，相同的话就是重复了，就不需要再对这个数进行递归。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res, vector&lt;<span class=\"type\">int</span>&gt;&amp; temp, vector&lt;<span class=\"type\">int</span>&gt;&amp; candidates, <span class=\"type\">int</span> target, <span class=\"type\">int</span> index, <span class=\"type\">int</span>&amp; sum)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断temp加上当前index的值是否是</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">\t\t\tres.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sum &gt; target) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// preVal是解决会出现重复结果问题</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> preVal = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果sum小于target</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = index; i &lt; candidates.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (candidates[i] != preVal &amp;&amp; (sum + candidates[i]) &lt;= target) &#123;</span><br><span class=\"line\">\t\t\t\tpreVal = candidates[i];</span><br><span class=\"line\">\t\t\t\ttemp.<span class=\"built_in\">push_back</span>(candidates[i]);</span><br><span class=\"line\">\t\t\t\tsum += candidates[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">backtracking</span>(res, temp, candidates, target, i + <span class=\"number\">1</span>, sum);</span><br><span class=\"line\">\t\t\t\tsum -= candidates[i];</span><br><span class=\"line\">\t\t\t\ttemp.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum2</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; candidates, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">\t\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (candidates.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 从小到大排序</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(candidates.<span class=\"built_in\">begin</span>(), candidates.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\tvector&lt;<span class=\"type\">int</span>&gt; temp = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">backtracking</span>(res, temp, candidates, target, <span class=\"number\">0</span>, sum);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看看我的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum2</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        backTrace(candidates, target, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTrace</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> startIdx)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum==target)&#123;</span><br><span class=\"line\">            ans.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(tmp));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">preVal</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startIdx; i&lt;candidates.length &amp;&amp; (sum + candidates[i]) &lt;= target ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(candidates[i]!=preVal)&#123;</span><br><span class=\"line\">                tmp.add(candidates[i]);</span><br><span class=\"line\">                preVal = candidates[i];</span><br><span class=\"line\">                backTrace(candidates, target, sum + candidates[i], i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                tmp.remove(tmp.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这题的去重原理可以看<a href=\"https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\"> 代码随想录</a></p>\n<p>这个去重为什么很难理解呢，所谓去重，其实就是使用过的元素不能重复选取。 这么一说好像很简单！</p>\n<p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是<strong>同一树枝上使用过</strong>（同一子树, 一个子树就是一个集合），一个维度是<strong>同一树层</strong>上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</p>\n<p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p>\n<p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p>\n<p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。其实就是，重复出现的元素，第一次出现的是最好用的，它会把所有有用的集合都包括起来，而后面出现的只会造成重复！</p>\n<p><strong>强调一下，树层去重的话，需要对数组排序</strong>！</p>\n<img src=\"/2024/03/05/LeetCodeNote/3.png\" class=\"\">\n\n<p><strong>讲道理，遇到回溯题，自己把递归树稍微画一下</strong>。</p>\n<p>重点在于区分 “<strong>树层去重</strong>”和“<strong>树枝去重</strong>”。</p>\n<p>妈的还有更狠的：<strong>直接用startIndex来去重</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; result;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; candidates, <span class=\"type\">int</span> target, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> startIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(path);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = startIndex; i &lt; candidates.<span class=\"built_in\">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 要对同一树层使用过的元素进行跳过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum += candidates[i];</span><br><span class=\"line\">            path.<span class=\"built_in\">push_back</span>(candidates[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtracking</span>(candidates, target, sum, i + <span class=\"number\">1</span>); <span class=\"comment\">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class=\"line\">            sum -= candidates[i];</span><br><span class=\"line\">            path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum2</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; candidates, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        path.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        result.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 首先把给candidates排序，让其相同的元素都挨在一起。</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(candidates.<span class=\"built_in\">begin</span>(), candidates.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(candidates, target, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"子集-II\"><a href=\"#子集-II\" class=\"headerlink\" title=\"子集 II\"></a>子集 II</h3><p><a href=\"https://leetcode.cn/problems/subsets-ii/description/\">子集 II</a></p>\n<p><strong>注意子集(子序列)和之前的区别</strong>，之前是不选没关系，直接往下走就可以，等走到底添加结果，相当于<strong>只要叶子节点</strong>，而<strong>子集</strong>在你选或者不选的情况下都需要直接添加进<strong>结果</strong>，也就是所有节点都是我们想要的结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">          List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">          List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">          <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">subsetsWithDup</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">              Arrays.sort(nums);</span><br><span class=\"line\">              ans.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(tmp));</span><br><span class=\"line\">              backTrace(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTrace</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> startIdx)</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(startIdx==nums.length) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startIdx; i&lt;nums.length; i++) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span>(i&gt;startIdx &amp;&amp; nums[i]==nums[i-<span class=\"number\">1</span>])</span><br><span class=\"line\">                      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                  tmp.add(nums[i]);</span><br><span class=\"line\">                  ans.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(tmp)); <span class=\"comment\">// 就是这里</span></span><br><span class=\"line\">                  backTrace(nums, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">                  tmp.remove(tmp.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"491-递增子序列\"><a href=\"#491-递增子序列\" class=\"headerlink\" title=\"491.递增子序列\"></a>491.递增子序列</h3><p><a href=\"https://leetcode.cn/problems/non-decreasing-subsequences/\">491.递增子序列</a><br>真尼玛难啊</p>\n<p>这里不能排序了，所以用 hashset uset 表示这层用过的符合要求的数，这里的符合要求指的是非递减。<br>这种hashset用法也可以用于前面的 子集Ⅱ 题，但是依然需要排序。<br>比如 4 4 1 4 4 4 不排序的话会有 4 1 和 1 4，那为什么这题不需要排序呢。<br>因为这题要求非严格递增，不会有 4 1 ，只会有 1 4。</p>\n<p>去重题看 <a href=\"https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\">代码随想录</a> 讲的确实清楚。<br>关键还是 树层 不能重复。</p>\n<p>唉真是无语了，心累。</p>\n<h3 id=\"46-全排列\"><a href=\"#46-全排列\" class=\"headerlink\" title=\"46. 全排列\"></a>46. 全排列</h3><p><a href=\"https://leetcode.cn/problems/permutations/description/\">46. 全排列</a></p>\n<p>我写了标记数组 ，没想到还有这么秀的解法。<br>要好好理解<strong>递归的变量保存</strong>，<strong>回溯的撤销</strong>操作。<br>这两点很重要。<br><strong>撤销撤销撤销</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">          List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">          <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">              List&lt;Integer&gt; output = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : nums) &#123;</span><br><span class=\"line\">                  output.add(num);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              backTrack(output, <span class=\"number\">0</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTrack</span><span class=\"params\">(List&lt;Integer&gt; nums, <span class=\"type\">int</span> startIdx)</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(startIdx==nums.size()) &#123;</span><br><span class=\"line\">                  ans.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(nums));</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startIdx; i&lt;nums.size(); i++) &#123;</span><br><span class=\"line\">                  Collections.swap(nums, startIdx, i);</span><br><span class=\"line\">                  backTrack(nums, startIdx+<span class=\"number\">1</span>);</span><br><span class=\"line\">                  Collections.swap(nums, startIdx, i);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"全排列-II\"><a href=\"#全排列-II\" class=\"headerlink\" title=\"全排列 II\"></a>全排列 II</h3><p><a href=\"https://leetcode.cn/problems/permutations-ii/description/\">47.全排列 II</a></p>\n<p>目前为止已经遇到了 组合、子集、排列的去重。</p>\n<p>允许排序的题都可以先排序再去重，当然对这题而言也可以不排序的去重也就是用 uset 记录当前树层使用过的数字，但是之前的组合用 uset 的话也得去重，之前讲过了，这题的话因为是全排列所以可以。</p>\n<p>排序去重的话效率肯定更高，这里的话得用标记数组了，不能用之前全排列的优化方法，因为那个方法会改变数字的顺序，排序数组也变乱序数组了。</p>\n<p>排序去重最为关键的代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>] &amp;&amp; used[i - <span class=\"number\">1</span>] == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">如果改成 used[i - <span class=\"number\">1</span>] == <span class=\"literal\">true</span>， 也是正确的!，去重代码如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>] &amp;&amp; used[i - <span class=\"number\">1</span>] == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要对树层中前一位去重，就用used[i - 1] &#x3D;&#x3D; false，如果要对树枝前一位去重用used[i - 1] &#x3D;&#x3D; true。<br>具体可以看 <a href=\"https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%80%9D%E8%B7%AF\">47.全排列 II</a>中的图。</p>\n<h3 id=\"51-N-皇后\"><a href=\"#51-N-皇后\" class=\"headerlink\" title=\"51. N 皇后\"></a>51. N 皇后</h3><p><a href=\"https://leetcode.cn/problems/n-queens/description/\">51. N 皇后</a></p>\n<p>经典回溯，没写出来</p>\n<h3 id=\"37-解数独\"><a href=\"#37-解数独\" class=\"headerlink\" title=\"37. 解数独\"></a>37. 解数独</h3><p><a href=\"https://leetcode.cn/problems/sudoku-solver/description/\">37. 解数独</a></p>\n<p>做出来了。</p>\n<p>有迭代优化，不断循环固定那些只能放一个数字的位置，之后再去回溯。</p>\n<h3 id=\"494-目标和\"><a href=\"#494-目标和\" class=\"headerlink\" title=\"494. 目标和\"></a>494. 目标和</h3><p><a href=\"https://leetcode.cn/problems/target-sum/description/\">494. 目标和</a></p>\n<p>这题最好的做法是转化为0-1背包问题进行求解。</p>\n<p>这里说一个回溯的<strong>注意事项</strong>，困扰了很久。</p>\n<p>首先此背包问题可以转化为一个组合问题，关键在于递归的返回时间。</p>\n<p>如果用的是 for 循环的写法，不能加上判断索引是否走到数组末尾这个条件，表面上没有影响，实际上是有的，会影响那么几个值，调试一下就知道了，因为如果<strong>最后一个数不取</strong>也就是不拿(startIndex-1)能达到target，<strong>不取之后并没有继续调用递归函数，因为for循环到底了</strong>，所以不取最后一个数的结果是没有计入ans的（因为此时startIndex !&#x3D; candidates.length），所以判断不拿是否应该计入ans得在for循环之前判断，而此时startIndex !&#x3D; candidates.length，也就是加入判断索引是否走到数组末尾这个条件确实是会影响的，之前的写法都没有<strong>写这个条件所以能通过</strong>，之前没注意到这个，没想到今天被暴击了。</p>\n<p>并且注意到，反正是组合，达到条件之后自然可以记录下来。</p>\n<p>调试果然还是好用的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findTargetSumWays</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> Arrays.stream(nums).sum() + target;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum&lt;<span class=\"number\">0</span> || sum%<span class=\"number\">2</span>!=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">bagSize</span> <span class=\"operator\">=</span> sum/<span class=\"number\">2</span>;</span><br><span class=\"line\">            backtracking(nums, bagSize, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">backtracking</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> startIndex)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这是错误的，不能多加这个判断</span></span><br><span class=\"line\"><span class=\"comment\">//              if(startIndex == candidates.length) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                  if (sum == target) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                      cnt++;</span></span><br><span class=\"line\"><span class=\"comment\">//                  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//              &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 这是正确的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startIndex; i&lt;candidates.length; i++) &#123;</span><br><span class=\"line\">                sum += candidates[i];</span><br><span class=\"line\">                backtracking(candidates, target, sum, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                sum -= candidates[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//    public int findTargetSumWays(int[] nums, int target) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        int sum = Arrays.stream(nums).sum() + target;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(sum&lt;0 || sum%2!=0) return 0;</span></span><br><span class=\"line\"><span class=\"comment\">//        sum /= 2;</span></span><br><span class=\"line\"><span class=\"comment\">//        int [] dp = new int[sum+1]; // 表示凑到总和为 j 有几种方案</span></span><br><span class=\"line\"><span class=\"comment\">//        dp[0] = 1;</span></span><br><span class=\"line\"><span class=\"comment\">//        for(int i = 0; i&lt;nums.length; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            for(int j = sum; j&gt;=nums[i]; j--) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                dp[j] += dp[j-nums[i]];</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        return dp[sum];</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h2><p>贪心基本都是 O(n)  O(1)</p>\n<h3 id=\"跳跃游戏-II\"><a href=\"#跳跃游戏-II\" class=\"headerlink\" title=\"跳跃游戏 II\"></a>跳跃游戏 II</h3><p><a href=\"https://leetcode.cn/problems/jump-game-ii/solutions/230241/tiao-yue-you-xi-ii-by-leetcode-solution/\">跳跃游戏 II</a><br>有点难，但是能做，迭代有点难看懂。</p>\n<p>关键在于：每次选<strong>能跳最远的那个位置</strong>去跳，别理解成每次跳最远的位置。比如当前位置我能跳到两三个位置，我看从这两三个位置起跳哪个能跳的更远，那这个位置就是局部最优的，当前我就选择跳这个位置。<br>也就是需要统计<strong>两个覆盖范围</strong>，当前这一步的最大覆盖和下一步最大覆盖。</p>\n<p>每次以最大覆盖范围为一次跳跃次数。</p>\n<h3 id=\"406-根据身高重建队列\"><a href=\"#406-根据身高重建队列\" class=\"headerlink\" title=\"406. 根据身高重建队列\"></a>406. 根据身高重建队列</h3><p><a href=\"https://leetcode.cn/problems/queue-reconstruction-by-height/description/\">406. 根据身高重建队列</a></p>\n<p>烂题，烂的要死。</p>\n<p>没做出来</p>\n<h3 id=\"435-无重叠区间\"><a href=\"#435-无重叠区间\" class=\"headerlink\" title=\"435. 无重叠区间\"></a>435. 无重叠区间</h3><p>没做出来 想死</p>\n<p><a href=\"https://leetcode.cn/problems/non-overlapping-intervals/solutions/541543/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/\">435. 无重叠区间</a></p>\n<p>妈的两题都倒在排序上，没有一点思路，怎么回事啊</p>\n<p>我一直想的是移除，实际上反着来才好做，怎样符合题意地去放最多的区间。</p>\n<p>我一直找最早下课的，这样我一天才可能上最多的课。</p>\n<h3 id=\"763-划分字母区间\"><a href=\"#763-划分字母区间\" class=\"headerlink\" title=\"763. 划分字母区间\"></a>763. 划分字母区间</h3><p><a href=\"https://leetcode.cn/problems/partition-labels/description/\">763. 划分字母区间</a></p>\n<p>没用贪心做就是没做出来 ， 废物</p>\n<p>只要记录最远出现的位置，说实话贪心代码都不太好实现。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; S.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">           right = <span class=\"built_in\">max</span>(right, hash[S[i] - <span class=\"string\">&#x27;a&#x27;</span>]); <span class=\"comment\">// 找到字符出现的最远边界</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (i == right) &#123;</span><br><span class=\"line\">               result.<span class=\"built_in\">push_back</span>(right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">               left = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"968-监控二叉树\"><a href=\"#968-监控二叉树\" class=\"headerlink\" title=\"968. 监控二叉树\"></a>968. 监控二叉树</h3><p><a href=\"https://leetcode.cn/problems/binary-tree-cameras/description/\">968. 监控二叉树</a></p>\n<p>这个确实做不来，树dp也看不懂。</p>\n<p>这题的<strong>后序遍历可以由底至上</strong>我知道，输在<strong>定义状态</strong>，<a href=\"https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF\">随想录</a>定义了三个状态在进行状态转移真的舒服很多。</p>\n<p>定义状态真的很重要啊，像之前的线段树，还有很多动规题，定义出好的状态基本就成功了。</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p><a href=\"https://blog.csdn.net/weixin_43294560/article/details/121292475\">动态规划思想</a></p>\n<p>状态设计很重要，有时候状态设计是很难看出来的，没有定义状态也就没办法进行状态转移了。</p>\n<p>第 300 题：「最长上升子序列」 待做</p>\n<p>最后再谈谈状态转移的「无后效性」(当前状态与之后状态无关)</p>\n<p>为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。<br>我的解释：</p>\n<p>「有向无环图」「拓扑序」表示了每一个子问题只求解一次，以后求解问题的过程不会修改以前求解的子问题的结果；<br>换句话说：如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫「有后效性」，我们在当前这个问题第 1 次拆分的子问题就是「有后效性」的（大家可以再翻到上面再看看）；<br>解决「<strong>有后效性</strong>」的办法是<strong>固定住需要分类讨论的地方</strong>，记录下更多的结果。在代码层面上表现为：<br><strong>状态数组增加维度</strong>，例如：「力扣」的股票系列问题；<br>把<strong>状态定义得更细致、准确</strong>，例如：前天推送的第 124 题：状态定义只解决路径来自左右子树的其中一个子树。</p>\n<p>可以看看这篇讲股票系列问题的动规题解<a href=\"https://leetcode.cn/circle/discuss/qiAgHn/\">股票问题系列通解（转载翻译）</a></p>\n<p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「<strong>最优子结构</strong>」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。</p>\n<h3 id=\"判断子序列\"><a href=\"#判断子序列\" class=\"headerlink\" title=\"判断子序列\"></a>判断子序列</h3><p><a href=\"https://leetcode.cn/problems/is-subsequence/solutions/346539/pan-duan-zi-xu-lie-by-leetcode-solution/\">392. 判断子序列</a><br>判断 s 是否是 t 的子序列。</p>\n<p>本质就是对 s 中每一个字符，在 t 中寻找下一个匹配字符，这也是时间复杂度的主要来源，当要匹配的子串 s 很多的时候，重复工作很多，所以可以尝试用动态规划的思想对母串 t 做预处理。</p>\n<p>我们可以预处理出对于 t 的每一个位置(0~t.length-1)，从该位置开始往后每一个字符(a,b,c,…,z)第一次出现的位置(只需要记录第一次出现的位置即可，不需要更新也不能更新)，所以预处理数组dp[t.length][26]是一个二维数组。</p>\n<p>令 dp[idx][c] 表示从 idx 位置开始字符 c (也就是当前匹配到的s中的字符)第一次出现的索引，<strong>状态转移</strong>是：<br>如果 dp[idx] 处的字符就是 c ，则 dp[idx][c] &#x3D; idx ，否则 dp[idx][c] &#x3D; dp[idx+1][c]，因为 c 没在 idx 位置，那么 c 一定在 (idx+1) 位置或之后的位置，也就是 dp[idx+1][c]。</p>\n<p>状态转移表示 前面的状态要由后面的状态而来，所以动态规划应该倒过来，由底至上。<br>底部就是 dp[t.length-1][c]，如果在 t.length-1 位置出现了字符 c ，则dp[t.length-1][c] &#x3D; t.length-1，其余的 25个字符不会再出现，dp值会等于 dp[t.length][c]，所以我们建的二维数组应该是 (t.length+1)*26 的，让边界也能进行状态转移，并且 dp[t.length][…] 应该初始化为让我们能够判断这个字符不存在的索引，比如就是t.length。<br>在遍历 s 中字符的时候，如果发现这个字符在 t 中的索引是 t.length ，则说明 s 并不是 t 的子序列，能够遍历完成则成功。</p>\n<p>匹配过程就是直接dp[idx][s.charAt(j)]跳到这个字符所在的索引。</p>\n<p>预处理的时间是固定的，并且之后匹配每一个 s 的时间复杂度都是 O(s.length)，所以当s数目很多的时候也可以完成匹配。</p>\n<p>注意先判断这个字符所在的索引是不是t.length，不是的话索引更新为idx &#x3D; dp[idx][c]+1用来匹配下一个字符(因为dp[idx][c]已经和这一个字符匹配了)，如果没有这个+1一定错。</p>\n<h3 id=\"比特位计数-1\"><a href=\"#比特位计数-1\" class=\"headerlink\" title=\"比特位计数\"></a>比特位计数</h3><p><a href=\"https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/\">338. 比特位计数</a></p>\n<p>三种动规都很好理解。</p>\n<h3 id=\"53-最大子数组和\"><a href=\"#53-最大子数组和\" class=\"headerlink\" title=\"53. 最大子数组和\"></a>53. 最大子数组和</h3><p><a href=\"https://leetcode.cn/problems/maximum-subarray/description/\">53. 最大子数组和</a></p>\n<p><a href=\"https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/\">前缀和解法</a></p>\n<p>要边维护最小前缀和一边求答案，不能求出最大、最小前缀和再算差值，因为最小前缀和可能会出现在最大前缀和后面，我就是犯了这个错误一直写不出来。<br>并且前缀和要初始化为0，并且 curSum 加上当前值之后才能与 minPreSum 相减，因为子数组至少要有一个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">curSum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">minPreSum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> n : nums) &#123;</span><br><span class=\"line\">    curSum += n;</span><br><span class=\"line\">    ans = Math.max(ans, curSum-minPreSum);</span><br><span class=\"line\">    minPreSum = Math.min(minPreSum, curSum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans;</span><br></pre></td></tr></table></figure>\n\n<p>第一次接触到 <a href=\"https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/\">线段树</a><br><strong>这个线段树很有意思</strong> ，维护四个变量，合并过程也很有趣</p>\n<p><strong>线段树区间合并法</strong>解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」</p>\n<h3 id=\"376-摆动序列\"><a href=\"#376-摆动序列\" class=\"headerlink\" title=\"376. 摆动序列\"></a>376. 摆动序列</h3><p><a href=\"https://leetcode.cn/problems/wiggle-subsequence/solutions/518296/bai-dong-xu-lie-by-leetcode-solution-yh2m/\">376. 摆动序列</a></p>\n<p>这个动规解释的很好 </p>\n<p>定义双状态，两个状态之间进行转移，不同于以前见到的只有一个状态。<br>上升摆动序列<br>下降摆动序列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">wiggleMaxLength_2</span> <span class=\"operator\">=</span> function (nums) &#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">\t<span class=\"comment\">//! up[i] 记录以i截止的上升摆动的最大长度</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"variable\">up</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).fill(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//! down[i] 记录以i截止的下降摆动的最大长度</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"variable\">down</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).fill(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tup[<span class=\"number\">0</span>] = down[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">let</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nums[i] &gt; nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//! 上升摆动：</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//情况1：连续的上升，不用当前元素，沿用之前的上升摆动长度值</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//情况2：下降过程，从上一个下降摆动过来 + 当前元素 成为上升摆动</span></span><br><span class=\"line\">\t\t\tup[i] = Math.max(up[i - <span class=\"number\">1</span>], down[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//! 此过程是上升摆动，所以下降摆动未变化，所以沿用之前的值</span></span><br><span class=\"line\">\t\t\tdown[i] = down[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i] &lt; nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//! 下降摆动：</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//情况1：连续的下降，不用当前元素，沿用之前的下降摆动长度</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//情况2: 下降过程，由上一个上升摆动过来 + 当前元素 成为下降摆动</span></span><br><span class=\"line\">\t\t\tdown[i] = Math.max(down[i - <span class=\"number\">1</span>], up[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//! 此过程是下降摆动，所以上升摆动未变化，所以沿用之前的值</span></span><br><span class=\"line\">\t\t\tup[i] = up[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//!既不是上升也不是下降，直接沿用直接的值 </span></span><br><span class=\"line\">\t\t\tup[i] = up[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\tdown[i] = down[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Math.max(up[n - <span class=\"number\">1</span>], down[n - <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><img src=\"/2024/03/05/LeetCodeNote/4.png\" class=\"\">\n\n<p><strong>0-1背包问题</strong>讲解见 <a href=\"https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html\">代码随想录</a></p>\n<p>在一维dp中很重要的一点就是遍历的顺序，首先，最外层应该是待放物品，这是最基本的<strong>保证物品只取一次</strong>的要求，其二，<strong>内层循环应该倒序</strong>，因为：在dp数组更新的时候是用上一层的<strong>左边索引处的值</strong>来更新当前层<strong>当前索引处</strong>的值，如果正序的话，那每个左边索引值都给你改成新值，还是错的，当前索引值有可能是对的么？</p>\n<p>上面两个坑我都踩过了，卡哥还是牛。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\">        dp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>完全背包问题讲解</strong><br>01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。<br>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先遍历物品，再遍历背包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\">        dp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒的，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</p>\n<p>在<strong>完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓</strong>的！</p>\n<p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要<strong>保证下标j之前的dp[j]都是经过计算的新值</strong>就可以了。</p>\n<p>对于纯完全背包问题，其for循环的先后循环是可以颠倒的！</p>\n<p>但如果题目稍稍有点变化，就会体现在遍历顺序上。</p>\n<p>如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了。</p>\n<h4 id=\"416-分割等和子集\"><a href=\"#416-分割等和子集\" class=\"headerlink\" title=\"416. 分割等和子集\"></a>416. 分割等和子集</h4><p><a href=\"https://leetcode.cn/problems/partition-equal-subset-sum/description/\">416. 分割等和子集</a></p>\n<p>至于上面说到的 “在dp数组更新的时候是用上一层的<strong>左边索引处的值</strong>来更新当前层<strong>当前索引处</strong>的值” ，到底什么时候用左边更新当前，什么时候用右边更新当前呢？<br><strong>还得看题意</strong>。</p>\n<p>以本题为例：如果设dp[0] &#x3D; true，慢慢更新到dp[sum]判断是否等于 true ，翻译过来就是用数组里的数能不能叠加到 sum，那很明显从索引0-&gt;sum自然就是以左更新右。<br>此时要用dp左边更新dp右边，所以肯定是先改右边的数再去改左边的数，即逆序。</p>\n<p>我也可以这么看：设dp[sum] &#x3D; true，慢慢更新到dp[0]判断是否等于 true ，翻译过来就是我能不能用 sum 去减数组的数，最终减到0，从索引sum-&gt;0自然就是以右更新左。<br>此时要用dp右边更新dp左边，所以肯定是先改左边的数再去改右边的数，即正序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPartition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> Arrays.stream(nums).sum();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum%<span class=\"number\">2</span>!=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        sum /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> [] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[sum+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 以左更新右</span></span><br><span class=\"line\"><span class=\"comment\">//        dp[0] = true;</span></span><br><span class=\"line\"><span class=\"comment\">//        for(int i = 0; i&lt;nums.length; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            for(int j = sum; j&gt;=nums[i]; j--) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                dp[j] |= dp[j-nums[i]];</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 以右更新左</span></span><br><span class=\"line\">        dp[sum] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j&lt;=sum-nums[i]; j++) &#123;</span><br><span class=\"line\">                dp[j] |= dp[j+nums[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1049-最后一块石头的重量-II\"><a href=\"#1049-最后一块石头的重量-II\" class=\"headerlink\" title=\"1049. 最后一块石头的重量 II\"></a>1049. 最后一块石头的重量 II</h4><p><a href=\"https://leetcode.cn/problems/last-stone-weight-ii/description/\">1049. 最后一块石头的重量 II</a></p>\n<p>这个讲的也不错</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路：</span></span><br><span class=\"line\"><span class=\"comment\">// 动态规划：01背包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0.分析：</span></span><br><span class=\"line\"><span class=\"comment\">// 我们由题目可以知道经过n次粉碎后，最终最多只会剩下1个石头，并且我们需要让最后一块石头的质量最小</span></span><br><span class=\"line\"><span class=\"comment\">// 我们继续分析可以发现（关键）：我们可以将这一堆石头分成两堆（heap1和heap2）</span></span><br><span class=\"line\"><span class=\"comment\">// 我们不妨设 heap1总质量 &gt;= heap2总质量，而最后的结果就是heap1 - heap2，我们只需要保证heap1 - heap2最小即可</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0.1 如何计算：</span></span><br><span class=\"line\"><span class=\"comment\">// 我们可以先求出这一堆石头的总质量sum，</span></span><br><span class=\"line\"><span class=\"comment\">// 而sum = heap1 + heap2    （heap1 &gt; heap2）</span></span><br><span class=\"line\"><span class=\"comment\">// heap1 - heap2 = sum - 2 * heap2</span></span><br><span class=\"line\"><span class=\"comment\">// 要求heap1 - heap2 的最小值，就可以转化成求sum - 2 * heap2 的最小值，</span></span><br><span class=\"line\"><span class=\"comment\">// 也就转化成了求 2 * heap2 的最大值，也就是求heap2的最大值（前提：sum - 2 * heap2 &gt;= 0 等价于 heap2 &lt;= sum / 2）</span></span><br><span class=\"line\"><span class=\"comment\">// 那么就转化成了01背包问题：背包的最大容量为 sum / 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.状态表示：f[i][j]</span></span><br><span class=\"line\"><span class=\"comment\">// 1.1 集合划分：i表示前i个石头，j表示背包最大容量；f[i][j]就表示前i个数，容量为j的背包能装下的石头最大质量</span></span><br><span class=\"line\"><span class=\"comment\">// （注意：此题的石头体积与石头质量都是stones[i]）</span></span><br><span class=\"line\"><span class=\"comment\">// 1.2 属性（一般为最大值、最小值、数量）：最大值</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.状态计算：</span></span><br><span class=\"line\"><span class=\"comment\">// 2.1 f[i][j]可以表示成f[i - 1][j]，表示不加上当前第i块石头的背包最大质量</span></span><br><span class=\"line\"><span class=\"comment\">// 2.2 f[i][j]还可以表示成f[i - 1][j - stones[i]] + stones[i]，表示加上第i块石头后背包最大质量</span></span><br><span class=\"line\"><span class=\"comment\">// 2.3 所以最后总和为j的所有方案为：f[i][j] = max(f[i - 1][j] + f[i - 1][j - stones[i]] + stones[i])</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.优化：</span></span><br><span class=\"line\"><span class=\"comment\">// 通过滚动数组可以将二维数组优化成一维数组：f[i][j] --&gt; f[j] </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lastStoneWeightII</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = stones.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> s : stones) sum += s;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">f</span><span class=\"params\">(sum / <span class=\"number\">2</span> + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span> ; i &lt; n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = sum / <span class=\"number\">2</span>; j &gt;= stones[i]; --j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                f[j] = <span class=\"built_in\">max</span>(f[j], f[j - stones[i]] + stones[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum - <span class=\"number\">2</span> * f[sum / <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"518-零钱兑换-II\"><a href=\"#518-零钱兑换-II\" class=\"headerlink\" title=\"518. 零钱兑换 II\"></a>518. 零钱兑换 II</h4><p><a href=\"https://leetcode.cn/problems/coin-change-ii/description/\">518. 零钱兑换 II</a></p>\n<p>纯完全背包问题由于并不限制数组只取一次，所以内外循环没有额外要求，但某些情况除外！因为纯完全背包问题求的是最大价值，多余的排列并不影响这个值，但是影响计数！</p>\n<p>不限制数目，所以是一个完全背包问题，但要注意的本题求的是组合数。<br>做法就是固定硬币的顺序，让外层循环遍历数组 coins 的值，内层循环遍历背包的大小，这样在求出 dp[i]的时候，该金额对应的硬币面额的顺序就固定了，因此不会计算重复的排列。<br>如 coins &#x3D; [1,2]，对于 dp[3] 的计算，因为先遍历面额 1 再遍历面额 2，所以不会出现2+1的组合，只有1+1+1 和 1+2的组合。</p>\n<p>反之，如果两个循环遍历颠倒，外层循环遍历背包的大小，内层循环遍历数组 coins 的值，则因为每个dp[i]都去尝试各个硬币值，一定会出现重复的排列，如coins &#x3D; [2，3，5]，对于 dp[5] &#x3D; 2+3 和 3+2，这就是区别。</p>\n<h4 id=\"377-组合总和-Ⅳ\"><a href=\"#377-组合总和-Ⅳ\" class=\"headerlink\" title=\"377. 组合总和 Ⅳ\"></a>377. 组合总和 Ⅳ</h4><p><a href=\"https://leetcode.cn/problems/combination-sum-iv/description/\">377. 组合总和 Ⅳ</a></p>\n<p>刚好，上一题是组合，这一题考的是排列，很明显，只要更换内外层循环的顺序即可。</p>\n<p>外层循环遍历从 1 到 target 的每个值，内层循环遍历数组 nums 的值，外层的每个值作为一个总和计算 dp[i] 时要考虑以 nums 的每一个小于等于 i 的数作为排列的最后一个元素的情况，将这些情况加起来作为当前的排列数。<br>如：以 nums&#x3D;{2,3,5} 为例，计算 dp[5]时会以 2 为结尾，以 3 为结尾，所以dp[5] &#x3D; dp[3]+dp[2]。动手模拟下也能发现。</p>\n<h4 id=\"背包总结\"><a href=\"#背包总结\" class=\"headerlink\" title=\"背包总结\"></a>背包总结</h4><p>背包的递推公式比较容易，难在遍历顺序上，把遍历顺序摸透，才算是真正理解背包。</p>\n<p>一维 dp 数组 <strong>01背包</strong> 只能先遍历物品再遍历背包容量（因为每个物品只有一个），且第二层for循环是从大到小遍历（因为要用dp数组左边的旧值更新当前的值，所以只能从右往左更新）。</p>\n<p>一维 dp 数组 <strong>纯完全背包</strong>先遍历物品还是先遍历背包都是可以的（因为纯完全背包求得是最大价值，求排列还是组合并不影响），且第二层for循环是从小到大遍历（因为每个物品可以取无限次）。</p>\n<p><strong>完全背包</strong>如果求<strong>组合数</strong>就是<strong>外层</strong>for循环<strong>遍历物品</strong>，<strong>内层</strong>for<strong>遍历背包</strong>（固定物品的顺序）。</p>\n<p><strong>完全背包</strong>如果求<strong>排列数</strong>就是<strong>外层</strong>for<strong>遍历背包</strong>，<strong>内层</strong>for循环<strong>遍历物品</strong>（不固定物品顺序）。</p>\n<h3 id=\"打家劫舍\"><a href=\"#打家劫舍\" class=\"headerlink\" title=\"打家劫舍\"></a>打家劫舍</h3><p><a href=\"https://leetcode.cn/problems/house-robber-iii/description/\">198.打家劫舍</a></p>\n<p>动态规划经典题，有扩展。</p>\n<p>关键就在于 <strong>考虑</strong>这个关键字。</p>\n<p>如果偷当前 i 这个房间，则 i-1不能考虑，注意，考虑不代表一定偷，偷不偷由遍历过程中的max来决定，保证取最大值。</p>\n<p>也就是 <code>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</code></p>\n<h3 id=\"树-dp\"><a href=\"#树-dp\" class=\"headerlink\" title=\"树 dp\"></a>树 dp</h3><p>目前做到的树 dp 都是<strong>用数组作为容器储存状态</strong>，就像之前提过的，问题复杂时可以用更多的状态来实现动态规划。</p>\n<h4 id=\"968-监控二叉树-1\"><a href=\"#968-监控二叉树-1\" class=\"headerlink\" title=\"968. 监控二叉树\"></a>968. 监控二叉树</h4><p><a href=\"https://leetcode.cn/problems/binary-tree-cameras/description/\">968. 监控二叉树</a></p>\n<h4 id=\"337-打家劫舍-III\"><a href=\"#337-打家劫舍-III\" class=\"headerlink\" title=\"337. 打家劫舍 III\"></a>337. 打家劫舍 III</h4><p><a href=\"https://leetcode.cn/problems/house-robber-iii/description/\">337. 打家劫舍 III</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> traversal(root)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span>[] traversal(TreeNode root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] status = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span> [<span class=\"number\">2</span>]; <span class=\"comment\">// 不考虑自身时能获得的最大值，考虑自身时能获得的最大值</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] left = traversal(root.left);</span><br><span class=\"line\">        <span class=\"type\">int</span>[] right = traversal(root.right);</span><br><span class=\"line\">        status[<span class=\"number\">0</span>] = left[<span class=\"number\">1</span>]+right[<span class=\"number\">1</span>];</span><br><span class=\"line\">        status[<span class=\"number\">1</span>] = Math.max( left[<span class=\"number\">1</span>]+right[<span class=\"number\">1</span>], root.val+left[<span class=\"number\">0</span>]+right[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"股票问题\"><a href=\"#股票问题\" class=\"headerlink\" title=\"股票问题\"></a>股票问题</h3><p>股票问题常常<strong>增加状态的维度</strong></p>\n<p><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/\">123. 买卖股票的最佳时机 III</a><br>这题比较难，很关键的一点就在于一定要<strong>定义清楚状态</strong>，不能把第一次交易和第二次交易混在一起，第二次交易一定是在第一次交易结束的时候进行的。</p>\n<h3 id=\"300-最长递增子序列\"><a href=\"#300-最长递增子序列\" class=\"headerlink\" title=\"300. 最长递增子序列\"></a>300. 最长递增子序列</h3><p>这题的贪心解法很有意思，也很难想。</p>\n<p><a href=\"https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/\">最长递增子序列</a></p>\n<p>贪在让子序列最后一个元素最小，让 minTail[i] 为所有长度为 i 的子序列中最小的尾元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 贪心</span></span><br><span class=\"line\">        <span class=\"comment\">// minTail</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] minTail = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        minTail[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;minTail[len-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                minTail[len++] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> find(minTail,<span class=\"number\">0</span>,len-<span class=\"number\">1</span>,nums[i]);</span><br><span class=\"line\">                minTail[idx+<span class=\"number\">1</span>] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span>[] array, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start&lt;end) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (end-start+<span class=\"number\">1</span>)/<span class=\"number\">2</span>+start;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(array[mid]&lt;num) &#123;</span><br><span class=\"line\">                start = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                end = mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array[start]&gt;=num) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"字符串二维-dp\"><a href=\"#字符串二维-dp\" class=\"headerlink\" title=\"字符串二维 dp\"></a>字符串二维 dp</h3><h4 id=\"1143-最长公共子序列\"><a href=\"#1143-最长公共子序列\" class=\"headerlink\" title=\"1143.    最长公共子序列\"></a>1143.    最长公共子序列</h4><p>拼多多一面原题</p>\n<p><a href=\"https://leetcode.cn/problems/longest-common-subsequence/description/\">1143.    最长公共子序列</a></p>\n<p>明明<a href=\"https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/\">718. 最长重复子数组</a>一下就写出来了，这题基本一样写老半天。</p>\n<p>这种题就得动态规划做，整那种花里胡哨的就等死吧。</p>\n<p>和以前做的题很不一样的是这种<strong>匹配问题</strong>关键就是这种都是 <strong>二维dp</strong>。</p>\n<p>状态转移的关键不再是判断一维状态是否相等了，而是二维各自的元素是否相等了，一共两种状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestCommonSubsequence</span><span class=\"params\">(String s1, String s2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> s1.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> s2.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> [][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n1+<span class=\"number\">1</span>][n2+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i&lt;n1; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j&lt;n2; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s1.charAt(i)==s2.charAt(j)) &#123;</span><br><span class=\"line\">                    dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = Math.max(dp[i][j+<span class=\"number\">1</span>], dp[i+<span class=\"number\">1</span>][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = Math.max(ans, dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"72-编辑距离\"><a href=\"#72-编辑距离\" class=\"headerlink\" title=\"72. 编辑距离\"></a>72. 编辑距离</h4><p><a href=\"https://leetcode.cn/problems/edit-distance/description/\">72. 编辑距离</a><br>编辑距离算法被数据科学家广泛应用，是用作机器翻译和语音识别评价标准的基本算法。</p>\n<p><strong>编辑距离</strong>是一系列经典题目，很多<strong>二维dp</strong>题都由编辑距离改编而来，重中之重。</p>\n<p>这题的关键在于 虽然说是让 word1 向 word2 靠齐，也就是字面意义的 word2 不能改，但在逻辑上是可以改的，word1 插入一个最合适的数等效于 word2 删除一个数，毕竟在 dp 过程中是肯定不能在word1 显式插入一个数字的。</p>\n<p>妈的就倒在这了，只考虑word1删除和替换元素，甚至考虑到如果 word1 比 word2 短就反过来执行程序。</p>\n<p>唉，so close。</p>\n<p>关键：对两个单词计算编辑距离，<strong>插入与删除等价</strong>！</p>\n<p>这样一来，本质不同的操作实际上只有三种：<br>在单词 A 中删除一个字符；<br>在单词 B 中删除一个字符；<br>修改单词 A&#x2F;B 的一个字符。</p>\n<h4 id=\"回文-dp\"><a href=\"#回文-dp\" class=\"headerlink\" title=\"回文 dp\"></a>回文 dp</h4><p><a href=\"https://leetcode.cn/problems/longest-palindromic-substring/description/\">5. 最长回文子串</a> 许多回文题基本都很相似，可以用 dp 做， 也可以用 中心扩展法（双指针法）做，还有 Manacher 算法。</p>\n<p><strong>中心扩展法</strong> 空间性能比 DP 更好，关键就是 首先回文串要么是偶数长度要么是奇数长度，而区分不同回文串的要点除了回文串的内容，还有就是回文串的中心（这个中心更具体地是指中心在原字符串中所处的位置），因为当回文中心不一样时<strong>也算不同的回文子串</strong>，计算 <strong>回文子串数目</strong> 或者 <strong>回文子串长度</strong> 都是不影响的。</p>\n<p>那接下要做的就是遍历所有的回文中心，获得这个中心能向外扩展得到的偶数长奇数长回文子串，故谓<strong>中心扩展</strong>。当然这里的回文中心是广义的，因为偶数长回文子串肯定是由起始长度为2的回文中心向外扩展而来的。</p>\n<p>写法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j&lt;=<span class=\"number\">1</span>; j++) &#123;  <span class=\"comment\">// j 为0， 奇数长； j 为1， 偶数长</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> i+j;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&gt;=<span class=\"number\">0</span> &amp;&amp; r&lt;n &amp;&amp; ch[l]==ch[r]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-l+<span class=\"number\">1</span>&gt;maxLen) &#123;</span><br><span class=\"line\">                left = l;</span><br><span class=\"line\">                right = r;</span><br><span class=\"line\">                maxLen = r-l+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l--;</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"97-交错字符串\"><a href=\"#97-交错字符串\" class=\"headerlink\" title=\"97. 交错字符串\"></a>97. 交错字符串</h4><p><a href=\"https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&envId=top-interview-150\">97. 交错字符串</a> 真难阿，好久没遇到写不出来的中等题了。唉悲伤</p>\n<h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><p>什么时候用单调栈呢？</p>\n<p>通常是一维数组，要<strong>寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置</strong>，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。</p>\n<h3 id=\"654-最大二叉树\"><a href=\"#654-最大二叉树\" class=\"headerlink\" title=\"654. 最大二叉树\"></a>654. 最大二叉树</h3><p><a href=\"https://leetcode.cn/problems/maximum-binary-tree/solutions/1/zhua-wa-mou-si-by-muse-77-myd7/\">图解</a>讲的很清楚</p>\n<p>这题用单调栈<br><strong>边遍历数组边构造树只遍历一次</strong>，真的太精妙了。<br>感觉关键就在于：<br>1、有大小的比较<br>2、入栈元素可能是我的右节点，也可能我(栈顶)或者我下面的一些都属于它的左子树。一切都是根据大小的比较。<br>最难的就是想到边形成单调栈边构造，我一直以为单调栈是生成完了才用，和单调队列一样。</p>\n<h3 id=\"下一个更大元素-I\"><a href=\"#下一个更大元素-I\" class=\"headerlink\" title=\"下一个更大元素 I\"></a>下一个更大元素 I</h3><p><a href=\"https://leetcode.cn/problems/next-greater-element-i/description/\">496. 下一个更大元素 I</a></p>\n<p>自己写出单调栈了哈哈</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElement(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; hmap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;Integer&gt; stk = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> tmp;</span><br><span class=\"line\">        <span class=\"type\">int</span> [] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i&lt; nums2.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stk.empty() &amp;&amp; stk.peek()&lt;nums2[i]) &#123;</span><br><span class=\"line\">                tmp = stk.pop();</span><br><span class=\"line\">                hmap.put(tmp, nums2[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stk.push(nums2[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i&lt; nums1.length; i++) &#123;</span><br><span class=\"line\">            ans[i] = hmap.containsKey(nums1[i])? hmap.get(nums1[i]) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"739-每日温度\"><a href=\"#739-每日温度\" class=\"headerlink\" title=\"739. 每日温度\"></a>739. 每日温度</h3><p><a href=\"https://leetcode.cn/problems/daily-temperatures/description/\">739. 每日温度</a></p>\n<p>第一次做到<strong>存储下标</strong>的，之前都是直接存储数，还是看需求的，必须这题的需求就是两个数索引的差。</p>\n<h3 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h3><p><a href=\"https://leetcode.cn/problems/trapping-rain-water/description/\">42. 接雨水</a> 一开始我是用类dp法写的，比较简单。</p>\n<p>这题的单调栈法很不错，有种一层层往上加的感觉，原理就是栈里保存比栈顶大的，然后遍历过程中遇到比当前栈顶大的，那么对这个栈顶来说就已经是一个坑了，可以装水。</p>\n<p>双指针法有点难，关键是只需要知道左右两边比自己高的两个柱子中比较低的一个，所以当左边&#x2F;右边出现了一个比现在明确的真正意义上的右边&#x2F;左边最大高度柱子时，当前位置能接的水量也就知道了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = height.length - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">leftMax</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, rightMax = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">    leftMax = Math.max(leftMax, height[left]);</span><br><span class=\"line\">    rightMax = Math.max(rightMax, height[right]);</span><br><span class=\"line\">    <span class=\"comment\">// 对 left 来说，leftMax 是明确的真正意义上的左边最大高度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class=\"line\">        ans += leftMax - height[left];</span><br><span class=\"line\">        ++left;</span><br><span class=\"line\">    <span class=\"comment\">// 对 right 来说，rightMax 是明确的真正意义上的左边最大高度</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ans += rightMax - height[right];</span><br><span class=\"line\">        --right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"84-柱状图中最大的矩形\"><a href=\"#84-柱状图中最大的矩形\" class=\"headerlink\" title=\"84. 柱状图中最大的矩形\"></a>84. 柱状图中最大的矩形</h3><p><a href=\"https://leetcode.cn/problems/largest-rectangle-in-histogram/description/\">84. 柱状图中最大的矩形</a></p>\n<p>看看<a href=\"https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/2749284/dan-diao-zhan-by-iridescent-zhang-33zk/\">我的题解</a></p>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><p><a href=\"https://wansuanfa.com/index.php/816\">图的遍历</a> 讲的不错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// N叉树</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfsTree</span><span class=\"params\">(Tree root)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 访问当前节点，不一定放在这，也可以放到其他地方</span></span><br><span class=\"line\">    System.out.println(root.val);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; root.子节点个数; i++) &#123;</span><br><span class=\"line\">        dfsTree(root.第i个子节点);</span><br><span class=\"line\">        <span class=\"comment\">// 如果需要回溯，这里要撤销选择</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于矩阵的访问我们可以把它看做是一棵 4 叉树的前序遍历</span></span><br><span class=\"line\"><span class=\"comment\">// 如果是矩阵，需要访问和他挨着的上下左右4个方向，(x,y)是当前位置的坐标。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfsMatrix</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix, <span class=\"type\">boolean</span>[][] visited, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先不能越界。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= matrix.length || y &lt; <span class=\"number\">0</span> || y &gt;= matrix[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前位置被访问过，就不要在重复访问，直接跳过。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[x][y])</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    visited[x][y] = <span class=\"literal\">true</span>;<span class=\"comment\">// 先标记，表示当前位置被访问过。</span></span><br><span class=\"line\">    <span class=\"comment\">// 访问当前位置的上下左右4个方向，也可以像BFS中使用for循环来访问他的4个方向。</span></span><br><span class=\"line\">    dfsMatrix(matrix, visited, x - <span class=\"number\">1</span>, y);<span class=\"comment\">//上</span></span><br><span class=\"line\">    dfsMatrix(matrix, visited, x + <span class=\"number\">1</span>, y);<span class=\"comment\">//下</span></span><br><span class=\"line\">    dfsMatrix(matrix, visited, x, y - <span class=\"number\">1</span>);<span class=\"comment\">//左</span></span><br><span class=\"line\">    dfsMatrix(matrix, visited, x, y + <span class=\"number\">1</span>);<span class=\"comment\">//右</span></span><br><span class=\"line\">    <span class=\"comment\">// 递归之后还要往回走，如果需要回溯这个位置要还原，</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果不需要回溯，下面这行代码就不要写。</span></span><br><span class=\"line\">    visited[x][y] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>广搜： 广搜的搜索方式就适合于解决<strong>两个点之间的最短路径</strong>问题。</p>\n<p>因为广搜是从<strong>起点出发</strong>，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p>\n<p>当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，这类问题的特征就是不涉及具体的遍历方式，只要能把<strong>相邻且相同属性的节点标记上</strong>就行。</p>\n<p><strong>只要BFS只要搜到终点(搜到的一瞬间)一定是一条最短路径</strong>，不管有没有障碍。DFS 应该是需要遍历完所有的路径并维护最短路径。</p>\n<p>一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历？</p>\n<p>很多网上的资料都是直接说用队列来实现。</p>\n<p>其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。</p>\n<p>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。</p>\n<p>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p>\n<p>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。</p>\n<p>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</p>\n<p>那么广搜需要<strong>注意转圈搜索的顺序</strong>吗？ <strong>不需要</strong>！</p>\n<p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以。</p>\n<h3 id=\"200-岛屿数量\"><a href=\"#200-岛屿数量\" class=\"headerlink\" title=\"200. 岛屿数量\"></a>200. 岛屿数量</h3><p><strong>flood fill</strong> 算法，水漫算法，相当于用每种颜色填充每一个连通块。</p>\n<p><a href=\"https://leetcode.cn/problems/number-of-islands/description/\">200. 岛屿数量</a> 好难</p>\n<p>难在想到每次处理一个岛屿，只处理所有连成一片的 1 。</p>\n<p>广搜难在需要注意到：是加入队列时进行标记访问过这个点，而不是出队的时候进行标记。<br>这取决于我们对 代码中队列的定义，<strong>队列中的节点就表示已经走过的节点</strong>。 所以<strong>只要加入队列，立即标记该节点走过</strong>。</p>\n<h4 id=\"并查集解法\"><a href=\"#并查集解法\" class=\"headerlink\" title=\"并查集解法\"></a>并查集解法</h4><p>已经完全解析了，看注释吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UnionFind</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> count;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UnionFind</span><span class=\"params\">(<span class=\"type\">char</span>[][] grid)</span> &#123;</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> grid.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        parent = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m * n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    parent[i * n + j] = i * n + j;</span><br><span class=\"line\">                    ++count;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 路径压缩</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">union</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootx</span> <span class=\"operator\">=</span> find(x);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rooty</span> <span class=\"operator\">=</span> find(y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootx != rooty) &#123;  <span class=\"comment\">// 不在一个集合，如果已经在一个集合的话不会再次操作，也就不会再次减 count</span></span><br><span class=\"line\">            parent[rootx] = rooty;</span><br><span class=\"line\">            --count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getCount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;  <span class=\"comment\">// 比如总共五个 1 ，会拉四个集合，每拉一个 union count 自减一次，所以能得到岛屿数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numIslands</span><span class=\"params\">(<span class=\"type\">char</span>[][] grid)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (grid == <span class=\"literal\">null</span> || grid.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nr</span> <span class=\"operator\">=</span> grid.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nc</span> <span class=\"operator\">=</span> grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num_islands</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">UnionFind</span> <span class=\"variable\">uf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnionFind</span>(grid);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; r &lt; nr; ++r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; c &lt; nc; ++c) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (grid[r][c] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                grid[r][c] = <span class=\"string\">&#x27;0&#x27;</span>;  <span class=\"comment\">// 减少一点 union 操作次数，对结果不影响 </span></span><br><span class=\"line\">                <span class=\"comment\">// 换句话说是表示这个 1 已经完成了它的使命，把所有与它相连的 1 都拉到集合里面了，这些 1 后面没必要再访问它</span></span><br><span class=\"line\">                <span class=\"comment\">// 当然，由于集合的性质，不改为0，后面访问了也没关系，count不会再减了</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; grid[r-<span class=\"number\">1</span>][c] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    uf.union(r * nc + c, (r-<span class=\"number\">1</span>) * nc + c);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r + <span class=\"number\">1</span> &lt; nr &amp;&amp; grid[r+<span class=\"number\">1</span>][c] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    uf.union(r * nc + c, (r+<span class=\"number\">1</span>) * nc + c);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; grid[r][c-<span class=\"number\">1</span>] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    uf.union(r * nc + c, r * nc + c - <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c + <span class=\"number\">1</span> &lt; nc &amp;&amp; grid[r][c+<span class=\"number\">1</span>] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    uf.union(r * nc + c, r * nc + c + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> uf.getCount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><p>并查集常用来解决<strong>连通性问题</strong>。</p>\n<p>大白话就是当我们需要<strong>判断两个元素是否在同一个集合</strong>里的时候，我们就要想到用并查集。</p>\n<p>并查集主要有两个功能：</p>\n<p>将两个元素添加到一个集合中。<br>判断两个元素在不在同一个集合</p>\n<p><a href=\"https://programmercarl.com/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html\">并查集理论基础</a> 讲的不错</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">1005</span>; <span class=\"comment\">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; parent = vector&lt;<span class=\"type\">int</span>&gt; (n, <span class=\"number\">0</span>); <span class=\"comment\">// C++里的一种数组结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并查集初始化</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        parent[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 并查集里寻根的过程  Java 写法</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断 u 和 v是否找到同一个根</span></span><br><span class=\"line\">bool <span class=\"title function_\">isSame</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> v)</span> &#123;</span><br><span class=\"line\">    u = find(u);</span><br><span class=\"line\">    v = find(v);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> u == v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将v-&gt;u 这条边加入并查集</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">join</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> v)</span> &#123;</span><br><span class=\"line\">    u = find(u); <span class=\"comment\">// 寻找u的根</span></span><br><span class=\"line\">    v = find(v); <span class=\"comment\">// 寻找v的根</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u == v) <span class=\"keyword\">return</span> ; <span class=\"comment\">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class=\"line\">    father[v] = u;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，join 函数中前三行和 isSame 函数是重复的，但这三行绝对不能用通过调用 isSame 函数来替换，因为下一行的 <code>father[v] = u</code> 表示的意思是让 v 的 根 指向 u的 根，这样才能通过<strong>单向的连接就能表示两个元素的相连</strong>。否则单单 <code>father[v] = u</code> 的意思就是让 v 指向 u ，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">join</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">join</span>(<span class=\"number\">3</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这是用 isSame 替换，此时无法表示 1 与 3 在一个集合里。</p>\n<img src=\"/2024/03/05/LeetCodeNote/5.png\" class=\"\"> \n\n<p>这是不用 isSame 替换，此时可以表示 1 与 3 在一个集合里。</p>\n<img src=\"/2024/03/05/LeetCodeNote/6.png\" class=\"\"> \n\n\n<p><code>join(u, v) </code>的含义就是 v 的根（或者叫头）指向 u 的根（或者叫头）。这点和上面的那个<strong>易错点</strong>是很关连的。</p>\n<p>还有：<strong>路径压缩</strong> &#x2F;&#x2F; 验证过了<br>路径压缩会在寻根的<strong>漫长过程</strong>中，把这条路径上的<strong>所有非根节点</strong>的<strong>父节点</strong>全都设为<strong>最前端的根节点</strong>，只要这条路径跑一次，基本都会重设父节点，这些子节点都会直接挂载到根节点下面。</p>\n<p>注意看：无论使用并查集模板里哪一个函数（除了init函数），都会有路径压缩的过程（因为里面都调用了 find 函数），第二次访问相同节点的时候，这个节点就是直连根节点的，即 第一次访问的时候它的路径就被压缩了。</p>\n<p>路径压缩后的<strong>并查集时间复杂度</strong>在<strong>O(logn)与O(1)<strong>之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。<br>在第一次查询（find）的时候，相当于是</strong>n叉树上从叶子节点到根节点</strong>的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame 函数里涉及的查询操作也是一样的过程。</p>\n<p><strong>拓展</strong></p>\n<p>在「路径压缩」讲解中，我们知道如何靠压缩路径来缩短查询根节点的时间。</p>\n<p>其实还有另一种方法：<strong>按秩（rank）合并</strong>。</p>\n<p>rank表示<strong>树的高度</strong>，即树中结点<strong>层次的最大值</strong>。</p>\n<p>为防止两颗树合并后整棵树的高度变的更高，一定是 rank 小的树合入 到 rank大 的树（比较矮的树合入比较高的树），这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。</p>\n<p><strong>按秩（rank）合并</strong>不需要路径压缩，因为一旦做路径压缩，rank记录的高度就不准了，根据rank来判断如何合并就没有意义。</p>\n<p>其实我们在优化并查集查询效率的时候，只用路径压缩的思路就够了，不仅代码实现精简，而且效率足够高。<br>按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1005</span>; <span class=\"comment\">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; father = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (n, <span class=\"number\">0</span>); <span class=\"comment\">// C++里的一种数组结构</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; rank = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (n, <span class=\"number\">1</span>); <span class=\"comment\">// 初始每棵树的高度都为1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并查集初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        father[i] = i;</span><br><span class=\"line\">        rank[i] = <span class=\"number\">1</span>; <span class=\"comment\">// 也可以不写</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 并查集里寻根的过程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> u == father[u] ? u : <span class=\"built_in\">find</span>(father[u]);<span class=\"comment\">// 注意这里不做路径压缩</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断 u 和 v是否找到同一个根</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSame</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    u = <span class=\"built_in\">find</span>(u);</span><br><span class=\"line\">    v = <span class=\"built_in\">find</span>(v);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> u == v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将v-&gt;u 这条边加入并查集</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    u = <span class=\"built_in\">find</span>(u); <span class=\"comment\">// 寻找u的根</span></span><br><span class=\"line\">    v = <span class=\"built_in\">find</span>(v); <span class=\"comment\">// 寻找v的根</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class=\"comment\">// rank小的树合入到rank大的树</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> father[v] = u;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; </span><br><span class=\"line\">    <span class=\"comment\">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><p><a href=\"https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked\">207. 课程表</a></p>\n<p>还是容易理解的</p>\n<h2 id=\"字典序算法\"><a href=\"#字典序算法\" class=\"headerlink\" title=\"字典序算法\"></a>字典序算法</h2><p><a href=\"https://blog.csdn.net/HappyRocking/article/details/83619392\">字典序算法详解</a> 讲的挺好的。</p>\n<p><a href=\"https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked\">31. 下一个排列</a></p>\n<p>字典序算法用来解决这样一个问题：给定其中一种排列，求基于字典序的下一种排列。</p>\n<p>比如给定一种排列为 abc，则其基于字典序的下一种排列为 acb。</p>\n<p>要求下一种排列既要比原排列大，又不能有第三种排列位于他俩之间。即下一种排列为大于原排列的最小排列。</p>\n<p>其实我们总体目标就是把一个递增序的123456转为递减序的654321【这里是从左往右看的】<br>以输入为 3 2 5 8 7 6 4 为例，字典序算法的步骤：<br>1、从右往左看，寻找最先出现的两个<strong>从右往左</strong>看呈递减趋势的数字，这里就是5 8，称5为左邻，8为右邻。【右邻8及其右边已经呈我们要的递减了，没法再在这边操作了】<br>2、重新从右往左找第一个比左邻5大的数（这里一定是找大于它的数，换一个等于的数有啥用），因为我们要用一个较小的数去和5换。这样换完之后才能小一点。这里我们找到6，将它和5换，则得到  3 2 6 8 7 5 4，左邻位置现在是6。【这里我们注意到8 7 5 4和原来一样是递减的，原因就是因为6是第一个大于5的】<br>3、将左邻位置(也就是现在的6)后面的所有数字重排序成递增的，得到3 2 6 4 5 7 8，这里我们只要使用双指针一直头尾交换就可以啦。</p>\n<p>还是很简单滴。注意第一步如果没有这样的两个数说明已经全局递减的，这时候直接跳到第三步，形成一个循环。</p>\n<h2 id=\"疑难\"><a href=\"#疑难\" class=\"headerlink\" title=\"疑难\"></a>疑难</h2><p><a href=\"https://leetcode.cn/problems/longest-increasing-subsequence/\">300 动态规划、二分查找解法</a></p>\n<p><a href=\"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/\">105 106从前序与中序遍历序列构造二叉树</a> 迭代法很恶心</p>\n<p><a href=\"https://leetcode.cn/problems/largest-triangle-area/description/\">812. 最大三角形面积 凸包问题</a></p>\n<p><a href=\"https://leetcode.cn/problems/combinations/description/\">77. 组合 字典序法解决组合枚举</a></p>\n<p><a href=\"https://leetcode.cn/problems/non-decreasing-subsequences/solutions/387656/di-zeng-zi-xu-lie-by-leetcode-solution/\">491. 非递减子序列 回溯去重</a><br>这个回溯去重真看不懂</p>\n<p><a href=\"https://leetcode.cn/problems/reconstruct-itinerary/solutions/389885/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/\">332. 重新安排行程 Hierholzer 算法</a></p>\n<p><a href=\"https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked\">295. 数据流的中位数</a> 题简单，但是第一次见到用TreeMap，可以再了解下</p>\n<p><a href=\"https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/1208350/cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526/?envType=study-plan-v2&envId=top-interview-150\">373. 查找和最小的 K 对数字</a> 这题的二分查找可能有点难了</p>\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"题\"><a href=\"#题\" class=\"headerlink\" title=\"题\"></a>题</h2><h3 id=\"给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩\"><a href=\"#给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩\" class=\"headerlink\" title=\"给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩\"></a>给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩</h3><p><strong>太难了呀</strong><br>select s.sid, s.name, sc.cid, sc.score<br>from studeng s join score sc on s.sid&#x3D;sc.sid and  sc.sid&#x3D;’02’<br>where not exists (select 1 from Score where Score.sid&#x3D;s.sid and Score.cid&#x3D;’01’) </p>\n<p>select s.sid, s.name, sc.cid, sc.score<br>from<br>student s  left join score as sc1 on s.sid&#x3D;sc1.sid and sc1.cid&#x3D;’01’ left join score as sc2 on s.sid&#x3D;sc2.sid and sc2.cid&#x3D;’02’<br>where sc1.cid is null and sc2.cid is not null;</p>\n<h3 id=\"给定一个学生表-student-score（stu-id，subject-id，score），查询总分排名在5-10名的学生id及对应的总分\"><a href=\"#给定一个学生表-student-score（stu-id，subject-id，score），查询总分排名在5-10名的学生id及对应的总分\" class=\"headerlink\" title=\"给定一个学生表 student_score（stu_id，subject_id，score），查询总分排名在5-10名的学生id及对应的总分\"></a>给定一个学生表 student_score（stu_id，subject_id，score），查询总分排名在5-10名的学生id及对应的总分</h3><p>WITH StudentTotalScores AS (…): 定义 CTE（子查询 (Common Table Expressions, CTE)，计算每个学生的总分。</p>\n<p>RANK()函数是一种窗口函数，用于生成一个特定排序的序号。它与OVER子句结合使用，以指定排名的排序依据。<br>RANK()函数用于生成排序结果中的排名。不同于ROW_NUMBER()，它会处理并列的情况。例如，如果有两个记录的得分相同，那么它们会得到相同的排名，下一名将跳过。<br>OVER子句用于定义窗口函数的分区和排序方式，在你的例子中，它指定了如何排序生成排名：<br>窗口函数应用于ORDER BY total_score DESC：按总分从高到低进行排序。</p>\n<p>RANK() OVER (ORDER BY total_score DESC) AS rank:<br>    RANK(): 生成排名。<br>    OVER (ORDER BY total_score DESC): 按总分从高到低排序来计算排名。<br>    AS rank: 给生成的排名列取名为rank。</p>\n<p>WITH StudentTotalScores AS (<br>    SELECT<br>        stu_id,<br>        SUM(score) AS total_score<br>    FROM<br>        student_score<br>    GROUP BY<br>        stu_id<br>),<br>RankedStudents AS (<br>    SELECT<br>        stu_id,<br>        total_score,<br>        RANK() OVER (ORDER BY total_score DESC) AS ranking<br>    FROM<br>        StudentTotalScores<br>)<br>SELECT<br>    stu_id,<br>    total_score<br>FROM<br>    RankedStudents<br>WHERE<br>    ranking BETWEEN 5 AND 10;</p>\n<p>除了这种声明子查询为某个表的with方式，还可以使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM (</span><br><span class=\"line\">    SELECT</span><br><span class=\"line\">        Prices.product_id AS product_id,</span><br><span class=\"line\">        Prices.price * UnitsSold.units AS sales,</span><br><span class=\"line\">        UnitsSold.units AS units</span><br><span class=\"line\">    FROM Prices </span><br><span class=\"line\">    LEFT JOIN UnitsSold ON Prices.product_id = UnitsSold.product_id</span><br><span class=\"line\">    AND (UnitsSold.purchase_date BETWEEN Prices.start_date AND Prices.end_date)</span><br><span class=\"line\">) T</span><br></pre></td></tr></table></figure>\n<p>在from的时候用小括号命名别名为表T</p>\n<h3 id=\"1934-确认率\"><a href=\"#1934-确认率\" class=\"headerlink\" title=\"1934. 确认率\"></a>1934. 确认率</h3><p><strong>有个问题待解决，当两个相同的表leftjoin似乎会产生类笛卡尔积，实际上是由于连接条件不唯一导致的</strong></p>\n<p><strong>原来join是（以left join为例），此刻选择两条记录，如果满足on后面的条件，就将右边的记录接在左边后面成为一条新纪录作为结果集之一，并且如果对一条左边记录来说，右边没有任何一条符合则会生成一条【左边记录-null】的新纪录。所以以后连接条件一定要唯一，否则容易拿不到自己想要的结果</strong>。</p>\n<p>SELECT *<br>FROM table1 AS alias1<br>LEFT JOIN table2 AS alias2<br>ON alias1.column &#x3D; alias2.column;<br>会从 table1 中获取所有记录，并根据 ON 条件与 table2 中的记录进行匹配。如果匹配成功，返回匹配的记录；如果匹配不成功，则返回 table1 的记录，并用 NULL 填充 table2 的列。</p>\n<p><a href=\"https://leetcode.cn/problems/confirmation-rate/description/?envType=study-plan-v2&envId=sql-free-50\">1934. 确认率</a></p>\n<p>IFNULL(expression, alt_value)<br>如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。</p>\n<p>IF函数根据条件的结果为true或false，返回第一个值，或第二个值<br>IF(condition, value_if_true, value_if_false)</p>\n<p>ROUND() 函数用于把数值字段舍入为指定的小数位数。<br>ROUND(column_name,decimals) decimals：可选。规定要返回的小数位数decimals 甚至可以是0、负数，用于对小数点左边进行四舍五入。</p>\n<p><strong>COUNT：是对记录进行汇总，即计数记录数</strong><br><strong>SUM：是对符合条件的数值列字段进行求和</strong><br>SUM函数内部设置筛选条件<br>sum( action &#x3D; ‘confirmed’ ) <a href=\"https://www.cnblogs.com/bravesunforever/p/11722995.html\"> sum不止可以用于字段</a><br>每个Price与25对比后的判断结果，小于25，判断为False，用数字0表示；大于25，判断为True，用数字1表示；<br>可以发现，虽然判断结果为False，但仍然是一条记录，所以前两行虽然判断结果为0，但是 count(price&gt;25)列仍填充1（对count来说只要不为null就计数）<br>price&gt;25为False，即0，相当于sum( 0 ) 结果仍然是0<br>也可以在sum内部写if条件<code>sum(if(tb2.action=&#39;confirmed&#39;,1,0)</code><br><strong>按照这样的理论</strong>，sum绝对不止局限在字段，可以理解为对每条记录可以进行一样计算，并为其总和，比如我可以在sum中进行两个字段的相乘。</p>\n<p>可以考虑使用AVG函数，需要注意的是AVG函数是可以写条件判断的。<br>AVG(c.action&#x3D;’confirmed’)  应该也是判断为False，用数字0表示，判断为True，用数字1表示，然后除以总行数</p>\n<p><strong>布尔表达式在MySQL中的行为</strong><br>在MySQL中，布尔表达式（如 c.action &#x3D; ‘confirmed’）在数值上下文中会被隐式转换为数值：<br>真（TRUE）被转换为 1。<br>假（FALSE）被转换为 0。<br>因此，表达式 c.action &#x3D; ‘confirmed’ 对于每一行来说，要么是1（如果 action 是 ‘confirmed’），要么是0（否则）。</p>\n<h3 id=\"1251-平均售价\"><a href=\"#1251-平均售价\" class=\"headerlink\" title=\"1251. 平均售价\"></a>1251. 平均售价</h3><p><a href=\"https://leetcode.cn/problems/average-selling-price/description/?envType=study-plan-v2&envId=sql-free-50\">1251. 平均售价</a></p>\n<h3 id=\"1633-各赛事的用户注册率\"><a href=\"#1633-各赛事的用户注册率\" class=\"headerlink\" title=\"1633. 各赛事的用户注册率\"></a>1633. 各赛事的用户注册率</h3><p><strong>两个表没必要连接，但主表需要另一个表的某个信息，此时就是子查询嵌套，不是连接了</strong></p>\n<p><a href=\"https://leetcode.cn/problems/percentage-of-users-attended-a-contest/description/?envType=study-plan-v2&envId=sql-free-50\">1633. 各赛事的用户注册率</a></p>\n<p>在select里面用**(select count(1) from users)**表示从user表查到的行数，直接就用了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">contest_id , round(100*count(1)/(select count(1) from users),2) as percentage </span><br><span class=\"line\">from         </span><br><span class=\"line\">Register</span><br><span class=\"line\">group by contest_id</span><br><span class=\"line\">order by percentage desc, contest_id asc</span><br></pre></td></tr></table></figure>\n\n<p>mysql order排序 默认是<strong>升序</strong><br>多字段排序需要各自分别定义升降序<br>比如<br> SELECT * FROM students st <strong>ORDER BY</strong> st.sAge DESC, st.sGrade ASC;<br>并且按字段先后顺序排优先级，这里就先Age降序，然后Grade 升序</p>\n<p>用<strong>distinct</strong>来返回不重复的用户名select distinct name，id from user, 去重</p>\n<h3 id=\"1211-查询结果的质量和占比\"><a href=\"#1211-查询结果的质量和占比\" class=\"headerlink\" title=\"1211. 查询结果的质量和占比\"></a>1211. 查询结果的质量和占比</h3><img src=\"/2024/03/05/LeetCodeNote/7.png\" class=\"\">\n\n\n<p>判断字段是否为null 要用 字段-IS NOT NULL，不能用！&#x3D;</p>\n<h3 id=\"1193-每月交易-I\"><a href=\"#1193-每月交易-I\" class=\"headerlink\" title=\"1193. 每月交易 I\"></a>1193. 每月交易 I</h3><p>我们在用Mysql抽取数据时候，经常需要按照天、周、月等不同的粒度对数据进行分组统计。而我们的时间可能是“2017&#x2F;12&#x2F;5 0:0:0”这种准确的时间。所以在进行分组之前我们需要对时间进行一下处理。</p>\n<p>DATE_FORMAT是MySQL内置的一个函数，作用是以不同的格式显示日期&#x2F;时间数据。具体的语法如下：</p>\n<p>DATE_FORMAT(date,format)，其中<br>date：合法的日期。format：规定日期&#x2F;时间的输出格式</p>\n<p>按天统计：select DATE_FORMAT(start_time,<strong>‘%Y%m%d’</strong>) days<br>按周统计：select DATE_FORMAT(start_time,<strong>‘%Y%u’</strong>) weeks<br>按月统计:  select DATE_FORMAT(start_time,<strong>‘%Y%m’</strong>) months  这样的会转化成字符串”201812”<br>其中年的Y换成y则只会输出后两位，比如2018的18，m换成M则变成月份英文单词，d同理。</p>\n<p>这题要输出成【2018-12 】这样的格式，所以使用date_format(trans_date,’%Y-%m’)<br> 或者也可以left(trans_date, 7) 从左侧取七位</p>\n<h3 id=\"550-游戏玩法分析-IV\"><a href=\"#550-游戏玩法分析-IV\" class=\"headerlink\" title=\"550. 游戏玩法分析 IV\"></a>550. 游戏玩法分析 IV</h3><p><a href=\"https://leetcode.cn/problems/game-play-analysis-iv/description/?envType=study-plan-v2&envId=sql-free-50\">550. 游戏玩法分析 IV</a></p>\n<p>被子查询狠狠坑了，就是基础不好。（时间加一天不会，多表联查不知道，）</p>\n<p>草泥马的，我以为 select from只能从一张表查，我真服了!<br>原来可以用逗号分隔查两张表（这样是笛卡尔积连结），比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select Activity.player_id as player_id</span><br><span class=\"line\">  from (</span><br><span class=\"line\">    select player_id, DATE_ADD(MIN(event_date), INTERVAL 1 DAY) as second_date</span><br><span class=\"line\">    from Activity</span><br><span class=\"line\">    group by player_id</span><br><span class=\"line\">  ) as Expected, Activity</span><br><span class=\"line\">  where Activity.event_date = Expected.second_date and Activity.player_id = Expected.player_id</span><br></pre></td></tr></table></figure>\n\n<p>能够直接求出某列去重后的元素<br><strong>select count(distinct player_id) from activity</strong><br>count(distinct Activity.player_id) 直接就是去重后的行数<br>仔细看这里的区别， 第一个多表联查result, Activity，所以只要count(distinct Activity.player_id)就行，第二个只有result，所以要(select count(distinct player_id) from activity)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- select round(result.cnt/ count(distinct Activity.player_id),2) as fraction </span><br><span class=\"line\">-- ) as result, Activity</span><br><span class=\"line\"></span><br><span class=\"line\">-- select round(result.cnt/ (select count(distinct player_id) from activity),2) as fraction </span><br><span class=\"line\">-- ) as result</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1378-使用唯一标识码替换员工ID\"><a href=\"#1378-使用唯一标识码替换员工ID\" class=\"headerlink\" title=\"1378. 使用唯一标识码替换员工ID\"></a>1378. 使用唯一标识码替换员工ID</h3><p>join（外连接）<br>1.inner join，内连接,显示两个表中有联系的所有数据;简写成join，如果一边缺了会自动重复。<br>2.left join，左链接,以左表为参照,显示所有数据,右表中没有则以null显示<br>3.right join，右链接,以右表为参照显示数据，,左表中没有则以null显示<br>比如这题就要用到left&#x2F;right JOIN<a href=\"https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/description/?envType=study-plan-v2&envId=sql-free-50\">1378. 使用唯一标识码替换员工ID</a>因为要留NULL。<br>关键字 on<br>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。<br>在使用 left&#x2F;right jion 时，on 和 where 条件的区别如下：<br>1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。<br>2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。<br>使用 inner join 时on和where是一样的<br><a href=\"https://blog.csdn.net/weixin_45906830/article/details/111133181\">mysql的left join和inner join的详细用法</a> 这篇讲得好</p>\n<h3 id=\"1280-学生们参加各科测试的次数\"><a href=\"#1280-学生们参加各科测试的次数\" class=\"headerlink\" title=\"1280. 学生们参加各科测试的次数\"></a>1280. 学生们参加各科测试的次数</h3><p>交叉联结（corss join）：<br>使用交叉联结会将两个表中所有的数据两两组合<br>写join时默认就是 cross join ，这东西真的很重要，有时候为了获得某几列的所有组合就要用这个东西。<br>比如<a href=\"https://leetcode.cn/problems/students-and-examinations/solutions/2366340/students-and-examinations-by-leetcode-so-3oup/?envType=study-plan-v2&envId=sql-free-50\">难题</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">官解的写法也能学到些东西</span><br><span class=\"line\">SELECT </span><br><span class=\"line\">    s.student_id, s.student_name, sub.subject_name, IFNULL(grouped.attended_exams, <span class=\"number\">0</span>) AS attended_exams</span><br><span class=\"line\">FROM </span><br><span class=\"line\">    Students s</span><br><span class=\"line\">CROSS JOIN </span><br><span class=\"line\">    Subjects sub</span><br><span class=\"line\">LEFT <span class=\"title function_\">JOIN</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    SELECT student_id, subject_name, COUNT(*) AS attended_exams</span></span><br><span class=\"line\"><span class=\"params\">    FROM Examinations</span></span><br><span class=\"line\"><span class=\"params\">    GROUP BY student_id, subject_name</span></span><br><span class=\"line\"><span class=\"params\">)</span> grouped </span><br><span class=\"line\">ON s.student_id = grouped.student_id AND sub.subject_name = grouped.subject_name</span><br><span class=\"line\">ORDER BY s.student_id, sub.subject_name;</span><br></pre></td></tr></table></figure>\n\n<p>注意 USING (student_id,subject_name)意思是连结的用student_id subject_name这两列，也就是两个表有相同名称的这两列时可以这么用，完全可以用on代替，但是这里代替的写法应该是<br>ON stu.student_id &#x3D; ex.student_id AND sub.subject_name &#x3D; ex.subject_name 注意中间的and。<br>还发现 GROUP BY 、ORDER BY 都可以选一列以上</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">   stu.student<span class=\"emphasis\">_id, stu.student_</span>name, sub.subject<span class=\"emphasis\">_name, COUNT(ex.subject_</span>name) attended<span class=\"emphasis\">_exams</span></span><br><span class=\"line\"><span class=\"emphasis\">FROM</span></span><br><span class=\"line\"><span class=\"emphasis\">    Students stu JOIN Subjects sub LEFT JOIN Examinations ex on stu.student_</span>id = ex.student<span class=\"emphasis\">_id and sub.subject_</span>name = ex.subject<span class=\"emphasis\">_name</span></span><br><span class=\"line\"><span class=\"emphasis\">GROUP BY </span></span><br><span class=\"line\"><span class=\"emphasis\">    stu.student_</span>id, sub.subject<span class=\"emphasis\">_name</span></span><br><span class=\"line\"><span class=\"emphasis\">ORDER BY</span></span><br><span class=\"line\"><span class=\"emphasis\">    stu.student_</span>id, sub.subject<span class=\"emphasis\">_name</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"570-至少有5名直接下属的经理\"><a href=\"#570-至少有5名直接下属的经理\" class=\"headerlink\" title=\"570. 至少有5名直接下属的经理\"></a><a href=\"https://leetcode.cn/problems/managers-with-at-least-5-direct-reports/description/?envType=study-plan-v2&envId=sql-free-50\">570. 至少有5名直接下属的经理</a></h3><p>having count(Report.Id) &gt;&#x3D; 5 应该也是返回临时表</p>\n<p>函数合集：<br>计算字符串中字符数的最佳函数是 CHAR_LENGTH(str)<br>另一个常用的函数 LENGTH(str) 返回字符串 str 的字节数，如果包含特殊字符(某些字符包含多于 1 个字节)，结果可能和预期不太一样</p>\n<p>COUNT 想计数某个字段重复次数，先按这个字段group，然后count（另一个字段），这题就用到了，比如：想计算customer_id下有几个visit_id，就GROUP BY customer_id然后 COUNT(visit_id)<br>| visit_id | customer_id |<br>| 4        | 30          |<br>| 6        | 96          |<br>| 7        | 54          |<br>| 8        | 54          |</p>\n<h3 id=\"1581-进店却未进行过交易的顾客\"><a href=\"#1581-进店却未进行过交易的顾客\" class=\"headerlink\" title=\"1581. 进店却未进行过交易的顾客\"></a><a href=\"https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/description/?envType=study-plan-v2&envId=sql-free-50\">1581. 进店却未进行过交易的顾客</a></h3><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。COUNT(visit_id)是统计表中，visit_id 字段不为 NULL 的记录有多少个</p>\n<p>时间计算的函数：<br>datediff(日期1, 日期2)：很重要<br>得到的结果是日期1与日期2相差的天数。</p>\n<h3 id=\"197-上升的温度\"><a href=\"#197-上升的温度\" class=\"headerlink\" title=\"197. 上升的温度\"></a><a href=\"https://leetcode.cn/problems/rising-temperature/description/?envType=study-plan-v2&envId=sql-free-50\">197. 上升的温度</a></h3><figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT w1.id</span><br><span class=\"line\">FROM Weather w1, Weather w2 --这样写默认就是cross join</span><br><span class=\"line\">WHERE datediff(w1.recordDate, w2.recordDate)=1 AND w1.temperature&gt;w2.temperature</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"MySQL-知识点\"><a href=\"#MySQL-知识点\" class=\"headerlink\" title=\"MySQL 知识点\"></a>MySQL 知识点</h2><p>count(age &gt; 20 or null) 最好不要用 or null 这种写法，用count(if(age &gt; 20,1,null)或者 sum(age &gt; 20)比较好。注意这里之所以可以sum(age &gt; 20)因为对布尔表达式会默认转为0、1。</p>\n<p>判断字段空：只有name 为null 的时候 ISNULL(exp) 函数的返回值为1 ，空串和有数据都为0；<br>也可以 name is not null; 或 name is null;</p>\n<p>排序：order by 排序字段 asc（默认，还可选desc）</p>\n<p>去重：根据某些字段的去重查询（不考虑查询其他字段）<br>select <strong>distinct</strong> 字段 from table</p>\n<p>或者 group by 也可以去重<br>select c_name,c_year,c_month from table<br>group by c_name,c_year,c_month</p>\n<p>别名<br>列别名：SELECT  字段 [AS] 别名（AS关键字是可选的，别名如果有空格最好用单引号括起来）</p>\n<p>组合字段并使用别名<br>CONCAT_WS(‘, ‘, lastName, firstname) [AS] ‘Full name’</p>\n<p>ORDER BY，GROUP BY和HAVING子句中<strong>可以引用这些别名</strong>，不能在WHERE子句中使用列别名。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  customerName,</span><br><span class=\"line\"><span class=\"built_in\">COUNT</span>(o.orderNumber) [<span class=\"keyword\">as</span>] total #列别名，并且用函数作为一个字段  </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> customers [<span class=\"keyword\">as</span>] c <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> orders [<span class=\"keyword\">as</span>] o  #表别名，内联<span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span>应该是配合<span class=\"keyword\">ON</span>使用的</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.customerNumber <span class=\"operator\">=</span> o.customerNumber</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> customerName  # 去重？是的，而且要在<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span>前面</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> total <span class=\"operator\">&gt;=</span><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> total <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"select-命令执行流程\"><a href=\"#select-命令执行流程\" class=\"headerlink\" title=\"select 命令执行流程\"></a>select 命令执行流程</h3><p><strong>sql查询语句执行逻辑顺序</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">9</span>) SELECT </span><br><span class=\"line\">(<span class=\"number\">10</span>) DISTINCT &lt;column&gt;,</span><br><span class=\"line\">(<span class=\"number\">6</span>) AGG_FUNC &lt;column&gt; or &lt;expression&gt;, ...</span><br><span class=\"line\">(<span class=\"number\">1</span>) FROM &lt;left_table&gt; </span><br><span class=\"line\">    (<span class=\"number\">3</span>) &lt;join_type&gt;JOIN&lt;right_table&gt;</span><br><span class=\"line\">    (<span class=\"number\">2</span>) ON&lt;join_condition&gt;</span><br><span class=\"line\">(<span class=\"number\">4</span>) WHERE &lt;where_condition&gt;</span><br><span class=\"line\">(<span class=\"number\">5</span>) GROUP BY &lt;group_by_list&gt;</span><br><span class=\"line\">(<span class=\"number\">7</span>) WITH &#123;CUBE|ROLLUP&#125;</span><br><span class=\"line\">(<span class=\"number\">8</span>) HAVING &lt;having_condtion&gt;</span><br><span class=\"line\">(<span class=\"number\">11</span>) ORDER BY &lt;order_by_list&gt;</span><br><span class=\"line\">(<span class=\"number\">12</span>) LIMIT &lt;limit_number&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span>) FROM &lt;left_table&gt;      首先从表 MyNumbers 读取数据</span><br><span class=\"line\">    (<span class=\"number\">2</span>) ON&lt;join_condition&gt;</span><br><span class=\"line\">    (<span class=\"number\">3</span>) &lt;join_type&gt;JOIN&lt;right_table&gt;</span><br><span class=\"line\">(<span class=\"number\">4</span>) WHERE &lt;where_condition&gt;      对单记录进行过滤</span><br><span class=\"line\">(<span class=\"number\">5</span>) GROUP BY &lt;group_by_list&gt;      按照 num 列对数据进行分组。</span><br><span class=\"line\">(<span class=\"number\">6</span>) AGG_FUNC &lt;column&gt; or &lt;expression&gt;, ...      在分组的基础上计算每组的 COUNT(num)。</span><br><span class=\"line\">(<span class=\"number\">7</span>) WITH &#123;CUBE|ROLLUP&#125;</span><br><span class=\"line\">(<span class=\"number\">8</span>) HAVING &lt;having_condtion&gt;</span><br><span class=\"line\">(<span class=\"number\">9</span>) SELECT         返回要的字段作为结果集</span><br><span class=\"line\">(<span class=\"number\">10</span>) UNION         将两个查询结果集合并。一般情况下不说</span><br><span class=\"line\">(<span class=\"number\">11</span>) DISTINCT &lt;column&gt;,   注意DISTINCT是可以用在聚合函数比如count中的</span><br><span class=\"line\">(<span class=\"number\">12</span>) ORDER BY &lt;order_by_list&gt;</span><br><span class=\"line\">(<span class=\"number\">13</span>) LIMIT &lt;limit_number&gt; OFFSET &lt;offset_number&gt;;</span><br></pre></td></tr></table></figure>\n<p>但<strong>注意 sum&#x2F;count(distinct 某列)是能发挥distinct作用的，因为此时distinct是作为聚合函数的参数一块执行的</strong>。</p>\n<p>但注意日期格式化data_format之后的字段别名可以用在group by中，因为涉及到SQL 的执行流程，在 SELECT 语句执行前会经历：语义校验（词法分析） -&gt;语法校验（语法分析）-&gt;（构建）语法树-&gt;优化器-&gt;执行器。本例的 date_formate 就是在语法树之前就编译好了的，所以最后丢给执行器执行时就能使用前面的编译内容去得出结果。【select date_format(trans_date,’%Y-%m’) as month…from…group by month】</p>\n<h3 id=\"MySQL-日期函数\"><a href=\"#MySQL-日期函数\" class=\"headerlink\" title=\"MySQL 日期函数\"></a>MySQL 日期函数</h3><p>mysql日期函数<br>now() 当前日期和时间<br>curdate() 当前日期<br>date(某个日期时间) 获取日期或日期时间的日期部分<br>time() 仅时间<br>date_format()将日期和时间转为指定格式字符串</p>\n<p>between…and（推荐）判断某个时间是否在某个时间范围内<br><code>SELECT * FROM k_student WHERE create_time  between &#39;2019-07-25 00:00:33&#39; and &#39;2019-07-25 00:54:33&#39;</code><br>也可以用大小于号</p>\n<p>datediff(expr1, expr2)用于计算两个日期之间的<strong>天数差</strong>。<br>expr1 和 expr2 是两个日期表达式。expr1 表示结束日期，expr2 表示起始日期。<br>DATEDIFF 函数返回的是 expr1 与 expr2 之间相差的天数。</p>\n<p>最小天数加一天<br>DATE_ADD(MIN(event_date), INTERVAL 1 DAY)<br>DATE_SUB(MIN(event_date), INTERVAL 1 DAY)</p>\n<p>另一个关于时间计算的函数是：<br>timestampdiff(时间类型, 日期1, 日期2)<br>这个函数和上面 datediff 的正、负号规则刚好相反。<br>日期1大于日期2，结果为负，日期1小于日期2，结果为正。</p>\n<p>在“时间类型”的参数位置，通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差。</p>\n<hr>\n<p>在 SQL 语句中，对字段加单引号的情况通常是为了区分字符串常量和列名，而不加单引号的情况通常是用于列名或保留字。</p>\n<p>何时加单引号<br>字符串常量：在条件语句中如果要对一个列进行字符串比较或使用字符串常量，需要用单引号。例如：’approved’, ‘active’ 等。<br>日期常量：日期常量也需要用单引号。例如：’2023-12-08’, ‘2024-01-01’ 等。<br>字符型数据的插入：在插入字符型数据时需要用单引号。例如：<br>   INSERT INTO users (name, status) VALUES (‘John Doe’, ‘active’);<br>何时不加单引号<br>列名：列名通常不需要用单引号。例如：state, amount 等。<br>保留字：保留字在某些情况下可能会被错误识别，但如果它们明确指向数据库中的列或表，则不需要单引号。为了避免冲突，可以用反引号（MySQL）或双引号（标准 SQL）来引用，例如：state, `table` 等。<br>数值型常量：数值型数据在 SQL 语句中无需用单引号。例如：100, 0, 3.14 等。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">count 的 case 写法</span><br><span class=\"line\">COUNT(</span><br><span class=\"line\"><span class=\"code\">    CASE </span></span><br><span class=\"line\"><span class=\"code\">        WHEN state = &#x27;approved&#x27; </span></span><br><span class=\"line\"><span class=\"code\">    THEN 1 </span></span><br><span class=\"line\"><span class=\"code\">    ELSE NULL </span></span><br><span class=\"line\"><span class=\"code\">END)</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p><strong>子查询能否使用外部查询的字段取决于其位置和类型</strong>：</p>\n<ol>\n<li>具有独立上下文的子查询（如作为表达式使用）不能使用外部查询的字段。</li>\n<li>在 FROM 子句中的子查询可以是独立的，但也可以通过 JOIN 关联外部查询的字段。</li>\n<li><strong>关联子查询（例如在 WHERE 子句和 SELECT 子句中的子查询）通常会使用外部查询的字段。</strong></li>\n</ol>\n<h4 id=\"1、作为表达式使用：\"><a href=\"#1、作为表达式使用：\" class=\"headerlink\" title=\"1、作为表达式使用：\"></a>1、作为表达式使用：</h4><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">select contest<span class=\"emphasis\">_id , round(count(user_</span>id) <span class=\"emphasis\">* 100/ (select count(*</span>) from users), 2) as percentage </span><br><span class=\"line\">from Register</span><br><span class=\"line\">group by contest<span class=\"emphasis\">_id</span></span><br><span class=\"line\"><span class=\"emphasis\">order by percentage desc, contest_</span>id;</span><br></pre></td></tr></table></figure>\n\n<p>子查询<code>(select count(*) from users)</code>为主查询中的表达式提供数据，甚至可以 <code>(select count(distinct name) from users) </code>查询users 表中的用户总数。</p>\n<p>这种子查询不能使用外部查询的字段，因为它在单独的、独立的上下文中运行。</p>\n<p>看这里甚至在where中的datediff里也用了子查询作为一个表达式，也就是这题 <a href=\"https://leetcode.cn/problems/restaurant-growth/description/?envType=study-plan-v2&envId=sql-free-50\">1321. 餐馆营业额变化增长</a></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> visited_on, amount, round(amount<span class=\"operator\">/</span><span class=\"number\">7</span>, <span class=\"number\">2</span>) <span class=\"keyword\">as</span> average_amount </span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> visited_on,</span><br><span class=\"line\">        <span class=\"comment\">-- (select min(distinct(visited_on)) from customer) as mindate , 这一列没必要，可以直接在where中用表达式</span></span><br><span class=\"line\">        (<span class=\"keyword\">select</span> <span class=\"built_in\">sum</span>(amount) <span class=\"keyword\">from</span> customer c2 <span class=\"keyword\">where</span> datediff(c1.visited_on, c2.visited_on)<span class=\"operator\">&lt;=</span><span class=\"number\">6</span> <span class=\"keyword\">and</span> datediff(c1.visited_on, c2.visited_on)<span class=\"operator\">&gt;=</span><span class=\"number\">0</span>) <span class=\"keyword\">as</span> amount       </span><br><span class=\"line\">    <span class=\"keyword\">from</span> customer c1</span><br><span class=\"line\">) t</span><br><span class=\"line\"><span class=\"keyword\">where</span> datediff(visited_on, (<span class=\"keyword\">select</span> <span class=\"built_in\">min</span>(visited_on) <span class=\"keyword\">from</span> customer))<span class=\"operator\">&gt;=</span><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> visited_on, amount</span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> visited_on </span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"2、在-FROM-子句中作为一个临时表使用：\"><a href=\"#2、在-FROM-子句中作为一个临时表使用：\" class=\"headerlink\" title=\"2、在 FROM 子句中作为一个临时表使用：\"></a>2、在 FROM 子句中作为一个临时表使用：</h4><p>子查询可以作为一个临时表来使用，并在主查询中引用，这里的引用不局限于单表引用，也可以join其他表。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">select t.contest_id, t.avg_score</span><br><span class=\"line\">from </span><br><span class=\"line\">    (select contest_id, avg(score) as avg_score from Results group by contest_id) as t</span><br><span class=\"line\">where t.avg_score &gt; 50;</span><br></pre></td></tr></table></figure>\n<p>这里子查询将 Results 表按照 contest_id 分组并计算 avg_score，然后主查询从这个子查询结果中过滤 avg_score 大于 50 的记录。</p>\n<h4 id=\"3、在-WHERE-字段-in、EXIST-或-HAVING-子句中使用：\"><a href=\"#3、在-WHERE-字段-in、EXIST-或-HAVING-子句中使用：\" class=\"headerlink\" title=\"3、在 WHERE 字段 in、EXIST 或 HAVING 子句中使用：\"></a>3、在 WHERE 字段 in、EXIST 或 HAVING 子句中使用：</h4><p>子查询很常用的一个场景是在 WHERE 或 HAVING 子句中，通常用于提供过滤条件。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT contest<span class=\"emphasis\">_id, user_</span>id </span><br><span class=\"line\">FROM Register </span><br><span class=\"line\">WHERE user<span class=\"emphasis\">_id IN (</span></span><br><span class=\"line\"><span class=\"emphasis\">    SELECT user_</span>id </span><br><span class=\"line\"><span class=\"code\">    FROM Rewards </span></span><br><span class=\"line\"><span class=\"code\">    WHERE points &gt; 100</span></span><br><span class=\"line\"><span class=\"code\">);</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>WHERE EXIST 这种子查询还经常会使用外部查询的字段</strong>。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT u.user<span class=\"emphasis\">_id, u.name</span></span><br><span class=\"line\"><span class=\"emphasis\">FROM Users u</span></span><br><span class=\"line\"><span class=\"emphasis\">WHERE EXISTS (</span></span><br><span class=\"line\"><span class=\"emphasis\">    SELECT 1 </span></span><br><span class=\"line\"><span class=\"emphasis\">    FROM Orders o </span></span><br><span class=\"line\"><span class=\"emphasis\">    WHERE o.user_</span>id = u.user<span class=\"emphasis\">_id </span></span><br><span class=\"line\"><span class=\"emphasis\">      AND o.amount &gt; 100</span></span><br><span class=\"line\"><span class=\"emphasis\">); </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、在-SELECT-子句中使用（SELECT-子句的结果作为一列）：\"><a href=\"#4、在-SELECT-子句中使用（SELECT-子句的结果作为一列）：\" class=\"headerlink\" title=\"4、在 SELECT 子句中使用（SELECT 子句的结果作为一列）：\"></a>4、在 SELECT 子句中使用（SELECT 子句的结果作为一列）：</h4><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">select user<span class=\"emphasis\">_id, </span></span><br><span class=\"line\"><span class=\"emphasis\">       (select count(*) from Orders where Orders.user_</span>id = Users.user<span class=\"emphasis\">_id) as order_</span>count</span><br><span class=\"line\">from Users;</span><br></pre></td></tr></table></figure>\n<p>这里子查询还用了外部查询的字段作为子查询内部的过滤条件，甚至子查询发生在外部查询的from子句前面。</p>\n<hr>\n<p>由于子查询需要嵌套并执行多次，因此在性能方面要特别注意。如果你的数据集非常大，频繁的子查询可能会导致查询性能下降。在可能的情况下，使用 JOIN 操作或优化索引策略可能会更有效。</p>\n<hr>\n<p>在 SELECT 子句中使用的这种子查询，如果子查询结果集是空集，那么外部查询对该结果的处理通常为返回 NULL。</p>\n<p>SELECT (SELECT Salary FROM Employee WHERE Salary &#x3D; 10000) AS Result;<br>结果就是：<br>Result<br>NULL</p>\n<p>在 SQL 查询中，<strong>当在 SELECT 子句中使用子查询时，通常要求子查询返回的结果集只有一行</strong>。如果子查询返回多行而没有适当处理，会导致 SQL 查询执行失败。<br><strong>当在 SELECT 子句中使用子查询时</strong>，情况有两种：<br>子查询返回零行或一行：<br>这是期望的标准情况。<br>当子查询返回零行时，外查询结果为 NULL。<br>当子查询返回一行时，外查询结果为该行的值。<br>子查询返回多行：<br>这会导致 SQL 查询执行失败，抛出错误，如 Subquery returns more than 1 row。</p>\n<p><strong>在 SQL 中，子查询返回多行时不能直接用在 SELECT 子句中</strong>。这是因为<strong>SELECT子句期望的是标量子查询</strong>（即返回单一值的子查询）。如果子查询返回了多行数据，SQL 查询将会失败，并报错类似于 Subquery returns more than 1 row。</p>\n<p><strong>其实，如果子查询返回空集，那么外部查询就可以把它视为NULL</strong>。这个在其他情况待定，但基本没问题。</p>\n<h3 id=\"having-where\"><a href=\"#having-where\" class=\"headerlink\" title=\"having where\"></a>having where</h3><p>官网中明确表示</p>\n<p><strong>可以在group by、order by、having子句中使用别名。<br>不可以在where中使用别名。</strong></p>\n<p><a href=\"https://www.cnblogs.com/poloyy/p/12871310.html\">having 过滤分组结果集 </a></p>\n<p><strong>having是执行select前的最后一步</strong></p>\n<p><strong>注意：在 HAVING 子句中不允许使用聚合函数和一个原始字段进行比较</strong>，因为 HAVING 是在分组后进行过滤的，而这个分组后的过滤无法访问原始的非聚合字段。<br>having只能使用GROUP BY分组之后的聚合结果字段，也就是每一组数据的统计数据，比如SUM、AVG、MAX、MIN 和 COUNT 等，这些函数计算的结果就是聚合后的结果。这个分组的名字也可以用（GROUP BY 子句中的分组字段）。</p>\n<p>如果你试图在 HAVING 中使用一个原始数据的字段，则会出现错误。因为这些字段已经被聚合，或者说这些字段在分组后已经不再代表原始的单个数据行，而是代表整组数据的聚合结果。</p>\n<p><strong>当SQL语句中使用了group by关键字后，select后面除了聚合函数，就只能是group by后面出现的字段。</strong><br><a href=\"https://www.cnblogs.com/pure3417/p/15224587.html\">包括select也是只能用这几个字段</a> 这篇文章写得好。</p>\n<p>WHERE 用于在数据分组和聚合之前过滤记录。换句话说，它作用在 GROUP BY 语句之前，因此不能使用聚合函数。<br>HAVING 用于在数据分组和聚合之后过滤记录，通常与 GROUP BY 一起使用。HAVING 可以使用聚合函数。</p>\n<p>使用 WHERE 条件<br>使用 WHERE 来过滤记录时，不能直接基于聚合函数（如 SUM）进行过滤（也就是说不能用聚合函数），而只能过滤分组前的记录。例如，我们只能在数据分组前过滤 sale_amount 小于 50 的记录：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT product<span class=\"emphasis\">_id, SUM(sale_</span>amount) as total<span class=\"emphasis\">_sales</span></span><br><span class=\"line\"><span class=\"emphasis\">FROM Sales</span></span><br><span class=\"line\"><span class=\"emphasis\">WHERE sale_</span>amount &gt;= 50</span><br><span class=\"line\">GROUP BY product<span class=\"emphasis\">_id;</span></span><br></pre></td></tr></table></figure>\n<p>这个查询会<strong>首先过滤掉</strong> sale_amount &lt; 50 的记录，然后对剩下的记录进行分组并计算总销售额。<br>使用 HAVING 可以也只能基于聚合函数的结果进行过滤（不能再用原始字段）<br><code>HAVING SUM(sale_amount) &gt; 200;</code></p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>JOIN … ON … 默认是 INNER JOIN，与显式的 INNER JOIN 等价。<br>明确的 CROSS JOIN 或使用逗号 FROM table1, table2 会生成两个表所有行的笛卡尔积。<br>INNER JOIN 是在 ON 条件过滤后的联结，而逗号分隔的 FROM（from table1,table2） 是生成笛卡尔积，然后（可选）通过 WHERE 子句进行过滤可能可以达到类似 INNER JOIN 的效果。</p>\n<p>注意：只要是同一张表与自身进行连接，无论使用 LEFT JOIN、RIGHT JOIN、INNER JOIN 或 CROSS JOIN 等不同的连接方式，都可以称之为<strong>自连接</strong>（Self Join）。</p>\n<p>自连接的关键点在于，<strong>同一张表在查询中被引用多次</strong>。具体的连接类型只是决定了数据的匹配方式和返回结果的内容。<br>自连接指的是同一张表在查询中被引用多次，<strong>并以不同的别名进行关联</strong>。<br>自连接用途广泛，可以用于处理记录间亲缘关系、<strong>比较同表内记录</strong>（用的很多）等场景。</p>\n<h3 id=\"limit\"><a href=\"#limit\" class=\"headerlink\" title=\"limit\"></a>limit</h3><p>limit N,M : 相当于 limit M offset N , 从第 N 条记录开始, 返回 M 条记录<br>注意，这里两种写法是相反的意思。以后就用limit M offset N比较清晰一些。</p>\n<p>SELECT * FROM table_name LIMIT offset, limit;<br>limit带两个参数时即 limit N,M，偏移N，限制M条<br>SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15   </p>\n<p>如果只给定一个参数，它表示返回最大的记录行数目，即LIMIT N返回从0开始N条：<br>SELECT * FROM table LIMIT 5; &#x2F;&#x2F; 检索记录行 1-5</p>\n<h3 id=\"WITH-子句\"><a href=\"#WITH-子句\" class=\"headerlink\" title=\"WITH 子句\"></a>WITH 子句</h3><p>WITH 子句也被称为 “公用表表达式”（Common Table Expression, CTE）。它的主要作用是提高代码的可读性和重用性。WITH 子句允许您定义一个临时的、命名的<strong>结果集</strong>，可以在后续的 SELECT、INSERT、UPDATE 或 DELETE 语句中使用。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">WITH t AS (</span><br><span class=\"line\">    SELECT</span><br><span class=\"line\">        ...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这段代码定义了一个名字叫 t 的临时结果集。</p>\n<h3 id=\"窗口函数\"><a href=\"#窗口函数\" class=\"headerlink\" title=\"窗口函数\"></a>窗口函数</h3><p>MySQL 8.0 版本中可以使用窗口函数，它很像分组函数却又区别于分组函数，在使用group by后每组只有一个结果，而窗口函数不论是否分组都是一行一个结果。窗口函数不对数据进行分组，而是按照窗口划分，<strong>计算与当前窗口的聚合值，并将计算结果返回给这个窗口的每一行</strong>。</p>\n<p><a href=\"https://blog.csdn.net/chengyj0505/article/details/130057113\">MySQL 窗口函数</a> 这篇讲的很清楚。</p>\n<p>窗口函数允许您在<strong>不通过 GROUP BY 聚合</strong>的情况下，在查询<strong>结果集</strong>中计算<strong>某些聚合值</strong>。窗口函数通常与 <strong>OVER 子句</strong>一起使用，它指定了<strong>窗口的划分方式</strong>（即如何分组数据）。</p>\n<p><code>COUNT(*) OVER(PARTITION BY employee_id) AS count_over</code></p>\n<p><code>OVER(PARTITION BY employee_id)</code> 指定了<strong>窗口分组</strong>方式，即按 employee_id 划分数据。</p>\n<p>COUNT(*) 对这个划分得到的分组进行聚合，对这个分组进行计数。<br>AS count_over 给这个<strong>计算结果列</strong>起了一个别名叫 count_over。</p>\n<p><a href=\"https://leetcode.cn/problems/primary-department-for-each-employee/solutions/2702019/qiang-lie-jian-yi-bu-yao-shi-yong-unionc-l86h/?envType=study-plan-v2&envId=sql-free-50\">1789. 员工的直属部门</a> 这里之所以要这么做是因为我既需要分组得到count，我又想要不分组时候的原字段。（因为group之后非group字段就消失了）</p>\n<h3 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h3><p>字符串转换为大写，可以使用UPPER函数<br>SELECT UPPER(‘hello world’) AS UpperCaseString;<br>– 输出：HELLO WORLD</p>\n<p>要将字符串转换为小写，可以使用LOWER函数</p>\n<p>SUBSTRING(column_name, start, <strong>length</strong>)：从列的值中提取一个子串，从指定的起始位置开始，直到指定的长度。<br>SUBSTRING(name, 1, 1) 拿到name的子串，从位置1开始长度为1的子串。</p>\n<p>都可以用来拼接字段<br>CONCAT(UPPER(SUBSTRING(name, 1, 1)), LOWER(SUBSTRING(name, 2))): 将首字母（大写）和其余部分（小写）进行拼接，得到所需格式的姓名。<br>CONCAT_WS(separator,str1,str2,…))函数表示使用指定的分隔符 separator 连接多个字符串，分隔符为 NULL 则返回 NULL。<br>超牛的<strong>将多行的字符串按分组整合成一个字符串</strong>，必须配合group使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">GROUP_CONCAT(</span><br><span class=\"line\">    DISTINCT expression1</span><br><span class=\"line\">    ORDER BY expression2 asc/desc</span><br><span class=\"line\">    SEPARATOR sep</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">select sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product asc) as products</span><br><span class=\"line\">from activities</span><br><span class=\"line\">group by sell_date</span><br><span class=\"line\">order by sell_date</span><br></pre></td></tr></table></figure>\n\n<p>INSTR()<br>INSTR(str, substr)函数用于返回子串 substr 在字符串 str 中第一次出现的索引位置，没有找到子串时返回 0。<br>另外，LOCATE(substr,str)函数也可以用于返回子串 substr 在字符串 str 中第一次出现的索引位置，和 INSTR(str,substr) 函数唯一的不同就是参数的顺序相反。</p>\n<p><a href=\"https://blog.csdn.net/horses/article/details/118344265\">MySQL 十大常用字符串函数</a> 讲的挺好。</p>\n<p>正则表达式<br>在正则表达式中，一些字符具有特殊意义，比如 .、*、+、?、^、$、(、)、[、]、{、}、| 等等。如果你想要匹配这些字符本身，需要进行转义，即在这些字符前面加一个反斜杠 \\。<br><strong>由于反斜杠\\本身也是特殊字符需要转义</strong>，而<strong>字符串又以 \\ 作为转义符</strong>，所以在字符串中表示反斜杠时需要双写象征一个反斜杠，即我们需要使用<code> \\\\</code> 来表示一个反斜杠。<br>在正则表达式中，<code>\\s</code>表示匹配任何空白字符，包括空格、制表符、换页符等。在正则表达式的语法中，这是一个预定义字符类。<br>同理在正则表达式内，匹配空白字符需要使用 “\\s”。</p>\n<p>在正则表达式中，方括号 [] 定义<strong>字符类</strong>，字符类是一个特殊的表示法，用于<strong>匹配方括号内任意一个字符</strong><br>[abc] 匹配 ‘a’、’b’ 或者 ‘c’ 中的任意一个字符。<br>[0-9] 匹配任意一个数字。<br>字符类内的大多数字符不具备特殊意义，即它们被视作字面量字符，因此在字符类内不需要转义。例如，. 在字符类外表示任意字符，但在字符类内 [.] 就只表示字面上的一个点号。</p>\n<p><strong>元字符在字符类内部的处理 应该只需要考虑这两个</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">反斜杠是转义字符，其本身需要转义。不论在字符类内外都需要转义。</span><br><span class=\"line\"><span class=\"comment\">// 在字符类内外都需要双写反斜杠进行转义</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;[\\\\]&quot;</span>;</span><br><span class=\"line\">方括号本身具有定义字符类的功能，需要在字符类内使用时，需要通过反斜杠 \\进行转义。</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;[\\\\[\\\\]]&quot;</span>; <span class=\"comment\">// 匹配 [ 或 ]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">元字符（Meta Characters）</span><br><span class=\"line\">. (点)</span><br><span class=\"line\">匹配除换行符 \\n 之外的任何单个字符。</span><br><span class=\"line\">例如：a.b 可以匹配 aab, aXb, a0b 等等。</span><br><span class=\"line\">^ (脱字符)</span><br><span class=\"line\">匹配字符串的开始位置。</span><br><span class=\"line\">例如：^abc 只能匹配以 abc 开头的字符串。</span><br><span class=\"line\">$ (美元符)</span><br><span class=\"line\">匹配字符串的结束位置。</span><br><span class=\"line\">例如：abc$ 只能匹配以 abc 结尾的字符串。</span><br><span class=\"line\">* (星号)</span><br><span class=\"line\">匹配前面的字符零次或多次。</span><br><span class=\"line\">例如：a* 可以匹配空字符串、a、aa、aaa 等。</span><br><span class=\"line\">+ (加号)</span><br><span class=\"line\">匹配前面的字符一次或多次。</span><br><span class=\"line\">例如：a+ 可以匹配 a、aa、aaa 等，但不能匹配空字符串。</span><br><span class=\"line\">? (问号)</span><br><span class=\"line\">匹配前面的字符零次或一次（即前面的字符是可选的）。</span><br><span class=\"line\">例如：a? 可以匹配空字符串或 a。</span><br><span class=\"line\">&#123;n&#125;</span><br><span class=\"line\">匹配前面的字符恰好 n 次。</span><br><span class=\"line\">例如：a&#123;<span class=\"number\">3</span>&#125; 只能匹配 aaa。</span><br><span class=\"line\">&#123;n,&#125;</span><br><span class=\"line\">匹配前面的字符至少 n 次。</span><br><span class=\"line\">例如：a&#123;<span class=\"number\">2</span>,&#125; 可以匹配 aa、aaa、aaaa，等等。</span><br><span class=\"line\">&#123;n,m&#125;</span><br><span class=\"line\">匹配前面的字符至少 n 次，但不超过 m 次。</span><br><span class=\"line\">例如：a&#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>&#125; 可以匹配 aa、aaa 和 aaaa。</span><br><span class=\"line\">[] (中括号)</span><br><span class=\"line\">匹配括号内的任意一个字符。</span><br><span class=\"line\">例如：[abc] 可以匹配 a、b 或 c。</span><br><span class=\"line\">[^]（脱字符在中括号里）</span><br><span class=\"line\">匹配括号内未列出的任意字符。</span><br><span class=\"line\">例如：[^abc] 可以匹配除 a、b 和 c 之外的任意字符。</span><br><span class=\"line\">| (竖线)</span><br><span class=\"line\">表示 <span class=\"string\">&quot;或&quot;</span> 逻辑运算符。</span><br><span class=\"line\">例如：a|b 可以匹配 a 或 b。</span><br><span class=\"line\">() (圆括号)</span><br><span class=\"line\">用于分组，将多个字符视为一个整体。</span><br><span class=\"line\">例如：(abc) 将 abc 视为一个整体，并且可以引用分组。</span><br><span class=\"line\">\\ (反斜杠)</span><br><span class=\"line\">转义字符，用于转义元字符使其失去特殊含义。</span><br><span class=\"line\">例如：\\. 可以匹配 . 字符本身，而不再是任意字符。</span><br><span class=\"line\">预定义字符类（Predefined Character Classes）</span><br><span class=\"line\">\\d</span><br><span class=\"line\">匹配任何数字字符，相当于 [<span class=\"number\">0</span>-<span class=\"number\">9</span>]。</span><br><span class=\"line\">例如：\\d 可以匹配 <span class=\"number\">0</span> 到 <span class=\"number\">9</span> 之间的任何一个数字。</span><br><span class=\"line\">\\D</span><br><span class=\"line\">匹配任何非数字字符，相当于 [^<span class=\"number\">0</span>-<span class=\"number\">9</span>]。</span><br><span class=\"line\">例如：\\D 可以匹配字母、符号、空格等非数字字符。</span><br><span class=\"line\">\\w</span><br><span class=\"line\">匹配任何单词字符（包括下划线），相当于 [a-zA-Z0-9_]。</span><br><span class=\"line\">例如：\\w 可以匹配 a 到 z、A 到 Z、<span class=\"number\">0</span> 到 <span class=\"number\">9</span> 和 _。</span><br><span class=\"line\">\\W</span><br><span class=\"line\">匹配任何非单词字符，相当于 [^a-zA-Z0-9_]。</span><br><span class=\"line\">例如：\\W 可以匹配符号、空格等非单词字符。</span><br><span class=\"line\">\\s</span><br><span class=\"line\">匹配任何空白字符，包括空格、制表符、换页符等，相当于 [ \\t\\n\\x0B\\f\\r]。</span><br><span class=\"line\">例如：\\s 可以匹配空格和其他空白字符。</span><br><span class=\"line\">\\S</span><br><span class=\"line\">匹配任何非空白字符，相当于 [^ \\t\\n\\x0B\\f\\r]。</span><br><span class=\"line\">例如：\\S 可以匹配所有非空白字符。</span><br><span class=\"line\">边界匹配（Boundary Matchers）</span><br><span class=\"line\">\\b</span><br><span class=\"line\">匹配一个单词的边界。</span><br><span class=\"line\">例如：\\bword\\b 可以匹配 word，但不能匹配 sword 或 words。</span><br><span class=\"line\">\\B</span><br><span class=\"line\">匹配非单词边界。</span><br><span class=\"line\">例如：\\Bword\\B 可以匹配 swords 中的 word 部分。</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"delete语句\"><a href=\"#delete语句\" class=\"headerlink\" title=\"delete语句\"></a>delete语句</h3><p>一般是 delete from tableName where</p>\n<p>注意：为了 SQL 语法和执行流程中的一致性，在删除操作中直接查询同一张表是不允许的。</p>\n<p>这里理解下派生表（Derived Table）：派生表即子查询生成的一块临时数据集，如这里的 <code>select min(id) id from person p2 group by email</code> 生成的临时数据集。<br>派生表只在查询执行过程中生存，并且只在此次查询范围内有效。<br>同样的：这个也是一个派生表，并且由于多加了外层select就”<strong>避免</strong>“了同时删除和查询同一张表？</p>\n<p>具体来讲，当我们在一个查询中既要删除数据又要查询数据时，直接在删除子句 (DELETE) 中操作和查询同一个表可能会引发未定义的行为或者错误。通过使用额外的一层 SELECT，可以有效地避免这些情况。这一层 SELECT 生成了一个派生表，用于隔离修改和查询操作。【有点玄乎，先这么理解吧，得靠外层的select的派生表才能隔绝】【额外的 SELECT 创建了一个派生表，从而建立起了一种逻辑上的数据隔离。这样，不会因为删除操作进行时表的数据变化而影响到查询结果。】<br>在某些数据库管理系统中，一边查询一边删除同一个表可能会导致死锁或其它并发问题。通过这种<strong>迂回查询</strong>，避免了直接操作同一张表的问题，从而提高了操作的安全性。</p>\n<p>外层 t 的 SELECT <strong>包装了一层</strong>将其<strong>命名为 t 从而创建了派生表</strong>，这样可以确保后续语句引用此子查询结果。而非直接行操作。</p>\n<p>派生表 t 的数据在子查询执行的一开始就已经确定了，它不会随着对表 person 的后续操作而变化。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> t.id</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(id) <span class=\"keyword\">AS</span> id</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> person p2</span><br><span class=\"line\">    <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> email</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> t</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.cn/problems/delete-duplicate-emails/description/\">196. 删除重复的电子邮箱</a> 重要的delete题。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> p1 <span class=\"keyword\">FROM</span> Person p1,</span><br><span class=\"line\">    Person p2</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    p1.Email <span class=\"operator\">=</span> p2.Email <span class=\"keyword\">AND</span> p1.Id <span class=\"operator\">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure>\n\n<p><strong>这种DELETE方式很陌生</strong>，竟然和SELETE的写法类似。它涉及到t1和t2两张表，<strong>DELETE t1表示要删除t1的一些记录</strong>，具体删哪些，就看WHERE条件，满足就删；</p>\n<p><a href=\"https://leetcode.cn/problems/delete-duplicate-emails/solutions/219860/dui-guan-fang-ti-jie-zhong-delete-he-de-jie-shi-by/\">可以看这篇题解</a></p>\n<h3 id=\"UNION和UNION-ALL\"><a href=\"#UNION和UNION-ALL\" class=\"headerlink\" title=\"UNION和UNION ALL\"></a>UNION和UNION ALL</h3><p>UNION和UNION ALL 具有不同工作机制：</p>\n<p>UNION：默认会对合并的结果集进行<strong>去重</strong>操作，因此在UNION中每个子查询的ORDER BY子句必须放在整体查询之外，因为在去重之前的排序操作是无意义的。ORDER BY子句在使用UNION时应该对<strong>最终合并、去重后的结果进行排序</strong>。</p>\n<p>UNION ALL：则不进行去重操作，直接合并所有结果集。因此，<strong>每个子查询的ORDER BY子句可以保留在自己的子查询内部</strong>，因为UNION ALL是直接将所有结果集按照子查询的顺序合并，保留各自的排序。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://github.com/CyC2018/CS-Notes/tree/master\">CS-Notes</a> </p>\n<p><a href=\"https://programmercarl.com/\">代码随想录</a> </p>\n<p><a href=\"https://algo.itcharge.cn/07.Tree/\">算法通关手册（LeetCode）</a></p>\n<p><a href=\"https://blog.csdn.net/BillCYJ/article/details/79250382\">深入理解递归</a></p>\n"},{"title":"guitarNote","url":"/2023/01/02/guitarNote/","content":"<p><strong>抚琴动操，欲令众山皆响</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h1><h2 id=\"吉他挑选\"><a href=\"#吉他挑选\" class=\"headerlink\" title=\"吉他挑选\"></a>吉他挑选</h2><img src=\"/2023/01/02/guitarNote/2.jpg\" class=\"\">\n\n<p><a href=\"https://guitartogo-music.com/shopping-guide/first-guitar-shopping-guide/?utm_medium=adword&utm_campaign&utm_source&utm_term=%E5%90%89%E4%BB%96%20%E6%8E%A8%E8%96%A6&gclid=Cj0KCQiA5NSdBhDfARIsALzs2EBMD39h14gO-YOiLUzFY3ILddi8GC7qvtt4vymupiaHuXPNUr15NscaAtD8EALw_wcB\">新手吉他購買須知</a></p>\n<p><a href=\"https://guitartogo-music.com/shopping-guide/guitar-tonewoods/\">吉他木材</a></p>\n<p><a href=\"https://guitartogo-music.com/shopping-guide/how-to-choose-guitar-strings/\">吉他弦怎麼挑</a></p>\n<h2 id=\"基本功-左手和右手\"><a href=\"#基本功-左手和右手\" class=\"headerlink\" title=\"基本功(左手和右手)\"></a>基本功(左手和右手)</h2><p>右手大拇指弹456弦，食指弹3弦，中指弹2弦，无名指弹1弦。小拇指不弹（指弹对空间感把握较差的话可以搭在音孔附近，有利于右手拨弦找位置）</p>\n<ol>\n<li>先开始练53231323，空弦练，练这个是为了提高你手指的熟练度，很多新手刚开始练吉他都会出现刻意去看你的右手的问题，想去看自己的手指有没有放在对应的琴弦上面。 不要小瞧这个，你要练到<strong>不用看可以很流畅的弹出来</strong>，并且每一根手指弹完之后 可以很自然的放在对应的琴弦上面（要去找这个感觉）。</li>\n<li>爬格子左手要去按琴弦了，练着手会很痛因为要起茧子，老手不常弹再弹也一样会经历这个过程。一定要坚持，不要怕痛。如果连爬格子都坚持不下来，梦该醒了。<br><a href=\"https://www.bilibili.com/video/av70608132/?from=search&seid=529843851570307118&vd_source=7b41839c0bc8f13071f01977ba9e14de\">爬格子练习</a>（练了不少了，可以开始练音阶）<ul>\n<li>刚开始左手可能会按不紧导致弹不响，那就使劲去按别怕痛，不痛不肯起茧的</li>\n<li>需要练习左手手指跨度，推荐跟着<a href=\"https://www.bilibili.com/video/av81958961/?spm_id_from=333.788.b_7265636f5f6c697374.1&vd_source=7b41839c0bc8f13071f01977ba9e14de\">打开手指</a>锻炼。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"右手拨弦\"><a href=\"#右手拨弦\" class=\"headerlink\" title=\"右手拨弦\"></a>右手拨弦</h3><p>大拇指用拇指外侧的肉去拨弦，就是右手大拇指偏左侧的一点肉；<br>其他手指用的是指尖顶端的肉，指甲会带动一点琴弦；右手指甲要留1-2mm的长度，圆弧状；左手不留指甲。<br>所有手指都是往手心方向拨弦。<br>中指拨弦时食指不要靠在三弦上，无名指拨弦时食指中指不要靠在对应弦上免得造成障碍。<br>大拇指超出食指一个指节左右，<strong>大拇指用根部关节（大关节）运动来拨弦</strong>，其他手指也主要是用大关节来发力，然后配合中间关节来引导力的方向。</p>\n<h3 id=\"左手握法\"><a href=\"#左手握法\" class=\"headerlink\" title=\"左手握法\"></a>左手握法</h3><p>两种握法：<br>现代琴握法和古典琴握法。</p>\n<p>现代握法手指要斜向，这样才能伸得远，如果小鱼际碰到了琴颈，太垂直了手指就不好张开，够不到高品格了。</p>\n<p>左手手指的数字标记：<br>食指1、中指2、无名指3、小指4、大拇指T<br>左手按弦要点：<br>指尖按在品格最右边<br>手指关节自然拱起来</p>\n<h2 id=\"节拍\"><a href=\"#节拍\" class=\"headerlink\" title=\"节拍\"></a>节拍</h2><p><strong>拍号：</strong> 表示拍子的记号，如2&#x2F;4、3&#x2F;4、4&#x2F;4、2&#x2F;2、3&#x2F;8、6&#x2F;8等。拍号用分数形式标记，分子(左边的数字)表示每小节有几拍，分母(右边的数字)表示几分音符为一拍，读拍号时从右往左读(先读分母再读分子)，只读数字。如6&#x2F;8拍读作八六拍，表示八分音符为一拍，每小节有六拍；如4&#x2F;4读作四四拍，表示四分音符为一拍，每小节有四拍。</p>\n<p>以下图为例(4&#x2F;4 四四拍)：</p>\n<img src=\"/2023/01/02/guitarNote/5.png\" class=\"\">\n\n<p>该第七小节有四拍，每一个段落就是一拍。以四分音符为一拍的话，则二分音符长度为两个节拍，四分音符长度为一个节拍，上图两条线的就是十六分音符，长度为四分之一节拍，所以四个十六分音符组成了一个节拍，一条线的是八分音符，长度为二分之一节拍，相当于两个十六分音符，上图第二拍的后半拍出现了八分音符，所以在第三拍应该<strong>再持续一个十六分音符的时值</strong>再接着往下弹。</p>\n<h2 id=\"换弦和调弦\"><a href=\"#换弦和调弦\" class=\"headerlink\" title=\"换弦和调弦\"></a>换弦和调弦</h2><h3 id=\"换弦\"><a href=\"#换弦\" class=\"headerlink\" title=\"换弦\"></a>换弦</h3><p>123弦拧紧：吉他正面对你右手逆时针（对右手掌心来说是逆时针）的方向，音比较低要升的时候这么拧</p>\n<p>456弦拧紧：吉他正面对你左手逆时针（对左手掌心来说是逆时针）的方向，音比较低要升的时候这么拧</p>\n<p><a href=\"https://www.bilibili.com/video/BV1Hx411G7Gg/?spm_id_from=333.788.recommend_more_video.2&vd_source=7b41839c0bc8f13071f01977ba9e14de\">换弦</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1uv411a7Ac/?spm_id_from=333.337.search-card.all.click&vd_source=7b41839c0bc8f13071f01977ba9e14de\">吉他换弦</a></p>\n<p>放弦柱的时候往下压的同时弦要往上拉<br>旋钮要扭到孔朝前<br>琴弦拉过去理顺拉直<br>456弦从上琴枕的位置开始往回拉一品半，456拧旋钮要让弦往吉他正面左边走，具体看第一个视频。</p>\n<p>可以先调到降全音，再调到将半音，再调到标准音</p>\n<h3 id=\"调弦\"><a href=\"#调弦\" class=\"headerlink\" title=\"调弦\"></a>调弦</h3><h4 id=\"标准-x2F-特殊-调音\"><a href=\"#标准-x2F-特殊-调音\" class=\"headerlink\" title=\"(标准&#x2F;特殊)调音\"></a>(标准&#x2F;特殊)调音</h4><p>标准调音： <strong>E A D G B E</strong></p>\n<p>降全音：  D G C F A D</p>\n<p>降半音：  <strong>Eb G# C# F# A# Eb</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/BV1hb411G7Pf?p=1&vd_source=7b41839c0bc8f13071f01977ba9e14de\">特殊调弦</a> <strong>0:58</strong></p>\n<p>特殊调弦举例：<br><strong>open D：</strong> 从六弦到一弦调成了 D、A、D、F#(升F，在F和G之间的一个半音)、A、D 。 oepn D的空弦其实和标准调音的D和弦声音是一样的。</p>\n<h4 id=\"调音方法\"><a href=\"#调音方法\" class=\"headerlink\" title=\"调音方法\"></a>调音方法</h4><p>就近原则 + 松左紧右<br>比如六弦从 E 调到 D ，比较近的应该向左调，也就是使琴弦松的方向调（音高降低）。</p>\n<img src=\"/2023/01/02/guitarNote/3.png\" class=\"\">\n\n<p>松一弦和二弦这样比较细的弦的时候要慢一点，尤其是弦用了很久有生锈的情况时，会由于张力的突然大幅度减小使琴弦断开。<br>注意：调其他的弦一定会影响到其他的弦，比如把三弦调松了，调好的其他弦都会变紧，至少要重新调整一轮，影响会降得越来越低。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1hb411G7Pf?p=1&vd_source=7b41839c0bc8f13071f01977ba9e14de\">打品</a> <strong>26：11</strong>，如果因为音高过低出现了打品的情况，则可以稍微调高一下弦距。</p>\n<h3 id=\"琴颈\"><a href=\"#琴颈\" class=\"headerlink\" title=\"琴颈\"></a>琴颈</h3><img src=\"/2023/01/02/guitarNote/117.png\" class=\"\">\n\n<p>顺时针旋转（3的方向、往一弦拧），琴颈会上凸，降低弦距。</p>\n<p>逆时针旋转（2的方向、往六弦拧），琴颈会下凹，抬高弦距。</p>\n<p>最后一次去知音琴行调整弦距的时候，因为共振弹二弦的时候六弦低品处会有点打品，因为六弦音最低震动幅度最大，要么就用标准音（不要降全音），要么就扭琴颈往六弦方向拧，我最后选择让师傅往六弦方向拧了90度，解决了这个问题。</p>\n<p>后面如果想让弦距再低一点，可以往往一弦拧，<strong>最多拧90度</strong>，不能再多了。拧的过程中需要注意：琴弦无须全部放松，保持琴弦拉力，在调节的时候我们可以即时的看到效果。单次调节幅度不宜过大，以免对琴颈造成损害。</p>\n<p>另：赶紧换琴。</p>\n<h1 id=\"乐理\"><a href=\"#乐理\" class=\"headerlink\" title=\"乐理\"></a>乐理</h1><p>主要学习视频<a href=\"https://www.bilibili.com/video/BV1jW411J765?p=7&vd_source=7b41839c0bc8f13071f01977ba9e14de\">基础乐理入门</a>。</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"吉他的音\"><a href=\"#吉他的音\" class=\"headerlink\" title=\"吉他的音\"></a>吉他的音</h3><p>调音器模式：G吉他、B贝斯、V小提琴、U尤克里里、C十二平均律。<br>在吉他模式下调音只会出现 <strong>E A D G B E</strong> 这几个字母。</p>\n<p>在<strong>C调</strong>的情况下，如果使用音名来表示每一根琴弦的空弦音高，一把吉他的<strong>标准音高</strong>从粗线到细弦分别是：<strong>E A D G B E</strong> （音高从低到高，六弦最低，一弦最高）</p>\n<blockquote>\n<p>这两张图很重要<br><strong>音阶</strong></p>\n</blockquote>\n<img src=\"/2023/01/02/guitarNote/12.png\" class=\"\">\n<blockquote>\n<p><strong>高八度和低八度</strong></p>\n</blockquote>\n<img src=\"/2023/01/02/guitarNote/14.png\" class=\"\">\n<p>越往右边音调越高，越往左边音调越低</p>\n<p>六弦： E，简谱3，<strong>低音</strong>的Mi<br>五弦： A，简谱6，<strong>低音</strong>的La<br>四弦： D，简谱2，<strong>中音</strong>的Re<br>三弦： G，简谱5，<strong>中音</strong>的Sol<br>二弦： B，简谱7，<strong>中音</strong>的Si<br>一弦： E，简谱3，<strong>高音</strong>的Mi</p>\n<p><strong>各弦之间形成三，四度音程关系</strong>。简单地看几度音程关系可以这样看：看上图两个音高之间共包含了几个音高，如六弦E和五弦A之间包括了(E、F、G、A)则为四度音程关系，也可以通过计算(6-3+1&#x3D;4)；再如五弦A和四弦D之间包括了(A、B、C、D)同样为四度音程关系，计算时四弦D应该是(7+2&#x3D;9)，所以计算为(9-6+1&#x3D;4)。在音程章节细说。</p>\n<p><strong>标准定弦</strong>的音高其实是：E2-A2-D3-G3-B3-E4<br>字母表示音名，<strong>数字表示所在八度</strong>（六弦E和五弦A是低音，四弦D、三弦G和二弦B是中音，一弦E是高音。还有倍低音和倍高音这两个八度），这种体系称为<strong>科学记谱法</strong>，这种记谱法为每一个音高指定了频率，如下：</p>\n<img src=\"/2023/01/02/guitarNote/6.png\" class=\"\">\n\n<p><strong>音和音之间的全半音关系：</strong> </p>\n<img src=\"/2023/01/02/guitarNote/15.png\" class=\"\">\n\n<p>两个白键之间有黑键就是<strong>全音</strong>的关系，没有黑键则是<strong>半音</strong>的关系。<br>#表示升，b表示降。如1和2之间的黑键可以叫做升C或降D。<br>中间有半音的话，升音的过程会经过这个半音。</p>\n<img src=\"/2023/01/02/guitarNote/16.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/63.png\" class=\"\">\n\n<p>琴弦越短，音高越高。通过左手按弦，移动一个品格，就会增加音高一个半音。琴颈上一共有20个品格，也就是20个半音。</p>\n<img src=\"/2023/01/02/guitarNote/64.png\" class=\"\">\n\n<p>原声(acoustic guitar)吉他的音域接近四個八度音！</p>\n<img src=\"/2023/01/02/guitarNote/65.png\" class=\"\">\n\n\n<h3 id=\"谱\"><a href=\"#谱\" class=\"headerlink\" title=\"谱\"></a>谱</h3><p>五线谱有五根线，线上和线间都可以画音符，即五线四间可以画九个音符，还可以在五线上下加两根线，即上加一线、上加二线、下加一线、下加二线，还有上加一间、上加二间、下加一间、下加二间都可以画音符。</p>\n<p>五线谱有高音谱号（拧的像麻花一样）和低音谱号，<strong>吉他用的主要是高音谱号</strong>，对应的叫<strong>高音谱表</strong>。</p>\n<p>五线谱<strong>下加一线</strong>上的音是Do（1），上一个间的音符是Re（2），上一根线是Mi（3），上一个间是Fa（4），以此类推。可以快速找到八度的<strong>C大调音阶</strong>在五线谱的什么位置。</p>\n<p>六线谱不是真正的乐谱，它没有告诉你正在弹的是什么音，只是告诉你左手右手该怎么操作，<strong>国际</strong>上通用的乐谱通常是<strong>六线谱加上五线谱</strong>的形式，<strong>国内标准</strong>通常是<strong>六线谱加上简谱</strong>的形式，简谱就是1234567。</p>\n<p>简谱通过加<strong>高低音点</strong>来区分这个音所在的八度的（高音点在上面，低音点在下面，有低中高八度）。五线谱中是通过<strong>音符在五线谱中的高低位置</strong>来分辨音的高低的，这也是二者最大的区别。</p>\n<h3 id=\"打拍子-附点音符\"><a href=\"#打拍子-附点音符\" class=\"headerlink\" title=\"打拍子 附点音符\"></a>打拍子 附点音符</h3><img src=\"/2023/01/02/guitarNote/17.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/18.png\" class=\"\">\n\n<p>一个全音符，两个二分音符，四个四分音符，八个八分音符··乘起来都是1，表示四拍，四拍就是四个段落。</p>\n<img src=\"/2023/01/02/guitarNote/19.png\" class=\"\">\n\n<p>休止就是只打拍子不演奏。</p>\n<img src=\"/2023/01/02/guitarNote/20.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/21.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/22.png\" class=\"\">\n\n<p><strong>附点音符</strong>和音符一样都是用来描述音符的时值，也就是这个音符应该持续的时间。</p>\n<img src=\"/2023/01/02/guitarNote/23.png\" class=\"\">\n\n<p>1 2 5 6 分别是 Do Re Sol La，下划线，附点，横线等都是在描述每个音在一个拍中持续的时长，整个拍的时值是不会变的。</p>\n<img src=\"/2023/01/02/guitarNote/24.png\" class=\"\">\n\n<p><strong>连音：</strong><br><strong>同音</strong>之间的连音有点像全音符5—，之所以这样的写法有可能是因为全音符这四拍被分成了两个小节，小节开头不能是横线，所以这样写，便于两个小节合并。<br><strong>异音</strong>之间的连接要连贯一点，像是吸一口气演奏完。</p>\n<img src=\"/2023/01/02/guitarNote/25.png\" class=\"\">\n\n\n<h3 id=\"切分节奏\"><a href=\"#切分节奏\" class=\"headerlink\" title=\"切分节奏\"></a>切分节奏</h3><p>带黄色*号的的是切分音，把这个音符给切开，跟前面或后面的音符组成一个四分音符也就是组成一拍，因为前面的拍号2&#x2F;4表示这里四分音符为一拍，一个小节有两拍。整个小节就是切分节奏。</p>\n<img src=\"/2023/01/02/guitarNote/26.png\" class=\"\">\n\n\n<h3 id=\"拍号-小节\"><a href=\"#拍号-小节\" class=\"headerlink\" title=\"拍号 小节\"></a>拍号 小节</h3><p>在<strong>小节线后面的第一拍</strong>永远是<strong>强拍</strong>，在<strong>小节线前面的最后一拍</strong>永远是<strong>弱拍</strong>。</p>\n<img src=\"/2023/01/02/guitarNote/27.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/30.png\" class=\"\">\n\n<p><strong>先读分母再读分子</strong>，如八三拍。</p>\n<img src=\"/2023/01/02/guitarNote/28.png\" class=\"\">\n\n<p>四二拍，四分音符为一拍，一个小节有两拍， 没有四分音符没关系，只要组合成四分音符就可以。</p>\n<p>横线<strong>下面的点表示低音</strong>，<strong>右下角的点是附点</strong>。</p>\n<img src=\"/2023/01/02/guitarNote/29.png\" class=\"\">\n\n\n<h3 id=\"强弱拍-弱起\"><a href=\"#强弱拍-弱起\" class=\"headerlink\" title=\"强弱拍 弱起\"></a>强弱拍 弱起</h3><p>四四拍相当于两个四二拍合在一起，但<strong>一个小节只能有一个强拍</strong>，所以第三个拍变成次强拍，改编曲子时可以把四四拍改成两个四二拍。<br><strong>四四拍 比如 动次打次</strong>。</p>\n<img src=\"/2023/01/02/guitarNote/31.png\" class=\"\">\n\n<p>在<strong>每一个拍子</strong>中，<strong>前半拍都是强拍，后半拍都是弱拍</strong>，V的前一半是强拍，后一半是弱拍。<br><strong>起</strong>：你看歌词从哪里开始就是从哪里起<br><strong>单位拍弱起</strong>：05，休止符不唱，5要唱，5是在这个单位拍的弱拍上，这个拍从5开始也就是从弱拍开始，因此叫做单位拍弱起。<br><strong>小节弱起</strong>：记得小节线前面一定是弱拍吗？所以5是上一个小节的弱拍，从5开始也就是弱拍起，所以是小节弱起。<br><strong>小节弱起且弱拍起</strong>：看歌词(你问我爱你有多深 的 你)上面的八分音符05，05是上一个小节的弱拍（05在小节线前，是强、弱、次强、弱的最后一个弱），又是从05这个单位拍的弱拍（后半拍是弱拍）5起，所以是小节弱起且弱拍起。</p>\n<img src=\"/2023/01/02/guitarNote/32.png\" class=\"\">\n\n\n<h3 id=\"反复记号\"><a href=\"#反复记号\" class=\"headerlink\" title=\"反复记号\"></a>反复记号</h3><p><strong>D.S 代表从记号处反复</strong>，最后一个<strong>标记符号</strong>配合其他的符号使用。  </p>\n<img src=\"/2023/01/02/guitarNote/61.png\" class=\"\">\n\n<p>注释讲的不错。括号里的D.C表示这里讲D.C，所以<strong>第二种</strong>从头反复记号下面应该是D.C而不是D.S。第六种的符号就是龟跳符号。</p>\n<img src=\"/2023/01/02/guitarNote/62.png\" class=\"\">\n\n\n\n<h2 id=\"音程\"><a href=\"#音程\" class=\"headerlink\" title=\"音程\"></a>音程</h2><h3 id=\"音程概念\"><a href=\"#音程概念\" class=\"headerlink\" title=\"音程概念\"></a>音程概念</h3><h4 id=\"自然音程\"><a href=\"#自然音程\" class=\"headerlink\" title=\"自然音程\"></a>自然音程</h4><img src=\"/2023/01/02/guitarNote/34.png\" class=\"\">\n<img src=\"/2023/01/02/guitarNote/35.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/36.png\" class=\"\">\n\n<p><strong>纯&#x2F;小&#x2F;大&#x2F;增&#x2F;减 几度</strong>，其中的<strong>几度</strong>是前面提到过的的度数，并不是单纯由音数决定。</p>\n<p><strong>规律</strong>：<br>2367只有大小。<br>1458只有纯(但是4、5还有增四减五)。<br>技巧：<strong>2、3</strong>的大小是<strong>小的有半音</strong>，<strong>6、7</strong>的大小是<strong>大的有半音</strong>。<br><strong>增四减五音数3</strong>要记。</p>\n<p><strong>方法</strong>：<br>重点是知道几度，几度就用后减前+1来计算，比如根音是1，冠音是3，3-1+1&#x3D;3，没半音，所以是大三度，真简单。<br>按照这个方法，纯一，纯八不用记，<strong>纯四&lt;增四&#x3D;音数3&#x3D;减五&lt;纯五</strong>，所以纯四音数为2.5，纯五音数为3.5，<strong>或者说4、5有半音的都是纯的</strong>。</p>\n<img src=\"/2023/01/02/guitarNote/37.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/38.png\" class=\"\">\n\n<h4 id=\"音程的转位\"><a href=\"#音程的转位\" class=\"headerlink\" title=\"音程的转位\"></a>音程的转位</h4><p>下面的音是低音下方音（根音），上面的音是高音上方音（冠音）。<strong>转位是把在下面的根音提高一个纯八度放到原来冠音的上面</strong>。<br>转换前后的两组的<strong>音程</strong>是有规律的：<strong>度数和是9，并且一大一小，纯对纯，增对减</strong>，比如转位前是大三度，转位后就是小六度。</p>\n<img src=\"/2023/01/02/guitarNote/39.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/40.png\" class=\"\">\n\n\n<h3 id=\"变化音和变化音程\"><a href=\"#变化音和变化音程\" class=\"headerlink\" title=\"变化音和变化音程\"></a>变化音和变化音程</h3><h4 id=\"变化音\"><a href=\"#变化音\" class=\"headerlink\" title=\"变化音\"></a>变化音</h4><img src=\"/2023/01/02/guitarNote/41.png\" class=\"\">\n\n<h4 id=\"变化音程\"><a href=\"#变化音程\" class=\"headerlink\" title=\"变化音程\"></a>变化音程</h4><p>除了自然音程以外的都是变化音程。</p>\n<p><strong>增音程</strong>比纯音程、大音程都要大半个音数，<strong>减音程</strong>比纯音程、小音程还要小半个音数。<br><strong>倍增音程</strong>比增音程还要大半个音数，<strong>倍减音程</strong>比减音程还要小半个音数。</p>\n<p>如3-b4，是减二度，实际音高就是纯一度。(ps:3-bb4即倍减二度是不存在的)<br>如1-#7，是增七度，实际音高就是纯八度。(ps:1-x7即倍增七度是存在的)</p>\n<img src=\"/2023/01/02/guitarNote/42.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/44.png\" class=\"\">\n\n<p>引入<strong>等音程</strong>的概念：这俩音响效果完全一样（就是听起来实际音高一样），音数相同，唯一不同的是度数不同，也就是两个音之间包含的音级的数目不同，3-b4有3和4，度数是2，3-3度数只有3，度数是1。</p>\n<img src=\"/2023/01/02/guitarNote/45.png\" class=\"\">\n\n\n\n<h2 id=\"和弦\"><a href=\"#和弦\" class=\"headerlink\" title=\"和弦\"></a>和弦</h2><p>分为三、七、九、挂留和弦。</p>\n<h3 id=\"三和弦\"><a href=\"#三和弦\" class=\"headerlink\" title=\"三和弦\"></a>三和弦</h3><p><strong>有三个音，能够按照三度关系依次排列。</strong></p>\n<p>如C和弦（1 3 5），以1为根音，三度为关系往上叠加。<br>常用三和弦有四种：</p>\n<ol>\n<li><strong>大三和弦</strong>，以C和弦为例（1 3 5），是<strong>大三度加小三度</strong>的组合，记作C或CM。<br>常用大三和弦有<strong>C</strong>（1 3 5），<strong>F</strong>（4 6 高音1），<strong>G</strong>（5 7 高音2）</li>\n<li><strong>小三和弦</strong>，以Am和弦为例（6 高音1 高音3），<strong>小三度加大三度</strong>。<br>常用小三和弦有<strong>Am</strong>（6 高音1 高音3），<strong>Dm</strong>（2 4 6），<strong>Em</strong>（3 5 7）</li>\n<li><strong>增三和弦</strong>，以Caug为例（1 3 #5），是大三度加大三度的组合。</li>\n<li><strong>减三和弦</strong>，以Cdim为例（1 b3 b5），是小三度加小三度的组合。常用减三和弦还有Bdim（7 高音2 高音4）。</li>\n</ol>\n<p>增三和弦和减三和弦都很不协调，在乐曲中用的少，一般用的多的是大三和小三和弦。</p>\n<img src=\"/2023/01/02/guitarNote/46.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/47.png\" class=\"\">\n\n\n<h3 id=\"七和弦\"><a href=\"#七和弦\" class=\"headerlink\" title=\"七和弦\"></a>七和弦</h3><p>在三和弦的基础上加了一个<strong>根音的七度音（小七度或大七度）</strong>。<br>大三和弦主要有：C、F、G；小三和弦主要有Dm、Em、Am。</p>\n<ol>\n<li><strong>大大七和弦（简称大七和弦）</strong>，比如<strong>C大七（1 3 5 7）</strong>是大三C和弦加一个<strong>根音的大七度</strong>，用<strong>CM7或Cmaj7</strong>表示。大三C和弦是C（1 3 5），加一个相对根音（1）的大七度（所以是1 7），合起来就是Cmajor7（1 3 5 7）。常用大大七和弦还有有：<strong>FM7&#x2F;Fmaj7（4 6 高音1 高音3）</strong>。</li>\n<li><strong>大小七和弦（在调式中也被叫做属七和弦）</strong>，是一个<strong>大三和弦</strong>加一个<strong>根音的小七度</strong>。 比如<strong>C7（1 3 5 b7）</strong>，由大三C和弦加一个（1 b7，这是小七度）组成。常用大小七和弦还有<strong>G7（5 7 高音2 高音4）</strong>。</li>\n<li><strong>小大七和弦</strong>，由一个<strong>小三和弦</strong>如Dm加一个<strong>大七度</strong>组成如<strong>DmM7（2 4 6 #高音1）</strong>，小大七和弦还有AmM7（6 高音1 高音3 #高音5），用的比较少。</li>\n<li><strong>小小七和弦</strong>（简称<strong>小七和弦</strong>），由一个<strong>小三度</strong>比如Dm加一个<strong>小七度</strong>组成<strong>Dm7（2 4 6 高音1）</strong>，常见的还有<strong>Em7（3 5 7 高音2）</strong>，<strong>Am7（6 高音1 高音3 高音5）</strong>。</li>\n<li><strong>减小七和弦</strong>，在<strong>减三和弦</strong>的基础上加了一个根音的<strong>小七度</strong>，比如Bdim（7 高音2 高音4）加一个小七度（7 高音6）组成Bdim7（7 高音2 高音4 高音6）。</li>\n<li><strong>减减七和弦（或者叫半减七）</strong>，<strong>减三和弦</strong>加根音的<strong>减七度</strong>。</li>\n</ol>\n<p><strong>大大七和弦(大七和弦)、大小七和弦(属七和弦)和小小七和弦(小七和弦)用的比较多，要记住。名字中的大小就是大&#x2F;小三和弦和大&#x2F;小七度</strong>。如果用了大七度，则该七和弦的名字中有M7，用小七度只有7(小大七和弦那张图有错，以文字为准)。</p>\n<img src=\"/2023/01/02/guitarNote/49.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/50.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/52.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/51.png\" class=\"\">\n\n\n<h3 id=\"和弦的转位\"><a href=\"#和弦的转位\" class=\"headerlink\" title=\"和弦的转位\"></a>和弦的转位</h3><p>所谓转位就是把当前的最低音一个个升高纯八度后放到最上面，也成为了最高音。三和弦转位有两个，七和弦转位有四个。</p>\n<p>以三和弦的大三C和弦为例，两种转位，这里1永远是根音，在第一种转位下也是高音。</p>\n<img src=\"/2023/01/02/guitarNote/55.png\" class=\"\">\n\n<p><strong>三和弦转位</strong>命名的数字是：最低音到<strong>根音</strong>的度数(右下角)和最低音到<strong>最高音</strong>的度数(右上角)。第一种转位C6是因为根音和最高音都是 高音1。</p>\n<p>吉他琴谱有时候会出现C&#x2F;G，C&#x2F;E的表示，这些都是表示C的转位，因为<strong>大三G和弦</strong>（5 7 高音2）的最低音是5，<strong>小三Em和弦</strong>（3 5 7）的最低音是3，所以C&#x2F;G表示（5 高音1 高音3）即C的第二转位，C&#x2F;E表示（3 5 高音1）即C的第一转位。</p>\n<img src=\"/2023/01/02/guitarNote/56.png\" class=\"\">\n\n<p><strong>七和弦转位</strong>命名：当前转位最低音到<strong>七音</strong>的度数(右下角)和当前转位最低音到<strong>根音</strong>的度数(右上角)。其中<strong>七音</strong>是最开始的原位和弦中与最低音对应的那个音（二者差了七度），转位后七音不变。当然，根音就是原位和弦中的最低音，也不会变的。</p>\n<p>以七和弦的<strong>大小七和弦(属七和弦)</strong> <strong>G7</strong>（5 7 高音2 高音4）为例，这里5永远是根音，原位和弦最低音是5，和高音4差了七度，所以4是七音。第一转位下的5和6就是这么来的。<br>第三转位纯一度就不写了，2写右上角或写旁边。</p>\n<img src=\"/2023/01/02/guitarNote/57.png\" class=\"\">\n\n\n<h3 id=\"九和弦-挂留和弦\"><a href=\"#九和弦-挂留和弦\" class=\"headerlink\" title=\"九和弦 挂留和弦\"></a>九和弦 挂留和弦</h3><p>常见<strong>九和弦</strong>有<strong>C9（也叫属九和弦）</strong>和<strong>Cadd9</strong>。</p>\n<p>C9和C7（属七和弦）类似，在<strong>属七和弦</strong>的基础上再加一个<strong>九度音</strong>（相对于根音，应该也是小九度音），就像C7（大小七和弦）是在大三和弦的基础上加一个小七度音（相对于根音）。<br>Cadd9不符合传统和弦的定义，是在<strong>C和弦</strong>的基础上<strong>直接外加了一个九度音</strong>（相对于根音）。<br>注意不要混淆C9和Cadd9。</p>\n<img src=\"/2023/01/02/guitarNote/58.png\" class=\"\">\n\n<p><strong>挂留和弦</strong>一般指<strong>用二度音或纯四度音代替原来的三度音而排列组合成的和弦</strong>。<br><strong>sus</strong>就是挂留的意思，常见的有：Dsus2，Dsus4，Csus2。<br>大三C和弦本来是（1 3 5），Csus2是用二度音代替三音变成了（1 2 5），用2去代替3；Csus4是用四度音去代替三度音，所以变成了（1 4 5）。</p>\n<img src=\"/2023/01/02/guitarNote/59.png\" class=\"\">\n\n\n<h2 id=\"调与调式\"><a href=\"#调与调式\" class=\"headerlink\" title=\"调与调式\"></a>调与调式</h2><p>调：调像是一首歌曲的音高吧，同一首歌旋律相同调不同，听起来也是差很多的。<br>唱歌跑调指的是伴奏和唱的高度就不是一个调，显得很别扭不协调</p>\n<h3 id=\"调式：\"><a href=\"#调式：\" class=\"headerlink\" title=\"调式：\"></a>调式：</h3><p><strong>以一个音为核心，按照一定音程关系将不同音高的若干个乐音组织在一起构成一个有机体就叫做调式。</strong></p>\n<p>调式可以分为大调式和小调式，也可以分为自然、和声和旋律调。</p>\n<p>比如<strong>C大调(C Major)</strong> 是一个从C音开始的<strong>自然大调</strong>，组成的音有 <strong>C D E F G A B 高音C</strong>，是一个没有升号和降号的调。<br><strong>G大调</strong>则是以G为中心音的大调式，G自然大调音阶为 <strong>G A B C D E #F G</strong>。</p>\n<p><strong>调式体系</strong>包括<strong>大调与小调</strong>两种调式。根据<strong>主音(第一个音)</strong> 与其上方<strong>三度音</strong>的<strong>音程</strong>来分类，三级音为<strong>大三度者</strong>为<strong>大调式</strong>，三级音为<strong>小三度者</strong>为<strong>小调式（一般情况下）</strong>。调式自17世纪起在欧洲音乐中占重要地位，后也应用于其他地区。</p>\n<p><strong>自然大、小调式</strong>可以取<strong>自然音阶中任何一音为主音</strong>，分为：</p>\n<ul>\n<li><strong>自然大调式(亦称大音阶)<strong>：确定主音后按</strong>全音、全音、半音、全音、全音、全音、半音</strong>的顺序排列而得的调式音阶，这时半音位置在调式音阶的<strong>第3与第4、第7与第8音</strong>之间，其特点为：主音与其上方三度音、六度音、七度音构成<strong>大</strong>三度、<strong>大</strong>六度及<strong>大</strong>七度音程。</li>\n<li><strong>自然小调式(亦称小音阶)<strong>：确定主音后按</strong>全音、半音、全音、全音、半音、全音、全音</strong>的顺序排列而得的调式音阶，这时半音位置在调式音阶的<strong>第2与第3、第5与第6音</strong>之间。其特点为：主音与上方三度音、六度音、七度音构成<strong>小</strong>三度、<strong>小</strong>六度、<strong>小</strong>七度音程。</li>\n</ul>\n<p>所有大调的<strong>中心音</strong>都是<strong>1 Do</strong>，即<strong>主音</strong>是Do，<strong>主和弦</strong>都是<strong>以Do为根音</strong>(这个很重要)。<br>自然大调没有任何的升降音，其他大调在某些音上有降音。</p>\n<p>所有小调都是以<strong>6 La</strong>为中心，也就是<strong>La为主音</strong>，<strong>主和弦</strong>都是<strong>以La为开头</strong>。<br>自然小调没有任何的升降音，其他小调在某些音上有升音。</p>\n<img src=\"/2023/01/02/guitarNote/33.png\" class=\"\">\n\n<p>分辨是大调还是小调：<br>大调的第一个和弦一般是以大调大和弦为开头，比如C调是以C和弦为开头和结尾，也就是首尾呼应大调。小调一般是以小和弦开始，比如Am，Bm，Em开头，Am结束等。<br>小调一般以<strong>La 6</strong>为结束音，大调一般以<strong>Do 1</strong>为结束音，但开头的话不一定。<br>(看不懂)</p>\n<img src=\"/2023/01/02/guitarNote/60.png\" class=\"\">\n\n\n<h3 id=\"和弦-1\"><a href=\"#和弦-1\" class=\"headerlink\" title=\"和弦\"></a>和弦</h3><p><a href=\"https://xshcloudy.gitee.io/blog/uncategorized/%E5%90%89%E4%BB%96C%E5%A4%A7%E8%B0%83%E5%92%8C%E5%BC%A6%E6%80%BB%E7%BB%93/\">吉他C大调和弦总结</a> 写的不错</p>\n<p><strong>常见和弦图怎么看</strong>：竖线从左到右是六弦，五弦···一弦；从上到下看品格，分别是一品，二品···五品，相当于吉他竖起来正面面对你的时候你所看到的。</p>\n<p>和弦图中<strong>弦上的数字</strong>表示用哪根手指按弦，数字1代表食指、2代表中指、3代表无名指、4代表小指，如果和弦图中有数字5或者字母T则代表大拇指。</p>\n<p>最上方有<strong>叉和圆圈</strong>，<strong>圆圈</strong>代表<strong>有可能</strong>会发音，<strong>叉</strong>代表不管什么情况下，这个和弦的这根弦<strong>都不能发音</strong>。如果六弦上打叉了，可以用大拇指轻触它，即使不小心碰到也只能发出哑音。</p>\n<p>有的和弦会有简化版。</p>\n<p>如下图所示：</p>\n<img src=\"/2023/01/02/guitarNote/68.png\" class=\"\">\n\n<p>下图是<strong>另一种</strong>和弦图的表示方法，该方法<strong>以六线谱的形式</strong>(从上往下分别是一弦、二弦···六弦)表现和弦的按法。</p>\n<img src=\"/2023/01/02/guitarNote/66.png\" class=\"\">\n\n\n\n<h1 id=\"指弹\"><a href=\"#指弹\" class=\"headerlink\" title=\"指弹\"></a>指弹</h1><img src=\"/2023/01/02/guitarNote/7.png\" class=\"\">\n\n<h2 id=\"击弦\"><a href=\"#击弦\" class=\"headerlink\" title=\"击弦\"></a>击弦</h2><img src=\"/2023/01/02/guitarNote/8.png\" class=\"\">\n\n<p>四弦的空弦和四弦的二品之间有一个圆弧线（连音线），上方有一个h. ,说明需要一个击弦。</p>\n<p>先右手拨一个四弦的空弦，也就是0，然后用左手重重的敲击四弦的二品产生了第二个音2。击准了，别击到指甲缝里，也别击错。</p>\n<img src=\"/2023/01/02/guitarNote/11.png\" class=\"\">\n\n\n<h2 id=\"勾弦\"><a href=\"#勾弦\" class=\"headerlink\" title=\"勾弦\"></a>勾弦</h2><img src=\"/2023/01/02/guitarNote/9.png\" class=\"\">\n\n<p>在发生勾弦关系的前后音之间有一个在上方的连音线，在这两个音的上方有一个<strong>p.</strong> 。</p>\n<p>勾弦第一个音都是右手去拨一个非空弦，然后用左手手指上的肉去勾动那根弦（左手本来是按着品位的），往下往后勾动让它产生第二个音，这个音也就是该弦空弦的音。</p>\n<p>如果是勾一弦以外的弦，勾的角度就要有所变化，可以手指接近平行往掌心勾，不要碰到其他弦。</p>\n<img src=\"/2023/01/02/guitarNote/10.png\" class=\"\">\n\n\n<h2 id=\"拍扫\"><a href=\"#拍扫\" class=\"headerlink\" title=\"拍扫\"></a>拍扫</h2><p>吉他首先要垂直右大腿，拍的时候右手大鱼际碰到弦就碰到吧，但不要打到板。可以用中指和无名指扫弦，也可以不扫，手腕转动时让中指弹到你要弹的弦。如果只要弹一根弦最好用这种方法，扫弦容易扫到其它的弦，可能需要用手指闷住。我先采用后一种方法，让中指弹弦，这样准度比较高，用的手指越多越容易碰到其他弦。注意，弹弦的时侯，中指要往吉他偏一点，因为 这时候吉他垂直大腿，不偏一点中指会空的或者打到一弦，扫弦时也一样。左手指一定要垂直一点，不然会碰到其他弦，用指尖按弦，是有一定斜度的要靠近品丝，不要越来越往品格中间跑。<br>右手不认真不稍微用点力的话，很容易弹错点。右手还需要注意，不要太过贴近于琴弦，需要浮在琴弦上一定高度的，就是摆姿势那个高度，这样右手才不会一直弹错，还有就是，拍弹最好通过手腕的转动，配合中指来击弦，不要太用力，适中就好。还有右手四根手指弹弦要往手心弹，这不是废话，总之右手手型挺重要的，不然一直碰到其他弦。<br>吉他顶着胸口，这是有必要的</p>\n<h2 id=\"kick-and-the-snare-军鼓\"><a href=\"#kick-and-the-snare-军鼓\" class=\"headerlink\" title=\"kick and the snare(军鼓)\"></a>kick and the snare(军鼓)</h2><img src=\"/2023/01/02/guitarNote/115.png\" class=\"\">\n\n<p>X”表示拇指拍打（军鼓音符）可以指拍弦 也可以指大拇指拍面板</p>\n<p>两种最常见的打击乐技巧——踢击和军鼓。<br>图片中，红色箭头指向kick名称，蓝色箭头指向军鼓名称。<br>在我以前的安排中，我曾经将kick表示为水平括号（左图），<br>但现在我在 Guitar Pro 中为打击乐(percussion)编写单独的鼓轨道（右图）</p>\n<img src=\"/2023/01/02/guitarNote/116.png\" class=\"\">\n\n<p>五线谱&#x2F;六线谱&#x2F;打击乐轨<br>腕击&#x2F;拇指制音六弦或五弦&#x2F;拇指骨头击打音孔上方(军鼓)</p>\n<h2 id=\"大横按\"><a href=\"#大横按\" class=\"headerlink\" title=\"大横按\"></a>大横按</h2><p>无论是大横按还是小横按，手指的机能方面（手指是否有力量）很重要。但最重要的还是正确的方法和技巧，这更有助于你长期、高效、健康的练琴。力量VS重力如果完全使用手指对捏的力量，在初学阶段和后期有大量需要横按演奏的时候，会让你的手指和虎口处肌肉过度紧张。直接后果就是肌肉酸痛，无法继续保持好的演奏状态。长期下去甚至会不利于手指的健康。具体方法看下面这张图：</p>\n<img src=\"/2023/01/02/guitarNote/71.jpg\" class=\"\">\n\n<p>学会借力，利用手臂和手肘的重量，把重力转换成手指的压力。适当解放拇指在琴颈后方的力量，让拇指的作用成为一个支点，而不是主要发力点。感受一下其中力量的传递。</p>\n<p><a href=\"https://www.zhihu.com/question/661135474\">大横按怎么按起来轻松</a><br>讲的很好</p>\n<h1 id=\"更深层的乐理\"><a href=\"#更深层的乐理\" class=\"headerlink\" title=\"更深层的乐理\"></a>更深层的乐理</h1><h2 id=\"调\"><a href=\"#调\" class=\"headerlink\" title=\"调\"></a>调</h2><p>首调唱名法：<br>任何一个大调音阶，其第一个音到第八个音的依次间隔应该和C大调相同。我们唱起来应该感觉音程距离相同，只是音高有所不同。 无论什么大调，都依照C大调各音阶的唱名，将第一个音唱成Do,第二个音唱成Re…这种唱法称为“首调唱名法”。</p>\n<p>调式是指：以一个音为主音（最重要的音，也就是第一个音），其他各音按照一定的度数关系排列形成的音列（音按照高低顺序的排列）。</p>\n<p>C大调、C小调属于自然大调，自然小调。属于七声调式（由七个音构成的调式）。<br>这两种调式是“中古调式”里的其中两种，是西方几百年历史中，使用最多的两种调式。<br>不同调式的区别主要表现在两点：<br>　　第一：构成音数目的不同<br>　　第二：音与音之间是按照不同度数关系排列的。<br>由于自然大调与自然小调都属于七声调式，所以区别主要体现在后面一点上。<br>C大调的全称是：以C为主音（第一个音）构成的自然大调。<br>C小调的全称是：以C为主音（第一个音）构成的自然小调。<br>那么自然大调的度数排列规定为：<br>……I II III IV V VI VII I……<br>　　 全 全 半 全 全 全 半<br>　　C D E F G A B C<br>那么自然小调的度数排列规定为：<br>　　……I II III IV V VI VII I……<br>　　全 半 全 全 半 全 全<br>　　C D 降E F G 降A 降B C<br>可见度数关系的不同，调式的构成音也会不同。<br>在听觉上，小调的感觉为阴暗，悲伤；大调为明亮，平和。</p>\n<p>大调与小调的区别主要体现在调式上，也就是音阶中音级之间的关系不同。比如说大调，举我们都熟悉的例子——C大调，音阶是do re mi fa so la ti do，他们之间的音程关系是，全音-全音-半音-全音-全音-全音-半音。换一个主音试试，G大调，还按这个关系，那么就是so la ti do re mi #fa so。</p>\n<p>c大调就是do re mi fa so la ti do 也就是CDEFGABC<br>C小调是C D 降E F G 降A 降B C ，C小调实际上是降E大调(的移位)，用音程关系看。</p>\n<p><a href=\"https://www.wikiwand.com/zh-cn/%E8%87%AA%E7%84%B6%E5%A4%A7%E8%B0%83\">自然大调</a></p>\n<p>教会调式（Gregorian mode或church mode），即中古调式，为中世纪罗马教会统治欧洲时期的音乐所使用的调式，后来的人们称做“教会调式体系”。这些调式有一个共同特点：音阶由七个音构成，全部都是自然音，没有变化音，因此也称作“自然调式体系”。</p>\n<p>自然大调（经常简称为大调），即教会调式中的伊奥尼安调式（Ionian），是调式的一种。自然大调包含七个音符，在首调唱名中分别是Do、Re、Mi、Fa、Sol、La、Si（或Ti）。C大调是大调中最“简单”的一个调性，因为它是唯一一个没有任何升号（♯）和降号（♭）的大调，在钢琴中只需弹奏白键。</p>\n<p>比某个大调低小三度的小调，称为该大调的<strong>关系小调</strong>。C大调的关系小调是a小调，<strong>并行小调</strong>是c小调。</p>\n<p>自然大调中的音符从主音开始，按照音高依次为<strong>主音、上主音、中音、下属音、属音、下中音和下主音</strong>，也可以称作<strong>主音、二级音、三级音、四级音等等</strong>。除了中音和下属音，下主音和主音之间是小二度，其他相邻两音之间都是大二度。结构为：“全音、全音、半音、全音、全音、全音、半音”。</p>\n<p>共有七种带升号的大调，分别有一至七个升号。将某个带升号大调的<strong>属音</strong>作为主音，即构成比它增加一个<strong>升号</strong>的大调。在<strong>调性标记中的升号</strong>(最左边的符合)就是按照这种顺序排列的。</p>\n<img src=\"/2023/01/02/guitarNote/69.png\" class=\"\">\n\n<p>共有七种带降号的大调，分别有一至七个降号。将某个带降号大调的<strong>下属音</strong>作为主音，即构成比它增加一个<strong>降号</strong>的大调。在<strong>调性标记中的降号</strong>就是按照这种顺序排列的。</p>\n<img src=\"/2023/01/02/guitarNote/70.png\" class=\"\">\n\n<p>常用七大调是指<strong>调号</strong>(调性标记中的升、降号)不超过三个升降号（包括没有升降号）的七个大调，包括C大调、G大调、F大调、D大调、降B大调、A大调、降E大调。</p>\n<p>亦可以使用“<strong>五度圈</strong>”分辨各种大调，右边为有升号的大调，左边为有降号的大调。顺时针方向是每一次升纯五度（如C的顺时针方向下一个是G），逆时针方向是每一次降纯五度（如C的逆时针方向下一个是F）。</p>\n<img src=\"/2023/01/02/guitarNote/72.png\" class=\"\">\n\n<p><strong>Major</strong>是大调的意思，<strong>Minor</strong>是小调的意思。在西方音乐中，minor调式包括自然小调、和声小调和旋律小调，它们都有不同的和声结构和音阶模式。通常情况下，使用“m”来表示一个和弦是小调的，例如Am表示A minor，Em表示E minor等。</p>\n<img src=\"/2023/01/02/guitarNote/73.png\" class=\"\">\n\n\n\n\n\n<h1 id=\"弹琴\"><a href=\"#弹琴\" class=\"headerlink\" title=\"弹琴\"></a>弹琴</h1><p><strong>降一个全音</strong><br>AB CDEFGAB   ， EF，BC是半音关系</p>\n<p>E A D G B E<br>降一个全音<br>D G C F A D</p>\n<p>四弦自然泛音七品，然后是人工泛音19品</p>\n<p>泛音要弹得又快又轻，无名指按要果断一点，指头要立正有力，不然很容易按错</p>\n<img src=\"/2023/01/02/guitarNote/74.png\" class=\"\">\n<p>这里的弹法是：弹七再弹五，勾五弦到空弦，再弹七<br>其它的也可以类似这么弹，如果觉得琴谱的弹法比较难的话</p>\n<p>这样难度会更大，而且钩弦的响度不够，不好听。可以去看看原视频作者咋弹的。这里的一弦的×代表是用无名指向下打响</p>\n<p>这个需要慢慢找感觉了，本质的确是拍扫，只不过“扫”只能扫一根弦。有事没事就可以弹53231323，只不过123弦不是正常弹琴的“勾”，而是“向下打”。可以找几个节奏练，比如 5打2打1打2打、53打313打3、5323打323</p>\n<p>看自己习惯吧，对于单根弦的旋律音，我固定是无名指打1弦，中指打2弦，食指打3或者4弦</p>\n<p>小指（或无名指按个人喜好）按住一线8品食指同时按住一线5品弹响第一个音–5品的食指别松 小指（或无名指）勾线出第二个音，5品的食指勾响空线出第三个音。后面的小节一样的手法，这三个音有连音记号 就是弹响第一个音后面的两个音要靠击勾线弹出来。不需要按照eiro的视频弹，他的视频和谱子有几个细节不一样的，而且视频里的音频后期过，我们不可能弹出来一模一样的，他星际穿越那个视频最后那个琶音不是一把吉他完成的，我的也不是一把吉他完成的，刚开始没觉得，后来自己录音的时候发现了，自己才录了第二个和声。</p>\n<p>手指独立性要多练，没办法，你可以试试无名指勾，还有左手大拇指不要太靠上，除非你要用左手大拇指反扣6弦，其他时候尽量靠在琴颈中间，左手手腕不要太僵硬，所谓的拍扫其实是为了保证伴奏音的同时突出旋律音，所以你要知道那一拍的旋律音在哪根线，只需要保证能中指食指击打出那个音就行，其他的弦没打到也没有关系。但不能有其他的杂音，理论就是这样，弹琴时多想，不用纠结到底是那跟手指怎么弹，没有明文规定，这不是搞科研，很多大师姿势都不是所谓的标准姿势，标准姿势只是个参考。。。总之多思考。能发出你想要的音就行，哪怕你用脚弹都行。</p>\n<p>客气了，相互学习一起进步<br>我也是自学的，之前我也喜欢扣细节，希望跟大师们手型一样，后来发现与自己学琴的目的背道而驰了，反而是一中折磨，曲目弹出来只要能达到你想要的声音就行了，形式真的无所谓，我的思维是这样的：确定你想要的声音——怎么实现它——怎么实现最方便（或者说省力）——实现后怎么换把位最方便以及优化你的指法手型等。</p>\n<h1 id=\"录音\"><a href=\"#录音\" class=\"headerlink\" title=\"录音\"></a>录音</h1><h2 id=\"设备\"><a href=\"#设备\" class=\"headerlink\" title=\"设备\"></a>设备</h2><p>声卡至少需要两进两处的通道数量，这样就可以插两组麦克风进行立体声的拾音。</p>\n<img src=\"/2023/01/02/guitarNote/75.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/76.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/77.png\" class=\"\">\n\n<img src=\"/2023/01/02/guitarNote/78.png\" class=\"\">\n\n\n\n<h1 id=\"录视频\"><a href=\"#录视频\" class=\"headerlink\" title=\"录视频\"></a>录视频</h1><p>拍扫的动作好丑，大拇指动作不能太大，不然会很丑的。</p>\n<h2 id=\"Cubase\"><a href=\"#Cubase\" class=\"headerlink\" title=\"Cubase\"></a>Cubase</h2><p>DAW（Digital Audio Workstation），即数字音频工作站——是一种用于录音、混音、音频剪辑以及数字音频处理的软件。</p>\n<h3 id=\"创建单声道和立体声的音频轨\"><a href=\"#创建单声道和立体声的音频轨\" class=\"headerlink\" title=\"创建单声道和立体声的音频轨\"></a>创建单声道和立体声的音频轨</h3><p>单声道音频一定是单声道效果，立体声音频不一定是立体声效果(有可能听上去是单声道效果，只是音频轨里有两个一样的波形，即伪立体声)。</p>\n<p>单声道是左右两边声音一模一样，立体声是左右两边声音不一样。</p>\n<p>那伪立体声怎么得到的呢？即单声道音频以立体声的格式导出，就有上下两个波形了。伪立体声在软件中视为立体声，因为软件只认波形。</p>\n<p>导入音频时可以分割通道，再用推子中的平衡声像器将两个音频分别推到左右就能明显听出来，也可以用声场软件来检测。</p>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><p>电容麦中还有一个放大器，需要电源供电才能工作。但由于麦克风体积的原因，这个电源通常都被设计成外接式，称之为“幻象电源 Phantom Power”。</p>\n<p>从品质上比较：动圈式麦克风的中、低音相对温和饱满，高频相对不足，一般能比较好的抑制环境噪音；电容式麦克风的三频比较均衡，特别是高音细节表现比动圈麦好很多，同时灵敏度高，环境噪音稍大就可以被录进去。</p>\n<p>正常电平保持在 -20 到 -12 dB之间。最高峰值一般不要超过 -6 dB</p>\n<p>通常距离麦克风越近，信号里的低频就越丰满，但靠得太近也易导致低音变形失真。建议距离在 25 cm左右。最好安装防喷网，以避免爆音。</p>\n<p>声道 Channels：单声道 Mono通常指的是单一的输入信号源；立体声 Stereo指的是两个输入信号源。</p>\n<img src=\"/2023/01/02/guitarNote/118.png\" class=\"\">\n\n\n<p>下面三个都在<a href=\"https://www.bilibili.com/video/BV1hV411v7Vi/?spm_id_from=333.788.recommend_more_video.-1&vd_source=7b41839c0bc8f13071f01977ba9e14de\">如何提高你的吉他视频质量（2）音频处理</a></p>\n<h3 id=\"音频处理\"><a href=\"#音频处理\" class=\"headerlink\" title=\"音频处理\"></a>音频处理</h3><p>降噪 通常十几十几的降，多降几次，要选择整个文件</p>\n<p>标准化振幅，将信号放到0db，可以选一段进行放大的</p>\n<p>合并处理音频最好在多轨里面做<br>右键拆分或者ctrl k </p>\n<p>EQ：针对于频段，低频、中频、高频、超高频<br>压缩：服务于音量的大小和声音的“润色、美化”，尤其是对于带有打板技巧的指弹曲<br>混响：增强空间感、美化声音<br>延迟：使得音频更加的活跃、动感、精神也可以说是特效，也可以使得音频有空间感<br>立体声：对于音频的立体声起到非常好的作用，尤其是跟混响、延迟搭配起来，就可以达到你们喜欢的空灵感觉<br>音量最大化：每个人的版本不一样，我个人就喜欢他的“在尽量不损失音质的情况下提升音量”</p>\n<p>在效果链中，EQ和压缩没有固定的位置，可以直接放在前头，而混响放在末端比较合适</p>\n<h3 id=\"混响\"><a href=\"#混响\" class=\"headerlink\" title=\"混响\"></a>混响</h3><p>mix 混音量</p>\n<p>gravity 混音比重，想要混响感觉多一点还是少一点</p>\n<p>size  混响模拟空间的大小，越大空间感越庞大</p>\n<p>predelay 预延时，不开的话就是一弹的一瞬间就有混响了，开的话就是指定时间后出现混响，这样声音更清晰</p>\n<p>low&#x2F;high  低高音混响量</p>\n<p>调这俩时可以先把mix拉大</p>\n<p>moddepth 调制深度</p>\n<p>modrate 调制频率  右边复古，左边会亮一点</p>\n<p>这俩相当于调制音色，其实主要是调这俩</p>\n<p>用Fab的Pro-R</p>\n<h3 id=\"EQ\"><a href=\"#EQ\" class=\"headerlink\" title=\"EQ\"></a>EQ</h3><p>在fx里面有一些开关，是串联的，先开一个参数均衡器（EQ）</p>\n<ol>\n<li>HP 32HZ</li>\n<li>LP 20KHZ</li>\n<li>500HZ左右 -3.5dB能让声音清晰一点</li>\n<li>低频重容易昏头 可以用2 在105HZ左右拉-3.9dB Q3.4<br>其实具体大小看情况自己调</li>\n</ol>\n<img src=\"/2023/01/02/guitarNote/119.png\" class=\"\">\n<p>这玩意是AU自带的图形均衡器，这些参数应该是有自己的意义的，没事的时候可以这几个频率试试看什么感觉<br>每个地方多调调听听看，一般很少往上提的，都是往下拉，把不喜欢的声音去掉。<br>点不要太多</p>\n<p>用Fab的Pro-Q3</p>\n<h3 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h3><p>压缩很重要，可以降低很大的声音，提高很小的声音，相当于平衡曲子的动态范围，对打板的曲子很重要，因为打板的声音太大了，压缩后就很棒。</p>\n<p>用Fab的Pro-C2<br>外面一圈浓一点的白色线是压缩后的音量电平，里面灰色线是压缩前的电平。</p>\n<p>threthold 阈值，往左边的话压缩量就很大，即便高潮也变得平平无奇了</p>\n<p>通常在讨论压缩器的时候，会有6个参数，4个与效果相关，两个与时间相关。这里先讲效果相关的4个参数：</p>\n<p>门限Threshold<br>压缩比Ratio<br>提升Make up<br>拐点Knee</p>\n<p>Threshold门限，就是压缩器的工作起点。只有当电平超过门限后，压缩器才会开始工作。我们假设此时将压缩器的门限设置为-20，当设置的很小时就会压缩的很狠。</p>\n<p>Ratio压缩比，就是压缩器以什么样的量来压缩超过门限的电平。如下图，此时将压缩器的压缩比设置为2:1，音量关系就会变成下图。（应该就是你要以多大的比例来压过大的音量）</p>\n<p>横轴是压缩前的电平，竖轴是压缩后的电平</p>\n<img src=\"/2023/01/02/guitarNote/120.png\" class=\"\">\n<p>黑线的部分是压缩器未工作时的电平曲线，红线则是按门限-20、压缩比2:1设定时的电平曲线。可以看到，在高于门限之后，电平被以2:1的比率被压缩了：在-20的门限以上，处理前的信号达到0的时候，处理后的信号只有-10.</p>\n<p>Knee拐点，指的是在门限上下交界的地方，是以一种非黑即白的方式压缩，还是有一条渐进的曲线连接起压缩与不压缩的区间（下图绿线）。</p>\n<img src=\"/2023/01/02/guitarNote/121.png\" class=\"\">\n<p>Knee的值较大，拐点越不明显，我们一般称之为软拐点，能够使压缩与未压缩的声音部分区别比较小，比较不留痕迹。</p>\n<p>Make up提升，是将电平整体提升。因为压缩在工作的过程中的原理是将高于门限的电平压低，因此肯定会不可避免地降低整体的音量。为了让音量的平均值恢复到原本的听觉水平甚至更高，我们就要使用Make up 将所有电平共同提升。（图中蓝线）</p>\n<img src=\"/2023/01/02/guitarNote/122.png\" class=\"\">\n\n<p>除了上面四个参数，还有两个参数，Attack启动时间 和 Release释放时间</p>\n<p>这是一个声音的音量包络波形，也就是我们录进DAW时看的波形：很快的起振，相对长一些的衰减，没有sustain，比较接近一个鼓声(打板)的波形图。虚线为我们设定的压缩器门限，此时压缩器还没有起作用。</p>\n<p>当我们把压缩器的attack设为0（极快），release设为极快的时候，波形与压缩器的动作就形成了下面这样：</p>\n<img src=\"/2023/01/02/guitarNote/123.png\" class=\"\">\n<p>压缩器的动作与声音几乎同步。在这种情况下，音量能够被非常好地控制住，但是鼓声听起来一方面会比较不自然，而且这么快的release很容易在门限的地方产生抽吸效应。如果鼓声比较大，或者乐器不复杂的时候，会被很明显地听出来。</p>\n<p>如果是稍慢的attack与release的情况，就如下面这张图</p>\n<img src=\"/2023/01/02/guitarNote/124.png\" class=\"\">\n\n<p>在这种压缩器设定下，鼓声中最明显的鼓皮起振的声音能够被不太受影响地放出来，听起来会自然很多。而且鼓声减弱下去的时候，较长的release也能保证鼓声在门限交接处的痕迹不会太大。</p>\n<p>这仅仅是两种不同设定组成的情况，没有对或错，在实际应用中需要分具体情境使用，并不是鼓声的音头一定要放出来，有一些需要比较硬核的鼓声的时候就是要把鼓声从头到尾压死(第一种用法，<strong>双极快挺不错的</strong>)，来达到一种类似振聋发聩的效果。</p>\n<p>attack就是往下压的速度，小的话(attack极快)就是瞬间往下压。就是压缩器波形左边的部分。<br>release就是释放的速度，时间小释放的快，时间大就是释放的慢，则压缩器的效果回复的时间更长，就是压缩器波形右边的部分。</p>\n<p>木吉他扫弦压缩起始时间(Attack)选择稍微慢一点，保留扫弦音头特点</p>\n<p>Pro-MB 动态压缩，就是某个频段多的时候才去压它</p>\n<p>参考自<a href=\"https://zhuanlan.zhihu.com/p/104482227\">压缩器Compressor科普</a></p>\n<h3 id=\"完善\"><a href=\"#完善\" class=\"headerlink\" title=\"完善\"></a>完善</h3><p>AU导出最后结果的时候，右键要导出的剪辑，选择混音会话为新建文件，这样才能进入波形界面，此时能够再次进行振幅标准化(AU导出时为了保护会减小振幅)，注意，这样的结果是带混音的。也就是说，如果不是导出最终结果，而是还要继续进行剪辑的中间结果，记得把fx关掉，此时可以直接在文件-&gt;导出-&gt;多轨混音..或者右键要导出的剪辑，选择导出缩混，这俩是一样的，和上面那个也类似，就是没法再标准化振幅了。记得中间结果一定要关掉混音fx再导出，否则有可能多次混音。</p>\n<h3 id=\"后期\"><a href=\"#后期\" class=\"headerlink\" title=\"后期\"></a>后期</h3><ol>\n<li>录一版较好的，再录一些同时间同状态的素材(这样能尽量让声音接近，减少剪辑痕迹)，将这些缩混导出来到test多轨里面(注意不要标准化)，拼接剪辑完成。</li>\n<li>之后才能进行标准化振幅，混音等流程。</li>\n</ol>\n<h3 id=\"视频\"><a href=\"#视频\" class=\"headerlink\" title=\"视频\"></a>视频</h3><p>左前方  左前方近景  右前方</p>\n<p>副歌1：左前方  左前方近景 </p>\n<p>副歌2：左前方  左前方近景  右前方</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://github.com/spotDL/spotify-downloader\">spotify-downloader</a> 免费下载<strong>spotify</strong>音乐 之前用的<code>spotdl web</code> 命令</p>\n<p><a href=\"https://kgm.worthsee.com/\">KGM格式在线转换为MP3</a> </p>\n<p><a href=\"https://www.rapidseedbox.com/zh/blog/yt-dlp-complete-guide\">yt-dlp</a> <strong>下载Youtube视频</strong></p>\n<p>使用命令如<code>yt-dlp -f “bestvideo[ext=mp4]+bestaudio[ext=m4a]” https://www.youtube.com/watch?v=TGnXy1W1688</code>可以下载最佳质量的视频<br>也可以<code>yt-dlp https://www.youtube.com/watch?v=TGnXy1W1688</code></p>\n<p><a href=\"https://kerrynotes.com/best-ssr-v2ray-proxy/\">机场推荐1</a></p>\n<p><a href=\"https://clashsub.com/top-jichang-tuijian/\">机场推荐2</a></p>\n<p><a href=\"https://scvipaff20240204.speedcat.cc/user\">闪电猫</a></p>\n<p><a href=\"https://glados.space/console\">GLaDOS</a></p>\n<p><a href=\"http://sakuracat-a.com/\">SakuraCat</a></p>\n<p><a href=\"https://bbs.guitarschina.com/thread-1668884-1-1.html\">特殊调弦</a> 这篇讲特调，讲的不错，有提到step是全音，semitone是半音</p>\n<p>海鸥sws指板宽度是1.8英寸，45.72mm；<br>faith中音都是45mm<br>其他款都是43mm<br>其实还是宽指板比较适合我</p>\n<p><a href=\"https://www.zhihu.com/tardis/zm/art/561191905?source_id=1003\">也许是世界上最好的吉他有效弦长指南</a></p>\n<p><a href=\"https://bbs.guitarschina.com/thread-583574-1-1.html\">吉他品格宽度</a></p>\n<p>魔法相框 西电毕业礼物定制</p>\n<p><a href=\"https://www.paperyy.com/\">PaperYY论文免费查重</a></p>\n<p><a href=\"https://www.musiccia.com/pu/54804611.html\">2022郑成河 river flows in you 谱子</a></p>\n","categories":["Interest"],"tags":["Guitar"]},{"title":"学习HTML","url":"/2022/09/07/htmlNote/","content":"<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p>超文本标记语言HTML is short for “HyperText Markup Language”，是一种用于创建网页的标准标记语言，可以使用HTML来建立自己的Web站点，HTML文档运行在浏览器上，由浏览器解析。</p>\n<span id=\"more\"></span>\n<ul>\n<li>HTML 不是一种编程语言，而是一种标记语言;</li>\n<li>标记语言是一套标记标签 (markup tag);</li>\n<li>HTML 使用标记标签来描述网页;</li>\n<li>HTML文档包括HTML标签和文本内容;</li>\n<li>HTML文档也叫做Web页面;</li>\n</ul>\n<p>HTML标签通常成对出现，如&lt;html&gt;内容&lt;&#x2F;html&gt;；<br>HTML元素指的是一对标签和开始、结束标签之间的内容，大多数HTML元素包含属性；<br>HTML元素可以相互嵌套，HTML文档就是由相互嵌套的元素构成的。</p>\n<p>Web浏览器读取HTML文档，并将其作为网页显示，浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户：</p>\n<p>&lt;a href&#x3D;”<a href=\"https://www.runoob.com&quot;&gt;这是一个链接/\">https://www.runoob.com&quot;&gt;这是一个链接\\</a></a><br>&lt;img src&#x3D;”&#x2F;images&#x2F;logo.png” width&#x3D;”258” height&#x3D;”39” &#x2F;&gt;<br>src、href都是属性</p>\n<p>空元素是没有内容的元素，在开始标签中关闭，通过在开始标签中添加斜杠，例如&lt;br&#x2F;&gt;是关闭空元素的正确方法，包括img元素也是这样；</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>HTML元素添设置属性来添加附加信息，属性一般描述在开始标签，通常以名称&#x3D;”值”的形式出现（name&#x3D;”value”）。<br>HTML链接由&lt;a&gt;定义，链接的地址在href属性中指定：&lt;a href&#x3D;”<a href=\"http://wwww.runoob.com&quot;&gt;这是一个链接/\">http://wwww.runoob.com&quot;&gt;这是一个链接\\</a><a>；<br>属性值始终被包括在引号中。</p>\n<p><a href=\"https://www.runoob.com/tags/html-reference.html\">HTML标签参考手册</a><br><a href=\"https://www.runoob.com/tags/ref-standardattributes.html\">HTML标准属性参考手册</a></p>\n<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>搜索引擎使用标题为网页的结构和内容编制索引，用户通过标题快速浏览你的网页，所以别乱用标题。</p>\n<p>&lt;!–添加注释–&gt;<br>&lt;br &#x2F;&gt;元素定义换行；<br>&lt;hr &#x2F;&gt;元素定义水平线</p>\n<p>HTML文档中连续的空格，Tab，换行都识别为一个空白字符，段内换行得用&lt;br&gt;；</p>\n<h3 id=\"头部\"><a href=\"#头部\" class=\"headerlink\" title=\"头部\"></a>头部</h3><p>头部&lt;head&gt;元素，在 <head>元素中你可以插入脚本（scripts）, 样式文件（stylesheet，CSS），及各种meta信息,可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, \\noscript&gt; 和 &lt;base&gt;。</p>\n<ul>\n<li>&lt;title&gt; 标签定义了不同文档的标题。</li>\n<li>&lt;base&gt; 标签描述了基本的链接地址&#x2F;链接目标，该标签作为HTML文档中所有的链接标签的默认链接;</li>\n<li>&lt;link&gt; 标签定义了文档与外部资源之间的关系，通常是链接到样式表。</li>\n<li>&lt;style&gt; 标签定义了HTML文档的样式文件引用地址，在&lt;style&gt; 元素中你也可以直接添加样式来渲染HTML文档；<blockquote>\n<p>&lt;link&gt;和&lt;style&gt;标签都可以通过链接&#x2F;引用样式文件(text&#x2F;css)来对HTML文档进行渲染；</p>\n</blockquote>\n</li>\n<li>meta标签描述了一些基本的元数据。</li>\n<li>&lt;script&gt;标签用于加载脚本文件，如： JavaScript。</li>\n</ul>\n<h3 id=\"HTML样式CSS\"><a href=\"#HTML样式CSS\" class=\"headerlink\" title=\"HTML样式CSS\"></a>HTML样式CSS</h3><p>&#x2F;CSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。</p>\n<blockquote>\n<p>CSS 可以通过以下方式添加到HTML中:</p>\n<ul>\n<li>内联样式- 在HTML元素中使用”style” 属性</li>\n<li>内部样式表- 在HTML文档头部&lt;head&gt;区域使用&lt;style&gt;元素来包含CSS</li>\n<li>外部引用- 使用link调用外部 CSS 文件（最好的方式）。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> 内联样式：指定文本的样式即指定文本的显示方式，使用内联样式的方法是在相关的标签中使用style属性并赋值，比如背景颜色<code>style=&quot;background-color:yellow;&quot;</code>，颜色<code>style=&quot;color:blue;&quot;</code>，字体，字体颜色，字体大小，文本对齐方式;</p>\n</blockquote>\n<blockquote>\n<p> 内部样式表：当这个文件需要特别样式时，就可以使用内部样式表。你可以在&lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:<br>   <figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">body</span> &#123;<span class=\"attribute\">background-color</span>:yellow;&#125;</span></span><br><span class=\"line\"><span class=\"language-css\">&#123;<span class=\"attribute\">color</span>:blue;&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p> 外部样式表：当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。<br> <figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure><br> rel是relation的意思</p>\n</blockquote>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>&lt;table&gt;\t定义表格<br>&lt;th&gt;\t定义表格的表头，就是表格最左边和上边的一列&#x2F;排。(table head)<br>&lt;tr&gt;\t定义表格的行(table row)<br>&lt;td&gt;\t定义表格单元(table data)</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h3 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h3><blockquote>\n<p>HTML 可以通过 &lt;div&gt; 和 &lt;span&gt;将元素组合起来。<br>大多数 HTML 元素被定义为块级元素或内联元素。<br>块级元素在浏览器显示时，通常会以新行来开始（和结束）。<br>内联元素在显示时通常不会以新行开始。</p>\n</blockquote>\n<p>HTML &lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。<br>&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示新行。<br>HTML &lt;span&gt; 元素是内联元素，可用作文本的容器，用来组合文档中的内联元素(inline)。</p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><blockquote>\n<p>HTML 表单用于收集用户的输入信息。HTML 表单表示文档中的一个区域，此区域包含交互控件，将用户输入的信息发送到 Web 服务器。</p>\n</blockquote>\n<h3 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h3><p>JavaScript 使 HTML 页面具有更强的动态和交互性。<br>看到脚本不看了</p>\n<h3 id=\"空元素\"><a href=\"#空元素\" class=\"headerlink\" title=\"空元素\"></a>空元素</h3><p>meta，img，br，hr，</p>\n<h3 id=\"非空元素\"><a href=\"#非空元素\" class=\"headerlink\" title=\"非空元素\"></a>非空元素</h3><p>html，head，title，body，h123456，p，</p>\n","categories":["Language"],"tags":["HTML"]},{"title":"httpNote","url":"/2024/05/02/httpNote/","content":"<p><em><strong>三十功名尘与土，八千里路云和月</strong></em></p>\n<span id=\"more\"></span>\n\n<p><strong>公钥用于加密或验证签名，私钥用于解密或生成签名。</strong></p>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP 是万维网（WWW）的数据通信的基础，设计目的是确保客户端与服务器之间的通信，是互联网上<strong>最常用</strong>的协议之一。</p>\n<p>基于 TCP&#x2F;IP 通信协议。</p>\n<p>设计 HTTP 最初的目的是为了提供一种<strong>发布和接收</strong> HTML 页面的方法，通过 HTTP 或者 HTTPS 协议<strong>请求的资源</strong>由<strong>统一资源标识符</strong>（Uniform Resource Identifiers，<strong>URL</strong>）来<strong>标识</strong>。</p>\n<p>HTTP 有多个版本，目前广泛使用的是 HTTP&#x2F;1.1 和 HTTP&#x2F;2，以及正在逐步推广的 HTTP&#x2F;3。</p>\n<p>HTTP&#x2F;1.1：支持持久连接，允许<strong>多个请求&#x2F;响应</strong>通过<strong>同一个 TCP 连接</strong>传输，减少了建立和关闭连接的消耗。<br>HTTP&#x2F;2：基于二进制分帧，支持多路复用，允许同时通过单一的 HTTP&#x2F;2 连接发起多重的、独立的、双向的交流。<br>HTTP&#x2F;3：基于 QUIC 协议，旨在减少网络延迟，提高传输速度和安全性。</p>\n<h2 id=\"HTTP-和-HTTPS-区别\"><a href=\"#HTTP-和-HTTPS-区别\" class=\"headerlink\" title=\"HTTP 和 HTTPS 区别\"></a>HTTP 和 HTTPS 区别</h2><p>HTTP一般指HTTP协议（超文本传输协议）”HyperText Transfer Protocol”，是因特网上应用最为广泛的一种网络传输协议，所有WWW（World Wide Web）文件都必须遵守的标准。HTTP用于Web浏览器和Web服务器之间的通信，基于<strong>TCP&#x2F;IP</strong>通信协议来传输数据（HTML文件、图片文件、查询结果等）。</p>\n<p>HTTPS 经由 HTTP 进行通信，但利用 <strong>SSL&#x2F;TLS</strong> 来加密数据包。<br>HTTP 的 URL 是由 http:&#x2F;&#x2F; 起始与默认使用端口 80，而 HTTPS 的 URL 则是由 https:&#x2F;&#x2F; 起始与默认使用端口443。<br>浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。<br>HTTPS 的主要作用是在不安全的网络上创建一个安全信道，并在可使用适当的加密包和<strong>服务器证书</strong>可被验证且可被信任的情况下，对窃听和中间人攻击提供合理的防护。<br>HTTPS 的信任基于预先安装在操作系统中的<strong>证书颁发机构</strong>（CA）</p>\n<p><a href=\"https://www.runoob.com/w3cnote/http-vs-https.html\">HTTP 与 HTTPS 的区别</a></p>\n<h2 id=\"HTTP-的请求-响应\"><a href=\"#HTTP-的请求-响应\" class=\"headerlink\" title=\"HTTP 的请求-响应\"></a>HTTP 的请求-响应</h2><img src=\"/2024/05/02/httpNote/1.png\" class=\"\">\n\n<p>HTTP 的<strong>请求-响应</strong>模型通常由以下几个步骤组成：</p>\n<ul>\n<li><p>建立连接：<strong>客户端与服务器之间建立连接</strong>。在传统的 HTTP 中，这是基于 TCP&#x2F;IP 协议的。最近的 HTTP&#x2F;2 和 HTTP&#x2F;3 则使用了更先进的传输层协议，例如基于 TCP 的二进制协议（HTTP&#x2F;2）或基于 UDP 的 QUIC 协议（HTTP&#x2F;3）。</p>\n</li>\n<li><p>发送请求：客户端向服务器发送请求(Request)，请求中<strong>包含</strong>要访问的<strong>资源</strong>的 <strong>URL</strong>、<strong>请求方法</strong>（GET、POST、PUT、DELETE 等）、<strong>请求头</strong>（例如，Accept、User-Agent）以及可选的<strong>请求体</strong>（对于 POST 或 PUT 请求）。</p>\n</li>\n<li><p>处理请求：服务器接收到请求后，根据请求中的信息<strong>找到相应的资源</strong>，执行相应的处理操作。这可能涉及从数据库中检索数据、<strong>生成动态内容</strong>或者简单地<strong>返回静态文件</strong>。</p>\n</li>\n<li><p>发送响应：服务器将处理后的结果封装在<strong>响应</strong>(Response)中，并将其发送回客户端。响应包含<strong>状态码</strong>（用于指示请求的成功或失败）、<strong>响应头</strong>（例如，Content-Type、Content-Length）以及可选的<strong>响应体</strong>（例如，HTML 页面、图像数据）。</p>\n</li>\n<li><p>关闭连接：在完成请求-响应周期后，客户端和服务器之间的连接可以被关闭，除非使用了持久连接（如 HTTP&#x2F;1.1 中的 keep-alive）。</p>\n</li>\n</ul>\n<h2 id=\"HTTP-状态码\"><a href=\"#HTTP-状态码\" class=\"headerlink\" title=\"HTTP 状态码\"></a>HTTP 状态码</h2><p>HTTP状态码是服务器对客户端请求的响应。</p>\n<p>状态码分为五类：</p>\n<p>1xx（信息性状态码）：表示接收的请求正在处理。<br>2xx（成功状态码）：表示请求正常处理完毕。<br>3xx（重定向状态码）：需要<strong>后续操作</strong>才能完成这一请求。<br>4xx（<strong>客户端</strong>错误状态码）：表示请求包含语法错误或无法完成。<br>5xx（<strong>服务器</strong>错误状态码）：服务器在处理请求的过程中发生了错误。</p>\n<h2 id=\"HTTP-消息结构\"><a href=\"#HTTP-消息结构\" class=\"headerlink\" title=\"HTTP 消息结构\"></a>HTTP 消息结构</h2><p>HTTP 是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个<strong>无状态</strong>（就是不记忆之前的状态）的请求&#x2F;响应协议。</p>\n<p>HTTP <strong>消息</strong>是客户端和服务器之间通信的基础，它们由一系列的文本行组成，遵循特定的格式和结构。</p>\n<p>HTTP消息分为两种类型：<strong>请求</strong>消息和<strong>响应</strong>消息。</p>\n<p>一个 HTTP 客户端是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个 HTTP 的请求的目的。</p>\n<p>一个 HTTP 服务器 同样也是一个应用程序（通常是一个 Web 服务，如 Nginx、Apache 服务器或 IIS 服务器等），通过接收客户端的请求并向客户端发送 HTTP 响应数据。</p>\n<p>空行还是很关键的，一看就比较清晰了。</p>\n<h3 id=\"客户端请求消息\"><a href=\"#客户端请求消息\" class=\"headerlink\" title=\"客户端请求消息\"></a>客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<strong>请求行</strong>（request line）、<strong>请求头部</strong>（header）、<strong>空行</strong>和<strong>请求数据</strong>四个部分组成，下图给出了请求报文的一般格式。</p>\n<img src=\"/2024/05/02/httpNote/2.png\" class=\"\">\n\n<img src=\"/2024/05/02/httpNote/3.png\" class=\"\">\n\n\n<h3 id=\"服务器响应消息\"><a href=\"#服务器响应消息\" class=\"headerlink\" title=\"服务器响应消息\"></a>服务器响应消息</h3><p>HTTP 响应也由四个部分组成，分别是：<strong>状态行</strong>、<strong>消息报头</strong>、<strong>空行</strong>和<strong>响应正文</strong>。</p>\n<img src=\"/2024/05/02/httpNote/5.png\" class=\"\">\n\n<img src=\"/2024/05/02/httpNote/4.png\" class=\"\">\n\n\n<h2 id=\"HTTP-方法\"><a href=\"#HTTP-方法\" class=\"headerlink\" title=\"HTTP 方法\"></a>HTTP 方法</h2><p>HTTP 方法指定了客户端可以对<strong>服务器上的资源</strong>执行哪些动作。</p>\n<p>主要的HTTP方法有：</p>\n<ul>\n<li>GET：请求从服务器获取指定资源。这是最常用的方法，用于访问页面。</li>\n<li>POST：请求服务器 <strong>接受并处理</strong> <strong>请求体</strong>中的数据，通常用于<strong>表单提交</strong>。</li>\n<li>PUT：请求服务器<strong>存储一个资源</strong>，并用 请求体中的内容 <strong>替换</strong> 目标资源的所有内容。</li>\n<li>DELETE：请求服务器<strong>删除</strong>指定的资源。</li>\n<li>HEAD：与 GET 类似，但不获取资源的内容，<strong>只获取响应头</strong>信息。</li>\n</ul>\n<img src=\"/2024/05/02/httpNote/6.png\" class=\"\">\n\n<img src=\"/2024/05/02/httpNote/7.png\" class=\"\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.runoob.com/http/http-header-fields.html\">HTTP 响应头信息</a>  看到这</p>\n"},{"title":"TrickyNote","url":"/2025/09/30/TrickyNote/","content":"<p><em><strong>千磨万击还坚劲，任尔东西南北风</strong></em></p>\n<span id=\"more\"></span>\n\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"探究并发插入-二级-uk-记录-导致的死锁问题\"><a href=\"#探究并发插入-二级-uk-记录-导致的死锁问题\" class=\"headerlink\" title=\"探究并发插入 二级 uk 记录 导致的死锁问题\"></a>探究并发插入 二级 uk 记录 导致的死锁问题</h2><p>结合实践来理解理论，案例可复现。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 建表</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t (</span><br><span class=\"line\">  id <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  uk <span class=\"type\">INT</span> <span class=\"keyword\">UNIQUE</span> KEY,</span><br><span class=\"line\">  val <span class=\"type\">INT</span></span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入一些初始数据，方便观察间隙锁</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> t <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">100</span>), (<span class=\"number\">5</span>, <span class=\"number\">50</span>, <span class=\"number\">500</span>), (<span class=\"number\">7</span>, <span class=\"number\">70</span>, <span class=\"number\">700</span>), (<span class=\"number\">9</span>, <span class=\"number\">90</span>, <span class=\"number\">900</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2025/09/30/TrickyNote/image-3.png\" class=\"\" title=\"Alt text\">\n\n<p>1、我们尝试插入uk 冲突的数据 <code>insert into t values(null, 50, 1);</code>，肯定会执行失败，此时查看事务上锁状态 <code>select ENGINE_TRANSACTION_ID, index_name, lock_type, lock_mode, LOCK_STATUS, lock_data  from performance_schema.data_locks;</code>：</p>\n<img src=\"/2025/09/30/TrickyNote/image.png\" class=\"\" title=\"Alt text\">\n\n<p>可以看到上了两个锁，都很奇怪，一个个分析。</p>\n<p><em><strong>在 uk&#x3D;50 上加的 S 型临键锁</strong></em><br>有一些理论基础是，二级uk插入 record 的时候是分成了两个阶段:</p>\n<ol>\n<li>判断当前的物理记录上是否有冲突的record(delete-marked 是不冲突，即允许走到第二步)</li>\n<li>如果没有冲突, 那么可以执行插入操作</li>\n</ol>\n<hr>\n<p>InnoDB 的“免锁”插入优化 (Lock-free Insert)<br>“判断 -&gt; 插入”两个阶段之间需要锁，是完全正确的逻辑。但 InnoDB 实现这个“锁”的方式非常聪明，它不一定使用我们通常所说的、会持续到事务结束的重量级 Lock。<br>在REPEATABLE READ或READ COMMITTED隔离级别下，当向一个带有二级唯一索引的表插入一条新记录，并且没有发生唯一键冲突时，InnoDB会这样做：</p>\n<p>快速检查，但不加间隙锁：<br>InnoDB 会首先检查这个即将插入的键值是否存在。在执行这个检查时，它并不会像 SELECT … FOR UPDATE 那样，预先加上一个会持续整个事务的间隙锁或 Next-Key Lock。</p>\n<p>使用 Latch 保护内存：<br>在检查和插入的瞬间，它会使用一种比 Lock 更轻量级的并发控制机制——Latch (闩锁) 来保护 B+Tree 的索引页在内存中的数据结构。Latch 的作用时间极短，就是为了防止在内存中多个线程同时修改同一个索引页导致数据损坏。<br>执行插入并依赖新纪录的锁：<br>在 Latch 的保护下，InnoDB 确认没有重复键，然后将新记录插入到二级索引的 B+Tree 页面中。<br>一旦记录被插入，<strong>这条新记录本身就会带有一个排他记录锁</strong> (Exclusive Record Lock, X-Lock)。这个锁是<strong>隐式的</strong>，会持续到事务提交。<br>操作完成后，Latch 会被立刻释放。</p>\n<p>这个优化为什么是可行的？<br>在 阶段1 和 阶段2 之间，虽然没有长期的 Gap Lock，但有短期的 Latch 保护，足以防止并发的内存操作冲突。<br>一旦 阶段2 完成，新记录上的 X-Lock 就成了新的“守护者”。任何其他想插入完全相同键值的事务，在做冲突检查时，就会遇到这个 X-Lock 并被阻塞。<br>这种方式避免了为一个简单的 INSERT 操作锁定一大片间隙，极大地提高了并发插入的性能。如果两个事务要插入同一个间隙的不同位置（比如一个插 uk&#x3D;20，另一个插 uk&#x3D;30），它们将不会互相阻塞。<br>所以测试时看不到间隙锁，正是因为触发了这项优化。</p>\n<p>那什么时候会看到锁呢？<br>这项优化虽好，但它只适用于“简单无冲突”的场景。一旦情况变得复杂，InnoDB 就会退回到更保守、更安全的加锁方式。</p>\n<ol>\n<li>发生唯一键冲突时<br>这是最常见的情况。如果你的 INSERT 语句确实遇到了一个重复键（即使那个键是被另一个未提交的事务标记为删除的），InnoDB 就不能再使用上述的“免锁”优化了。<br>此时，InnoDB 会在它找到的那个冲突的二级索引记录上，加上一个共享型的 Next-Key Lock (S-Lock)。<br>这个 S-Lock 的目的是等待持有该记录（或标记删除该记录）的那个事务提交或回滚。<br>这个 Next-Key Lock 包含了间隙锁，因此在这种情况下，你就能观察到锁的存在了。它会阻止其他事务在你等待期间，在冲突记录附近插入新的数据。</li>\n</ol>\n<p>总结<br>对于二级唯一索引的无冲突插入，InnoDB 出于性能考虑，通常不会设置长事务周期的间隙锁。它依赖于短期 Latch 和新纪录的 隐式 X-Lock 来保证唯一性。<br>这个优化有其适用边界。一旦发生唯一键冲突，InnoDB 就会毫不犹豫地使用共享的 Next-Key Lock (包含间隙锁) 这种更强的锁来保证事务的隔离性和数据一致性，防止幻读。</p>\n<p><em><strong>进一步的，上面发生唯一键冲突时还有细节：</strong></em></p>\n<blockquote>\n<p>为什么唯一键冲突 如果是因为遇到确实存在的记录，会在它上面加 S 临键锁，而如果是遇到 标记删除的记录，不仅在该记录上加，还会在该记录 uk 排序后面的一条记录上也加一个 S 临键锁？为什么有这个区别？<br>简单的说，这个区别的根源在于：<br>一个真实存在的记录是一个确定的状态，而一个被标记删除的记录是一个不确定的、模糊的状态，为了应对这种不确定性，数据库必须采用更强、范围更大的锁来保护数据的一致性。</p>\n</blockquote>\n<p>场景一：冲突的记录是“真实存在”的 (Live Record)<br>在这种情况下，冲突的对象非常明确，就是 uk&#x3D;50 这一个点。事务 B 的意图也很明确：“我需要等待 uk&#x3D;50 这条记录本身的状态发生改变（比如被事务 A 删除并提交）”。<br>所以，InnoDB 只需要在 uk&#x3D;50 这条二级索引记录上加上一个 S-Lock (共享锁)（通常是 S-Next-Key Lock，但主要作用点是记录本身）就足够了。这个锁的核心目的就是监视这个已存在的记录，等待持有该记录的 X-Lock 释放。这个锁的行为是确定的、聚焦的。</p>\n<p>场景二：冲突的记录是“标记删除”的 (Delete-Marked Record)<br>因为这个“鬼魂”记录<strong>本身不是一个稳定的锁定目标</strong>，它随时可能被物理清除 (Purge)（如果清除了可能导致上的锁就不见了，所以在下一条记录也加锁）。InnoDB 需要锁住的是由于删除而产生的<strong>“真空地带”或者说“间隙”</strong>。</p>\n<p>如何最可靠地锁住一个间隙？答案是：锁住这个间隙的边界。<br>所以 InnoDB 采取了以下策略：<br>在该记录上加锁：首先，在找到的那个被标记删除的 uk&#x3D;50 记录上加上 S-Lock，这是为了等待事务 A 的结果。<br>在下一条记录上也加锁：这是关键一步。为了防止任何事务（包括事务 C）在这个新产生的、不稳定的间隙中插入数据（从而对事务 B 造成幻读），InnoDB 必须将这个间隙锁住。它通过在 uk&#x3D;50 之后物理上存在的下一条记录（我们称之为 uk_next）上也加上一个 S-Next-Key Lock 来实现。<br>这个 Next-Key Lock 会锁住 uk_next 记录本身，以及它和 uk&#x3D;50 之间的整个间隙。<br>通过锁住下一条记录，InnoDB 成功地将 uk&#x3D;50 这个“可能为空”的坑以及它周围的空间全部封锁了，直到事务 A 提交或回滚，所有不确定性都消除之后，才会允许其他事务进入这片区域。</p>\n<p>为什么用 S-Lock 来实现等待？<br>S-Lock（共享锁）准确地表达了事务B的意图：“我不想修改你（事务A）的这条记录，我只是想读它最终的、确定的状态。”<br>这允许多个像事务B这样的“等待者”（比如事务C、事务D都想插入同一个email），它们可以同时持有S-Lock来等待事务A的结果，就像大家一起在“等候室”里等。如果用 X-Lock，那么等待者之间还会互相排斥，没有必要。<br>所以，这个 S-Lock 本质上是一个“等待锁”或“观察锁”，它让并发的 INSERT 操作在遇到潜在冲突时，能够安全、正确地排队。</p>\n<img src=\"/2025/09/30/TrickyNote/image-6.png\" class=\"\" title=\"Alt text\">\n<hr>\n<hr>\n<p>先删除 uk&#x3D;50 的记录 <code>delete from t where uk = 50;</code>：</p>\n<img src=\"/2025/09/30/TrickyNote/image-1.png\" class=\"\" title=\"Alt text\">\n<p>然后插入 uk&#x3D;50 的记录 <code>insert into t values(10, 50, 1);</code>，区别于上面的插入语句，这条语句是能进入二阶段插入成功的，因为 uk&#x3D;50 的记录已经被 delete marked 标记了，但这时上了很多意想不到的锁：</p>\n<img src=\"/2025/09/30/TrickyNote/image-4.png\" class=\"\" title=\"Alt text\">\n<p>给被删的 uk&#x3D;50 的记录上了 S GAP，刚插入的 uk&#x3D;50 的记录上了 S GAP，被删的 uk&#x3D;50 的记录的下一条记录 即 uk&#x3D;70 处上了 S 临键锁。</p>\n<p>先来看看 官方 对包含 <strong>唯一键</strong> 的 insert 语句的 <strong>pseudocode</strong>:</p>\n<blockquote>\n<p>find the B-tree page in the secondary index you want to insert the value to<br>    assert the B-tree page is latched<br>    equal-range &#x3D; the range of records in the secondary index which conflict with your value<br>    if(equal-range is not empty){<br>      release the latches on the B-tree and start a new mini-transaction<br>      for each record in equal-range<br>        lock gap before it, and the record itself (this is what LOCK_S does)<br>      also lock the gap after the last(equal-range)<br>      also (before Bug #32617942 was fixed) lock the record after last(equal-range)<br>      once you are done with all of the above, find the B-tree page again and latch it again<br>    }<br>    insert the record into the page and release the latch on the B-tree page.</p>\n<p>翻译如下：<br>找到你想要插入值的二级索引所在的B树页。<br>确认该B树页已被闩锁 (latched)。<br>equal-range &#x3D; 与待插入值冲突的二级索引记录范围。<br>if (equal-range 不为空) {<br>    释放B树上的闩锁，并开启一个新的迷你事务 (mini-transaction)。<br>    对于 equal-range 中的每一条记录：<br>        锁定其之前的间隙 (gap) 和记录本身（这就是 LOCK_S 锁的作用）。<br>    同时，锁定 equal-range 中最后一条记录之后的间隙。<br>    同时（在修复 Bug #32617942 之前），还会锁定 equal-range 中最后一条记录之后的下一条记录。<br>    完成以上所有操作后，重新定位到该B树页并再次对其进行闩锁。<br>}<br>将记录插入该页面，然后释放该B树页上的闩锁。</p>\n</blockquote>\n<p>阶段1 和 阶段2 之间必须要有 latch（闩锁） 或者 lock 来保证原子性，否则随便就出现 uk 失效了，这里的伪代码描述的操作是通过一阶段 uk 检查后才进行的。<br>根据伪代码描述，当前的实现是，如果没有重复记录，也就是 <code>equal-range</code> 为空，那就借助 latch（Latch 是一种非常轻量级的锁，用来保护内存中的数据结构比如 B+ 树的一个页面在被多线程并发访问时不被破坏，它的持有时间通常非常短。）来实现两阶段的原子性，latch 我们是无法用 查询锁 操作看到的。<br>如果有重复记录（这里特指 delete-marked 的记录），开始上锁，发现上锁情况和我们执行结果基本符合，加了gap lock 以后就可以禁止其他事务在这个 gap 区间插入数据, 也就是通过 lock 来保证阶段1和阶段2的原子性。注意 uk&#x3D;70 也被上了临键锁，那这样防的范围就太大了，也就是这个 <a href=\"https://bugs.mysql.com/bug.php?id=68021\">issue</a> 遇到的问题。</p>\n<p>如果把这个next-key lock 去掉会有什么问题?</p>\n<blockquote>\n<p>第一列是 uk，红的表示 delete-marked 的记录但是没有 purge 掉。<br>那么如果像官方一样把next-key lock 改成 record lock 以后, 如果这个时候插入两个record (13000, 99), (13000, 120).<br>第一个record 在unique check 的时候对 (13000, 100), (13000, 102), (13000, 108)..(13000, 112) 所有的二级索引加record S lock, insert 的时候对 (13000, 100) 加GAP | insert_intention lock.<br>第二个 record 在unique check 的时候对(13000, 100), (13000, 102), (13000, 108)..(13000, 112) 所有的二级索引加record S lock. insert 的时候对 (13000, 112)加 GAP | inser_intention lock.<br>那么这时候这两个record 都可以同时插入成功, 就造成了unique key 约束失效了.</p>\n</blockquote>\n<img src=\"/2025/09/30/TrickyNote/image-5.png\" class=\"\" title=\"Alt text\">\n\n\n<p>假如 a 事务删除一条记录，b事务想插入这条记录，是会被阻塞的，因为 a 持有这条记录的 uk 上的 X 记录锁，而 b 事务想插入这条记录，b 会尝试获取一个 S 型临键锁，因为 a 事务还没 提交，此时上的 S 能保证不管 a 是否提交，b 都能执行对应的操作，比如 a 提交..</p>\n<h2 id=\"排查命令\"><a href=\"#排查命令\" class=\"headerlink\" title=\"排查命令\"></a>排查命令</h2><p>查询 information_schema.INNODB_TRX 表来获取当前所有活跃的 InnoDB 事务</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    trx_id,                <span class=\"comment\">-- 事务ID</span></span><br><span class=\"line\">    trx_state,             <span class=\"comment\">-- 事务状态 (e.g., RUNNING, LOCK WAIT)</span></span><br><span class=\"line\">    trx_started,           <span class=\"comment\">-- 事务开始时间</span></span><br><span class=\"line\">    trx_mysql_thread_id,   <span class=\"comment\">-- 对应的MySQL连接线程ID (非常重要)</span></span><br><span class=\"line\">    trx_query,             <span class=\"comment\">-- 当前正在执行的SQL（如果恰好在执行）</span></span><br><span class=\"line\">    trx_isolation_level,   <span class=\"comment\">-- 事务隔离级别</span></span><br><span class=\"line\">    (UNIX_TIMESTAMP() <span class=\"operator\">-</span> UNIX_TIMESTAMP(trx_started)) <span class=\"keyword\">AS</span> running_seconds <span class=\"comment\">-- 已运行秒数</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    information_schema.INNODB_TRX</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">    trx_started;           <span class=\"comment\">-- 按开始时间排序，便于找到老事务</span></span><br></pre></td></tr></table></figure>\n<p>trx_mysql_thread_id: 这是关联其他表的关键，它就是我们平时说的 connection id 或 process id。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 事务<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> ti <span class=\"keyword\">WHERE</span> session_ref_id <span class=\"operator\">=</span> <span class=\"number\">4090</span>;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> ti (session_ref_id, customer_id, client_id, app_id) <span class=\"keyword\">VALUES</span> (<span class=\"number\">5000</span>, <span class=\"number\">9000</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"operator\">=</span> </span><br><span class=\"line\"><span class=\"keyword\">update</span> ti <span class=\"keyword\">set</span> session_ref_id<span class=\"operator\">=</span><span class=\"number\">4090</span> <span class=\"keyword\">where</span> session_ref_id<span class=\"operator\">=</span><span class=\"number\">4090</span>;    只给主键索引加了记录锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">update</span> ti <span class=\"keyword\">set</span> app_id<span class=\"operator\">=</span><span class=\"number\">6</span> <span class=\"keyword\">where</span> session_ref_id<span class=\"operator\">=</span><span class=\"number\">4090</span>;    只给主键索引加了记录锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">update</span> ti <span class=\"keyword\">set</span> customer_id<span class=\"operator\">=</span><span class=\"number\">9500</span> <span class=\"keyword\">where</span> customer_id<span class=\"operator\">=</span><span class=\"number\">9000</span>;     只上了两条记录锁</span><br><span class=\"line\"></span><br><span class=\"line\">这两条搞事情</span><br><span class=\"line\"><span class=\"keyword\">update</span> ti <span class=\"keyword\">set</span> session_ref_id<span class=\"operator\">=</span><span class=\"number\">5000</span> <span class=\"keyword\">where</span> customer_id<span class=\"operator\">=</span><span class=\"number\">9000</span> <span class=\"keyword\">and</span> client_id<span class=\"operator\">=</span><span class=\"number\">10</span> <span class=\"keyword\">and</span> app_id<span class=\"operator\">=</span><span class=\"number\">5</span>;     等价  <span class=\"keyword\">delete</span><span class=\"operator\">+</span><span class=\"keyword\">insert</span> 的组合上了很多锁</span><br><span class=\"line\"><span class=\"keyword\">update</span> ti <span class=\"keyword\">set</span> session_ref_id<span class=\"operator\">=</span><span class=\"number\">5000</span> <span class=\"keyword\">where</span> session_ref_id<span class=\"operator\">=</span><span class=\"number\">4090</span>;     等价  <span class=\"keyword\">delete</span><span class=\"operator\">+</span><span class=\"keyword\">insert</span> 的组合上了很多锁</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 事务<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> ti (session_ref_id, customer_id, client_id, app_id) <span class=\"keyword\">VALUES</span> (<span class=\"keyword\">NULL</span>, <span class=\"number\">8001</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> ti (session_ref_id, customer_id, client_id, app_id) <span class=\"keyword\">VALUES</span> (<span class=\"keyword\">NULL</span>, <span class=\"number\">9001</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 查看锁</span><br><span class=\"line\"><span class=\"keyword\">select</span> ENGINE_TRANSACTION_ID, index_name, lock_type, lock_mode, LOCK_STATUS, lock_data  <span class=\"keyword\">from</span> performance_schema.data_locks;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> performance_schema.data_locks\\G;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 设置超时时间、启动事务</span><br><span class=\"line\"><span class=\"keyword\">set</span> innodb_lock_wait_timeout<span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看当前事务id</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TRX_ID <span class=\"keyword\">FROM</span> information_schema.INNODB_TRX  <span class=\"keyword\">WHERE</span> TRX_MYSQL_THREAD_ID <span class=\"operator\">=</span> CONNECTION_ID();</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看自动提交</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;autocommit&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置当前事务隔离级别为 读提交，这是最常用的方式，只影响你当前的数据库连接，断开后失效。</span><br><span class=\"line\"><span class=\"keyword\">SET</span> transaction_isolation <span class=\"operator\">=</span> <span class=\"string\">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class=\"line\"># 查看当前会话的隔离级别</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> @<span class=\"variable\">@transaction</span>_isolation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> ENGINE_TRANSACTION_ID, index_name, lock_type, lock_mode, LOCK_STATUS, lock_data  <span class=\"keyword\">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>\n\n\n<img src=\"/2025/09/30/TrickyNote/image-7.png\" class=\"\" title=\"Alt text\">\n\n<img src=\"/2025/09/30/TrickyNote/image-8.png\" class=\"\" title=\"Alt text\">\n<p>可以看到 RR 级别的话在 IODKU 执行更新的情况下也会给 主键上的supremum pseudo-record 记录加上 X 型的临键锁，很可怕。</p>\n<blockquote>\n<p>除了防止幻读，也为了 保证语句复制的安全性 (Statement-Based Replication Safety)<br>在基于语句的复制（SBR）模式下，主库只会把原始的IODKU语句发送到从库去执行。<br>如果主库上多个IODKU语句是并发执行的，它们的执行顺序可能会影响最终结果（比如，谁执行了INSERT，谁执行了UPDATE）。<br>为了保证从库重放时能得到和主库完全一致的结果，InnoDB必须对这类可能插入新记录（尤其是可能插入到末尾）的操作进行串行化处理。<br>锁住supremum记录就是一种简单有效的串行化手段。它相当于一个“队尾锁”，确保同一时间只有一个事务可以在表的末尾进行插入或更新操作，从而保证了在从库上以任何顺序重放，结果都是确定的。<br>这个强锁主要是为了满足REPEATABLE-READ的严格要求。在执行IODKU的事务开始前，将会话的隔离级别临时调整为 READ-COMMITTED。</p>\n</blockquote>\n<img src=\"/2025/09/30/TrickyNote/image-9.png\" class=\"\" title=\"Alt text\">\n<p>读提交就没有这个问题。</p>\n<hr>\n<p>事务1<br>insert into t values(null, 50, 50) on duplicate key update val&#x3D;50;</p>\n<img src=\"/2025/09/30/TrickyNote/image-10.png\" class=\"\" title=\"Alt text\">\n\n<p>事务2<br>insert into t values(null, 70, 70) on duplicate key update val&#x3D;70;</p>\n<img src=\"/2025/09/30/TrickyNote/image-11.png\" class=\"\" title=\"Alt text\">\n\n<p>事务1<br>insert into t values(null, 60, 60) on duplicate key update val&#x3D;60;</p>\n<img src=\"/2025/09/30/TrickyNote/image-12.png\" class=\"\" title=\"Alt text\">\n<p>进入等待锁的状态，等第四步之后发现死锁，事务2 回滚，插入语句执行成功。</p>\n<img src=\"/2025/09/30/TrickyNote/image-13.png\" class=\"\" title=\"Alt text\">\n\n<p>事务2<br>insert into t values(null, 30, 30) on duplicate key update val&#x3D;30;<br>死锁，事务2 回滚。</p>\n<p>成功复现了 那篇博客 的场景，IODKU 遇到重复的 二级 uk 更新 非索引列 的值，并在重复的记录上加了 X 型临键锁，导致出现死锁。<br>这个应该对应我实际遇到的场景</p>\n<hr>\n<p>来理一下发生的事情。<br>首先上面那种场景能理解了，稍微有点问题的是在记录存在的情况下（不是被delete marked 的记录），为什么上锁的时候还要上 S 锁（普通insert 是S，IODKU 是X 临键锁）。<br>实际上如果uk重复的记录是 被删除的，那上 临键锁是可以理解的，就像博客例子举的那样。<br>如果遇到被删除的重复记录，会在每个 uk 上给重复的记录加 临键锁，还会给 下一条 记录 也加一个 临键锁。</p>\n<p>为什么 primary key 也是unique key index, 为什么primary key 没有这个问题?<br>本质原因是在secondary index 里面, 由于mvcc 的存在, 当删除了一个record 以后, 只是把对应的record delete marked, 在插入一个新的record 的时候, delete marked record 是保留的.<br>也就是说，主键索引树上记录和 二级索引树 记录都是 标记删除，此时插入一条 主键重复记录的话，会直接在原位置写这条记录，然后记一个 undolog，原来的二级索引是 标记删除，两种情况，一种是这条记录 uk 和原来的不一样，那就没什么考虑了，在二级索引树插入记录就好了，第二种是 uk 和原来的一样，这时：</p>\n<img src=\"/2025/09/30/TrickyNote/image-14.png\" class=\"\" title=\"Alt text\">\n<p>可以发现，应该还是在索引树插入记录，然后会遇到重复键，因此给重复的记录和下一条记录都上了临键锁。<br>问题同样回到了 二级uk重复的时候上了很多锁，或者说，二级树为什么不能直接在 标记删除的记录上修改呢？正是因为允许存在多条uk相同的记录（包括标记删除的），所以才要上那么多锁。如同这个图所说的那样：</p>\n<img src=\"/2025/09/30/TrickyNote/image-15.png\" class=\"\" title=\"Alt text\">\n<p>假如现在插入的新纪录 主键不同，但是uk相同，如果我们直接修改二级树上的记录，把二级索引的主键列改成新纪录的值，那就会出现，如果一个事务通过uk想找原来的记录就找不到了，因为现在的uk的主键列已经变了，所以这样就无法实现mvcc了。而如果保留原来记录的二级索引，那查找的时候就会找到这条记录，拿着主键去聚簇索引找，然后再通过mvcc看到“可见”的记录。我的理解是这样的，所以如果在 二级uk 重复的情况下，就会上锁，因为存在多条记录，光靠latch应该保护不了了。</p>\n<p>在primary index 里面, 在delete 之后又insert 一个数据（主键相同）, 会将该record delete marked 标记改成non-delete marked, 然后记录一个delete marked 的record 在undo log 里面, 这样如果有历史版本的查询, 会通过mvcc 从undo log 中恢复该数据. 因此不会出现多个相同主键的delete mark record 跨多个page 的情况, 也就不会出现上述case 里面(13000, 100) 在page1, (13000, 112) 在page3.</p>\n<p>那么在insert 的时候, 和上面的二级索引插入2阶段类似, 需要有latch 或者lock 进行保护, 这里primary index 通过持有page X latch 就可以保证两个阶段的原子性, 从而两次的insert 不可能同时插入成功, 进而避免了这个问题.</p>\n<img src=\"/2025/09/30/TrickyNote/image-16.png\" class=\"\" title=\"Alt text\">\n<img src=\"/2025/09/30/TrickyNote/image-17.png\" class=\"\" title=\"Alt text\">\n<p>第一种情况的先删后增就是很明显的在插入的时候uk遇到重复键，并且要重新插入一个二级索引，该索引的主键列是新的主键值。<br>第二种情况和第三种情况本质是一样的，其实和第一种也差别不大，因为都更新了主键，更新主键往往也是分成两步，先删除原纪录，然后插入新纪录，因为更新主键意味着在聚簇索引树的位置也要变了，所以是先删除后插入。</p>\n<p>至于为什么 记录存在（非标记删除） 的情况也要上 S 锁，之前也查过了。</p>\n<p>结论:<br>在delete + insert, insert … on duplicate key update, replace into 等场景中, 为了实现判断插入记录与现有物理记录是否冲突和插入记录这两个阶段的原子, unique check 的时候会给所有的相同的record 和下一个record 加上next-key lock. 导致后续insert record 虽然没有冲突, 但是还是会被Block 住, 进而有可能造成死锁的问题.</p>\n<p>更新主键 (Clustered Index Key)<br>更新一条记录的主键值，在InnoDB存储引擎中，其底层操作等同于在聚簇索引中删除旧记录，然后插入一条新记录。<br>为什么是这样？<br>聚簇索引的本质: 在InnoDB中，表本身就是按主键顺序组织的一个B+树结构，这被称为聚簇索引。数据行的所有内容（所有列的值）都存储在B+树的叶子节点上。数据的物理存储顺序与主键的逻辑顺序是紧密相关的。<br>更新的后果: 当您更新一个主键的值（例如，UPDATE … SET id &#x3D; 200 WHERE id &#x3D; 100;），这条记录在B+树中的物理位置必须改变。原来id&#x3D;100的记录存放在包含99、101等邻近键值的磁盘页（Page）上，而id&#x3D;200的记录需要被移动到存放199、201等键值的磁盘页上。<br>实现方式: 对于B+树这种有序结构来说，最高效地“移动”一条记录的方式，就是将其视为两个独立操作：<br>删除 (DELETE): 在id&#x3D;100的旧位置，将原记录标记为删除。<br>插入 (INSERT): 在id&#x3D;200的正确新位置，插入一条包含所有新数据的记录。</p>\n<p>这个“删除+插入”的操作会引发一系列连锁反应，代价非常高昂：<br>二级索引的连锁更新: 表上所有的二级索引都存储了对应的主键值作为“指针”来定位完整的数据行。当主键值发生变化时，这条记录在每一个二级索引中的条目也必须被更新。这同样是通过对每个二级索引进行“删除旧条目（包含旧主键值），插入新条目（包含新主键值）”来完成的。<br>磁盘I&#x2F;O和日志: 这个过程会涉及对聚簇索引和所有二级索引的多次磁盘页面读写，并产生大量的redo log和undo log。</p>\n<p>“直接修改主键列”不行，根本原因在于：<br>维护有序性: 直接修改会破坏二级索引按照 (二级索引键, 主键) 组合的严格排序规则。<br>物理结构: 索引值的改变意味着物理存储位置的改变，数据库引擎通过“逻辑删除+逻辑插入”来实现这种物理位置的移动。<br>算法统一性: “删除+插入”是一个统一且健壮的逻辑，它可以处理所有索引键值更新的情况，而“原地更新”只在极少数不影响排序的特殊情况下才可能实现，数据库引擎为了逻辑的简单和可靠，会统一采用前者。<br>技术上的解释：B+树的物理结构<br>有序存储: B+树的叶子节点是双向链表，所有索引条目在这些叶子节点上是严格有序存储的。这个顺序是物理上的，决定了数据存放在哪个磁盘页（Page）以及页内的哪个位置。<br>位置决定价值: 一个索引条目的值决定了它在B+树中的物理存放位置。<br>修改即移动: 当你修改一个索引条目中的任何一个排序列（无论是二级索引键本身，还是作为次要排序列的主键）时，这个条目的逻辑顺序就可能发生改变。只要逻辑顺序变了，它在B+树中的物理位置也必须改变。<br>“删除+插入”是“移动”的实现: 在B+树这种精密的结构中，最直接、最可靠的“移动”一个条目的算法，就是先在旧位置将其删除，再在新位置将其插入。这个过程可能只涉及在一个页内的移动，也可能涉及跨磁盘页的移动（如果新旧位置离得很远）。</p>\n<h1 id=\"Nginx-amp-Openresty\"><a href=\"#Nginx-amp-Openresty\" class=\"headerlink\" title=\"Nginx &amp; Openresty\"></a>Nginx &amp; Openresty</h1><p>非阻塞就是，事件没有准备好，马上返回EAGAIN，告诉你，事件还没准备好呢，你慌什么，过会再来吧。好吧，你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。所以，才会有了异步非阻塞的事件处理机制，具体到系统调用就是像select&#x2F;poll&#x2F;epoll&#x2F;kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们(epoll_wait())是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。当事件没准备好时，放到epoll里面，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里面。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这种事件处理方式是有很大的优势的，<strong>不需要创建线程，每个请求占用的内存也很少</strong>，没有上下文切换，事件处理非常的轻量级。<strong>并发数再多也不会导致无谓的资源浪费（上下文切换）</strong>。更多的并发数，只是会占用更多的内存而已。 我之前有对连接数进行过测试，在24G内存的机器上，处理的并发请求数达到过200万。现在的网络服务器基本都采用这种方式，这也是nginx性能高效的主要原因。</p>\n<p>nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。</p>\n<p>对于一个基本的web服务器来说，事件通常有三种类型，网络事件、信号、定时器。从上面的讲解中知道，网络事件通过异步非阻塞可以很好的解决掉。如何处理信号与定时器？</p>\n<p>event模块的主要功能就是，监听accept后建立的连接，对读写事件进行添加删除。事件处理模型和Nginx的非阻塞IO模型结合在一起使用。<strong>当IO可读可写的时候，相应的读写事件就会被唤醒，此时就会去处理事件的回调函数。</strong><br>特别对于Linux，Nginx大部分event采用epoll EPOLLET（边沿触发）的方法来触发事件，只有listen端口的读事件是EPOLLLT（水平触发）。对于边沿触发，如果出现了可读事件，必须及时处理，否则可能会出现读事件不再触发，连接饿死的情况。</p>\n<p>在ngx_trylock_accept_mutex()函数里面，如果拿到了锁，Nginx会把listen的端口读事件加入event处理，该进程在有新连接进来时就可以进行accept了。注意accept操作是一个普通的读事件。下面的代码说明了这点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"type\">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ngx_posted_accept_events) &#123;</span><br><span class=\"line\">        ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class=\"line\">        ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Nginx多进程的锁在底层默认是通过CPU自旋锁来实现。如果操作系统不支持自旋锁，就采用文件锁。<br>ngx_process_events()函数是所有事件处理的入口，它会遍历所有的事件。抢到了accept锁的进程跟一般进程稍微不同的是，它被加上了NGX_POST_EVENTS标志，也就是说在ngx_process_events() 函数里面只接受而不处理事件，并加入post_events的队列里面。直到ngx_accept_mutex锁去掉以后才去处理具体的事件。为什么这样？<strong>因为ngx_accept_mutex是全局锁，这样做可以尽量减少该进程抢到锁以后，从accept开始到结束的时间，以便其他进程继续接收新的连接，提高吞吐量。</strong></p>\n<p>ngx_posted_accept_events和ngx_posted_events就分别是accept延迟事件队列和普通延迟事件队列。<strong>可以看到ngx_posted_accept_events还是放到ngx_accept_mutex锁里面处理的。该队列里面处理的都是accept事件，它会一口气把内核backlog里等待的连接都accept进来，注册到读写事件里。</strong></p>\n<p>而ngx_posted_events是普通的延迟事件队列。一般情况下，什么样的事件会放到这个普通延迟队列里面呢？我的理解是，那些CPU耗时比较多的都可以放进去。因为Nginx事件处理都是根据触发顺序在一个大循环里依次处理的，因为Nginx一个进程同时只能处理一个事件，所以有些耗时多的事件会把后面所有事件的处理都耽搁了。</p>\n<p>为了更精细地控制对于客户端请求的处理过程，nginx把这个处理过程划分成了11个阶段。他们从前到后，依次列举如下：<br>NGX_HTTP_POST_READ_PHASE:<br>     读取请求内容阶段<br>NGX_HTTP_SERVER_REWRITE_PHASE:<br>     Server请求地址重写阶段<br>NGX_HTTP_FIND_CONFIG_PHASE:<br>     配置查找阶段:<br>NGX_HTTP_REWRITE_PHASE:<br>     Location请求地址重写阶段<br>NGX_HTTP_POST_REWRITE_PHASE:<br>     请求地址重写提交阶段<br>NGX_HTTP_PREACCESS_PHASE:<br>     访问权限检查准备阶段<br>NGX_HTTP_ACCESS_PHASE:<br>     访问权限检查阶段<br>NGX_HTTP_POST_ACCESS_PHASE:<br>     访问权限检查提交阶段<br>NGX_HTTP_TRY_FILES_PHASE:<br>     配置项try_files处理阶段<br>NGX_HTTP_CONTENT_PHASE:<br>     内容产生阶段<br>NGX_HTTP_LOG_PHASE:<br>     日志模块处理阶段</p>\n<p>四层和七层负载均衡的区别<br><strong>层数越低，接触到的数据信息就越基础；层数越高，能理解的数据内容就越丰富</strong>。</p>\n<p>四层负载均衡 (Layer 4 Load Balancing)<br>核心原理：它工作在 TCP&#x2F;UDP 协议层。负载均衡器在接收到客户端请求后，会通过<strong>修改数据包的目标地址和端口（以及源地址，实现NAT）</strong>，然后直接转发给后端某一台服务器。在这个过程中，它不会去读取数据包的具体内容。<br>决策依据：它做转发决策的唯一依据是 网络层传输层 层的信息，主要是源&#x2F;目标 IP 地址和源&#x2F;目标端口号。<br>工作模式：可以看作一个“包转发器 (Packet Forwarder)”。<strong>客户端和后端服务器之间建立的是一条完整的 TCP 连接，负载均衡器只是这条连接上的一个中转节点</strong>。<br>性能极高：因为它不关心包里面的具体内容，不需要解析应用层协议，所以处理速度非常快，开销极低，能应对巨大的流量。<br>通用性强：只要是基于 IP 和端口的协议，理论上都可以进行负载均衡，不限于 HTTP。<br>缺点：<br>功能单一：它无法感知应用层的状态。比如，它无法根据请求的 URL、浏览器类型、Cookie 等信息来做更智能的转发。<br>典型代表：LVS (Linux Virtual Server)、云服务商的网络负载均衡器 (NLB)。</p>\n<p>七层负载均衡 (Layer 7 Load Balancing)<br>工作层面：应用层 (Application Layer)。<br>核心原理：它工作在 HTTP&#x2F;HTTPS, FTP, SMTP 等具体的应用协议层。<strong>它会与客户端建立一次完整的 TCP 连接</strong>，<strong>接收并完整地读取应用层的数据</strong>（比如一个完整的 HTTP 请求），然后根据请求中的具体内容，<strong>再作为一个新的客户端与后端服务器建立另一条 TCP 连接</strong>，将请求转发过去。<br>决策依据：除了 L4 的所有信息外，它还能解析出应用层的各种信息，如 URL 路径、HTTP Headers (请求头)、Cookie、请求方法 (GET&#x2F;POST) 等。<br>优点：<br>极其智能和灵活：可以实现复杂的路由规则。例如：<br>将 yourdomain.com&#x2F;images&#x2F;* 的请求转发到图片服务器集群。<br>将 yourdomain.com&#x2F;api&#x2F;* 的请求转发到 API 服务器集群。<br>根据用户的 Cookie 实现“会话保持 (Sticky Session)”，确保同一用户的请求总是发到同一台后端服务器。<br>可以<strong>修改 HTTP 报文，比如添加&#x2F;删除 Headers</strong>。<br>可以<strong>卸载 SSL&#x2F;TLS 加密，后端服务器只需处理 HTTP 即可</strong>。<br>缺点：<br>性能开销更大：因为它需要解析应用层协议，维持与客户端和服务器的两条连接，缓冲数据，所以 CPU 和内存消耗都比四层负载均衡大，性能也相对较低。<br>典型代表：Nginx、云服务商的应用负载均衡器 (ALB)。</p>\n<hr>\n<p>OpenResty® 是一个功能完备的Web平台，它集成了<strong>增强版的Nginx核心、增强版的LuaJIT、大量精心编写的Lua库以及众多高质量的第三方Nginx模块</strong>及其外部依赖 。<strong>将Nginx服务器有效地转变为一个强大的Web应用服务器</strong> 。在这个服务器中，Web开发者<strong>可以使用Lua编程语言来编写脚本</strong>，驱动现有的Nginx C模块，从而处理复杂的业务逻辑。<br>这种架构的核心优势在于其将<strong>动态语言（Lua）的灵活性与底层C语言服务器（Nginx）的原始性能相结合</strong>。OpenResty® 旨在<strong>利用Nginx的事件模型，在Nginx服务器内部完整地运行服务器端Web应用</strong>，不仅能与HTTP客户端进行非阻塞I&#x2F;O，还能与MySQL、PostgreSQL、Memcached和Redis等远程后端进行非阻塞I&#x2F;O 。</p>\n<hr>\n<p>应当总是使用 set_keepalive，同时连接池的大小应当设置得足够大。否则短连接很容易将你系统的临时端口用尽。<br>另外，在进行压力测试时，应当禁掉 DDEBUG 和 –with-debug，同时使用 warn 以上的 error_log<br>日志过滤级别。<strong>否则你的 nginx<br>都忙着刷不带缓冲的错误日志了</strong>。另外，你也应<strong>设置访问日志的缓冲区或者完全禁掉访问日志</strong>（如果你不需要的话），见</p>\n<p>如果你的 nginx 进程的 CPU 占用比较高，可以使用“火焰图”（flamegraph）对内部的执行热点进行分析：<br><a href=\"https://github.com/openresty/openresty-systemtap-toolkit#ngx-sample-bt\">分析工具</a></p>\n<p><a href=\"https://groups.google.com/g/openresty/c/RcsypnlYcPY/m/aGhPPcI8Si8J\">一篇挺有意思的排错</a></p>\n<p><a href=\"https://groups.google.com/g/openresty/c/phXeClwZVqM/m/BCgzr1Q6CEMJ\">信号量</a></p>\n<p><a href=\"https://groups.google.com/g/openresty/c/psPBSG4KcSU/m/Ur9VjTvKBAAJ\">基于Openresty开发的应用路由性能调优思路</a><br>Lua火焰图显示，CPU时间主要消耗在ngx_http_lua_var_set&#x2F;get这两个函数上，而不是他自己编写的业务逻辑代码。这几乎是找到了“冒烟的枪”。它清晰地指明，性能瓶颈在于通过ngx.var这个API在Lua和Nginx之间传递数据所带来的巨大开销。ngx.var是用于读写Nginx变量的接口，频繁调用它意味着频繁地在Lua VM和Nginx C核心之间进行数据交换和上下文切换，而这个过程的成本远高于纯粹在Lua VM内部执行的计算。<br>ua代码大部分时间是在解释模式下运行，而不是被LuaJIT的<strong>即时编译器（JIT）</strong>所编译和优化。他在火焰图中观察到的lj_BC_xxx栈帧是这一判断的直接证据，这些栈帧代表LuaJIT正在执行字节码（ByteCode），这是其解释器的典型特征。<br>对于一个像LuaJIT这样以高性能著称的VM，JIT编译是其速度的关键来源。当JIT编译器成功运行时，它会将频繁执行的Lua代码（“热代码”）编译成本地的机器码，其执行效率可以逼近原生C代码。反之，如果代码路径由于某些原因无法被JIT编译，VM就会退回到逐条解释执行字节码的慢速模式。这两种模式之间的性能差异可以是数量级的。<br>需要理解为什么JIT会失效。LuaJIT的JIT编译器并非万能，它不支持Lua语言的所有特性和内建函数。那些不被支持的部分被称为“NYI”（Not Yet Implemented，尚未实现）原语。当JIT编译器在分析一个热代码路径时，如果遇到了一个NYI原语，它会放弃对该路径的编译，这个过程称为“JIT中止”（JIT abort）。<br>为了解决这个问题，OpenResty生态系统提供了一个关键的库：lua-resty-core 。这个库的核心作用是为那些在标准Lua中是NYI的常用函数（尤其是与ngx_lua模块API交互的核心部分）提供了JIT兼容的替代实现。通过在代码的init_by_lua阶段简单地执行require “resty.core”，开发者实际上是在“猴子补丁”（monkey-patching）当前的Lua环境，用JIT友好的版本覆盖了那些有问题的标准函数。   </p>\n<p>在OpenResty中，<strong>决定应用性能的最关键因素，是确保热点代码路径能够被LuaJIT的JIT编译器成功编译</strong>。章亦春的所有建议——使用lua-resty-core、避免NYI、预分配表——最终都服务于这一个目标。开发者必须建立一种“像JIT一样思考”的心智模型，在编写代码时，优先选择JIT友好的模式和API，而不是仅仅遵循常规的编码习惯。这意味着，对性能有极致要求的团队，不能将LuaJIT仅仅看作一个黑盒，而应主动去了解其工作原理、优势和限制。<br>因此，在设计应用架构时，应有意识地减少这种“跨界聊天”（必须警惕<strong>Nginx的C环境和Lua VM</strong>之间边界穿越的成本。每一次这样的穿越都涉及到数据结构的转换和上下文的切换，其开销远大于在单一环境（无论是纯C还是纯Lua）中的操作。）。例如，Guanglin Lv后来确认他<strong>主要使用ngx.ctx在不同的Lua处理阶段之间传递数据</strong>。<strong>ngx.ctx是一个请求级别的Lua table</strong>，其数据完全保留在Lua VM内部，因此在access_by_lua中存入、在balancer_by_lua中取出的操作，几乎没有额外的边界穿越开销。与之相比，如果使用ngx.var来传递大量或复杂的数据，则每次读写都会触发一次昂贵的C&#x2F;Lua交互。选择正确的API来在不同阶段间共享状态，是降低这部分固定开销的关键。</p>\n<p>将性能剖析融入开发生命周期：<strong>火焰图的生成和分析不应仅仅是解决线上问题时的最后手段，而应成为性能测试和回归分析的标准流程</strong>。在开发和测试阶段就主动进行剖析，可以在问题暴露于生产环境之前，识别并修复潜在的性能瓶颈。</p>\n<hr>\n<p>epoll的工作模式:<br>epoll的一个实例（你可以想象成一块监控面板）可以同时监控一个监听fd和成千上万个连接fd。<br><strong>当epoll_wait()返回时</strong>，它会告诉你：“监听fd响了，快去accept！” 或者 “连接fd 123有数据了，快去read！” 或者 “连接fd 456可以发送数据了，快去write！”<br>你的程序（Nginx的worker进程）在一个循环里调用epoll_wait()，然后根据返回的fd类型和事件类型，去执行相应的accept, read, write操作。</p>\n<p>什么是惊群？<br>多个worker进程以fork()方式创建，它们继承了父进程（Master进程）打开的所有fd，其中就包括那个唯一的监听fd。于是，所有worker进程都持有同一个监听fd。在老的Linux内核中，当一个新连接到来时，内核会唤醒所有正在epoll_wait()并等待这个监听fd的进程。假设有8个worker进程，8个进程同时被唤醒，然后冲过去调用accept()。但连接只有一个，所以最终只有一个worker能accept()成功，剩下7个都失败返回（得到EAGAIN错误）。这7个进程白白被唤醒了一次，做了无用功，并引发了不必要的CPU上下文切换，浪费了系统资源。这就是“惊群”。<br>Linux 2.6 之前的解决方案 (Nginx的accept_mutex)(用户态锁):<br>Nginx引入了一个<strong>accept_mutex（接受互斥锁）</strong>。<br>在每个worker进程的事件循环中，它会尝试去非阻塞地获取这个锁 (trylock)。<br>获取锁成功:<br>这个worker进程成为“天选之子”，它负责去监听新连接。<br>它会把监听fd通过epoll_ctl()添加到自己的epoll监控集合中。<br>现在，只有它自己会因为新连接事件而被唤醒。<br>获取锁失败:<br>说明已经有其他worker在监听了。<br>它会把监听fd从自己的epoll监控集合中移除。<br>这样，它就只处理自己手上的已有连接的读写事件，完全不关心新连接的到来。<br>这样，通过这把锁，Nginx在同一时刻，确保了只有一个worker进程在处理新连接，从而在应用层完美地解决了惊群问题。<br>SO_REUSEPORT选项 (Linux 3.9+): 这是一个更现代、更高效的解决方案。<br>Nginx的现代实践:<br>Nginx会检测内核版本。在支持SO_REUSEPORT的现代Linux系统上，你可以在nginx.conf的listen指令后添加reuseport选项。<br>listen 80 reuseport;<br>启用后，Nginx将使用SO_REUSEPORT机制，并自动禁用旧的accept_mutex，从而获得更好的性能和连接分发均衡性。</p>\n<p>无论是哪个版本的Nginx，也无论是否使用SO_REUSEPORT，初始化的流程都是一致的：<br>Master进程启动: 读取配置文件（如nginx.conf），根据listen指令得知需要监听哪些端口（如80, 443）。<br>创建和绑定:** Master进程调用socket()创建套接字，设置SO_REUSEADDR等选项<strong>，并调用bind()将其绑定到指定的IP和端口，最后调用listen()开始监听。这一步只由Master进程完成。<br>Fork子进程: Master进程随后fork()出指定数量的Worker子进程。<br>继承文件描述符: 根据Unix&#x2F;Linux的特性，</strong>子进程会继承父进程所有已打开的文件描述符。这意味着，每一个Worker进程都拥有了那个由Master进程创建好的监听套接字的“副本”**。</p>\n<p>关键区别在于SO_REUSEPORT如何影响这个继承来的套接字：<br><strong>不使用reuseport（经典模式）</strong>: 所有Worker进程<strong>共享同一个底层的内核监听队列</strong>。这就是产生“惊群”问题的根源，需要accept_mutex等机制来协调。<br><strong>使用reuseport（现代模式）</strong>: 当Master进程为一个套接字设置了SO_REUSEPORT选项并fork出多个Worker进程后，虽然每个Worker继承的fd数值上是同一个，但在内核层面，情况发生了根本性的变化：<br><strong>独立的内核队列:</strong> 内核会为每一个使用了这个SO_REUSEPORT套接字的进程（也就是每个Worker进程）创建一个<strong>专属的、独立的监听队列</strong>。它不再是所有进程共享一个总队列。<br><strong>内核级负载均衡</strong>:当一个新的TCP连接请求（SYN包）到达时，内核不会去唤醒任何人。相反，内核会根据这个连接的四元组（源IP、源端口、目的IP、目的端口）进行一次哈希计算。<br><strong>精准投递</strong>: 根据哈希计算的结果，内核会精确地选择一个Worker进程，并将这个新连接放入它专属的那个监听队列中。<br><strong>唯一唤醒</strong>:因为<strong>连接只被放入了一个队列</strong>，所以最<strong>终只有那一个被选中的Worker进程的epoll_wait()会被唤醒</strong>，因为它监控的专属队列(全连接队列)变“满”了。其他所有Worker进程的队列都没有变化，它们会继续安然休眠。<br>SO_REUSEPORT的出现，让内核改变了游戏规则。它在唤醒进程之前，就通过哈希算法做了一次“分流”，将连接请求“精准投递”到某个特定的Worker进程。因此，即使所有Worker都在等待，也只有一个会被“精准命中”并唤醒。这就在内核层面彻底、高效地解决了惊群问题。</p>\n<p>在通常情况（没有 SO_REUSEPORT）下是完全正确的。一个内核中的socket对象，确实对应着一套自己的SYN队列和Accept队列。在Nginx的经典模式下，所有Worker进程继承并共享的是同一个内核socket对象，因此它们也就在争抢同一套队列资源。</p>\n<p>但是，SO_REUSEPORT的出现就是为了打破这个规则。<br>当Master进程在socket上设置SO_REUSEPORT选项后，这个socket的性质就变了。它告诉内核：“我准备创建一个可以被多个进程共同绑定的服务端口，请为它们建立一个群组（group）”。<br>之后，当Master进程fork出Worker进程时：<br>虽然每个Worker进程继承的fd数值上是同一个，但在内核看来，由于SO_REUSEPORT的存在，内核会为每一个持有这个fd的Worker进程，都维护一套独立的、专属的SYN队列和Accept队列。<br><strong>正是因为SO_REUSEPORT，内核才为每个Worker进程分配了专属的监听队列，即使它们最初源自同一个socket调用。</strong></p>\n<p>问：在reuseport场景下，各个工作进程在epoll里面注册的是什么？<br>答：每个Worker进程在自己的epoll实例中，注册的依然是那个从Master进程继承来的、数值相同的监听fd。<br>例如，Master创建的监听fd是5，那么所有Worker进程都会执行 epoll_ctl(worker_epoll_fd, EPOLL_CTL_ADD, 5, …)。它们看起来都在监控同一个东西。</p>\n<p>问：在什么情况下会触发回调然后accept新连接？<br>答：神奇之处在于内核的“精准投递”，下面是完整的分解步骤：</p>\n<p>启动阶段:<br>Master进程创建listening_fd（假设为5），并为其设置SO_REUSEPORT选项。<br>Master进程fork出3个Worker进程（W1, W2, W3）。<br>W1, W2, W3都继承了listening_fd&#x3D;5。<br>W1将fd&#x3D;5加入自己的epoll_1；W2将fd&#x3D;5加入自己的epoll_2；W3将fd&#x3D;5加入自己的epoll_3。<br>所有Worker都调用epoll_wait()进入休眠。<br>新连接到达 (SYN包):<br>一个客户端的SYN包到达服务器。<br>内核协议栈识别出该包的目标端口（如80）启用了SO_REUSEPORT。<br>内核哈希与分发:<br>内核提取该连接的四元组（例如 src_ip:12345, dst_ip:80）。<br>内核对这个四元组进行哈希计算，得出一个结果。根据这个结果，内核决定将这个连接分配给W2。<br>专属队列处理:<br>内核将这个半连接信息放入W2专属的SYN队列，并从W2的端口回复SYN-ACK。<br>客户端回复最终的ACK。<br>内核在W2专属的SYN队列中找到对应条目，完成握手，并将这个完整的连接放入W2专属的Accept队列。<br>关键点：从始至终，W1和W3的SYN队列与Accept队列都是空的，完全没有感知到这个新连接的存在。<br>精准Epoll通知与回调:<br>因为只有W2的Accept队列中有了新内容，所以只有<strong>W2的监听fd（fd&#x3D;5）</strong>的内核状态变为了“可读”。<br>内核检查所有正在监控fd&#x3D;5的epoll实例。<strong>但是，由于SO_REUSEPORT的队列隔离机制，内核知道这个“可读”事件只与W2有关。</strong><br>因此，内核只唤醒正在epoll_2上等待的W2进程。<br>W2的epoll_wait()返回，事件循环发现是fd&#x3D;5就绪了。<br>它调用注册在fd&#x3D;5上的回调函数，即ngx_event_accept。<br>成功Accept:<br>ngx_event_accept函数调用accept(5, …)。<br>因为W2的专属Accept队列中确实有一个等待处理的连接，所以accept()调用立即成功，返回一个新的连接fd。<br>后续流程就和我们之前讨论的一样了，W2开始在这个新的连接fd上处理HTTP请求。<br>总结: 在reuseport场景下，所有Worker进程看似在epoll中监控同一个监听fd，但<strong>SO_REUSEPORT选项已经授权内核进行了一次预处理和分流</strong>。内核通过哈希，将不同的连接请求放入了绑定到同一个端口的不同socket的私有队列中，从而实现了只唤醒一个“天选”进程的效果，完美地解决了惊群问题。</p>\n<p>为了精确，我们需要将“监听队列”拆分为两个在内核中真实存在的、不同的队列：<br>半连接队列 (SYN Queue): 当服务器收到客户端的SYN包后，会回复SYN-ACK，然后将这个“半成品”连接放入SYN队列，等待客户端最终的ACK。<br>全连接队列 (Accept Queue): 当服务器收到最终的ACK后，三次握手完成。内核会将这个连接从SYN队列中取出，放入Accept队列，等待应用程序调用accept()来取走。<br>通常我们口语中的“监听队列已满”，指的就是这个Accept Queue满了。<br>现在，我们结合这两个队列，重说一遍<strong>SO_REUSEPORT</strong>的流程：<br>初始化: Nginx的Master进程创建监听套接字时设置了SO_REUSEPORT。随后fork出的多个Worker进程虽然继承了fd，但内核因为这个选项，为每一个Worker进程都创建了一套独立的SYN队列和Accept队列。<br>新连接到达 (SYN包):<br>客户端的SYN包到达服务器网卡。<br>内核TCP&#x2F;IP协议栈发现这个包的目标端口启用了SO_REUSEPORT。<br>内核对该连接的四元组（源IP&#x2F;端口，目的IP&#x2F;端口）进行哈希计算。<br>精准投递 (SYN Queue):<br>根据哈希结果，内核选择一个唯一的Worker进程。<br>内核将这个半连接状态放入该Worker进程专属的SYN队列中，并从此队列回复SYN-ACK。<br>关键: 其他Worker进程的SYN队列完全没有变化，它们对此一无所知。<br>握手完成 (ACK包):<br>客户端回复最终的ACK包。<br>内核根据TCP状态找到之前存放的半连接条目（就在那个被选中的Worker的SYN队列里），完成握手。<br>随后，内核将这个完全建立好的连接放入该Worker进程专属的Accept队列中。<br>唤醒:<br>由于只有这一个Worker进程的Accept队列从“空”变成了“非空”，因此只有它的监听套接字（listening fd）的<strong>“可读”状态</strong>被触发了。<br>因此，只有这个Worker进程的epoll_wait()会从阻塞中返回，并得到“监听套接字可读”的通知。<br>总结: SO_REUSEPORT的本质，就是在内核层面为每个Worker进程创建了专属的、私有的连接接收流水线（SYN队列 + Accept队列），并通过哈希算法在新连接进入的第一步就决定了它该走哪条流水线。这样就从根源上避免了所有Worker去争抢同一个公共资源。</p>\n<p>epoll注册、等待队列与事件处理器<br>Q: 内核的唤醒机制是否通过socket的等待队列实现的？<br>您的直觉完全正确！这正是通过Socket自己的“等待队列”（Wait Queue）实现的。<br>epoll并非一个孤立的系统，它深度整合在Linux的I&#x2F;O和进程调度机制中。<br><strong>等待队列 (Wait Queue)</strong>: 在内核中，几乎所有可能导致进程等待的资源（比如一个socket的接收缓冲区、一个锁）都有一个与之关联的“等待队列”。<strong>这个队列里记录了所有正在睡眠、等待该资源变为可用状态的进程</strong>。<br><strong>epoll_ctl的作用</strong>: 当你调用epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sock_fd, …)时，你不仅仅是在epoll实例中注册了一个fd。<strong>内核还会悄悄地做一件事：将当前进程（的一个引用）加入到sock_fd所对应的内核socket对象的等待队列中</strong>，并做一个标记：“<strong>这个进程是在等epoll事件</strong>”。<br>epoll_wait与休眠: 当进程调用epoll_wait()时，如果没有就绪事件，内核会让这个进程进入休眠状态。<br>状态改变与唤醒: 当一个数据包到达，<strong>内核协议栈将数据放入sock_fd的接收缓冲区</strong>。在完成这个动作后，<strong>内核会执行一个wake_up()操作</strong>，<strong>去唤醒所有在这个socket的等待队列中休眠的进程</strong>。<br>epoll响应: 被唤醒的进程中，<strong>epoll</strong>系统知道是它注册的等待事件发生了。于是，<strong>epoll会将这个就绪的fd信息放入自己的“就绪列表”中</strong>，<strong>最终epoll_wait()得以返回，将就绪列表交给用户程序</strong>。<br>所以，您的理解非常到位。epoll是高层管理者，它利用了底层每个socket自带的等待队列机制来实现高效的事件通知。</p>\n<p>Q: &amp;event 同时包含了读写事件的处理函数吗? 读、写要分开注册吗？<br>这两个问题也切中了epoll在应用层的使用精髓。<br>&amp;event里有什么？:<br>在Nginx中，一个<strong>连接ngx_connection_t</strong>通常包含<strong>两个独立的ngx_event_t结构体</strong>：一个用于读（rev），一个用于写（wev）。rev-&gt;handler指向读回调，wev-&gt;handler指向写回调。<br>epoll_ctl中传递的epoll_data联合体非常小，它只能保存一个指针（或者一个整数）。<br>因此，<strong>当Nginx注册读事件时，它传递的是读事件结构体 rev 的指针</strong>。<strong>当注册写事件时，传递的是写事件结构体 wev 的指针</strong>。<br>所以，epoll每次返回的“回传凭证”要么是读事件的指针，要么是写事件的指针，不可能同时是两者。Nginx拿到这个指针后，就知道是哪个具体事件就绪了，然后执行其对应的handler。</p>\n<p>读、写要分开注册吗？:<br>是的，读写事件的“兴趣”是独立管理的，可以分开注册，也可以合并注册。<br>epoll的事件掩码events是一个位掩码，你可以灵活地组合：<br>events &#x3D; EPOLLIN;  &#x2F;&#x2F; 只对读事件感兴趣<br>events &#x3D; EPOLLOUT; &#x2F;&#x2F; 只对写事件感兴趣<br>events &#x3D; EPOLLIN | EPOLLOUT; &#x2F;&#x2F; 同时对读和写都感兴趣<br>epoll_ctl有三种操作：ADD（添加）、MOD（修改）、DEL（删除）。Nginx正是通过MOD来动态地改变对一个fd的兴趣。</p>\n<p>一个典型的Nginx工作流:<br>连接建立后: Nginx只对读事件感兴趣。它会调用epoll_ctl(…, EPOLL_CTL_ADD, fd, {EPOLLIN, &amp;read_event})。<br>请求处理完，准备响应: Nginx开始write()响应数据。如果数据没写完（发送缓冲区满了），说明现在需要关注“可写”状态了。<br>修改兴趣: 它会调用epoll_ctl(…, EPOLL_CTL_MOD, fd, {EPOLLIN | EPOLLOUT, &amp;write_event})。<br>注意: 这里不仅添加了EPOLLOUT，也保留了EPOLLIN，因为在发送响应的同时，可能需要处理客户端发来的下一个请求（HTTP Keep-Alive）或连接关闭事件。同时，因为epoll_wait返回时会区分是读还是写事件触发的，Nginx会把写事件的指针作为回传凭证。<br>响应发送完毕: Nginx会再次调用epoll_ctl(…, EPOLL_CTL_MOD, fd, {EPOLLIN, &amp;read_event})，移除对EPOLLOUT的兴趣，因为它暂时不需要写数据了，只关心客户端的下一次读取请求。</p>\n<hr>\n<p><em><strong>important</strong></em></p>\n<p>epoll的本质：监控“就绪状态”，而非“事件对象”<br><strong>epoll里面直接存放的不是一个抽象的“事件”，而是对文件描述符（fd）的“就绪状态”的兴趣</strong>。<br>让我们走一遍全流程，看看数据包是如何唤醒进程的。</p>\n<p>A. “注册”的到底是什么？<br>当Nginx调用 epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sock_fd, <strong>&amp;event</strong>) 时，它实际上是在对内核说：<br>“你好内核，我（这个进程）对 sock_fd 这个文件描述符的<strong>可读（EPOLLIN）和可写（EPOLLOUT）</strong>状态非常感兴趣。请把它加入我的epoll_fd这个监控列表里。哦对了，如果它真的就绪了，你在通知我的时候，请把<strong>这个 &amp;event 的地址</strong>原封不动地还给我，这样我就知道是我当初注册的哪个具体任务了。”<br>epoll 并不理解 event 这个结构体（即Nginx的ngx_event_t）的内容。它只是把它当作一个<strong>回传凭证</strong>（在epoll_event结构中是epoll_data联合体）保存起来。<br>所以，epoll内部维护的是一个 &lt;fd, 关注的状态, 回传凭证&gt; 这样的兴趣列表。</p>\n<p>B. 从数据包到进程唤醒的全流程<br>数据到达: 一个网络数据包通过网卡进入系统。<br>内核协议栈处理: 内核的TCP&#x2F;IP协议栈处理这个数据包，识别出它属于哪个TCP连接。<strong>每个TCP连接在内核中都有一个struct sock对象，这个对象里包含了接收缓冲区和发送缓冲区</strong>。内核将包中的数据放入对应连接的接收缓冲区。<br>“就绪状态”改变: <strong>当接收缓冲区从“空”变为“非空”时</strong>，这个socket在内核中的状态就从“未就绪”变成了“可读就绪”。</p>\n<p>epoll的回调机制 (Kernel-Level): **内核在改变socket状态的同时，会检查这个socket是否被任何epoll实例所监控(等待队列)**。它发现你的Worker进程的epoll实例对这个socket的“可读”状态感兴趣。</p>\n<p><strong>加入就绪队列: 内核会将这个socket的fd和当初注册的那个“回传凭证”（也就是&amp;event的地址）</strong> 一起，添加到一个专属于你的epoll实例的<strong>就绪队列（Ready List）</strong>中。</p>\n<p>唤醒进程: 同时，内核会唤醒正在epoll_wait()调用上睡眠的你的Worker进程。</p>\n<p>epoll_wait()返回: <strong>Worker进程被唤醒后，epoll_wait()函数从内核态返回到用户态</strong>。它的返回值就是<strong>就绪队列中项目的数量</strong>，并且它会把<strong>你注册的那些“回传凭证”（epoll_event结构体数组）从内核空间拷贝到你传入的用户空间缓冲区（有一个拷贝）</strong>。</p>\n<p>Nginx的处理: <strong>Nginx的事件循环拿到这个epoll_event数组</strong>，遍历它。对于每一项，它取出“回传凭证”——那个ngx_event_t对象的指针，然后直接执行 event-&gt;handler(event)，<strong>调用之前注册好的回调函数</strong>，开始进行read()数据、解析HTTP等操作。</p>\n<p>C. 这是通用的机制吗？<br>是的，这是<strong>所有使用epoll的程序（不仅仅是Nginx）的标准工作模式</strong>。<br>无论是Redis、Netty（在Linux上）、Envoy还是任何其他使用epoll的高性能程序，其基本原理都是一样的：<br>用户态: 定义自己的事件&#x2F;连接管理结构。<br>注册: 通过epoll_ctl向内核注册对某个fd的就绪状态的兴趣，<strong>并附上一个指向自己事件管理结构的指针&#x2F;凭证</strong>。<br>等待: 调用epoll_wait()等待内核通知。<br>处理: 被唤醒后，从内核返回的凭证中找到自己的<strong>管理结构</strong>，<strong>执行相应的业务逻辑</strong>（<strong>回调</strong>）。<br>epoll本身是内核提供的一个高效的、通用的“就绪状态”通知机制，而Nginx则是在这个机制之上构建了自己精巧的事件处理框架。</p>\n<hr>\n<p>Nginx的Master-Worker之间通信和管理机制非常轻巧和可靠。<br><strong>通信机制：socketpair</strong><br>Master进程在fork出每个Worker进程之前，会通过socketpair()系统调用创建一对Unix域套接字（Unix Domain Socket）。这对套接字就像一条私密的、双向的管道。<br>fork之后，Master进程关闭其中一端，保留另一端。<br>Worker进程也关闭其中一端，保留与Master相对应的一端。<br>这样，Master和每个Worker之间都建立了一条专属的、全双工的通信渠道</p>\n<p>状态管理：信号 (Signal)<br>Master进程作为父进程，通过Unix信号机制来监控所有Worker子进程的状态。<br>注册信号处理器: <strong>Master进程在启动时会为关键信号（如SIGCHLD, SIGINT, SIGHUP等）注册好处理器函数</strong>。<br>SIGCHLD信号: <strong>这是最重要的信号。当任何一个Worker子进程终止（无论是正常退出还是异常崩溃）时，操作系统内核都会向其父进程（也就是Master进程）发送一个SIGCHLD信号</strong>。<br>状态回收与重启: Master进程的SIGCHLD处理器被触发后，<strong>会调用waitpid()等函数来“回收”这个已终止的子进程，并获取其退出状态码</strong>。通过分析状态码，Master就知道子进程是正常退出还是异常崩溃。如果发现是异常崩溃，并且配置了需要保持Worker数量，Master就会重新fork一个新的Worker进程，以维持服务的稳定性。<br>总结：Nginx的父子进程管理，是经典的Unix“信号驱动”模式，稳定、高效且可靠。</p>\n<hr>\n<p>epoll事件处理全流程详解 (含回调)<br>这是Nginx的心脏。我将为您描述一个HTTP请求从连接建立到响应完成的全过程。</p>\n<p>A. 核心构件：事件与处理器（回调）<br>在Nginx中，核心数据结构是：<br><strong>ngx_connection_t</strong>: 代表一个连接，包含了<strong>socket fd、读写缓冲区</strong>、SSL上下文等所有与连接相关的信息。<br><strong>ngx_event_t</strong>: 代表一个事件，<strong>是我们很重要的事件管理结构</strong>。每个连接（ngx_connection_t）<strong>都关联着一个读事件和一个写事件</strong>。事件结构体中最重要的成员是：<br><strong>handler</strong>: 这是一个函数指针，它指向一个处理该事件的函数。<strong>这就是Nginx的回调函数</strong>。<br><strong>active</strong>: 一个标志，表示这个事件是否已经被添加到了epoll中。</p>\n<p>B. 事件循环：永不停歇的心脏<br>每个Worker进程都在一个while(1)循环中工作，这个循环的核心是ngx_process_events_and_timers()函数。<br>调用epoll_wait()，并设置一个超时时间。<strong>Worker进程在此阻塞，等待内核通知事件的发生</strong>。<br>epoll_wait()返回，携带了一批“就绪”的事件。<br><strong>Worker进程遍历这些就绪的事件（需要先拷贝到内核）。</strong><br>对于<strong>每一个就绪的事件 event，直接执行：event-&gt;handler(event)<strong>。这就是回调函数的调用。<br>处理完所有I&#x2F;O事件后，</strong>处理定时器队列中的超时事件</strong>（如连接超时）。<br>回到第1步，继续循环。</p>\n<p>C. 流程1：处理新连接 (Accept Event)<br>注册: Nginx启动时，<strong>监听套接字的读事件的handler被设置为ngx_event_accept函数</strong>。这个<strong>读事件被加入到epoll中</strong>。<br>事件发生: 一个客户端发起TCP连接请求，三次握手完成。<strong>内核将这个新连接放入Accept队列</strong>，<strong>监听套接字变为“可读”</strong>。（<strong>通过等待队列将事件加入到就绪队列</strong>……）<br>处理:<br>epoll_wait()被唤醒，<strong>返回监听套接字的读事件</strong>。<br><strong>事件循环调用其handler</strong>，也就是<strong>ngx_event_accept</strong>。<br>ngx_event_accept函数内部：<br>a. 调用accept()接收新连接，得到一个新的连接socket fd。<br>b. 从<strong>连接池中</strong>获取一个<strong>ngx_connection_t</strong>结构体来管理这个新连接。<br>c. 【关键：注册新回调】 为这个新连接设置初始的事件处理器。通常，会将新连接的读事件的handler设置为ngx_http_init_request，写事件的handler设置为一个空闲处理器（因为现在还不需要写）。<br>d. 将这个新连接的读事件添加到epoll中，开始等待客户端发送数据。</p>\n<p>D. 流程2：处理请求数据 (Read Event)<br>事件发生: 客户端沿着新建立的连接发送HTTP请求（如GET &#x2F;index.html …）。连接socket变为“可读”。<br>处理:<br>epoll_wait()被唤醒，返回这个连接的读事件。<br>事件循环调用其handler，也就是我们上一步设置的ngx_http_init_request。<br>ngx_http_init_request和后续的HTTP处理函数内部：<br>a. 调用read()或recv()<strong>从socket缓冲区读取数据到Nginx的内存缓冲区</strong>。<br>b. <strong>开始解析HTTP请求</strong>（请求行、请求头等）。<br>c. 【状态机与回调变更】** Nginx的请求处理是一个状态机<strong>。例如，读完请求行后，</strong>读事件的handler<strong>可能会被修改为ngx_http_process_request_headers。</strong>整个请求处理过程，事件的handler会根据当前状态不断地被修改，指向下一个阶段该执行的函数**。<br>d. 如果一次read()没有读完整个请求，函数就直接返回。因为读事件还在epoll里，下次数据到来时，epoll会再次通知，并从上次的状态继续执行。<br>e. 请求完全接收并解析完毕后，Nginx根据配置找到对应的资源（文件或上游服务器），准备响应。</p>\n<p>E. 流程3：发送响应数据 (Write Event)<br>事件发生与注册:<br>Nginx准备好了响应数据（比如读取了index.html文件内容），调用write()或send()发送。<br>由于<strong>TCP滑动窗口和内核发送缓冲区</strong>的限制，一次write()可能无法发送完所有数据。<br>当w<strong>rite()返回一个小于预期发送的字节数，或者返回EAGAIN错误</strong>时，Nginx知道现在不能再写了。<br>【关键：注册写回调】 此时，Nginx会将这个连接的写事件添加到epoll中，并将其handler设置为一个专门的发送函数，如ngx_http_writer。<br>处理:<br>当客户端接收了数据，内核的发送缓冲区有了空闲空间，连接socket变为“可写”。<br>epoll_wait()被唤醒，返回这个连接的写事件。<br>事件循环调用其handler，也就是ngx_http_writer。<br>ngx_http_writer函数内部：<br>a. 继续发送缓冲区中剩余的数据。<br>b. 如果<strong>数据全部发送完毕，就将这个连接的写事件从epoll中移除</strong>，因为暂时不再需要关注“可写”状态了。<br>c. 如果数据依然没有发完，就什么也不做，等待下一次epoll的“可写”通知。</p>\n<p>这个“<strong>注册-等待-回调</strong>”的循环，就是Nginx用单线程高效处理海量并发I&#x2F;O的全部奥秘。</p>\n<h1 id=\"uWSGI-amp-Gevent\"><a href=\"#uWSGI-amp-Gevent\" class=\"headerlink\" title=\"uWSGI &amp; Gevent\"></a>uWSGI &amp; Gevent</h1><p><em><strong>WSGI (Web Server Gateway Interface)</strong></em> - “协议与规范”<br>WSGI 本身不是一个服务器，也不是一个库，它是一个<strong>规范</strong>（一种标准接口）。你可以把它理解成是 Python 世界里的 “API 规范”，专门用来定义 Web 服务器 (比如 uWSGI) 如何与 Python Web 应用程序&#x2F;框架 (比如 Django, Flask) 进行通信。</p>\n<p>这个规范解决了什么问题？在 WSGI 出现之前，如果你写了一个 Python Web 框架，你可能需要为各种不同的 Web 服务器（Apache, Nginx 等）编写专用的适配器。这非常混乱。</p>\n<p>WSGI 的出现统一了江湖。它规定：<br><strong>服务器端 (uWSGI) 必须实现一个方式，能够调用应用程序</strong>。<br><strong>应用程序端 (你的代码) 必须提供一个可调用对象</strong>（通常是一个函数），我们称之为 <strong>application</strong>。</p>\n<p>这个 application 函数必须接受两个参数：<br><strong>environ</strong>: 一个<strong>包含了所有 HTTP 请求信息的 dict 对象</strong>（比如请求头，路径，方法等）。<br>start_response: 一个<strong>由服务器 uWSGI 提供的回调函数</strong>。应用程序在<strong>准备好响应头（比如 200 OK, Content-Type: application&#x2F;json）后</strong>，必须<strong>先调用这个函数</strong>，然后<strong>再返回响应体</strong>。</p>\n<p>底层细节：<br><strong>WSGI 的核心就是一个简单的函数签名 application(environ, start_response)<strong>。</strong>uWSGI 服务器负责把原始的 HTTP 请求解析成 environ 字典</strong>，并<strong>提供 start_response 函数</strong>，然后调用你的 Python 代码即 application。你的代码里面<strong>负责处理业务逻辑，调用 start_response</strong>，并<strong>返回响应体数据</strong>。它是一个纯粹的、解耦的“契约”。</p>\n<p><em><strong>uWSGI - “应用程序服务器”</strong></em><br>uWSGI 是一个<strong>功能强大的应用程序服务器</strong>。它的核心职责是“承上启下”：<br>对上 (对 Nginx): 它能与<strong>专业的 Web 服务器（如 Nginx）</strong>高效通信。它们之间通常使用一种性能极高的二进制协议，叫做 <strong>uwsgi</strong> 协议（注意小写，以区别于软件本身）。这种通信<strong>可以通过 TCP 端口</strong>，也可以通过你提到的、性能更高的 <strong>Unix 域套接字（Unix Socket）</strong>进行。<br>对下 (对 Python 应用): 它负责<strong>加载并运行你的 Python WSGI 应用程序</strong>。它会<strong>管理一个或多个工作进程</strong>（Worker Processes），并<strong>将来自 Nginx 的请求分发给这些进程来处理</strong>。</p>\n<p>核心功能和底层细节：<br>进程管理: uWSGI 通常会有一个 Master 进程和多个 Worker 进程。Master 进程负责监控和管理 Worker 进程，如果某个 Worker 挂了，Master 会重新拉起一个新的。<br>协议翻译: 它的核心工作之一<strong>就是将 Nginx 通过 uwsgi 协议发来的请求，翻译成符合 WSGI 规范的 environ 和 start_response</strong>，然后<strong>调用你的 Python application</strong>。反过来，它再把 Python 应用返回的<strong>响应</strong>，<strong>打包成 uwsgi 协议格式</strong>，发回给 Nginx。<br>性能: uWSGI 是用 C 语言编写的，性能极高。它能处理高并发请求，并有效地利用多核 CPU 资源。</p>\n<p><em><strong>Gevent - “并发魔法师”</strong></em><br><strong>Gevent 是一个基于协程的 Python 网络库</strong>。它解决的核心问题是高并发 I&#x2F;O。<br>在传统的同步模型里，一个进程&#x2F;线程在处理一个请求时，如果遇到 I&#x2F;O 操作（比如查询数据库、请求外部 API），它就会阻塞，CPU 就在那里空等，直到 I&#x2F;O 操作完成。这极大地浪费了 CPU 资源。<br>Gevent 引入了协程（也叫微线程或 <strong>Greenlet</strong>）。协程是一种非常轻量级的“线程”，它的切换开销极小，并且是由程序代码自己来控制切换时机（称为“协作式调度”）。</p>\n<p>底层细节 (Gevent 的魔法：Monkey Patching):<br>Gevent 最神奇的地方在于它的“猴子补丁” (monkey.patch_all())。当你调用这个函数时，Gevent 会在<strong>运行时动态地替换掉 Python 标准库中所有会产生阻塞的 I&#x2F;O 函数</strong>（比如 socket.connect, socket.recv, time.sleep 等），换成它自己实现的非阻塞版本。<br>工作原理: 当你的代码（已经打了猴子补丁）执行到一个 I&#x2F;O 操作时，比如 requests.get(‘http:&#x2F;&#x2F;…’)，底层的 socket.recv() 实际上是 Gevent 的版本。它不会真的阻塞整个进程，而是会：<br><strong>向操作系统注册一个事件</strong>，告诉内核：“当这个 socket 有数据可读时，请通知我。”<br>让出 (yield) 当前协程的执行权。<br>Gevent 的事件循环 (Event Loop) 会接管控制权，去看有没有其他已经准备好（比如 CPU 计算任务，或者其他已完成的 I&#x2F;O）的协程可以运行。<br>当最初的那个数据库查询&#x2F;API 请求返回数据后，操作系统通知 Gevent 的事件循环，<strong>事件循环再把执行权交还给之前被挂起的那个协程，让它从刚才停下的地方继续执行</strong>。</p>\n<p>这一切对于你的业务代码来说是完全透明的。你依然可以像写同步代码一样书写逻辑，但底层却实现了异步非阻塞的高并发效果。这使得单个 uWSGI Worker 进程可以同时处理成百上千个并发连接。</p>\n<p>第二部分：一个请求的完整生命周期 (底层细节)<br>假设你的配置是：Nginx &lt;–&gt; Unix Socket &lt;–&gt; uWSGI (with Gevent workers) &lt;–&gt; Your WSGI App</p>\n<p>第1步: 客户端 -&gt; Nginx<br>用户浏览器发起一个 HTTP 请求，例如 GET &#x2F;api&#x2F;users&#x2F;123。<br>经过 DNS 解析、TCP 三次握手、TLS 握手（如果是 HTTPS），请求数据包到达你的服务器的 80&#x2F;443 端口。<br>Linux 内核协议栈处理数据包，将其递交给正在监听该端口的 Nginx Master 进程。Nginx Master 进程再将这个连接交给一个空闲的 Nginx Worker 进程处理。</p>\n<p>第2步: Nginx 内部处理<br>Nginx Worker 进程解析 HTTP 请求报文，得到请求方法 (GET)、路径 (&#x2F;api&#x2F;users&#x2F;123)、HTTP 版本、请求头等信息。<br>Nginx 查看自己的配置文件 (nginx.conf)。它根据 server_name 和 location 块匹配请求。它发现 &#x2F;api&#x2F; 路径的请求应该被代理到后端。<br>配置中写的是 uwsgi_pass unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;your&#x2F;app.sock;。Nginx 知道它需要和 uWSGI 通信。</p>\n<p>第3步: Nginx -&gt; uWSGI (通过 Unix Socket)<br>这是关键的一步。Nginx 不会把原始的 HTTP 报文直接发过去。<br>它会按照 <strong>uwsgi</strong> 协议的格式，将解析好的请求信息（如 REQUEST_METHOD, PATH_INFO 等）打包成一个<strong>二进制的数据块</strong>。<br>Nginx 通过系统调用 write()，将这个二进制数据块写入到 &#x2F;path&#x2F;to&#x2F;your&#x2F;app.sock 这个 Unix 域套接字文件中。<strong>因为是文件系统 IPC，它绕过了整个网络协议栈，没有 TCP 的封包&#x2F;解包、校验和、拥塞控制等开销，速度极快。</strong></p>\n<p>第4步: uWSGI 接收并分发<br>uWSGI Master 进程早已创建好了这个 app.sock 文件并监听它。<strong>当有数据写入时，操作系统会唤醒正在 accept() 上等待的 uWSGI Master 或 Worker</strong>。<br>uWSGI Master 进程将这个新连接交给一个空闲的 uWSGI Worker 进程来处理。<br>这个 <strong>Worker 进程从 Unix Socket 中通过 read() 读取 Nginx 发来的 uwsgi 协议数据</strong>。</p>\n<p>第5步: uWSGI Worker 内部处理 &amp; 调用 Python 应用<br>Worker 进程解析 uwsgi 二进制数据，将其翻译成 WSGI 规范所要求的 <strong>environ</strong> 字典。<br>Worker 进程<strong>创建一个 start_response 回调函数</strong>。<br>现在，它拥有了调用 Python 应用所需的一切。它调用你的 **WSGI 入口函数：application(environ, start_response)**。</p>\n<p>第6步: Python 应用 &amp; Gevent 的表演时刻<br>你的 Python 代码开始执行。假设处理 &#x2F;api&#x2F;users&#x2F;123 需要查询数据库。<br>代码执行到 db_cursor.execute(“SELECT * FROM users WHERE id&#x3D;123”)。<br>由于 monkey.patch_all() 的作用，这个<strong>数据库驱动底层的 socket 操作已经被换成了 Gevent 的非阻塞版本</strong>。<br>当前协程（Greenlet）被挂起，它会让出 CPU，同时告诉 Gevent 的事件循环：“当数据库连接上有数据返回时，请叫醒我。”<br>关键点：这个 uWSGI Worker 进程并没有被阻塞！Gevent 的事件循环会立刻检查是否有其他协程可以运行。如果此时 Nginx 又发来了第二个请求，这个 Worker 进程可以立即开始处理第二个请求，启动一个新的协程，而第一个请求的协程则在静静地等待数据库返回结果。这就是用 Gevent 实现高并发的核心。</p>\n<p>第7步: 应用返回响应<br>数据库返回了查询结果。操作系统通知 Gevent 的事件循环，事件循环唤醒了第一个请求对应的协程(通过执行回调函数实现的，回调知道是哪个协程，并且将读到的socket上的数据库数据作为结果返回回去)。<br><strong>协程从之前挂起的地方继续执行</strong>，处理数据库结果，生成 JSON 响应。<br>代码调用 start_response(‘200 OK’, [(‘Content-Type’, ‘application&#x2F;json’)])。<br>函数 return [b’{“id”: 123, “name”: “Alice”}’]，返回响应体。</p>\n<p>第8步: uWSGI -&gt; Nginx (返回路径)<br>uWSGI Worker 进程拿到了 Python 应用返回的响应头和响应体。<br>它将这些信息<strong>再次打包成 uwsgi 协议的二进制格式</strong>。<br>通过 write() 系统调用，将响应数据写回给来时的那个 Unix Socket 连接。</p>\n<p>第9步: Nginx -&gt; 客户端<br>Nginx Worker <strong>进程正在 epoll 上监听着这个 Socket</strong>。当 uWSGI 写回数据时，Nginx 被唤醒。<br>Nginx 从 Socket 读取 uwsgi 协议的响应数据，将其解析并翻译成标准的 HTTP 响应报文（添加 HTTP&#x2F;1.1 200 OK 状态行，组装响应头等）。<br>最后，Nginx 将这个完整的 HTTP 响应报文通过服务器的网卡发送回用户的浏览器。</p>\n<p>第10步: 浏览器渲染<br>浏览器接收到 HTTP 响应，解析内容并将其渲染成用户看到的页面。<br>至此，一个请求的完整旅程结束。这个架构的精髓在于：<br><strong>Nginx 负责处理一切与网络相关的脏活累活</strong>（<strong>连接管理、静态文件、安全、负载均衡</strong>）。<br><strong>uWSGI</strong> 作为坚固的桥梁，<strong>高效地管理和运行 Python 进程</strong>。<br><strong>Gevent 在应用层内部</strong>，用魔法般的方式让<strong>同步风格的代码实现了异步 I&#x2F;O</strong>，极大地提升了单个进程的并发处理能力。</p>\n<hr>\n<p><em><strong>OpenResty Cosocket 是什么？</strong></em><br>Cosocket (<strong>Coroutine Socket</strong>) 并不是一种新的 socket 类型，而是 ngx_lua 模块提供的一套 Lua API。这套 API 的目的是让用户可以在 Lua 代码中，以一种同步的、看起来是阻塞的方式，来执行底层的、异步的、非阻塞的网络 I&#x2F;O 操作。<br>当你调用一个 cosocket API (例如 tcpsock:connect, tcpsock:receive) 时，它并不会阻塞整个 Nginx 的 Worker 进程。相反，<strong>它巧妙地利用了 Lua 协程和 Nginx 事件循环，实现了高效的并发。</strong><br>Cosocket 如何与 Nginx 事件循环协作？可以分解为以下几个步骤：</p>\n<ol>\n<li><p>发起 I&#x2F;O 调用: <strong>你的 Lua 代码在一个由 ngx_lua 模块创建和管理的 Lua 协程中运行</strong>。当代码执行到 local ok, err &#x3D; tcpsock:connect(“google.com”, 80) 时，connect 函数被调用。</p>\n</li>\n<li><p>启动底层操作 &amp; 注册事件:<br>connect 函数（内部是 C 实现）会调用 Nginx 底层的<strong>非阻塞 socket API 来真正发起一个 TCP 连接</strong>。因为是非阻塞的，这个调用会立即返回，通常会返回一个 <strong>EAGAIN</strong> 或 EINPROGRESS 的错误码，表示“操作正在进行中”。<br>同时，它将这个 <strong>socket 的文件描述符 (fd) 以及我们感兴趣的事件（对于 connect 来说是 “可写” 事件）当然还有回调函数</strong>注册到 Nginx 的主事件循环中。Nginx 的事件循环通常是基于 epoll (在 Linux 上) 的。<br>这个注册动作相当于告诉 Nginx：“请帮我盯着这个 socket，当它可以写入数据时（意味着连接已成功建立），请通知我。”</p>\n</li>\n<li><p>协程让出 (Yield):<br>在注册完事件后，C 函数会**调用 coroutine.yield()**。这是最关键的一步。<br>yield 会暂停当前 Lua 协程的执行，并将控制权交还给 ngx_lua 模块的 C 代码。<br>此时，这个处理请求的 Nginx Worker 进程完全没有被阻塞。它可以去处理其他请求、处理其他已经就绪的 I&#x2F;O 事件，CPU 资源被充分利用。你的那个 Lua 协程则进入“休眠”状态，等待被唤醒。</p>\n</li>\n<li><p><em><strong>事件就绪</strong></em> &amp; Nginx 唤醒:<br>一段时间后，TCP 连接成功建立。操作系统<strong>会通知 Nginx 的事件循环（epoll_wait 返回）</strong>，告知之前注册的那个 socket fd 现在“可写”了。<br>（<em><strong>这一步之前有一些底层知识待补充</strong></em>）Nginx 的事件循环会<strong>调用与该事件关联的回调函数</strong>。这个回调函数是由 ngx_lua 模块在第 2 步设置好的。</p>\n</li>\n<li><p>协程恢复 (Resume):<br>这个<strong>回调函数知道是哪个 Lua 协程在等待这个事件</strong>。它会调用 <strong>coroutine.resume()<strong>，</strong>唤醒之前休眠的那个协程</strong>，<strong>并将 I&#x2F;O 操作的结果（成功还是失败，错误信息等）作为 resume 的参数传递回去</strong>。<br><strong>Lua 协程从之前 yield 的地方继续执行</strong>，tcpsock:connect 函数现在才真正“返回”，并将结果赋值给 ok 和 err 变量。<br>总结一下：对于写 Lua 代码的你来说，tcpsock:connect 看起来就像一个普通的阻塞函数。但<strong>实际上，在它“阻塞”的期间，整个 Nginx 服务依然在全速运转，处理着成千上万的其他任务</strong>。Cosocket API 就像一个语法糖，让你能用同步的思维写出异步性能的代码。</p>\n</li>\n</ol>\n<p><em><strong>与 Gevent 的比较：异同之处</strong></em><br>Cosocket 的思想和 Gevent 非常相似。它们都致力于解决同一个问题：如何用同步的编码风格实现异步 I&#x2F;O 并发。<br><strong>相同点：</strong><br>核心机制: 两者都依赖于“<strong>协程</strong>&#x2F;微线程”（Lua Coroutine vs Gevent Greenlet）<strong>作为并发调度的基本单位</strong>。<br>用户体验: 两者<strong>都提供了看似阻塞的 API，让开发者无需手动管理复杂的回调函数</strong>（避免了“回调地狱”）。<br>底层思想: 都是通过“<strong>发起 I&#x2F;O -&gt; 注册事件 -&gt; 让出执行权 -&gt; 事件就绪 -&gt; 恢复执行权</strong>”的模式来工作。</p>\n<p>底层区别 (非常关键)：</p>\n<img src=\"/2025/09/30/TrickyNote/image-19.png\" class=\"\" title=\"Alt text\">\n\n<p>它们依靠什么来完成事件循环？这是对底层机制的终极追问。</p>\n<p>OpenResty: <strong>它完全依赖 Nginx 的事件循环</strong>。Nginx 的事件循环是其高性能的核心，它在底层<strong>会使用操作系统提供的最高效的 I&#x2F;O 多路复用技术</strong>。<br>在 Linux 上是 epoll。<br>在 FreeBSD&#x2F;macOS 上是 kqueue。<br>在 Windows 上是 IOCP (I&#x2F;O Completion Ports)。<br>Nginx 会自动选择当前 OS 支持的最佳模型。所以，<strong>Cosocket 的事件驱动能力，实际上是由 Nginx 和操作系统内核共同提供的</strong>。</p>\n<p><strong>Gevent</strong>: 它依赖于<strong>独立的事件循环 C 库</strong>，<strong>最常见的是 libev 或 libevent</strong>。这些 C 库做的事情和 Nginx 的事件循环非常类似，它们也封装了底层的 epoll, kqueue 等系统调用，提供了一套统一的、跨平台的事件处理接口。所以，追根溯源，<strong>Gevent 最终也是依赖操作系统内核提供的 I&#x2F;O 多路复用机制</strong>。</p>\n<p>核心结论：<br>OpenResty 的做法是一种<strong>深度整合</strong>、天人合一的模式。Lua 代码和协程成为了 Nginx 事件驱动世界的一等公民，共享同一个强大的心脏（事件循环）。<br>Gevent 的做法是一种<strong>通用嵌入</strong>、自给自足的模式。它在 Python 进程这个独立的王国里，建立了一套属于自己的、完整的事件驱动系统。</p>\n<hr>\n<p>如果把 ngx_lua 模块比作一块性能炸裂的顶级 CPU，那么 OpenResty 就是设计和制造了这块 CPU，并围绕它构建了一台功能完备、性能均衡的超级计算机。</p>\n<p>简单来说，<em><em>ngx_lua 模块以及基于它构建的整个 lua-resty-</em> 非阻塞库生态系统</em>*，就是 <strong>OpenResty 项目的核心产出和最大贡献</strong>。</p>\n<p>第一部分：谁做了什么？OpenResty 快的根源归属<br>OpenResty 的快，是 Nginx、LuaJIT 和 OpenResty 自身贡献三者完美结合的成果，缺一不可。</p>\n<ol>\n<li>Nginx：提供 “骨骼与心脏”<br><strong>高性能事件循环</strong> (The Heart): Nginx 的核心是一个基于操作系统事件通知机制（如 epoll, kqueue）的、非阻塞的事件循环。这是整个架构得以运转的“心脏”。它能以极低的开销管理数以万计的并发连接。<br>成熟的 HTTP 服务器 (The Skeleton): <strong>Nginx 提供了稳定、高效的 HTTP 协议解析、请求&#x2F;响应管理、连接管理等所有 Web 服务器的基础功能</strong>。<br>模块化架构: Nginx 允许第三方模块（比如 ngx_lua）深度嵌入到它的请求处理流程中，在不同的阶段挂载自己的处理逻辑。<br>Nginx 贡献了“快”的底层 I&#x2F;O 模型。</li>\n<li>LuaJIT：提供 “超速大脑与轻功”<br><strong>JIT (Just-In-Time) 编译器</strong>: LuaJIT 是 Lua 语言的一个超高性能实现。它的 JIT 编译器能将热点 Lua 代码编译成高效的本地机器码，使得 Lua 代码的执行速度可以接近甚至媲美 C 语言。这对于需要复杂计算和业务逻辑的场景至关重要。<br><strong>原生的协程支持</strong> (The Agility): Lua 语言原生就支持协程 (coroutine)。这是 yield 和 resume 的语言基础。没有这个，cosocket 的实现会困难得多。<br><strong>FFI</strong> (Foreign Function Interface): LuaJIT 的 FFI 机制允许 Lua 代码<strong>以极高的性能直接调用 C 函数和使用 C 的数据结构</strong>，几乎没有性能损耗。ngx_lua 模块正是利用 FFI 实现了 Lua 与 Nginx (C代码) 之间的高效通信。<br>LuaJIT 贡献了“快”的计算能力和并发调度的语言基础。</li>\n<li>OpenResty：作为 “总设计师与神经系统”<br>OpenResty 是将 Nginx 的“心脏”和 LuaJIT 的“大脑”完美缝合在一起的“总设计师”，并为这具强大的身体打造了完整的“神经系统”。<br><strong>ngx_lua_module (The Bridge)</strong>: 这是 OpenResty 项目的<strong>核心创造</strong>。这个 C 模块是连接 Nginx 事件循环和 Lua 协程的桥梁。我们上一轮讨论的 cosocket API 就是由这个模块提供的。它<strong>实现了将 I&#x2F;O 操作注册到 Nginx 事件循环并适时 yield&#x2F;resume Lua 协程</strong>的全部魔法。<br>非阻塞库生态 (lua-resty-X) (The Nervous System): 只有 cosocket 这个底层 API 是不够的。开发者需要方便的工具来和 Redis, MySQL, Memcached 等后端服务通信。OpenResty 项目开发并维护了一整套 lua-resty-X 库。这些库全部基于 cosocket API 构建，确保了所有外部通信都是 100% 非阻塞的。lua-resty-mysql, lua-resty-redis 等都是 OpenResty 的官方作品。<br>OpenResty <strong>贡献了将两者能力融合的关键技术（ngx_lua），并在此基础上构建了完整的、实用的、高性能的非阻塞业务开发平台（lua-resty-X 库）</strong>。</li>\n</ol>\n<p>第二部分：实战拆解：lua-resty-mysql 的一次 query 操作<br>让我们看看 local result, err &#x3D; db:query(“SELECT * FROM users WHERE id &#x3D; 123”) 这行代码背后发生了什么，来体会上面讲的协作过程。</p>\n<p>前提: 假设已经通过 resty.mysql:new() 创建了 db 对象，并通过 db:connect() 建立了连接（connect 本身也是一个非阻塞的 cosocket 操作）。<br>获取连接 (OpenResty 的贡献):<br>db:query 首先会从内部的连接池中获取一个可用的 MySQL 连接。<strong>连接池 (set_keepalive) 是 lua-resty-mysql 库提供的重要性能优化</strong>，它避免了为每个查询都重新建立 TCP 连接的巨大开销。<br>构建并发送请求包 (LuaJIT + OpenResty):<br>lua-resty-mysql 库（纯 Lua 代码）会将 SELECT 语句按照 MySQL 的通信协议格式化成一个二进制数据包。<br>然后它调用底层的 cosocket API：ok, err &#x3D; tcpsock:send(packet)。<br><strong>ngx_lua 模块接管</strong>，将这个数据包通过<strong>非阻塞的 send() 系统调用写入 socket</strong>。如果<strong>内核的发送缓冲区满了，当前协程就会 yield，并将 socket 的“可写”事件注册到 Nginx 事件循环中，等待缓冲区可用</strong>。</p>\n<p>等待响应包 (Nginx + OpenResty):<br>发送成功后，代码需要等待 MySQL 服务器返回数据。lua-resty-mysql 会调用 data, err &#x3D; tcpsock:receive(…)。<br>这是最关键的非阻塞等待点。receive 函数<strong>通过 ngx_lua 模块，将这个 socket 的“可读”事件注册到 Nginx 的事件循环中</strong>。（都是通过 ngx_lua 模块注册 IO 事件和对应的回调函数(该函数负责读写数据和resume 协程)）</p>\n<p>然后，当前 Lua 协程立刻 yield (让出)，执行权返回给 Nginx。<br>Nginx Worker 进程此时完全空闲，可以去处理其他成百上千个并发请求。</p>\n<p>数据到达并唤醒 (Nginx + OpenResty):<br>MySQL 服务器处理完查询，将结果通过网络发回。<br>数据到达服务器网卡，Nginx 的事件循环（epoll_wait）被唤醒，发现之前注册的那个 socket 变得“可读”。<br><em><strong>Nginx 触发 ngx_lua 模块预设的回调，该回调 resume 之前休眠的那个 Lua 协程，并将从 socket 读到的数据块作为返回值</strong></em>。</p>\n<p>解析并返回结果 (LuaJIT + OpenResty):<br>Lua 协程被唤醒，<em><strong>tcpsock:receive 函数“返回”了原始的二进制数据</strong></em>。<br>lua-resty-mysql 库（纯 Lua 代码）开始解析这个二进制数据包，将其转换成用户友好的 Lua table 格式。<br>最后，db:query 函数将这个 table 返回给调用它的业务代码。同时，将这个 MySQL 连接放回连接池，以备下次使用。</p>\n<p>总结:<br>在这个过程中，<strong>Nginx 负责监听 socket 事件，LuaJIT 负责高效地执行协议解析和业务逻辑</strong>，而 OpenResty（通过 ngx_lua 和 lua-resty-mysql）则扮演了指挥官的角色，<strong>完美地编排了整个异步流程</strong>，让开发者感觉不到底层的复杂性，同时获得了极致的性能。</p>\n<h1 id=\"limit-rate-amp-limit-conn\"><a href=\"#limit-rate-amp-limit-conn\" class=\"headerlink\" title=\"limit rate &amp; limit conn\"></a>limit rate &amp; limit conn</h1><p>加入了nodelay参数之后的限速算法，到底算是哪一个“桶”，是漏桶算法还是令牌桶算法？当然还算是漏桶算法。考虑一种情况，令牌桶算法的token为耗尽时会怎么做呢？由于它有一个请求队列，所以会把接下来的请求缓存下来，缓存多少受限于队列大小。但此时缓存这些请求还有意义吗？如果server已经过载，缓存队列越来越长，RT越来越高，即使过了很久请求被处理了，对用户来说也没什么价值了。所以当token不够用时，最明智的做法就是直接拒绝用户的请求，这就成了漏桶算法，哈哈~</p>\n<p>burst队列在哪里<br>只要excess &lt; limit-&gt;burst限速模块就会返回NGX_OK，并没有把多余请求放入队列的操作，这是因为Nginx是基于timer来管理请求的，当限速模块返回NGX_OK时，调度函数会计算一个延迟处理的时间，同时把这个请求放入到共享的timer队列中（一棵按等待时间从小到大排序的红黑树）。</p>\n<p>Nginx主要有两种限速方式：按连接数限速(ngx_http_limit_conn_module)、按请求速率限速(ngx_http_limit_req_module)。</p>\n<p>并非所有连接都会被计数。只有当服务器正在处理请求并且已读取整个请求标头时，该连接才会被计数。</p>\n<p>该 Lua 模块除了支持在超过并发级别阈值时立即拒绝连接之外，还支持延迟连接。</p>\n<p>default_conn_delay是典型连接（或请求）的默认处理延迟。</p>\n<p>该延迟作为因并发请求（或连接）过多而引入的额外延迟的基本单位<br>与上一种情况类似，此方法还返回第二个返回值，指示此时（包括当前请求）的并发请求数（或连接数）。<strong>第二个返回值可用于监控未调整的传入并发级别</strong>。<br>监控并发等级怎么做？</p>\n<p>此类的每个实例不包含任何状态信息，但包含conn和burst 阈值。基于键的实际限制状态存储在新lua_shared_dict方法 中指定的共享内存区域中，所以限速器实例在工作进程级别之间的共享是安全的只要限速值和burst的组合不变。<br>即便变了也没关系，只要去更新实例的那两个关键成员变量即可。</p>\n<p>幽灵计数器<br>在极端情况下，例如 nginx 工作进程在处理请求过程中崩溃，存储在共享内存区域中的计数器可能会不同步。这可能会导致灾难性的后果，例如永久地盲目拒绝所有传入连接。（请注意，标准ngx_limit_conn模块也存在此问题。）我们可能会在不久的将来为该 Lua 模块添加针对此类情况的自动保护功能。<br>此外，确保调用leaving首先出现在 log_by_lua<em>处理程序代码中非常重要，以尽量减少其他log_by_lua</em>Lua 代码抛出异常并阻止leaving调用运行的机会。<br>两种主要的失败场景：<br>Worker 进程崩溃（最严重的情况）<br>一个请求进入，incoming() 执行成功，计数器 +1。<br>在处理这个请求的过程中（比如执行 proxy_pass 或者一段复杂的 Lua 代码时），这个 Nginx Worker 进程因为某种原因（比如 C 模块的 bug、内存溢出等）突然崩溃退出了。<br>由于进程都没了，这个请求的 log_by_lua* 阶段自然也永远不会被执行。<br>后果：计数器被成功地 +1，但对应的 -1 操作 (leaving()) 却人间蒸发了。这个计数器在共享内存里就产生了一个无法减少的“幽灵计数”。<br>1、使用外部存储（架构级解决方案）<br>共享内存的根本问题在于它的状态会随着 Nginx 的生命周期而持续，且缺乏 TTL (Time-To-Live) 这种自动过期机制。代价是引入了网络开销和对外部 Redis 服务的依赖。<br>2、实现“清道夫”后台任务（修复）<br>这个方案用于解决最棘手的 Worker 进程崩溃问题。resty.limit.conn 本身没有提供自动修复机制，我们需要自己实现一个“巡检员”。<br>思路：利用 ngx.timer.at 创建一个只在某个 Worker 进程中运行的后台定时任务，定期检查共享内存中的数据，清理那些明显“死亡”的连接计数。<br>但这有个难题：我们怎么知道哪个计数是“幽灵”？一个长时间保持高位的计数器可能是真实的高并发，也可能是幽灵。<br>改进思路：引入“租约”或“心跳”机制。 我们不能只存一个数字，需要存更丰富的信息。<br>改造数据结构：在共享内存中，不直接存一个 count，而是存一个 table，里面记录了每个连接的唯一 ID 和进入时间。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- shm_dict:set(&quot;some_ip&quot;, &#123;</span></span><br><span class=\"line\"><span class=\"comment\">--    [&quot;reqid_1&quot;] = 1665000000, -- 请求ID和进入时的时间戳</span></span><br><span class=\"line\"><span class=\"comment\">--    [&quot;reqid_2&quot;] = 1665000001,</span></span><br><span class=\"line\"><span class=\"comment\">-- &#125;)</span></span><br></pre></td></tr></table></figure>\n<p>incoming() 的作用是向这个 table 里插入一个新的请求记录。leaving() 则是删除对应的记录。连接数就是 table 的大小。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 在 init_worker_by_lua* 阶段</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scavenger</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"comment\">-- 逻辑：遍历共享内存中的所有 key</span></span><br><span class=\"line\">    <span class=\"comment\">-- 检查每个 key 对应的 table</span></span><br><span class=\"line\">    <span class=\"comment\">-- 如果发现某个请求的时间戳已经非常老（比如超过了 5 分钟）</span></span><br><span class=\"line\">    <span class=\"comment\">-- 就认为它是一个因为崩溃而遗留的“幽灵连接”，将其从 table 中移除</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">-- 最后，设置下一次执行</span></span><br><span class=\"line\">    ngx.timer.at(<span class=\"number\">60</span>, scavenger) <span class=\"comment\">-- 每 60 秒执行一次</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ngx.worker.id() == <span class=\"number\">0</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"comment\">-- 只在 0 号 worker 中启动这个定时器</span></span><br><span class=\"line\">    ngx.timer.at(<span class=\"number\">60</span>, scavenger)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>不再需要一个独立的 count 变量。count 的值是动态地从这个 table 中派生出来的。count 就是这个 table 中键值对的数量。<br>我们为每个被监控的 key（比如一个 IP 地址）在共享内存中存储一个序列化后的 Lua table。这个 table 的键是唯一的请求 ID (ngx.var.request_id)，值是请求开始的时间戳。<br>为了线程安全必须使用 <strong>lua-resty-lock 锁</strong><br>通过序列化 + 外部锁的组合，我们既可以在共享内存中存储和操作任意复杂的表结构，又能完美地保证并发环境下的线程安全。而 count 则是通过实时计算 table 的大小得来，确保了数据的一致性。<br><strong>稍微有点重</strong></p>\n<p>只读检查。不会真的去修改共享内存。这是一种“预检”或“试探”模式，允许你在不消耗配额的情况下，提前知道请求是否会被允许。</p>\n<p>组合限速器<br>此模块可以考虑所有相关的限制器，而不会给当前请求带来任何额外的延迟。<br>ngx.ctx 是什么？是否是请求维度的上下文？支持多个限速器上下文吗？</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> lim3:is_committed() <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> ctx = ngx.ctx</span><br><span class=\"line\">    ctx.limit_conn = lim3</span><br><span class=\"line\">    ctx.limit_conn_key = keys[<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>这个方案虽然复杂，但非常稳健，可以有效地自动修复因崩溃导致的计数器不一致问题。<br>Nginx 的共享内存字典 (ngx.shared.DICT) 是一个基于红黑树实现的、高性能的 key-value 存储，不能存储嵌套表，所以要用 cjson。</p>\n<p>resty.limit.req类的实例返回当前每秒的<strong>超额请求数</strong>（如果超过速率阈值），而resty.limit.conn类的实例返回<strong>当前并发级别</strong>。</p>\n<p>所有具体的限制器对象必须遵循<strong>相同的粒度</strong>（通常是 NGINX 服务器实例级别，涵盖其所有工作进程）。</p>\n<hr>\n<p>多限速器系统采用了类2PC的原子性实现机制，通过<strong>预执行+提交的两阶段操作，配合回滚机制</strong>，确保多个限速器的状态更新具有原子性。这种设计在保证数据一致性的同时，避免了TCC模式的复杂业务逻辑，适合限速这种相对简单的场景。</p>\n<p>TCC的Try特征：<br>✅ 资源检查：检查是否超过burst限制<br>✅ 不实际提交：commit&#x3D;false时不写入共享内存<br>✅ 快速失败：任一限速器检查失败立即返回<br>TCC的Confirm特征：<br>✅ 实际提交：commit&#x3D;true写入共享内存<br>✅ 逐个确认：依次对每个限速器确认<br>TCC的Cancel特征：<br>✅ 补偿操作：uncommit减少excess值<br>✅ 业务回滚：恢复限速器状态</p>\n<p>现有TCC实现的不足：<br>Try阶段不够纯粹：最后一个限速器在Try阶段就提交了（i &#x3D;&#x3D; n时commit&#x3D;true）<br><strong>没有真正的资源预留：Try阶段只是计算，没有预留资源</strong><br>Cancel操作有限：只能简单减少excess，无法完全撤销复杂状态</p>\n<p>为什么说是TCC而不是2PC？<br>2PC特征（现有代码不符合）：<br>❌ 没有全局事务协调者的Prepare&#x2F;Commit投票机制<br>❌ 没有参与者的”准备好提交”确认过程<br>❌ 不是基于数据库事务的ACID特性<br>TCC特征（现有代码符合）：<br>✅ 业务层面的三阶段操作<br>✅ Try阶段的业务检查和资源预留概念<br>✅ Confirm阶段的业务确认<br>✅ Cancel阶段的业务补偿</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://mysql.taobao.org/monthly/2022/05/02/\">MySQL · 引擎特性 · InnoDB unique check 的问题</a></p>\n<p><a href=\"https://tengine.taobao.org/book/chapter_02.html#id1\">nginx平台初探</a></p>\n<p><a href=\"https://xie.infoq.cn/article/2ee961483c66a146709e7e861\">高性能 -Nginx 多进程高并发、低时延、高可靠机制</a></p>\n<p><a href=\"https://blog.openresty.com.cn/cn/dynamic-tracing/\">动态追踪技术漫谈</a></p>\n<p><a href=\"\"></a></p>\n"},{"title":"latexNote","url":"/2022/09/24/latexNote/","content":"<p><strong>LaTeX: 一个让你的文档看起来更专业的排版系统</strong></p>\n<span id=\"more\"></span>\n\n<h2 id=\"配置vscode-texlive-SumatraPDF环境\"><a href=\"#配置vscode-texlive-SumatraPDF环境\" class=\"headerlink\" title=\"配置vscode texlive SumatraPDF环境\"></a>配置vscode texlive SumatraPDF环境</h2><h3 id=\"关于-TeX-Live\"><a href=\"#关于-TeX-Live\" class=\"headerlink\" title=\"关于 TeX Live\"></a>关于 TeX Live</h3><p>所谓 TeX 发行，也叫 TeX 发行版、<strong>TeX 系统</strong>或者 TeX 套装，指的是包括 <strong>TeX 系统的各种可执行程序，以及他们执行时需要的一些辅助程序和宏包文档</strong> 的集合。</p>\n<p>TeX Live 是 TUG (TeX User Group) 维护和发布的 TeX 系统，可说是「官方」的 TeX 系统。我们推荐任何阶段的 TeX 用户，都尽可能使用 TeXLive，以保持在跨操作系统平台、跨用户的一致性。<br>Texlive 是 LaTex 的编译环境，提供了大量的脚本和宏包供我们使用，并且有很方便的宏包管理器可以下载更新宏包，十分方便。</p>\n<p>正向同步: 即从代码定位到编译出来的 pdf 文件相应位置<br>反向同步: 即从编译出的 pdf 文件指定位置跳转到 tex 文件中相应代码所在位置</p>\n<blockquote>\n<ul>\n<li>PDFTeX程序：Tex语言的一个实现，也就是把Tex语言转换为排版的一个程序。它会把TeX 语言写的代码直接编译成 PDF文件。</li>\n<li>PDFLaTeX命令：PDFTeX程序中的命令，用来编译用LaTeX格式写的tex文件。</li>\n<li>XeTeX程序：TeX语言的新的实现，即把Tex语言转换为排版的一个新程序。支持Unicode编码和直接访问操作系统字体。</li>\n<li>XeLaTeX命令：XeTeX程序中的命令，用来编译用LaTeX格式写的tex文件。<br>两者最大的区别是：XeLaTeX对应的XeTeX对字体的支持更好，允许用户使用操作系统字体来代替TeX的标准字体，而且对非拉丁字体的支持更好。</li>\n</ul>\n</blockquote>\n<h3 id=\"vscode-user-setting-json设置latex的代码\"><a href=\"#vscode-user-setting-json设置latex的代码\" class=\"headerlink\" title=\"vscode user setting.json设置latex的代码\"></a>vscode user setting.json设置latex的代码</h3><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;never&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.showContextMenu&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.intellisense.package.enabled&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.message.error.show&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.message.warning.show&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.latex.tools&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xelatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xelatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-synctex=1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-interaction=nonstopmode&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-file-line-error&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;%DOCFILE%&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;pdflatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;pdflatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-synctex=1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-interaction=nonstopmode&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-file-line-error&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;%DOCFILE%&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bibtex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bibtex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;%DOCFILE%&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.latex.recipes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xelatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;tools&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;xelatex&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;pdflatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;tools&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pdflatex&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xe-&gt;bib-&gt;xe-&gt;xe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;tools&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;xelatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;bibtex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;xelatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;xelatex&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;pdf-&gt;bib-&gt;pdf-&gt;pdf&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;tools&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pdflatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;bibtex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pdflatex&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pdflatex&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.aux&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.bbl&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.blg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.idx&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.ind&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.lof&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.lot&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.out&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.toc&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.acn&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.acr&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.alg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.glg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.glo&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.gls&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.ist&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.fls&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.log&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;*.fdb_latexmk&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;onFailed&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.latex.recipe.default&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lastUsed&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;double-click&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用 SumatraPDF 预览编译好的PDF文件</span></span><br><span class=\"line\"><span class=\"comment\">// 设置VScode内部查看生成的pdf文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;external&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"comment\">// PDF查看器用于在\\ref上的[View on PDF]链接</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.view.pdf.ref.viewer&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;auto&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"comment\">// 使用外部查看器时要执行的命令。此功能不受官方支持。</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.view.pdf.external.viewer.command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:/Users/ASUS/AppData/Local/SumatraPDF/SumatraPDF.exe&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 注意修改路径</span></span><br><span class=\"line\"><span class=\"comment\">// 使用外部查看器时，latex-workshop.view.pdf.external.view .command的参数。此功能不受官方支持。%PDF%是用于生成PDF文件的绝对路径的占位符。</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;%PDF%&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"comment\">// 将synctex转发到外部查看器时要执行的命令。此功能不受官方支持。</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:/Users/ASUS/AppData/Local/SumatraPDF/SumatraPDF.exe&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 注意修改路径</span></span><br><span class=\"line\"><span class=\"comment\">// latex-workshop.view.pdf.external.synctex的参数。当同步到外部查看器时。%LINE%是行号，%PDF%是生成PDF文件的绝对路径的占位符，%TEX%是触发syncTeX的扩展名为.tex的LaTeX文件路径。</span></span><br><span class=\"line\"><span class=\"attr\">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;-forward-search&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;%TEX%&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;%LINE%&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"comment\">//    &quot;-reuse-instance&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//    &quot;\\&quot;H:/Microsoft VS Code/Code.exe\\&quot; \\&quot;H:/Microsoft VS Code/resources/app/out/cli.js\\&quot; -r -g \\&quot;%f:%l\\&quot;&quot;, // 注意修改路径</span></span><br><span class=\"line\">    <span class=\"string\">&quot;%PDF%&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/434142338\">vscode SumatraPDF 设置反向搜索</a><br>打开SumatraPDF，进入设置-&gt;选项对话框，在“设置反向搜索命令行”处（即双击PDF文件时，应运行的命令）填入如下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;H:\\Microsoft VS Code\\Code.exe&quot;</span> <span class=\"string\">&quot;H:\\Microsoft VS Code\\resources\\app\\out\\cli.js&quot;</span>  --ms-enable-electron-run-<span class=\"keyword\">as</span>-node -r -g <span class=\"string\">&quot;%f:%l&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h3><blockquote>\n<p>Ctrl + Alt + B：编译（编译选项与上一次编译相同）<br>Ctrl + Alt + R：编译（可选编译链）<br>Ctrl + Alt + V：打开 PDF 预览<br>Ctrl + Alt + J：定位跳转到光标所在位置对应的 PDF 文件位置</p>\n</blockquote>\n<p><strong>参考文章</strong><br><a href=\"https://zhuanlan.zhihu.com/p/166523064\">Visual Studio Code (vscode)配置LaTeX</a><br><a href=\"https://zhuanlan.zhihu.com/p/38178015\">使用VSCode编写LaTeX</a><br><a href=\"https://blog.ceba.tech/2018/11/Visual-Studio-Code-LaTeX/index.html\">Visual Studio Code 折腾记：LaTeX 集成编辑环境</a></p>\n<h2 id=\"LaTex教程\"><a href=\"#LaTex教程\" class=\"headerlink\" title=\"LaTex教程\"></a>LaTex教程</h2><p><strong>控制序列</strong>是以反斜杠\\开头，以第一个空格或非字母 的字符结束的一串字符，他们并不被输出，但是他们会影响输出文档的效果。比如：<br><code>\\documentclass&#123;article&#125;</code>中的<code>documentclass</code>就是控制序列，它后面紧跟着的{article}代表这个控制序列的一个必要的参数，这个控制序列的作用，是调用名为 <strong>article</strong> 的<strong>文档类</strong>。</p>\n<blockquote>\n<p>部分控制序列还有被方括号 [ ] 包括的可选参数。<br>所谓文档类，即是 TeX 系统预设的（或是用户自定的）一些格式的集合。不同的文档类在输出效果上会有差别。</p>\n</blockquote>\n<p><code>\\begin&#123;document&#125;</code>中的控制序列是begin，<code>\\end&#123;document&#125;</code> 中的控制序列是end，二者总是成对出现。这两个控制序列以及他们中间的内容被称为<strong>环境</strong>；他们之后的第一个必要参数总是一致的，被称为环境名，比如这里的<code>document</code>。</p>\n<blockquote>\n<p>只有在 <code>document</code> 环境中的内容，才会被正常输出到文档中去或是作为控制序列对文档产生影响。因此，在<code>\\end&#123;document&#125;</code>之后插入任何内容都是无效的。</p>\n</blockquote>\n<p>\\begin{document}与\\documentclass{article}之间的部分被称为导言区。导言区中的控制序列，通常会影响到整个输出文档。比如<code>usepackage&#123;lipsum&#125;</code>中的控制序列是<code>usepackage</code>。你可以将导言区理解为是对整篇文档进行设置的区域——在导言区出现的控制序列，往往会影响整篇文档的格式。</p>\n<blockquote>\n<p>比如，我们通常在导言区设置页面大小、页眉页脚样式、章节标题样式等等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\documentclass&#123;article&#125;</span><br><span class=\"line\">% 这里是导言区</span><br><span class=\"line\">\\begin&#123;document&#125;</span><br><span class=\"line\">Hello, world!</span><br><span class=\"line\">\\end&#123;document&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"中英混排\"><a href=\"#中英混排\" class=\"headerlink\" title=\"中英混排\"></a>中英混排</h3><p>在现在，一切教你使用 CJK 宏包的模板、人、网页、书，都是糟糕的、有害的、恼人的、邪恶的和应该摒弃的。</p>\n<p>现在，XeTeX 原生支持 Unicode，并且可以方便地调用系统字体。可以说解决了困扰中国 TeX 使用者多年的大问题，实现了中文支持。<br>此外，除去中文支持，中文的版式处理和标点禁则也是不小的挑战。好在由吴凌云和江疆牵头，现在主要由刘海洋和李清维护的 <strong>ctex宏包 &#x2F; 文档类</strong>一次性解决了这些问题。<strong>ctex宏包和文档类</strong>的优势在于，它适用于多种编译方式；在内部处理好了中文和中文版式的支持，隐藏了这些细节；并且，提供了不少中文用户需要的功能接口。</p>\n<p><em><strong>CTeX 宏集</strong></em><br>虽然它的名字也是「CTeX」，但是 CTeX 宏集和 CTeX 套装是两个不同的东西(CTeX 宏集本质是 LaTeX 宏的集合，包含若干文档类（.cls 文件）和宏包（.sty 文件）。CTeX 套装是一个<strong>过时的 TeX 系统</strong>。不要安装和使用 CTeX 套装！)。CTeX 宏集是集成了中文支持、操作系统判定、字体选择、版式预设为一体的一组 <em><strong>宏包和文档类</strong></em> 的合集。我们推荐在任何情况下，优先使用 CTeX 宏集处理中文。</p>\n<p>所谓宏包，就是一系列控制序列的合集。这些控制序列太常用，以至于人们会觉得每次将他们写在导言区太过繁琐，于是将他们打包放在同一个文件中，成为所谓的宏包（台湾方面称之为「巨集套件」）。<code>\\usepackage&#123;&#125;</code> 可以用来调用宏包。</p>\n<p>新版 CTeX 宏集的默认能够自动检测用户的操作系统，并为之配置合适的字库。对于 Windows 用户、Mac OS X 用户和 Linux 用户，都无需做任何配置，就能使用 CTeX 宏集来排版中文。<br><strong>请在任何情况下优先使用 CTeX 宏集在 LaTeX 中处理中文！</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class=\"line\">\\begin&#123;document&#125;</span><br><span class=\"line\">你好，world!</span><br><span class=\"line\">\\end&#123;document&#125;</span><br></pre></td></tr></table></figure>\n<p>差异：</p>\n<ol>\n<li>文档类从 article 变为 ctexart；</li>\n<li>增加了文档类选项 UTF8， 将文档以 UTF-8 编码保存；</li>\n</ol>\n<p>你也可以直接使用 xeCJK 宏包来支持中英文混排，不过大多数情况是不推荐这样做的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\documentclass&#123;article&#125;</span><br><span class=\"line\">\\usepackage&#123;xeCJK&#125; %调用 xeCJK 宏包</span><br><span class=\"line\">\\setCJKmainfont&#123;SimSun&#125; % 定义在<span class=\"string\">&quot;xeCJK&quot;</span>宏包中的控制序列，设置CJK主字体为 SimSun （宋体）</span><br><span class=\"line\">\\begin&#123;document&#125;</span><br><span class=\"line\">你好，world!</span><br><span class=\"line\">\\end&#123;document&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"组织文章\"><a href=\"#组织文章\" class=\"headerlink\" title=\"组织文章\"></a>组织文章</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class=\"line\">% 导言区</span><br><span class=\"line\">\\title&#123;你好，world!&#125;</span><br><span class=\"line\">\\author&#123;Liam&#125;</span><br><span class=\"line\">\\date&#123;\\today&#125;</span><br><span class=\"line\">\\begin&#123;document&#125;</span><br><span class=\"line\">\\maketitle</span><br><span class=\"line\">\\section&#123;你好中国&#125;</span><br><span class=\"line\">中国在 East Asia.</span><br><span class=\"line\">\\subsection&#123;Hello Beijing&#125;</span><br><span class=\"line\">北京是 capital of China.</span><br><span class=\"line\">\\subsubsection&#123;Hello Dongcheng District&#125;</span><br><span class=\"line\">\\paragraph&#123;Tian<span class=\"number\">&#x27;</span>anmen Square&#125;</span><br><span class=\"line\">is in the center of Beijing</span><br><span class=\"line\">\\subparagraph&#123;Chairman Mao&#125;</span><br><span class=\"line\">is in the center of 天安门广场。</span><br><span class=\"line\">\\subsection&#123;Hello 北京&#125;</span><br><span class=\"line\">\\paragraph&#123;北京&#125; is an international city。</span><br><span class=\"line\">\\end&#123;document&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.postimg.cc/rsJSnsPW/1.jpg\" alt=\"对应的结果\"></p>\n<p><strong>出现的控制序列</strong></p>\n<blockquote>\n<ul>\n<li>导言区</li>\n<li>\\title{·}   % 定义标题</li>\n<li>\\author{·}  % 定义作者</li>\n<li>\\date{·}  % 定义日期</li>\n<li></li>\n<li>环境</li>\n<li>\\maketitle   % 这个控制序列能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。<br><strong>在文档类 article&#x2F;ctexart 中，定义了五个控制序列来调整行文组织结构。</strong></li>\n<li>\\section{·}</li>\n<li>\\subsection{·}</li>\n<li>\\subsubsection{·}</li>\n<li>\\paragraph{·}</li>\n<li>\\subparagraph{·}<br><strong>在report&#x2F;ctexrep中，还有\\chapter{·}；在文档类book&#x2F;ctexbook中，还定义了\\part{·}。</strong><br>LaTeX 使用 <code>\\section&#123; &#125;、\\subsection&#123; &#125; 和\\subsubsection&#123; &#125;</code> 命令来定义文档章节。\\section{ }命令和\\paragraph{ }命令，两个的功能相似，但是\\section{ }命令会自动编号，也会在目录中自动显示，而\\paragraph{ }命令则不会自动编号，也不会在目录中显示。并且\\paragraph{ }命令相对来说被使用的频率很少。</li>\n</ul>\n</blockquote>\n<h3 id=\"插入目录\"><a href=\"#插入目录\" class=\"headerlink\" title=\"插入目录\"></a>插入目录</h3><p>找到 \\maketitle，在它的下面插入控制序列 \\tableofcontents，保存并用 XeLaTeX 编译两次，观察效果：<br><img src=\"https://i.postimg.cc/q7t747Ny/1.jpg\" alt=\"插入目录\"><br>请注意，LaTeX 将一个换行当做是一个简单的空格来处理，如果输出文档需要换行另起一段，则需要用两个换行（一个空行）来实现。</p>\n<h3 id=\"查看当前操作系统的字体\"><a href=\"#查看当前操作系统的字体\" class=\"headerlink\" title=\"查看当前操作系统的字体\"></a>查看当前操作系统的字体</h3><p>用notepad++打开 C 盘根目录下的 C:\\font_zh-cn.txt（UTF-8编码下看到的才正常）。<br>文件中每行都是一个可用的字体。如：<br><code>C:/WINDOWS/fonts/simsun.ttc: SimSun,宋体:style=Regular,常规</code>，此处表明该字体有两个表示名：宋体和SimSun</p>\n<h2 id=\"写作技巧\"><a href=\"#写作技巧\" class=\"headerlink\" title=\"写作技巧\"></a>写作技巧</h2><h3 id=\"使用模板写作\"><a href=\"#使用模板写作\" class=\"headerlink\" title=\"使用模板写作\"></a>使用模板写作</h3><p><strong>建议在使用中自己整理几个自己常用的模板</strong>，从网上下载的模板只能提供一个大体的方向，有时也存在版本不同造成的兼容性问题，细节需要自己完善。</p>\n<ul>\n<li><a href=\"https://links.jianshu.com/go?to=http://www.latextemplates.com/\">LaTeXtemplates.com</a>网站是非常不错的模板分享网站，收集了包括书信，报告，论文，演示文稿，简历等等模板，整体收集模板质量很不错，非常推荐。</li>\n<li>在 <a href=\"https://github.com/MartinThoma/LaTeX-examples\">LaTeX-examples </a> 有作者收集的非常好的模板收集，也收集了大量的tikz等等例子，可下载，选择自己喜欢的模板使用。</li>\n<li>在 <a href=\"http://uk.tug.org/training/thesis/\">国外高校论文模板</a> 有不少收集好的国外高校论文模板。</li>\n<li><a href=\"https://www.overleaf.com/\">overleaf</a>也可以找到很多期刊的模板代码，还支持在线编辑，所见即所得。</li>\n</ul>\n<h3 id=\"文献引用\"><a href=\"#文献引用\" class=\"headerlink\" title=\"文献引用\"></a>文献引用</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\documentclass&#123;ctexart&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\\bibliographystyle&#123;plain&#125;   %引用的样式%</span><br><span class=\"line\">\\begin&#123;document&#125;</span><br><span class=\"line\">    这是一个参考文献引用：\\cite&#123;graves1989practical&#125; %大括号内为相应文献的引用标签</span><br><span class=\"line\">    \\bibliography&#123;text&#125;     %导入参考文献库文件%</span><br><span class=\"line\">\\end&#123;document&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要创建参考文献文件text.bib，获取参考文件信息可以自己手动整理，也可以在谷歌学术输入文献名，点击引用，并选择以BibTeX格式引用，如果出现 <code>403. That’s an error. Your client does not have permission to get URL /scholar.bib?</code>，可能是由于IP被谷歌拉入了黑名单。可以尝试换ip地址或者使用IPv6地址（一般被拉黑的是IPv4地址），我在代理中使用IPv6地址便可获得引用信息。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">@article&#123;ferrari2006raman,   %此处为引用标签。 这是注释，真正使用时不能写注释</span><br><span class=\"line\">  title=&#123;Raman spectrum of graphene and graphene layers&#125;,</span><br><span class=\"line\">  author=&#123;Ferrari, Andrea C and Meyer, JC and Scardaci, V and Casiraghi, C and Lazzeri, Michele and Mauri, Francesco and Piscanec, S and Jiang, Da and Novoselov, KS and Roth, S and others&#125;,</span><br><span class=\"line\">  journal=&#123;Physical review letters&#125;,</span><br><span class=\"line\">  volume=&#123;<span class=\"number\">97</span>&#125;,</span><br><span class=\"line\">  number=&#123;<span class=\"number\">18</span>&#125;,</span><br><span class=\"line\">  pages=&#123;<span class=\"number\">187401</span>&#125;,</span><br><span class=\"line\">  year=&#123;<span class=\"number\">2006</span>&#125;,</span><br><span class=\"line\">  publisher=&#123;APS&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数学公式\"><a href=\"#数学公式\" class=\"headerlink\" title=\"数学公式\"></a>数学公式</h3><p>为了使用 AMS-LaTeX 提供的数学功能，我们需要在导言区加载amsmath宏包：<br><code>\\usepackage&#123;amsmath&#125;</code><br>LaTeX 的数学模式有两种：行内模式 (inline) 和行间模式 (display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行并且居中。<br>在行文中，使用$ … $可以插入行内公式，使用\\[ … \\]可以插入行间公式，如果需要对行间公式进行编号，可以使用equation环境： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\begin&#123;equation&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">\\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>公式规范及上下标</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;$E=mc^<span class=\"number\">2</span>$.</span><br><span class=\"line\">&gt;\\[ E=mc^<span class=\"number\">2.</span> \\]</span><br><span class=\"line\">&gt;\\begin&#123;equation&#125;</span><br><span class=\"line\">&gt;E=mc^<span class=\"number\">2.</span></span><br><span class=\"line\">&gt;\\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>\n<p>这里提一下关于公式标点使用的规范。行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。<br>在数学模式中，需要表示上标，可以使用 ^ 来实现（下标则是 _）。它默认只作用于之后的一个字符，如果想对连续的几个字符起作用，请将这些字符用花括号 {} 括起来。</p>\n</blockquote>\n<blockquote>\n<p><strong>根号与分式</strong><br>根式用 \\sqrt{·} 来表示，分式用 \\frac{·}{·} 来表示（第一个参数为分子，第二个为分母）。<br>可以发现，在行间公式和行内公式中，分式的输出效果是有差异的。如果要强制行内模式的分式显示为行间模式的大小，可以使用 \\dfrac, 反之可以使用 \\tfrac。<br>在行内写分式，你可能会喜欢 xfrac 宏包提供的 \\sfrac 命令的效果。<br>排版繁分式，你应该使用 \\cfrac 命令。</p>\n</blockquote>\n<blockquote>\n<p><strong>运算符</strong><br>一些小的运算符，可以在数学模式下直接输入；另一些需要用控制序列生成，如:<br><code>\\[ \\pm \\times \\div \\cdot \\cap \\cup \\geq \\leq \\neq \\approx \\equiv \\]</code><br><img src=\"https://i.postimg.cc/3NPr9Wm3/QQ-20220930113402.jpg\" alt=\"运算符\"><br>连加、连乘、极限、积分等大型运算符分别用 \\sum, \\prod, \\lim, \\int 生成。他们的上下标在行内公式中被压缩，以适应行高。我们可以用 \\limits 和 \\nolimits 来强制显式地指定是否压缩这些上下标。<br>多重积分可以使用 \\iint, \\iiint, \\iiiint, \\idotsint 等命令输入。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;$ \\sum_&#123;i=<span class=\"number\">1</span>&#125;^n i\\quad \\prod_&#123;i=<span class=\"number\">1</span>&#125;^n $</span><br><span class=\"line\">&gt;$ \\sum\\limits _&#123;i=<span class=\"number\">1</span>&#125;^n i\\quad \\prod\\limits _&#123;i=<span class=\"number\">1</span>&#125;^n $</span><br><span class=\"line\">&gt;\\[ \\lim_&#123;x\\to0&#125;x^<span class=\"number\">2</span> \\quad \\int_a^b x^<span class=\"number\">2</span> dx \\]</span><br><span class=\"line\">&gt;\\[ \\lim\\nolimits _&#123;x\\to0&#125;x^<span class=\"number\">2</span>\\quad \\<span class=\"type\">int</span>\\nolimits_a^b x^<span class=\"number\">2</span> dx \\]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.postimg.cc/Y2sq3Dzb/2.jpg\" alt=\"运算符\"></p>\n</blockquote>\n<blockquote>\n<p><strong>定界符（括号等）</strong><br>各种括号用 (), [], {}, \\langle\\rangle 等命令表示；注意花括号通常用来输入命令和环境的参数，所以在数学公式中它们前面要加 \\。因为 LaTeX 中 | 和 | 的应用过于随意，amsmath 宏包推荐用 \\lvert\\rvert 和 \\lVert\\rVert 取而代之。<br>为了调整这些定界符的大小，amsmath 宏包推荐使用 \\big, \\Big, \\bigg, \\Bigg 等一系列命令放在上述括号前面调整大小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;\\[ () \\; [] \\; \\&#123;\\&#125; \\; \\langle\\rangle \\; \\lvert\\rvert \\; \\lVert\\rVert \\]</span><br><span class=\"line\">&gt;\\[ \\Biggl(\\biggl(\\Bigl(\\bigl((x)\\bigr)\\Bigr)\\biggr)\\Biggr) \\]</span><br><span class=\"line\">&gt;\\[ \\Biggl\\lVert\\biggl\\lVert\\Bigl\\lVert\\bigl\\lVert\\lVert x</span><br><span class=\"line\">&gt;\\rVert\\bigr\\rVert\\Bigr\\rVert\\biggr\\rVert\\Biggr\\rVert \\]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.postimg.cc/1XDVdMNj/3.jpg\" alt=\"定界符\"></p>\n</blockquote>\n<blockquote>\n<p><strong>省略号</strong><br>省略号用 \\dots, \\cdots, \\vdots, \\ddots 等命令表示。\\dots 和 \\cdots 的纵向位置不同，前者一般用于有下标的序列。<br><code>\\[ x_1,x_2,\\dots ,x_n\\quad 1,2,\\cdots ,n\\quad \\vdots\\quad \\ddots \\]</code><br><img src=\"https://i.postimg.cc/FFxT1x6Z/4.jpg\" alt=\"省略号\"></p>\n</blockquote>\n<blockquote>\n<p><strong>矩阵</strong><br>amsmath 的 pmatrix, bmatrix, Bmatrix, vmatrix, Vmatrix 等环境可以在矩阵两边加上各种分隔符。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;\\[ \\begin&#123;pmatrix&#125; a&amp;b\\\\c&amp;d \\end&#123;pmatrix&#125; \\quad</span><br><span class=\"line\">&gt;\\begin&#123;bmatrix&#125; a&amp;b\\\\c&amp;d \\end&#123;bmatrix&#125; \\quad</span><br><span class=\"line\">&gt;\\begin&#123;Bmatrix&#125; a&amp;b\\\\c&amp;d \\end&#123;Bmatrix&#125; \\quad</span><br><span class=\"line\">&gt;\\begin&#123;vmatrix&#125; a&amp;b\\\\c&amp;d \\end&#123;vmatrix&#125; \\quad</span><br><span class=\"line\">&gt;\\begin&#123;Vmatrix&#125; a&amp;b\\\\c&amp;d \\end&#123;Vmatrix&#125; \\]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44jpqbz2aj208k024744.jpg\"><br>使用 smallmatrix 环境，可以生成行内公式的小矩阵。<br><code>Marry has a little matrix $ ( \\begin&#123;smallmatrix&#125; a&amp;b\\\\c&amp;d \\end&#123;smallmatrix&#125; ) $.</code><br><img src=\"https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44jsd9ldbj20680200si.jpg\"></p>\n</blockquote>\n<blockquote>\n<p><strong>多行公式 公式组 分段函数</strong><br>需要对齐的公式，可以使用 aligned <strong>次环境</strong>来实现，它必须包含在数学环境之内。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;\\[ \\begin&#123;aligned&#125;</span><br><span class=\"line\">&gt;x =&amp; a+b+c+ \\\\</span><br><span class=\"line\">&gt;&amp;d+e+f+g</span><br><span class=\"line\">&gt;\\end&#123;aligned&#125; \\]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44k2acde4j205g02ft8h.jpg\"></p>\n<p>需要对齐的公式组可以使用 align 环境，没有包括在[ ]中间的话会带有编号。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;\\begin&#123;align&#125;</span><br><span class=\"line\">&gt;a &amp;= b+c+d \\\\</span><br><span class=\"line\">&gt;x &amp;= y+z</span><br><span class=\"line\">&gt;\\end&#123;align&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.postimg.cc/nLvHXMfm/1.jpg\"></p>\n<p>分段函数可以用cases次环境来实现，它必须包含在数学环境之内。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;\\[ y= \\begin&#123;cases&#125;</span><br><span class=\"line\">&gt;-x,\\quad x\\leq <span class=\"number\">0</span> \\\\</span><br><span class=\"line\">&gt;x,\\quad x&gt;<span class=\"number\">0</span></span><br><span class=\"line\">&gt;\\end&#123;cases&#125; \\]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44k7zto1wj205o01pt8i.jpg\"></p>\n</blockquote>\n<p>建议 LaTeX 用户应当尽可能避免使用辅助工具输入数学公式。但对于急用的初学者而言，适当地使用辅助工具（而不形成依赖）也是有一些收益的。</p>\n<ul>\n<li><p><a href=\"https://mathpix.com/\">https://mathpix.com/</a> 能够通过热键呼出截屏，而后将截屏中的公式转换成 LaTeX 数学公式的代码。</p>\n</li>\n<li><p><a href=\"https://www.codecogs.com/latex/eqneditor.php\">在线LaTeX公式编辑器</a>，非常方便直观。</p>\n</li>\n<li><p><a href=\"http://detexify.kirelabs.org/classify.html\">http://detexify.kirelabs.org/classify.html</a> 允许用户用鼠标在输入区<strong>绘制单个数学符号的样式</strong>，系统会根据样式返回对应的 LaTeX 代码（和所需的宏包）。这在<strong>查询</strong>不熟悉的数学符号时特别有用。</p>\n</li>\n</ul>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>tabular 环境提供了最简单的表格功能。它用 \\hline 命令表示横线，在列格式中用 | 表示竖线；用 &amp; 来分列，用 \\ 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 l、c、r 来表示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\begin&#123;tabular&#125;&#123;|l|c|r|&#125;</span><br><span class=\"line\"> \\hline</span><br><span class=\"line\">操作系统&amp; 发行版&amp; 编辑器\\\\</span><br><span class=\"line\"> \\hline</span><br><span class=\"line\">Windows &amp; MikTeX &amp; TexMakerX \\\\</span><br><span class=\"line\"> \\hline</span><br><span class=\"line\">Unix/Linux &amp; teTeX &amp; Kile \\\\</span><br><span class=\"line\"> \\hline</span><br><span class=\"line\">Mac OS &amp; MacTeX &amp; TeXShop \\\\</span><br><span class=\"line\"> \\hline</span><br><span class=\"line\">通用&amp; TeX Live &amp; TeXworks \\\\</span><br><span class=\"line\"> \\hline</span><br><span class=\"line\">\\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://liam.page/uploads/teaching/LaTeX/figures/818901c1jw1e44ku9n696j20cj05haad.jpg\" alt=\"效果\"><br>表格也有类似的工具：<a href=\"https://www.tablesgenerator.com/\">Creat LaTeX tables online</a></p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>关于 LaTeX 插图，首先要说的是：「LaTeX 只支持 .eps 格式的图档」这个说法是错误的。<br>在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用graphicx宏包提供的\\includegraphics命令。比如你在你的 TeX 源文件同目录下，有名为 a.jpg 的图片，你可以用这样的方式将它插入到输出文档中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\documentclass&#123;article&#125;</span><br><span class=\"line\">\\usepackage&#123;graphicx&#125;</span><br><span class=\"line\">\\begin&#123;document&#125;</span><br><span class=\"line\">\\includegraphics&#123;a.jpg&#125;</span><br><span class=\"line\">\\end&#123;document&#125;</span><br></pre></td></tr></table></figure>\n<p>图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用<code>\\includegraphics</code>控制序列的可选参数来控制。比如<br><code>\\includegraphics[width = .8\\textwidth]&#123;a.jpg&#125;</code><br>这样图片的宽度会被缩放至页面宽度的百分之八十，图片的总高度会按比例缩放。</p>\n<h3 id=\"浮动体\"><a href=\"#浮动体\" class=\"headerlink\" title=\"浮动体\"></a>浮动体</h3><p>插图和表格通常需要占据大块空间，所以在文字处理软件中我们经常需要调整他们的位置。figure 和 table 环境可以自动完成这样的任务；这种自动调整位置的环境称作浮动体(float)。我们以 figure 为例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class=\"line\">\\usepackage&#123;amsmath&#125;</span><br><span class=\"line\">\\usepackage&#123;graphicx&#125;</span><br><span class=\"line\">\\begin&#123;document&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\\begin&#123;figure&#125;[htbp]</span><br><span class=\"line\">    \\centering</span><br><span class=\"line\">    \\includegraphics[width = <span class=\"number\">.8</span>\\textwidth]&#123;a.jpg&#125;</span><br><span class=\"line\">    \\caption&#123;有图有真相&#125;</span><br><span class=\"line\">    \\label&#123;fig:myphoto&#125;</span><br><span class=\"line\">\\end&#123;figure&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\\end&#123;document&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.postimg.cc/rm1JhDDM/2.jpg\"><br>htbp 选项用来指定插图的理想位置，这几个字母分别代表 here, top, bottom, float page，也就是就这里、页顶、页尾、浮动页（专门放浮动体的单独页面或分栏）。\\centering 用来使插图居中；<strong>\\caption 命令设置插图标题</strong>，LaTeX 会自动给浮动体的标题加上编号。注意 \\label 应该放在标题命令之后。</p>\n<h3 id=\"幻灯片\"><a href=\"#幻灯片\" class=\"headerlink\" title=\"幻灯片\"></a>幻灯片</h3><p>LaTeX的确还可以制作精美的幻灯片pdf，不过具体使用方法与论文写作大同小异，网上也有很多漂亮的模板。</p>\n<h2 id=\"版面设置\"><a href=\"#版面设置\" class=\"headerlink\" title=\"版面设置\"></a>版面设置</h2><h3 id=\"页边距\"><a href=\"#页边距\" class=\"headerlink\" title=\"页边距\"></a>页边距</h3><p>设置页边距，推荐使用 <code>geometry</code> 宏包。<br>比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在<strong>导言区</strong>加上这样几行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\usepackage&#123;geometry&#125;</span><br><span class=\"line\">\\geometry&#123;papersize=&#123;<span class=\"number\">20</span>cm,<span class=\"number\">15</span>cm&#125;&#125;</span><br><span class=\"line\">\\geometry&#123;left=<span class=\"number\">1</span>cm,right=<span class=\"number\">2</span>cm,top=<span class=\"number\">3</span>cm,bottom=<span class=\"number\">4</span>cm&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"页眉页脚\"><a href=\"#页眉页脚\" class=\"headerlink\" title=\"页眉页脚\"></a>页眉页脚</h3><p>设置页眉页脚，推荐使用 fancyhdr 宏包。<br>比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在<strong>导言区</strong>加上如下几行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\usepackage&#123;fancyhdr&#125;</span><br><span class=\"line\">\\pagestyle&#123;fancy&#125;</span><br><span class=\"line\">\\lhead&#123;lichao zhang&#125;</span><br><span class=\"line\">\\chead&#123;\\today&#125;</span><br><span class=\"line\">\\rhead&#123;lczhang93@gmail.com&#125;</span><br><span class=\"line\">\\lfoot&#123;&#125;</span><br><span class=\"line\">\\cfoot&#123;\\thepage&#125;</span><br><span class=\"line\">\\rfoot&#123;&#125;</span><br><span class=\"line\">\\renewcommand&#123;\\headrulewidth&#125;&#123;<span class=\"number\">0.4</span>pt&#125;</span><br><span class=\"line\">\\renewcommand&#123;\\headwidth&#125;&#123;\\textwidth&#125;</span><br><span class=\"line\">\\renewcommand&#123;\\footrulewidth&#125;&#123;<span class=\"number\">0</span>pt&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首行缩进\"><a href=\"#首行缩进\" class=\"headerlink\" title=\"首行缩进\"></a>首行缩进</h3><p>CTeX 宏集已经处理好了首行缩进的问题（自然段前<strong>空两格汉字宽度</strong>）。<br>因此，使用 CTeX 宏集进行中西文混合排版时，我们不需要关注首行缩进的问题。</p>\n<h3 id=\"行间距\"><a href=\"#行间距\" class=\"headerlink\" title=\"行间距\"></a>行间距</h3><p>我们可以通过 setspace 宏包提供的命令来调整行间距。比如在<strong>导言区</strong>添加如下内容，可以将行距设置为字号的 1.5 倍(这不是设置 1.5 倍行距)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\usepackage&#123;setspace&#125;</span><br><span class=\"line\">\\onehalfspacing</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"段间距\"><a href=\"#段间距\" class=\"headerlink\" title=\"段间距\"></a>段间距</h3><p>我们可以通过修改长度 \\parskip 的值来调整段间距。例如在<strong>导言区</strong>添加以下内容<br><code>\\addtolength&#123;\\parskip&#125;&#123;.4em&#125;</code><br>则可以在原有的基础上，增加段间距 0.4em。如果需要减小段间距，只需将该数值改为负值即可。</p>\n<p><em><strong>日常写作可以用轻量级的Markdown，想要获得更为复杂和严谨的论文排版作品，上LaTeX，这样基本就能涵盖所有的写作场景，告别臃肿难用的word软件，让我们更专注于内容，享受其中。</strong></em></p>\n<p><strong>参考文章</strong><br><a href=\"https://www.jianshu.com/p/3e842d67ada2\">LaTeX零基础入门教程</a><br><a href=\"https://liam.page/2014/09/08/latex-introduction/\">一份其实很短的 LaTeX 入门文档</a></p>\n","categories":["Language"],"tags":["LaTeX"]},{"title":"pynqNote","url":"/2022/10/25/pynqNote/","content":"<p><strong>PYNQ is an open-source project from Xilinx® that makes it easier to use Xilinx platforms.<br>Using the Python language and libraries, designers can exploit the benefits of programmable logic and microprocessors to build more capable and exciting electronic systems.</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"启动-PYNQ\"><a href=\"#启动-PYNQ\" class=\"headerlink\" title=\"启动 PYNQ\"></a>启动 PYNQ</h1><ol>\n<li>在 MicroSD 卡中烧录 pynq 的镜像文件；<br> 在 <a href=\"http://www.pynq.io/board.html\">http://www.pynq.io/board.html</a> 下载镜像文件，用 WIN32 Disk Imager 将镜像刻录到 SD 卡中。</li>\n<li>设置电路板<br> 根据你的选择（板子供电方式，启动方式）来设置电路板，将跳线放置到相应的位置，连接 microUSB 电缆 和 以太网 电缆。板子上电一段时间后，正常情况下会看到这样的现象，DONE LED 应打开，随后 2 个蓝色 LED 和 4 个黄色用户 LED 闪烁。蓝色 LED 将闪烁一段时间，然后将关闭，而黄色 LED 将保持点亮状态，这表明该板已准备好使用。</li>\n<li>以太网连接<ul>\n<li>有联网的路由器：如果你的身边有路由器，则可以将 pynq 的以太网接口和路由器的LAN口相连，板子的IP地址将由DHCP服务器自动配置，pynq能从internet下载数据包。电脑浏览器地址栏中输入 <a href=\"http://pynq:9090/\">http://pynq:9090/</a> 将能够访问板载Linux上运行的 Jupyter Notebook Web服务器的主页。想要获得板子的IP地址以便和板子进行通信可以通过PuTTY串口通讯软件，也可以使用名为“Angry IP Scanner”的软件，可以从 <a href=\"https://angryip.org/download\">https://angryip.org/download</a> 获得。它通常会自动检你的网络配置并配置 IP 范围，只需要按开始按钮即可。例如我的主机在无线局域网中的IP地址为<code>192.168.31.29</code>，运行Angry IP Scanner如下：<br> <img src=\"https://i.postimg.cc/1t92ZjMm/5.jpg\"><br> <img src=\"https://i.postimg.cc/7Z0WJkWP/dfs.jpg\"><br> 于是我在地址栏中输入 pynq 的IP地址<code>192.168.31.166</code>，能看到和输入 <a href=\"http://pynq:9090/\">http://pynq:9090/</a> 一样的效果，输入密码 <code>xilinx</code> 就能进入jupyter的网页。</li>\n<li>无联网的路由器：你可以将 pynq 的以太网接口和 PC 的以太网接口相连，这种情况下，你需要设置 PC 的以太网静态 IP 地址，开发板的默认静态 IP 地址为 192.168.2.99，你需要将 PC 的 IP 地址配置在相同的网段内，这样二者就可以进行通信了，例如：IP地址配置为 192.168.2.1，子网掩码配置为 255.255.255.0。（打开网络与共享中心–&gt;更改适配器设置–&gt;选择以太网右击属性–&gt;选中Internet协议版本4–&gt;选中属性–&gt;选中‘使用下面的IP地址’选项–&gt;输入对应数），你可以使用命令<code>ping 192.168.2.99</code>查看是否连接成功。连接成功后在浏览器地址栏输入 <a href=\"http://192.168.2.99:9090/\">http://192.168.2.99:9090/</a> 就可以打开嵌入式Web服务器Jupyter Notebook的页面。这里 pynq 是无法从internet进行下载更新的，但是，如果你的电脑是通过 WIFI 连接互联网的，可以将网络共享给PYNQ-Z2板卡，可以参考<a href=\"https://blog.csdn.net/qq_43588553/article/details/113699594\">这篇文章</a>。</li>\n</ul>\n</li>\n<li>通过samba传输文件<br> 在开发过程中，如果需要在PC机与板卡之间传输一些较大的文件，可以通过PYNQ支持的samba协议将PYNQ的文件系统当作一个网络硬盘直接读取。在Windows中只需要打开资源管理器，输入<code>\\\\pynq\\xilinx</code>即可成功连接。<br> <img src=\"https://i.postimg.cc/MTHF3jdt/3.jpg\"><br> 其中文件夹<code>jupyter_notebooks</code>内容与 Jupyter Notebook 服务器主页显示的一致。</li>\n</ol>\n<h2 id=\"PYNQ-Z2-接口\"><a href=\"#PYNQ-Z2-接口\" class=\"headerlink\" title=\"PYNQ-Z2 接口\"></a>PYNQ-Z2 接口</h2><h2 id=\"关于-Jupyter-Notebook\"><a href=\"#关于-Jupyter-Notebook\" class=\"headerlink\" title=\"关于 Jupyter-Notebook\"></a>关于 Jupyter-Notebook</h2><p>从SD中启动实际上是运行了一个利用 ARM 处理器功能的操作系统 (Linux)，Jupyter-Notebook 是在 Linux 中运行的服务器。通过使用PC访问 Jupyter-Notebook 服务器连接到设备，现在可以在浏览器网页上编写代码，代码将在 FPGA Arm Cortex 处理器内部执行，所以基本上你可以在处理器上远程运行命令。</p>\n<h2 id=\"本节参考：\"><a href=\"#本节参考：\" class=\"headerlink\" title=\"本节参考：\"></a>本节参考：</h2><p><a href=\"https://blog.umer-farooq.com/a-pynq-z2-guide-for-absolute-dummies-part-i-fun-with-leds-and-switches-47dd76abf9a9\">Umer Farooq : A PYNQ-Z2 Guide for Absolute Dummies </a><br><a href=\"https://blog.csdn.net/qq_34341423/article/details/102507665\">csdn PYNQ-Z2快速上手</a><br><a href=\"https://www.youtube.com/watch?v=RiFbRf6gaK4&t=6s\">video </a></p>\n<h1 id=\"学习-PYNQ\"><a href=\"#学习-PYNQ\" class=\"headerlink\" title=\"学习 PYNQ\"></a>学习 PYNQ</h1><p><strong>写在前面：</strong> 最好的老师就是 <code>/home/xilinx/jupyter_notebooks</code> 里的<strong>官方例程</strong></p>\n<h2 id=\"什么是PYNQ\"><a href=\"#什么是PYNQ\" class=\"headerlink\" title=\"什么是PYNQ\"></a>什么是PYNQ</h2><p>PYNQ是Python On Zynq的缩写，它是一个软件开发框架，指导硬件层、驱动层和应用层之间的接口设计，不是ISE、Vivado、SDSoC这样的IDE工具，更不是Zynq芯片的下一代芯片产品。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk4J6DptOU7hJqfmFm%2FFramework.png?generation=1574912214909447&alt=media\"></p>\n<p>PYNQ框架的设计初衷是通过高层次的封装，将底层硬件FPGA实现细节与上层应用层的使用脱耦，<strong>对软件开发者来说，PYNQ框架已经提供了完整的访问FPGA资源的library，让上层应用开发者通过Python编程就可以调用FPGA模块</strong>，不需要懂Verilog&#x2F;VHDL硬件编程就可以享受FPGA可并行计算、接口可方便扩展和可灵活配置带来的诸多好处。</p>\n<p>在PYNQ框架下，ARM A9 CPU上运行的软件包括：</p>\n<ul>\n<li>载有Jupyter Notebooks设计环境的网络服务器</li>\n<li>IPython内核和程序包</li>\n<li>Linux</li>\n<li>FPGA的基本硬件库和API</li>\n</ul>\n<p><strong>PYNQ框架是为软件开发者提供了访问FPGA资源的python接口，Python开发者可以忽略这些实现细节</strong>，通过python即可轻松访问FPGA，动态加载各种预编译好的FPGA应用，像调用函数一样去调用各种通过FPGA加速的应用或者访问连接到FPFA的外设。让软件工程师能轻松享受FPGA并行计算和可灵活配置的诸多好处，并不是说用Python对FPGA进行编程来取代传统的RTL编程方式，注意区别。总而言之，PYNQ只是一个工具而已，一个让软件工程师不需要学习太多硬件知识就能发挥FPGA功能的工具。</p>\n<h2 id=\"Jupyter-Notebook必知必会\"><a href=\"#Jupyter-Notebook必知必会\" class=\"headerlink\" title=\"Jupyter Notebook必知必会\"></a>Jupyter Notebook必知必会</h2><p><strong>Jupyter是基于网页的用于交互计算的应用程序</strong>，可被应用于全过程计算：开发、文档编写、运行代码和展示结果。Jupyter可以很方便地部署在嵌入式Linux中，作为嵌入式Linux的Web IDE。</p>\n<p>Notebook主要由两部分组成，<strong>网页应用和文档部分</strong>。网页应用即基于网页形式的、结合了编写说明文档、数学公式、交互计算和其他富媒体形式的工具。简言之，网页应用是可以实现各种功能的工具。 至于文档，Notebook中所有交互计算、编写说明文档、数学公式、图片以及其他富媒体形式的输入和输出，都是以文档的形式体现的。这些文档是保存为后缀名为.ipynb的JSON格式文件，不仅便于版本控制，也方便与他人共享。此外，文档还可以导出为：HTML、LaTeX、PDF等格式。</p>\n<p>Notebook具有下列特点：</p>\n<ul>\n<li>编程时具有语法高亮、缩进、tab补全的功能。</li>\n<li>可直接通过浏览器运行代码，同时在代码块下方展示运行结果。</li>\n<li>以富媒体格式展示计算结果。富媒体格式包括：HTML，LaTeX，PNG，SVG等。</li>\n<li>对代码编写说明文档或语句时，支持Markdown语法。</li>\n<li>支持使用LaTeX编写数学性说明。</li>\n</ul>\n<p>具体关于 Jupyter Notebook 用户UI界面的介绍可以看<a href=\"https://pynqdocs.gitbook.io/pynq-tutorial/pynq-zhong-wen-zi-liao/03jupyter-notebook-bi-zhi-bi-hui\">这里</a>。</p>\n<p>base文件夹和logictools文件夹与具体的Overlay应用相关（Overlay的概念后面会介绍），common文件夹中的是与具体Overlay不绑定的较为通用的例子。对新手来说，getting_started文件夹提供了了解PYNQ必知必会的几个例子，建议先从这里入手。</p>\n<h2 id=\"PYNQ-Overlay介绍\"><a href=\"#PYNQ-Overlay介绍\" class=\"headerlink\" title=\"PYNQ Overlay介绍\"></a>PYNQ Overlay介绍</h2><p>Overlays，或者硬件库，都是可编程FPGA的设计理念。<br>通过它们，用户可以把Zynq处理系统（Processing System of the Zynq）上的应用扩展到可编程逻辑层面上。Overlays可以用来加速软件应用或者为特定的应用自定义其硬件平台。</p>\n<p>PYNQ提供了一个Python交互界面，允许我们通过处理系统上的Python来控制可编程逻辑里的overlays。FPGA设计是一个非常专业化的任务，这需要专业的硬件工程知识。PYNQ的overlays就是由硬件设计师创建，并且包装成了PYNQ PYTHON API。软件开发者就可以无需重新自己设计overlay，而是直接使用这些写好的overlay来操作特定的硬件模块。这其实和专业软件工程师设计软件库并把它们包装成用户可用的API的道理一样。</p>\n<p>一般来讲，我们把那些比较基层的、更像是用来<strong>做参考设计</strong>的overlay称为<strong>base overlay</strong>。它们是已经烧写在SD卡上的。当然了，我们也可以自己安装新的Overlay并在运行中使用他们。</p>\n<p>每一个Overlay都会有其对应的.bit文件，比如base_overlay对应的就是base.bit。我们可以用下面的方法加载Overlay。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pynq <span class=\"keyword\">import</span> overlay</span><br><span class=\"line\">overlay = Overlay(<span class=\"string\">&quot;base.bit&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>对于我们提到的已有的base overlay，PYNQ很贴心的为我们准备了专门的类，方便我们使用它们。调用代码如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pynq.overlays.base <span class=\"keyword\">import</span> BaseOverlay</span><br><span class=\"line\">base_overlay = BaseOverlay(<span class=\"string\">&quot;base.bit&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>base_overlay</strong>就是把bit文件转化后的python类。</p>\n<p>对于一个python类，我们自然可以使用辅助函数help来查看这个类的具体介绍</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">help</span>(base_overlay)</span><br></pre></td></tr></table></figure>\n<p>部分介绍如下：</p>\n<h2 id=\"BaseOverlay介绍\"><a href=\"#BaseOverlay介绍\" class=\"headerlink\" title=\"BaseOverlay介绍\"></a>BaseOverlay介绍</h2><ul>\n<li>PYNQ-Z2上的base overlay所涉及的硬件如下：</li>\n<li>HDMI接口（输入输出）</li>\n<li>Audio codec</li>\n<li>4个绿色LED，2个彩色LED，两个开关，四个按钮</li>\n<li>两个Pmod PYNQ Microblaze</li>\n<li>Arduino PYNQ Microblaze</li>\n<li>RPI (Raspberry Pi) PYNQ MicroBlaze</li>\n<li>4个跟踪分析器（PMODA,  PMODB, ARDUINO, RASPBERRYPI）</li>\n</ul>\n<h3 id=\"HDMI\"><a href=\"#HDMI\" class=\"headerlink\" title=\"HDMI\"></a>HDMI</h3><p>PYNQ-Z2板上的 HDMI接口 是直接连接到可编程逻辑引脚上的。也就是说在板上没有外用的HDMI电路，HDMI接口是由 HDMI IP 控制生成的。</p>\n<p>HDMI IP是链接到处理系统DRAM上的，视频可以以<strong>流</strong>的方式从HDMI输入端进入内存，然后再从HDMI输出端流出。这就允许我们通过python来处理视频数据，或者干脆通过python写一段视频流然后再由HDMI输出。</p>\n<p>虽然Jupyter notebook支持内嵌的video形式，但是我们从HDMI捕捉到的视频数据会是原生的，如果不进行适当的编码处理，将无法在notebook上直接播放。</p>\n<p><strong>HDMI IN</strong>：HDMI输入端IP可以捕捉标准的HDMI分辨率。在HDMI资源被连接后，HDMI控制器就会启动，并自动检测输入的数据。分辨率情况可以从Python 的HDMI类里读取，图像数据也可以流入处理系统DRAM。</p>\n<p><strong>HDMI OUT</strong>：数据可以从处理系统DRAM流到HDMI输出端。HDMI输出控制器能通过帧缓冲器来达到视频数据的流畅播放。<br>HDMI输出端IP支持以下分辨率：</p>\n<ul>\n<li>640x480</li>\n<li>800x600</li>\n<li>1280x720 (720p)</li>\n<li>1280x1024</li>\n<li>1920x1080 (1080p)</li>\n</ul>\n<p><em><strong>HDMI实例：</strong></em><br>源码在板上的getting_started文件夹下base_overlay_video里。<br>首先，我们得准备一个满足上述条件的输出显示屏，两根HDMI-HDMI线。将HDMI IN端与电脑相连，再将HDMI OUT端与准备的显示屏相连。打开我们的Jupyter Notebook。</p>\n<p>可以结合<a href=\"http://pynq:9090/notebooks/getting_started/5_base_overlay_video.ipynb\">源码</a>和<a href=\"https://pynqdocs.gitbook.io/pynq-tutorial/pynq-zhong-wen-zi-liao/05baseoverlay-jie-shao#hdmi-out\">教程</a>来学习使用 HDMI。</p>\n<h3 id=\"IOP-Pmod\"><a href=\"#IOP-Pmod\" class=\"headerlink\" title=\"IOP-Pmod\"></a>IOP-Pmod</h3><p>Pmod包是一个使用Pmod端口的外部设备的驱动集合。一个Pmod端口是一个12引脚接口，传统的Pmod外接设备包括了各式传感器（光、温度）、交互设备（网口、WIFI、蓝牙）以及输入输出设备（按钮、开关、LED）。<br><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45oYcmYScZaIkqVF%2F16.png?generation=1574912160835169&alt=media\"><br>每一个Pmod连接器是由2排6引脚共计12引脚构成的。每一排由3.3V(VCC),接地(GND)以及4个数据引脚构成。如果使用两排的话那就是8个数据引脚。<br><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45o_00CI6NFq0CO8%2F17.png?generation=1574912160926567&alt=media\"></p>\n<p>所有的引脚都在3.3V时正常工作。根据不同设备的不同pull-up&#x2F;pull-down I&#x2F;O要求，Pmod数据引脚会有不同的IO标准。（例如IIC需要pull-up，SPI需要pull-down）</p>\n<p>引脚0,1和4,5是连接到pull-down电阻器。这个可以支持SPI接口以及大部分外接设备。引脚2,3和6,7是连接到pull-up电阻器。这个可以支持IIC接口。</p>\n<p><em><strong>略~~</strong></em></p>\n<h2 id=\"Logictools-Overlay\"><a href=\"#Logictools-Overlay\" class=\"headerlink\" title=\"Logictools Overlay\"></a>Logictools Overlay</h2><p>Logictools overlay 包含了可编程逻辑硬件区块来与外部数字逻辑电路连接。Python可以做出有限状态机（Finite State Machine）、布尔型逻辑函数和数字模式。一个可编程 switch 连接了硬件区和外部IO引脚之间的输入和输出。Logictools overlay也可以通过追踪分析器（trace analyzer）来捕捉IO接口传来的数据，方便我们分析调试。<br><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45k0Rmf1MxjzmVqs%2F01.png?generation=1574912184317900&alt=media\"><br>Logictools IP包含了4个主要硬件区块</p>\n<ul>\n<li>布尔型生成器</li>\n<li>跟踪分析器</li>\n<li>模式生成器</li>\n<li>FSM生成器（有限状态机生成器）</li>\n</ul>\n<p>每一个区块不需要汇编配置文件，这意味着一个配置可以直接加载到生成器里并立即执行。</p>\n<p>PYNQ-Z2 logictools overlay有两个logictools逻辑控制处理器（LCP），一个与Arduino header连接，一个与RPI header连接。<br>Arduino header有20个引脚，RPI有26个引脚，他们可以用作为LCP的GPIO。</p>\n<p>板上的4个LED和4个按钮可以连接到任意一个LCP上，使得扩展输入成为了可能。注意！LED和按钮是共享的，在一个时刻只能被一个LCP使用。<br><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45k2w-Kfk__l6Lk7%2F02.png?generation=1574912184236329&alt=media\"></p>\n<p><strong>以下三个例程都在</strong> <a href=\"http://pynq:9090/tree/logictools\">&#x2F;home&#x2F;xilinx&#x2F;jupyter_notebooks&#x2F;logictools</a></p>\n<h3 id=\"布尔型生成器\"><a href=\"#布尔型生成器\" class=\"headerlink\" title=\"布尔型生成器\"></a>布尔型生成器</h3><p>与BaseOverlay不一样，我们要用LogicToolsOverlay来导入对应的logictools.bit。所谓布尔型生成器，就是用与、或、异或、非来构成最终的布尔型输出。LD是板上的LED，PB是板上的按钮，进行布尔运算之后将结果1&#x2F;0赋值给LD进行输出。从bit文件转换出的logictools_olay类里，我们可以找到布尔型生成器（来自 pynq.lib.logictools 的 boolean_generator），用其初始化一个布尔型生成器出来，并用对应的表达式（存储在列表或字典中）配置该生成器，随后用run来运行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pynq.overlays.logictools <span class=\"keyword\">import</span> LogicToolsOverlay</span><br><span class=\"line\"><span class=\"keyword\">from</span> pynq.lib.logictools <span class=\"keyword\">import</span> BooleanGenerator</span><br><span class=\"line\"></span><br><span class=\"line\">logictools_olay = LogicToolsOverlay(<span class=\"string\">&#x27;logictools.bit&#x27;</span>)</span><br><span class=\"line\">boolean_generator = logictools_olay.boolean_generator</span><br><span class=\"line\"></span><br><span class=\"line\">function = &#123;<span class=\"string\">&#x27;XOR_gate&#x27;</span>:<span class=\"string\">&#x27;LD2 = PB3^PB0&#x27;</span>, <span class=\"string\">&#x27;AND&#x27;</span>:<span class=\"string\">&#x27;LD1 = PB1&amp;PB0&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">boolean_generator.setup(function)</span><br><span class=\"line\">boolean_generator.run()</span><br><span class=\"line\"></span><br><span class=\"line\">boolean_generator.stop() <span class=\"comment\">#调用stop函数即可停止生成器运作。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模式生成器\"><a href=\"#模式生成器\" class=\"headerlink\" title=\"模式生成器\"></a>模式生成器</h2><p>这里我们用python代码来模拟电路，并用追踪生成器捕捉到的波形来验证我们的结果，展示如何操作模式生成器的单步运行模式。</p>\n<p>首先，我们导入logictools overlay，并通过代码形式模拟波形。波形的构造满足一定格式。用{‘signal’:[]}来表明输入的信号波形。在[]内，我们逐一添加波形信息。格式为：{‘name’:’’, ’pin’:’’, ‘wave’:’lh.’}其中l代表low波，h表示high波，‘.’表示重复前面波形。</p>\n<p>接下来，我们按照上图代码为我们的模拟内容增加一点东西。外层的{‘signal’:[]}框架不变，在[]里，我们将之前的4个模拟波形信号用列表的方式打包，并命名为‘stimulus’（列表的第一个元素为名称），以同样的格式增加一栏‘analysis’。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pynq.overlays.logictools <span class=\"keyword\">import</span> LogicToolsOverlay</span><br><span class=\"line\"><span class=\"keyword\">from</span> pynq.lib.logictools <span class=\"keyword\">import</span> Waveform</span><br><span class=\"line\"></span><br><span class=\"line\">logictools_olay = LogicToolsOverlay(<span class=\"string\">&#x27;logictools.bit&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">up_counter = &#123;<span class=\"string\">&#x27;signal&#x27;</span> : [</span><br><span class=\"line\">    [<span class=\"string\">&#x27;stimulus&#x27;</span>,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit0&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D0&#x27;</span>,<span class=\"string\">&#x27;wave&#x27;</span>:<span class=\"string\">&#x27;lh&#x27;</span>*<span class=\"number\">8</span> &#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit1&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D1&#x27;</span>,<span class=\"string\">&#x27;wave&#x27;</span>:<span class=\"string\">&#x27;lh.&#x27;</span>*<span class=\"number\">4</span> &#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit2&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D2&#x27;</span>,<span class=\"string\">&#x27;wave&#x27;</span>:<span class=\"string\">&#x27;l...h...&#x27;</span>*<span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit3&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D3&#x27;</span>,<span class=\"string\">&#x27;wave&#x27;</span>:<span class=\"string\">&#x27;l.......h.......&#x27;</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;analysis&#x27;</span>,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit0_output&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D0&#x27;</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit1_output&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D1&#x27;</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit2_output&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D2&#x27;</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;bit3_output&#x27;</span>,<span class=\"string\">&#x27;pin&#x27;</span>:<span class=\"string\">&#x27;D3&#x27;</span>&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#显示激励和跟踪信号的波形</span></span><br><span class=\"line\">waveform = Waveform(up_counter)</span><br><span class=\"line\">waveform.display() <span class=\"comment\">#Waveform函数只是一个把代码转换成模拟波形并输出的函数而已，不具备追踪功能。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置模式生成器</span></span><br><span class=\"line\">pattern_generator = logictools_olay.pattern_generator</span><br><span class=\"line\">pattern_generator.trace(num_analyzer_samples = <span class=\"number\">16</span>)</span><br><span class=\"line\">pattern_generator.setup(up_counter, </span><br><span class=\"line\">                        stimulus_group_name = <span class=\"string\">&#x27;stimulus&#x27;</span>, </span><br><span class=\"line\">                        analysis_group_name = <span class=\"string\">&#x27;analysis&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pattern_generator.step()                        </span><br><span class=\"line\">pattern_generator.show_waveform()                        </span><br></pre></td></tr></table></figure>\n<p>按照上面代码，我们生成一个模式生成器，其创建方式与布尔型生成器一模一样。在配置setup的时候，我们传入之前我们自己写的波形数据，并把模拟信号和分析内容指示给他。随后，我们调用模式生成器的step函数，即可跟踪模拟信号。重复运行step函数，我们可以看到，analysis栏波形按照上面stimulus栏的波形进行输出。</p>\n<h2 id=\"FSM生成器\"><a href=\"#FSM生成器\" class=\"headerlink\" title=\"FSM生成器\"></a>FSM生成器</h2><p>用FSM生成器来生成一个FSM（有限状态机）。这个例子中，我们做出来的FSM是一个格雷码计数器，它有三个状态位并可以通过8个状态来计数。计数器的输出是用格雷码编写的，这意味状态之间的转换只有一个2进制位会被改动（这是格雷码的特性）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pynq.overlays.logictools <span class=\"keyword\">import</span> LogicToolsOverlay</span><br><span class=\"line\"></span><br><span class=\"line\">logictools_olay = LogicToolsOverlay(<span class=\"string\">&#x27;logictools.bit&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fsm_spec = &#123;<span class=\"string\">&#x27;inputs&#x27;</span>: [(<span class=\"string\">&#x27;reset&#x27;</span>,<span class=\"string\">&#x27;D0&#x27;</span>), (<span class=\"string\">&#x27;direction&#x27;</span>,<span class=\"string\">&#x27;D1&#x27;</span>)],</span><br><span class=\"line\">            <span class=\"string\">&#x27;outputs&#x27;</span>: [(<span class=\"string\">&#x27;bit2&#x27;</span>,<span class=\"string\">&#x27;D3&#x27;</span>), (<span class=\"string\">&#x27;bit1&#x27;</span>,<span class=\"string\">&#x27;D4&#x27;</span>), (<span class=\"string\">&#x27;bit0&#x27;</span>,<span class=\"string\">&#x27;D5&#x27;</span>)],</span><br><span class=\"line\">            <span class=\"string\">&#x27;states&#x27;</span>: [<span class=\"string\">&#x27;S0&#x27;</span>, <span class=\"string\">&#x27;S1&#x27;</span>, <span class=\"string\">&#x27;S2&#x27;</span>, <span class=\"string\">&#x27;S3&#x27;</span>, <span class=\"string\">&#x27;S4&#x27;</span>, <span class=\"string\">&#x27;S5&#x27;</span>, <span class=\"string\">&#x27;S6&#x27;</span>, <span class=\"string\">&#x27;S7&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;transitions&#x27;</span>: [[<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S0&#x27;</span>, <span class=\"string\">&#x27;S1&#x27;</span>, <span class=\"string\">&#x27;000&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S0&#x27;</span>, <span class=\"string\">&#x27;S7&#x27;</span>, <span class=\"string\">&#x27;000&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S1&#x27;</span>, <span class=\"string\">&#x27;S2&#x27;</span>, <span class=\"string\">&#x27;001&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S1&#x27;</span>, <span class=\"string\">&#x27;S0&#x27;</span>, <span class=\"string\">&#x27;001&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S2&#x27;</span>, <span class=\"string\">&#x27;S3&#x27;</span>, <span class=\"string\">&#x27;011&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S2&#x27;</span>, <span class=\"string\">&#x27;S1&#x27;</span>, <span class=\"string\">&#x27;011&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S3&#x27;</span>, <span class=\"string\">&#x27;S4&#x27;</span>, <span class=\"string\">&#x27;010&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S3&#x27;</span>, <span class=\"string\">&#x27;S2&#x27;</span>, <span class=\"string\">&#x27;010&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S4&#x27;</span>, <span class=\"string\">&#x27;S5&#x27;</span>, <span class=\"string\">&#x27;110&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S4&#x27;</span>, <span class=\"string\">&#x27;S3&#x27;</span>, <span class=\"string\">&#x27;110&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S5&#x27;</span>, <span class=\"string\">&#x27;S6&#x27;</span>, <span class=\"string\">&#x27;111&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S5&#x27;</span>, <span class=\"string\">&#x27;S4&#x27;</span>, <span class=\"string\">&#x27;111&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S6&#x27;</span>, <span class=\"string\">&#x27;S7&#x27;</span>, <span class=\"string\">&#x27;101&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S6&#x27;</span>, <span class=\"string\">&#x27;S5&#x27;</span>, <span class=\"string\">&#x27;101&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;01&#x27;</span>, <span class=\"string\">&#x27;S7&#x27;</span>, <span class=\"string\">&#x27;S0&#x27;</span>, <span class=\"string\">&#x27;100&#x27;</span>],</span><br><span class=\"line\">                            [<span class=\"string\">&#x27;00&#x27;</span>, <span class=\"string\">&#x27;S7&#x27;</span>, <span class=\"string\">&#x27;S6&#x27;</span>, <span class=\"string\">&#x27;100&#x27;</span>],                            </span><br><span class=\"line\">                            [<span class=\"string\">&#x27;1-&#x27;</span>, <span class=\"string\">&#x27;*&#x27;</span>,  <span class=\"string\">&#x27;S0&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>]]&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成实例</span></span><br><span class=\"line\">fsm_generator = logictools_olay.fsm_generator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># The FSM generator will work at the default frequency of 10MHz. This can be modified using a frequency argument in the setup() method.</span></span><br><span class=\"line\">fsm_generator.setup(fsm_spec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示状态转移图</span></span><br><span class=\"line\">fsm_generator.show_state_diagram()</span><br><span class=\"line\"></span><br><span class=\"line\">fsm_generator.run()</span><br><span class=\"line\">fsm_generator.show_waveform()</span><br><span class=\"line\"></span><br><span class=\"line\">fsm_generator.stop()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PYNQ-Library详解-PS与PL接口\"><a href=\"#PYNQ-Library详解-PS与PL接口\" class=\"headerlink\" title=\"PYNQ Library详解 - PS与PL接口\"></a>PYNQ Library详解 - PS与PL接口</h2><p>USB端口和其他的标准接口可以连接现成的USB和其他外部设备到Zynq PS上，并可以通过Python&#x2F;Linux进行操控。<br>PYNQ提供overlay的一些底层控制，包括内存映射IO读写，内存分配等。</p>\n<h3 id=\"interrupt-中断\"><a href=\"#interrupt-中断\" class=\"headerlink\" title=\"interrupt 中断\"></a>interrupt 中断</h3><p><strong>Interrupt类</strong>代表了Vivado Block Design中的单一中断引脚。它通过使用一个wait函数去阻塞程序直到一个中断被抛出来模仿一个Python事件。</p>\n<p>中断只有在一个线程或者协程在等待对应事件的时候才能使用，推荐使用方法为在一个循环里进行等待（wait）操作，检查并清除IP里的中断注册器，然后再结束等待。比如说，AxiGPIO类就用这个方法等待所需要的值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AxiGPIO</span>(<span class=\"title class_ inherited__\">DefaultIP</span>):</span><br><span class=\"line\">    <span class=\"comment\"># Rest of class definition</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wait_for_level</span>(<span class=\"params\">self, value</span>):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.read() != value:</span><br><span class=\"line\">            self._interrupt.wait()</span><br><span class=\"line\">            <span class=\"comment\"># Clear interrupt</span></span><br><span class=\"line\">            self._mmio.write(IP_ISR, <span class=\"number\">0x1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MMIO\"><a href=\"#MMIO\" class=\"headerlink\" title=\"MMIO\"></a>MMIO</h3><p><strong>MMIO类</strong>允许Python对象获取<strong>映射的系统内存地址</strong>。特别的，在PL里的外部设备的注册与地址空间都是可以访问的。</p>\n<p>在一个overlay里，连接到 <strong>AXI通用端口（GP）</strong> 的外设将会把他们的注册器或地址空间映射到系统内存里。通过PYNQ，一个IP的注册器或者地址空间就可以通过MMIO类从Python获取。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45jVUe_Ugw9vd5Jg%2F53.png?generation=1574912159895092&alt=media\"></p>\n<p>MMIO提供了一个简单但方便的方法来访问控制外设。对于只有少量数据交互或者性能要求不高的外设，MMIO通常都是够用了的。如果对性能要求很高，或者大量数据要在PS和PL间传输，那么使用<strong>带有DMA IP和PYNQ DMA类的Zynq HP接口</strong>会更合适。</p>\n<h3 id=\"PS-GPIO\"><a href=\"#PS-GPIO\" class=\"headerlink\" title=\"PS GPIO\"></a>PS GPIO</h3><p>Zynq设备有最多从PS到PL的64个GPIO。它们可以用来做简单的操控。比如base overlay中通过PS GPIO来对IOP进行复位&#x2F;重置。PS GPIO是一个非常简单的接口，并不需要PL中的IP就可以使用。<br><strong>GPIO类</strong>就是用来控制PS GPIO的。(注意: AXI GPIO是由AxiGPIO类控制的)</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45jXG0ULRUQ7jW4o%2F54.png?generation=1574912159738464&alt=media\"></p>\n<p> PS GPIO使用Linux核来控制GPIO。这意味着操作系统会在运行时给GPIO分配一个标号。在使用PS GPIO之前，我们必须把Linux引脚标号映射到Python GPIO实例上。</p>\n<p>Get_gpio_pin()函数就是用来映射PS引脚标号到Linux引脚标号上的。</p>\n<p><strong>Linux引脚标号?</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pynq <span class=\"keyword\">import</span> GPIO</span><br><span class=\"line\"></span><br><span class=\"line\">output = GPIO(GPIO.get_gpio_pin(<span class=\"number\">0</span>), <span class=\"string\">&#x27;out&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span> = GPIO(GPIO.get_gpio_pin(<span class=\"number\">1</span>), <span class=\"string\">&#x27;in&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">output.write(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span>.read()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Xlnk\"><a href=\"#Xlnk\" class=\"headerlink\" title=\"Xlnk\"></a>Xlnk</h3><p><strong>Xlnk类</strong>用来分配连续内存。</p>\n<p>连接到<strong>AXI Master（HP或ACP端口）的IP</strong>能访问PS DRAM。</p>\n<p>连接到AXI Master（HP或ACP端口）的IP能访问PS DRAM。在PL里的IP访问DRAM前，必须给IP分配内存。Python里的一个数组将会被分配到虚拟内存的某个地方。被分配的物理内存地址必须提供给PL里的IP。</p>\n<p>Xlnk可以分配内存，并提供物理指针。它可以分配连续地址，PL IP可以用的更有效。通过Numpy包，Xlnk可以分配数组，这允许专门制定数组的数据类型。Xlnk也被DMA隐式使用来分配内存。</p>\n<h2 id=\"PYNQ-Library详解-IP访问\"><a href=\"#PYNQ-Library详解-IP访问\" class=\"headerlink\" title=\"PYNQ Library详解 - IP访问\"></a>PYNQ Library详解 - IP访问</h2><p>Vivado工具为各种接口标准和协议的外设提供了IP，PYNQ给常用的外接设备- Video（HDMI IN&#x2F;OUT）、 GPIO设备（Buttons, Switches, LEDs）、传感器和执行器等提供了Python API。这些PYNQ API也可以被扩展用以支持其他的IP。</p>\n<h3 id=\"Audio\"><a href=\"#Audio\" class=\"headerlink\" title=\"Audio\"></a>Audio</h3><p>Audio模块提供了从输入麦克风读取音频、从播放器播放音频以及读写音频文件的方法。Audio模块是连接到Audio IP子系统上来捕获播放内容。该模块可以支持不同的IP子系统。目前支持的有line-in, PYNQ-Z2上使用ADAU1761编码的HP&#x2F;Mic。</p>\n<p>实例在 <code>&lt;Jupyter Home&gt;/base/audio/audio_playback.ipynb</code> 。<br><em>It uses the audio jack HP+MIC to play back recordings; it can take inputs from the microphone on HP+MIC or LINE_IN. Pre-recorded audio sample can also be taken as input. Moreover, visualization with matplotlib is shown.</em></p>\n<h3 id=\"AxiGPIO\"><a href=\"#AxiGPIO\" class=\"headerlink\" title=\"AxiGPIO\"></a>AxiGPIO</h3><p>AxiGPIO类提供了读写通用设备如LED、按钮、开关等（需要通过AXI GPIO控制IP连接到PL上）并接受来自外部的中断。<br>每一个AXIGPIO能有至多两个通道，每一个通道至多有32个引脚。<br><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk4C5en0SfvtAreqaR%2F01.png?generation=1574912187256632&alt=media\"></p>\n<h3 id=\"AxiIIC\"><a href=\"#AxiIIC\" class=\"headerlink\" title=\"AxiIIC\"></a>AxiIIC</h3><p>AxiIIC类提供了对AXI IIC控制器IP的读与写。send()和receive()方法可以用来读与写。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">send(address, data, length, option=<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Address是外部设备IIC的地址 </li>\n<li>Data是一个被发送到IP的字节数组 </li>\n<li>length是发送的字节数 </li>\n<li>option允许一个IIC重复运行</li>\n</ul>\n<h3 id=\"DMA（直接内存访问）\"><a href=\"#DMA（直接内存访问）\" class=\"headerlink\" title=\"DMA（直接内存访问）\"></a>DMA（直接内存访问）</h3><p>PYNQ支持AX central DMA IP。DMA可以在PS DRAM与PL的快速交互中发挥出色的效果。DMA类只支持简单模式。</p>\n<p>DMA有一个AXI Lite控制接口，一个读写通道以及连接到一个IP的流（stream）端口。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk4C5jp2rnhULxrG04%2F03.png?generation=1574912187122306&alt=media\"></p>\n<p>读通道会从PS DRAM中读取数据，并写入流中。写通道会从流中读取数据并写回PS DRAM里。</p>\n<p><strong>需要注意</strong>的是DMA在完成数据传输的时候，需要连接到DMA（写通道）的IP来设置AXI TLAST信号。若该信号未被设置，DMA将会永远无法完成该次传输。在使用HLS来产生IP的时候，这一点非常重要——TLAST信号必须在C代码中设置。</p>\n<h3 id=\"Logictools\"><a href=\"#Logictools\" class=\"headerlink\" title=\"Logictools\"></a>Logictools</h3><p>Logictools包含了Trace Analyzer以及三个PYNQ硬件生成器（布尔型生成器、FSM生成器、模式生成器）的驱动。</p>\n<p>Logictools overlay里的主要硬件模块的基础操作都是一致的，它们是setup(), run(), step(), stop(), reset()。每一个模块可能有额外的独有<strong>方法</strong>来提供特定的功能。下图为运行的基本图解：</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk4C5na0bSI_8GlGdE%2F05.png?generation=1574912187117149&alt=media\"></p>\n<ul>\n<li><p>重置态 这个状态是一个模块在overlay加载后准备开始的状态。这个“重置”状态会一直维持直到使用setup()方法进行配置。 在“重置”状态下，所有的逻辑工具、overlay可用的IO都处于未连接状态。这可以预防一些由于粗心大意的驱动而造成的意外。  <strong>模式生成器</strong>有一个BRAM来存储将要生成的模式。在这个状态下，BRAM会被配置为0。类似的还有FSM生成器。</p>\n</li>\n<li><p>准备态 在这个状态下，生成器&#x2F;分析器已经配置完毕。将要连接的输入输出引脚已经准备完毕，但是把这些引脚连接到内部硬件的接口开关还未配置。</p>\n</li>\n<li><p>运行态 一旦生成器在准备状态，调用run()或step()即可使它们进入运行态。在这个状态下，接口开关已经配置为连接外部IO。硬件模块在这个状态下开始运行。 运行时默认是以single-shot模式。这个模式下，生成器将会在追踪分析器采集到足够多的数据或者模式结束后才会停止，这之后生成器和分析器会一起回到准备态。布尔型生成器是一个特例，它总是处于连续模式下运行。 在连续模式下，模式生成器会连续的生成它的模式，并在达到模式的末尾后循环运行。FSM生成器则会持续运行直到被停止。（使用stop()函数）</p>\n</li>\n</ul>\n<p> <strong>通用方法：</strong> </p>\n<ul>\n<li><strong>Setup()</strong> 每一模块必须在使用前使用setup()进行配置。 注意，当配置完成后，IO接口并未连接。 </li>\n<li><strong>Run()</strong> 该方法启动模块，使之进入运行态。 </li>\n<li><strong>Step()</strong> 与run()方法类似，区别在于运行的时候是一步一步运行的。 在对模式生成器使用该函数时，碰到结尾即停止，不会循环。 FSM生成器只有在获得了足够多的样本后才能进行step操作。 </li>\n<li><strong>Stop()</strong> 若一个模块正在运行，则在其重新运行前必须先停止。 一个模块的运行被停止后，它的输出就会与外部IO断开，只有当重新回到运行态后才会连接。 </li>\n<li><strong>Trace()</strong> 追踪功能默认开启。当启用时，追踪分析器会捕获所有已连模块的信息。使用trace方法启用或者停用。 </li>\n<li><strong>Reset()</strong> 重置生成器到初始状态，<strong>在更改硬件配置</strong>时我们需要调用该方法。</li>\n</ul>\n<p><strong>模式生成器：</strong><br>模式生成器支持至多64K的模式。根据sample clock的频率，会不断生产data word。<br>Sample clock也是可编程的。最慢的速度是252KHz，最快可以达到10MHz。</p>\n<p><strong>FSM生成器（有限状态机）：</strong><br>FSM生成器有一个内置模块内存来执行有限状态机。在Arduino shield header上的20个引脚都是可用的。FSM必须有最少1个输入，最多可以有19个输出。最大的输入个数为8个。比如说，基于输入的个数，如下的配置都是可行的。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk4C6A3nRKlhiPBgEI%2F17.png?generation=1574912187140929&alt=media\"></p>\n<p>追踪分析器是由MicroBlaze子系统控制，它连在一个DMA上，DMA也受到加载配置信息的MicroBlaze子系统的控制，包括配置模块内存来执行FSM。</p>\n<p><strong>Trace Analyzer（跟踪分析器）：</strong><br><strong>片上调试</strong>使得FPGA资源得以被用来监测调试时的内部外部信号。调试电路利用一些设计来保存系统运行时的信号数据。调试数据保存在芯片上的内存，并可以之后被读取分析。传统片上调试的常常会受限于本地内存的大小。这意味着只能得到有限的调试数据。 片上调试的概念已经被扩展到允许调试数据被保存在DDR内存。这使得我们可以获得更多的调试数据，并用python进行分析。 追踪分析器会监测PMOD和Arduino上的外部PL<strong>输入输出模块</strong>（IOB）。这些IOB是三态的。这意味着每一个引脚都会有三个内部信号：input（I），output（O），tri-state（T）。T信号被用来控制一个引脚是用作输入还是输出。Trace Analyzer会连接到IOP上的所有3个信号。 </p>\n<h3 id=\"Video\"><a href=\"#Video\" class=\"headerlink\" title=\"Video\"></a>Video</h3><p>Video子包里有一整套驱动集合——从HDMI-IN端口读取数据、写数据到HDMI-OUT端口、传输数据、设定中断、操作视频帧。</p>\n<p> 视频硬件子系统含有 HDMI-IN模块、HDMI-OUT模块和一个视频DMA。HDMI-IN和HDMI-OUT模块都支持彩色空间转换。例如从YCrCb到RGB或者反过来。 PYNQ-Z2板上有HDMI输入与HDMI输出端口。HDMI接口是直接连接到 可编程逻辑引脚 上的。在板上没有外用的HDMI电路。HDMI接口是由 可编程逻辑模块 的 HDMI IP 控制的。 HDMI IP是链接到处理系统DRAM上的，视频可以以流的方式从HDMI输入端进入内存，然后再从HDMI输出端流出。这就允许我们通过python来处理视频数据，或者干脆通过python写一段视频流然后再由HDMI输出。 虽然Jupyter notebook支持内嵌的video形式，但是我们从HDMI捕捉到的视频数据会是原生的，如果不进行适当的编码处理，将无法在notebook上直接播放。 - <strong>HDMI IN</strong></p>\n<p><strong>YCrCb:</strong> YCrCb即YUV，主要用于优化彩色视频信号的传输，与RGB视频信号传输相比，它最大的优点在于只需占用极少的频宽（RGB要求三个独立的视频信号同时传输）。其中“Y”表示明亮度（Luminance或Luma），也就是灰阶值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。“亮度”是透过RGB输入信号来建立的，方法是将RGB信号的特定部分叠加到一起。“色度”则定义了颜色的两个方面─色调与饱和度，分别用Cr和Cb来表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。</p>\n<p>HDMI输入端IP可以捕捉标准的HDMI分辨率。在HDMI资源被连接后，HDMI控制器就会启动，并自动检测输入的数据。分辨率情况可以从Python 的HDMI类里读取，图像数据也可以流入处理系统DRAM。</p>\n<h2 id=\"PYNQ-Library详解-PS-and-PL-control\"><a href=\"#PYNQ-Library详解-PS-and-PL-control\" class=\"headerlink\" title=\"PYNQ Library详解 - PS and PL control\"></a>PYNQ Library详解 - PS and PL control</h2><h2 id=\"PYNQ-Library详解-IOP\"><a href=\"#PYNQ-Library详解-IOP\" class=\"headerlink\" title=\"PYNQ Library详解 - IOP\"></a>PYNQ Library详解 - IOP</h2><p>Zynq平台通常有多个Headers和接口，它们用来连接外部设备或者直接连接Zynq PL引脚。许多现成的外部设备都可以连接到Pmod和Arduino接口上。其他的外部设备可以通过转换器（Adapter）或者面包板（Breadboard）连接到这些端口。<strong>需要注意的是</strong>当我们要使用一个外部设备的时候，我们必须先<strong>在overlay中构建一个控制器</strong>，并提供相应的软件驱动，然后我们才能使用这个设备。</p>\n<ul>\n<li>Arduino</li>\n<li>Grove</li>\n<li>Pmod</li>\n<li>RPi</li>\n</ul>\n<h3 id=\"Arduino\"><a href=\"#Arduino\" class=\"headerlink\" title=\"Arduino\"></a>Arduino</h3><p>Arduino子包包含了所有<strong>用来控制</strong> 连接到Arduino端口的外部设备 <strong>的驱动装置</strong>。一个Arduino连接器可以把Arduino compatible shields连接到PL引脚上。 不过要记得<strong>在一个overlay里必须有相应的控制器来执行对应的驱动</strong>，这之后shield才能被使用。 Arduino引脚也可以用作通用引脚来连接传统的硬件设施。</p>\n<p>如果有的话，一个Arduino PYNQ MicroBlaze可以控制Arduino接口。这个MicroBlaze就和Pmod的MicroBlaze一样，只是有更多的AXI控制器。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45Tm2OOYZ-C5fpav%2F38.png?generation=1574912159325564&alt=media\"></p>\n<p>正如在图标里所示，Arduino PYNQ MicroBlaze有一个PYNQ MicroBlaze子系统，一个配置开关，以及许多AXI控制器 <a href=\"https://pynqdocs.gitbook.io/pynq-tutorial/pynq-zhong-wen-zi-liao/0704pynq-library-xiang-jie-iop#arduino\">Arduino</a>。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45To804LALQA5LIM%2F39.png?generation=1574912159104658&alt=media\"></p>\n<p>在pynq.lib.arduino包里可以找到更多有关Arduino的信息。<br><a href=\"https://pynq.readthedocs.io/en/latest/pynq_libraries/arduino.html\">https://pynq.readthedocs.io/en/latest/pynq_libraries/arduino.html</a></p>\n<h3 id=\"Pmod\"><a href=\"#Pmod\" class=\"headerlink\" title=\"Pmod\"></a>Pmod</h3><p>Pmod包是一个 使用Pmod端的外部设备 的驱动集合。</p>\n<h3 id=\"Rpi\"><a href=\"#Rpi\" class=\"headerlink\" title=\"Rpi\"></a>Rpi</h3><p>Rpi子包是控制 连接RPi（Raspberry Pi）接口外设 的驱动集合。<br>同样的，在使用具体设备之前，我们需要加载相应的overlay上的控制器。RPi引脚也可用作通用引脚来连接传统的硬件设备。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45U9Z-38B3Iv8Vwl%2F50.png?generation=1574912159389267&alt=media\"></p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45UBlbtSd7VpQGoz%2F51.png?generation=1574912159169195&alt=media\"></p>\n<p>在pynq.lib.rpi包里可以找到更多信息。</p>\n<h2 id=\"PYNQ-Library详解-Pynq-MicroBlaze\"><a href=\"#PYNQ-Library详解-Pynq-MicroBlaze\" class=\"headerlink\" title=\"PYNQ Library详解 - Pynq MicroBlaze\"></a>PYNQ Library详解 - Pynq MicroBlaze</h2><p>PYNQ库提供了对子系统Pynq MicroBlaze的支持。<br>它允许我们加载 预编译好的应用，并且可以在Jupyter中 创建编译 新的应用。</p>\n<h3 id=\"MicroBlaze-Subsystem\"><a href=\"#MicroBlaze-Subsystem\" class=\"headerlink\" title=\"MicroBlaze Subsystem\"></a>MicroBlaze Subsystem</h3><p>PYNQ MicroBlaze子系统 可以由 PynqMicroblaze类 进行管控，这允许我们从Python下载程序，通过执行处理器的重置信号、共享数据内存读写 和 管理中断 来进行操控。</p>\n<p>每一个 PYNQ MicroBlaze子系统 都含有一个 IOP（IO处理器），一个IOP定义了一些能被Python控制的交互与动作控制器。现在一共有三个IOP：Arduino，PMOD，Logictools。</p>\n<p>该子系统含有一个MicroBlaze处理器，AXI交互、中断控制器，一个中断请求器和外部系统接口以及BRAM、内存控制器。</p>\n<p><img src=\"https://2192837526-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Luk3T3QoKyS_b-1joBV%2F-Luk3tukeoHpawWbVABz%2F-Luk45lutSSL0eZk-Bfp%2F52.png?generation=1574912162153238&alt=media\"></p>\n<p>AXI交互控制器把MicroBlaze连接到中断控制器、中断请求器和外部接口上。</p>\n<ul>\n<li>中断控制器是其他连接到MicroBlaze处理器的交互&#x2F;动作控制器的接口。</li>\n<li>中断请求器发送中断请求至Zynq处理系统。</li>\n<li>外部接口允许MIcroBlaze子系统与其他控制器或DDR内存进行交互。</li>\n<li>BRAM保存了MicroBlaze的指令和数据。</li>\n</ul>\n<p>BRAM是双端口的：一个端口连接到MicroBlaze指令与数据端口，另一个连接到ARM® Cortex®-A9 通讯处理器。</p>\n<p>如果外部接口连接到了DDR内存，则DDR可以用来在子系统和PS之间传输大量数据分段。</p>\n<p><strong>创建一个新的PYNQ MicroBlaze</strong><br>学到这不学了，等到觉得学这个对以后有帮助再继续吧。<a href=\"https://pynqdocs.gitbook.io/pynq-tutorial/pynq-zhong-wen-zi-liao/0705pynq-library-xiang-jie-pynq-microblaze#chuang-jian-yi-ge-xin-de-pynq-microblaze\">创建一个新的PYNQ MicroBlaze</a></p>\n<h1 id=\"本文参考\"><a href=\"#本文参考\" class=\"headerlink\" title=\"本文参考\"></a>本文参考</h1><p><a href=\"https://pynq.readthedocs.io/en/latest/\">官方文档</a><br><a href=\"https://pynqdocs.gitbook.io/pynq-tutorial/pynq-zhong-wen-zi-liao\">PYNQ-Z2 中文资料</a><br>来自公众号“PYNQ开源社区”的 <a href=\"https://mp.weixin.qq.com/s/GW_Ke2wEbcr3iXlML8O12w\">PYNQ入门资料集锦</a><br><a href=\"https://blog.umer-farooq.com/a-pynq-z2-guide-for-absolute-dummies-part-ii-using-verilog-and-vivado-to-burn-code-on-pynq-d856f79948b1\">Umer Farooq的文章</a></p>\n","categories":["FPGA"],"tags":["PYNQ"]},{"title":"videoCompress","url":"/2024/02/08/videoCompress/","content":"<p><em><strong>毕竟几人真得鹿，不知终日梦为鱼</strong></em></p>\n<span id=\"more\"></span>\n\n<h1 id=\"什么是视频压缩\"><a href=\"#什么是视频压缩\" class=\"headerlink\" title=\"什么是视频压缩\"></a>什么是视频压缩</h1><p><strong>视频压缩也称为视频编码</strong>，是减少视频数据大小以便可以有效地将其从一个地方移动到另一个地方的过程。一个完全未压缩的视频文件可能会占用几张蓝光光盘。从服务器流式传输到用户计算机也需要大量时间，而且实时回放几乎是不可能的。相比之下，压缩的视频文件可以放入一张蓝光光盘，即使图像质量非常高也是如此。它可以从服务器快速、近乎实时地流式传输到用户的计算机。</p>\n<p>视频压缩的运作原理是去除冗余的视觉信息和不必要的细节，并依靠数学计算来生成每一帧视频的大部分内容，而不是记录每一帧。通过记录图像在帧与帧之间的变化，视频压缩可以存储整个视频，而无需存储每一帧。</p>\n<p>H.264 是一种有损压缩标准，这意味着从视频中删除了不必要的信息。但是，这不应该影响视频的质量，因为显示视频的重要信息会被保留。</p>\n<h2 id=\"什么是高级视频编码-H-264\"><a href=\"#什么是高级视频编码-H-264\" class=\"headerlink\" title=\"什么是高级视频编码 (H.264)\"></a>什么是高级视频编码 (H.264)</h2><p>**高级视频编码 (AVC)**，也称为 H.264，是当今使用的最常见的视频压缩标准。AVC&#x2F;H.264 能够以比旧压缩标准更低的比特率编码高质量视频（“比特率”是每秒视频必须处理的信息单位数）。</p>\n<p>蓝光和各种流式传输服务，包括点播和直播电视，都使用 H.264。尽管它的使用有时需要向拥有专利的组织支付版税，但超过 90% 的视频行业使用 H.264。</p>\n<h2 id=\"哪些容器使用-AVC-x2F-H-264\"><a href=\"#哪些容器使用-AVC-x2F-H-264\" class=\"headerlink\" title=\"哪些容器使用 AVC&#x2F;H.264\"></a>哪些容器使用 AVC&#x2F;H.264</h2><p>**视频容器文件(音视频封装格式)**存储视频、音频和元数据；最常见的容器文件类型之一是 MP4。H.264 适用于多种容器格式，包括 MP4、TS(MPEG2-TS) 和 MOV。</p>\n<h2 id=\"什么是-H-265\"><a href=\"#什么是-H-265\" class=\"headerlink\" title=\"什么是 H.265\"></a>什么是 H.265</h2><p>**H.265 也称为高效视频编码 (HEVC)**，是 H.264 之后的压缩标准。它提供比 H.264 更好的图像质量。除了 H.264 之外，许多视频托管服务器还使用 H.265。但是，由于较旧的 H.264 已被广泛采用且能够以可管理的比特率提供良好的质量，因此它可能会继续使用一段时间。</p>\n<h2 id=\"视频编码\"><a href=\"#视频编码\" class=\"headerlink\" title=\"视频编码\"></a>视频编码</h2><img src=\"/2024/02/08/videoCompress/1.png\" class=\"\">\n\n<img src=\"/2024/02/08/videoCompress/2.png\" class=\"\">\n\n<p>我们常见的<strong>avi</strong>,wmv,<strong>mp4</strong>,flv,<strong>rmvb</strong>,<strong>mkv</strong>,mov,asf,3gp等视频格式是指他们的“<strong>封装格式</strong>”。但是其<strong>内部数据</strong>还有特有的“<strong>编码格式</strong>”，比如<strong>视频常见的编码格式</strong>有<strong>mpeg2</strong>,Xvid,wmv7<del>wmv9,**H.261</del>H.265**,vp8,<strong>vp9</strong>,realvideo,flashvideo等，<strong>音频常见的编码格式</strong>有<strong>mp3</strong>,<strong>AAC</strong>,wma7~wma9,DTS,AMR,FLAC,APE,TTA等。</p>\n<p>上面两张示意图可以便于理解。我们可以把<strong>视频的封装格式类比成压缩文件的rar、7z、zip</strong>等格式，相对来说<strong>视频内数据的编码格式可以类比为我们平时把文件压缩打包中里面的各类文件</strong>，比如txt、doc、jpg、xls等。我们都知道看doc文档和xls表格得用office或wps等软件，看pdf得用Adobe Reader、福昕pdf阅读器、小新pdf阅读器等软件，看jpg得用图片浏览器等等。所以说，<strong>查看文件最主要得看解压缩后内部文件的编码格式</strong>，找到对应它的程序。因此，看视频和剪辑视频，需要安装<strong>针对该视频内部编码格式</strong>的“<strong>编解码器</strong>”才行，<strong>而不能只看其外部封装格式</strong>。如果找不到对应的编解码器，可以尝试用一些<strong>转格式软件先把视频编码成其他格式</strong>。</p>\n<h1 id=\"FFmpeg\"><a href=\"#FFmpeg\" class=\"headerlink\" title=\"FFmpeg\"></a>FFmpeg</h1><p><strong>引题：</strong><br>如果你的视频文件使用的是不常见或不支持的编解码器，Premiere Pro可能无法解码和播放该文件。确保你的视频文件使用的是常见的、与Premiere Pro兼容的编解码器，例如H.264或Apple ProRes。如果不是，请尝试转码视频文件为Premiere Pro支持的格式。 </p>\n<p>现在我有一个vp9编码的MP4文件在Pr里面播放只有声音，视频是黑屏，所以我需要转换编码为H.264，也就是AVC。如何看视频编码格式可以用软件MediaInfo查看。</p>\n<p><code>ffmpeg -i input.mp4 -c:v h264 -c:a copy output.mp4 </code></p>\n<p>-c:v 是视频编码转换的格式<br>-c:a 是音频编码转换的格式</p>\n<p>h264是要转换成的视频编码</p>\n<p>copy其实很常用，因为视频编码是有损压缩，多次重新编码会造成无法挽回的画质音质损失，所以不重新编码的时候就用copy。</p>\n<p><strong>主要参考：</strong><br><a href=\"https://www.yumefx.com/?p=1334\">FFmpeg进行视频转码</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://zh.wikihow.com/%E5%8E%8B%E7%BC%A9%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6\">在Windows和Mac电脑使用Handbrake</a>Handbrake也是用的FFmpeg。</p>\n<p><strong>未看：</strong><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NTEzOTM5Mw==&mid=2247515283&idx=1&sn=1f6ac100ad020fb8e8238aefa5e89d19&chksm=fbda14bdccad9dabe8dfe7e90401acb04d906c56805c76f72fab242b763efd6aca70b4884e07&scene=21#wechat_redirect\">视频编码完全指南</a></p>\n"},{"title":"UbuntuNote","url":"/2023/04/19/ubuntuNote/","content":"<p><strong>Linux is not Unix</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"重装双系统-Ubuntu\"><a href=\"#重装双系统-Ubuntu\" class=\"headerlink\" title=\"重装双系统(Ubuntu)\"></a>重装双系统(Ubuntu)</h1><h2 id=\"彻底卸载Ubuntu\"><a href=\"#彻底卸载Ubuntu\" class=\"headerlink\" title=\"彻底卸载Ubuntu\"></a>彻底卸载Ubuntu</h2><p>原因：重装windows系统，Ubuntu引导不见了，Ubuntu无法使用了。或者想重装Ubuntu，或者不再使用，腾出空间。</p>\n<h3 id=\"删除Ubuntu系统磁盘空间\"><a href=\"#删除Ubuntu系统磁盘空间\" class=\"headerlink\" title=\"删除Ubuntu系统磁盘空间\"></a>删除Ubuntu系统磁盘空间</h3><p>如果在之前安装Ubuntu时选择的是下图选项：</p>\n<img src=\"/2023/04/19/ubuntuNote/1.png\" class=\"\">\n\n<p>则一般有三种创建分区的方式：</p>\n<ol>\n<li>分为两个区(‘&#x2F;‘、’&#x2F;home’)、</li>\n<li>分为四个区(‘swap’、’&#x2F;‘、’&#x2F;home’、’efi’)</li>\n<li>分为五个区(‘swap’、’&#x2F;‘、home’、’efi’、’&#x2F;usr’)</li>\n</ol>\n<p>我之前装的时侯分成了四个区即(‘swap’、’&#x2F;‘、’&#x2F;home’、’efi’)，因此在电脑的磁盘管理可以看到这四个区，其中’efi’也即<strong>系统分区</strong>，很重要，之前的话里面有Ubuntu和Windows的启动项，不放在一起的话Ubuntu的启动项会自己放在另一个<strong>efi系统分区</strong>，后面再说。其它三个分区都可以直接删除，在磁盘管理处直接删除卷即可。</p>\n<p>其实ubuntu的启动项应该还是会和windows的启动项放在一起都放在windows系统的EFI分区，ubuntu的EFI系统分区可以直接删除，详见这篇文章：<br><a href=\"https://bbs.huaweicloud.com/blogs/303695\">教你彻底卸载Ubuntu双系统</a></p>\n<h3 id=\"删除Ubuntu的系统启动项\"><a href=\"#删除Ubuntu的系统启动项\" class=\"headerlink\" title=\"删除Ubuntu的系统启动项\"></a>删除Ubuntu的系统启动项</h3><p>键盘按住 Win + R，输入 diskpart 进入相应命令行，输入 list disk 查看所有磁盘，并输入 <code>select disk 盘编号</code> 选择的盘应该是Ubuntu的启动项所在的那个盘，我的情况是Windows和Ubuntu的启动项所在的efi系统分区，和系统盘(C盘)并不在同一个磁盘，很奇怪。输入 list partition 查看该磁盘所有分区，并<code>select partition 分区编号</code>选择“系统”分区（即该efi） ，输入 <code>assign letter=字母</code> 将其分配成一个独立磁盘（磁盘字母随意只要不和现有磁盘冲突即可，如assign letter T）。磁盘T不可访问，可以通过软件 Total Commander来删除Ubuntu系统启动项，也可以<code>以管理员身份打开“记事本”，点击菜单栏“文件 -&gt; 打开”，选择刚刚创建的磁盘T，打开其中文件夹“EFI”，并选择该目录下的“Ubuntu”文件夹右键删除</code>，最后<code>remove letter=磁盘字母</code>删除创建的磁盘。</p>\n<p>把引导菜单中原Ubuntu系统涉及的启动项删除，可以在软件easybcd里编辑引导菜单：</p>\n<img src=\"/2023/04/19/ubuntuNote/2.png\" class=\"\">\n\n<p>删除Ubuntu项，这样在电脑开机进入bios的时候就看不到Ubuntu了。</p>\n<p><strong>至此彻底删除Ubuntu。</strong></p>\n<p>可参考：<br><a href=\"https://www.laomaotao.net/more/2021/0330/9229.html\">双系统如何删除一个系统</a><br><a href=\"https://blog.csdn.net/qq_42257666/article/details/120721561\">彻底卸载Ubuntu双系统</a><br><a href=\"https://beingjay.com/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/\">双系统下重装Ubuntu系统</a></p>\n<h2 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h2><h3 id=\"准备过程\"><a href=\"#准备过程\" class=\"headerlink\" title=\"准备过程\"></a>准备过程</h3><p>下载Ubuntu镜像文件，我下载了最新的LTS版本，即<code>Ubuntu 22.04.2 LTS</code>，可以选择桌面版(Desktop)或服务器版(Server)。<br><a href=\"https://cn.ubuntu.com/download/desktop\">下载Ubuntu桌面系统 | Ubuntu</a></p>\n<p>之后使用Rufus制作启动盘，至少大于4G，注意：制作启动盘会格式化硬盘。注意不要选错U盘，分区类型务必选择GPT分区表，目标系统类型务必选择UEFI(非CSM)，若你的BIOS只支持NTFS，要改成NTFS，不过一般都是支持FAT32的，先用FAT32，如果不行再回来改。</p>\n<img src=\"/2023/04/19/ubuntuNote/3.png\" class=\"\">\n\n<p>选择以iso镜像模式写入，进度条满之后即可。</p>\n<p>压缩磁盘空间得到一个未分配的空间，推荐大小为：</p>\n<ol>\n<li>只是玩一玩linux系统，则分配30GB</li>\n<li>学习ROS，80GB以上</li>\n<li>深度学习、机器学习，100GB以上</li>\n<li>软件开发，50GB</li>\n</ol>\n<p> 联想电脑Y9000P进入BIOS是F2，不行的话就Fn+2(数字键盘的2也可以)，F12可以选择以什么方式启动。</p>\n<p> 在BIOS中关闭安全启动(secure boot)和快速启动(fast boot)，我只关了安全启动。</p>\n<h3 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h3><p>插入U盘，进入BIOS设置从U盘启动或者直接F12选择从U盘启动，启动后进入Grub界面，类似这样：</p>\n<img src=\"/2023/04/19/ubuntuNote/4.png\" class=\"\">\n\n<p>我的是：</p>\n<ol>\n<li>Ubuntu</li>\n<li>Ubuntu高级选项</li>\n<li>Windows Boot manager</li>\n<li>something else</li>\n</ol>\n<p>安装时都选择中文，<strong>不联网(没换源，下载的话会很慢)<strong>，我选择了最小安装(简洁无敌)。</strong>一定要选择其他选项：</strong></p>\n<img src=\"/2023/04/19/ubuntuNote/5.png\" class=\"\">\n\n<h4 id=\"分区\"><a href=\"#分区\" class=\"headerlink\" title=\"分区\"></a>分区</h4><p><strong>这个过程十分关键</strong></p>\n<p>找到你刚刚压缩出来的空闲空间，根据大小判断，我的是260G左右。</p>\n<p><strong>选中空闲的空间</strong>，点击底下的➕建立分区，这次总共建立三个分区。</p>\n<ol>\n<li>EFI系统分区<br>也即启动分区，系统将从这里加载启动，内核文件也放在这里，大小选择512MB。<strong>分区类型选择逻辑分区，空间起始位置，”用于”选择EFI系统分区</strong>，如下：</li>\n</ol>\n<img src=\"/2023/04/19/ubuntuNote/6.png\" class=\"\">\n\n<ol start=\"2\">\n<li>根目录<br>这个越大也好，因为很多程序默认安装在根目录的opt文件夹下，新手不建议乱改安装位置。实际上剩余的全给根目录(‘&#x2F;‘)也没关系，因为Linux文件系统采用的是”使用时分配”的策略。也就是说，你用了多少，就会给那个分区分配多少分区，没用的时候，剩下的空间就处于”待分配”的状态。<strong>这里分区类型选择主分区，”用于”选择Ext4日志文件系统</strong>，如下：</li>\n</ol>\n<img src=\"/2023/04/19/ubuntuNote/7.png\" class=\"\">\n\n<ol start=\"3\">\n<li>&#x2F;home目录<br>这个是用户自己的空间，和Windows下的C盘以外的空间差不多，保存用户自己的数据，重装系统时这部分不会丢失，其余的空间都给&#x2F;home。<strong>这里分区类型选择逻辑分区，空间起始位置，”用于”选择Ext4日志文件系统</strong>。</li>\n</ol>\n<p>这次安装Ubuntu没有分配<strong>Swap区</strong>(虚拟内存)，因为现在大家内存都很大了，没有这个必要了，很多教程都比较老了，对现在的环境来说就是坑了。</p>\n<img src=\"/2023/04/19/ubuntuNote/1.jpg\" class=\"\">\n\n<img src=\"/2023/04/19/ubuntuNote/8.png\" class=\"\">\n\n<p>可以发现存在两个EFI系统分区，我知道448MB里面存放了Windows系统的启动项，488MB应该就是刚刚为Ubuntu创建的EFI系统分区，里面有启动项。</p>\n<h4 id=\"ELSE\"><a href=\"#ELSE\" class=\"headerlink\" title=\"ELSE\"></a>ELSE</h4><p>分区完后注意，在<strong>安装启动引导器的设备</strong>处，一定要选择刚刚为Ubuntu系统分配的<strong>EFI系统分区</strong>，还是根据大小判断(我们分配的大小会是511MB)，别选成了Windows的EFI系统分区(因为我为Ubuntu重新分配了EFI系统分区，这次两个系统的启动项就不在同一个EFI系统分区里了)</p>\n<img src=\"/2023/04/19/ubuntuNote/1.jpg\" class=\"\">\n\n<p>确定选择正确后便可以安装。</p>\n<p>设置密码图方便可以设置为空格(我就是这么做的)，root密码我设为了123，进入root的命令是<code>su root</code>。</p>\n<p>拔掉U盘之后就可以重启了，重启后进入Grub界面，选择Ubuntu则启动Ubuntu，选择Windows Boot Manager则启动Windows。如果嫌每次都进Grub太麻烦可以在BIOS中调整顺序把Windows放到Ubuntu前面，则每次默认直接进Windows。</p>\n<p>可参考：<br><a href=\"https://blog.csdn.net/NeoZng/article/details/122779035\">Ubuntu&#x2F;Windows双系统安装巨详细</a></p>\n<h1 id=\"学习Ubuntu\"><a href=\"#学习Ubuntu\" class=\"headerlink\" title=\"学习Ubuntu\"></a>学习Ubuntu</h1><h2 id=\"Linux系统目录结构\"><a href=\"#Linux系统目录结构\" class=\"headerlink\" title=\"Linux系统目录结构\"></a>Linux系统目录结构</h2><img src=\"/2023/04/19/ubuntuNote/2.jpg\" class=\"\">\n\n<ul>\n<li><p>&#x2F;bin：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>\n</li>\n<li><p>&#x2F;boot：<br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些链接文件以及镜像文件。</p>\n</li>\n<li><p>&#x2F;dev ：<br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>\n</li>\n<li><p>&#x2F;etc：<br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>\n</li>\n<li><p>&#x2F;home：<br>用户的主目录(lczhang)，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 eve。</p>\n</li>\n<li><p>&#x2F;lib：<br>lib 是 Library(库) 的缩写，这个目录里存放着系统最基本的动态链接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>\n</li>\n<li><p>&#x2F;media：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>\n</li>\n<li><p>&#x2F;mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p>\n</li>\n<li><p>&#x2F;opt：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如我安装一个谷歌就放到了这个目录下。默认是空的。</p>\n</li>\n<li><p>&#x2F;proc：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：<br><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></p>\n</li>\n<li><p>&#x2F;root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>\n</li>\n<li><p>&#x2F;sbin：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>\n</li>\n<li><p>&#x2F;sys：<br>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。<br>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。<br>该文件系统是内核设备树的一个直观反映。<br>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>\n</li>\n<li><p>&#x2F;tmp：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>\n</li>\n<li><p>&#x2F;var：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>\n</li>\n<li><p>&#x2F;run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>\n</li>\n<li><p>&#x2F;usr：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>\n</li>\n<li><p>&#x2F;usr&#x2F;bin：<br>系统用户使用的应用程序。</p>\n</li>\n<li><p>&#x2F;usr&#x2F;sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</p>\n</li>\n<li><p>&#x2F;usr&#x2F;src：<br>内核源代码默认的放置目录。</p>\n</li>\n</ul>\n<hr>\n<p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。<br><strong>&#x2F;etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。<br><strong>&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin</strong>: 这是系统预设的执行文件的放置目录，比如 ls 就是在 &#x2F;bin&#x2F;ls 目录下的。<br>值得提出的是 &#x2F;bin、&#x2F;usr&#x2F;bin 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。<br><strong>&#x2F;var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下。</p>\n<p>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。<br>文件系统的最顶层是由根目录开始的，系统使用 &#x2F; 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。<br>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 .. 来表示。</p>\n<ul>\n<li>. ：代表当前的目录，也可以使用 .&#x2F; 来表示；</li>\n<li>.. ：代表上一层目录，也可以 ..&#x2F; 来代表。</li>\n</ul>\n<p>如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。</p>\n<h2 id=\"Linux-文件基本属性\"><a href=\"#Linux-文件基本属性\" class=\"headerlink\" title=\"Linux 文件基本属性\"></a>Linux 文件基本属性</h2><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>\n<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>\n<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>\n<p>chown (change owner) ： 修改所属用户与组。<br>chmod (change mode) ： 修改用户的权限。</p>\n<p>在 Linux 中我们可以使用 ll 或者 ls –l 命令来显示一个文件的<strong>属性</strong>以及文件所属的<strong>用户和组</strong>，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@www /]<span class=\"meta\"># ls -l</span></span><br><span class=\"line\">total <span class=\"number\">64</span></span><br><span class=\"line\">dr-xr-xr-x   <span class=\"number\">2</span> root root <span class=\"number\">4096</span> Dec <span class=\"number\">14</span>  <span class=\"number\">2012</span> bin</span><br><span class=\"line\">dr-xr-xr-x   <span class=\"number\">4</span> root root <span class=\"number\">4096</span> Apr <span class=\"number\">19</span>  <span class=\"number\">2012</span> boot</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p>实例中，bin 文件的第一个属性用 d 表示。d 在 Linux 中代表该文件是一个目录文件。</p>\n<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>\n<p>当为 d 则是目录<br>当为 - 则是文件；<br>若是 l 则表示为链接文档(link file)；<br>若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；<br>若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。<br>接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。</p>\n<img src=\"/2023/04/19/ubuntuNote/3.jpg\" class=\"\">\n\n<p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）：</p>\n<img src=\"/2023/04/19/ubuntuNote/9.png\" class=\"\">\n\n<p>从左至右用 0-9 这些数字来表示。</p>\n<p>第 0 位确定文件类型，第 1-3 位确定<strong>属主</strong>（该文件的所有者）拥有该文件的权限。</p>\n<p>第4-6位确定<strong>属组</strong>（所有者的同组用户）拥有该文件的权限，第7-9位确定<strong>其他用户</strong>拥有该文件的权限。<br>其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限；</p>\n<p>第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。</p>\n<h3 id=\"Linux文件属主和属组\"><a href=\"#Linux文件属主和属组\" class=\"headerlink\" title=\"Linux文件属主和属组\"></a>Linux文件属主和属组</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@www /]<span class=\"meta\"># ls -l</span></span><br><span class=\"line\">total <span class=\"number\">64</span></span><br><span class=\"line\">drwxr-xr-x <span class=\"number\">2</span> root  root  <span class=\"number\">4096</span> Feb <span class=\"number\">15</span> <span class=\"number\">14</span>:<span class=\"number\">46</span> cron</span><br><span class=\"line\">drwxr-xr-x <span class=\"number\">3</span> mysql mysql <span class=\"number\">4096</span> Apr <span class=\"number\">21</span>  <span class=\"number\">2014</span> mysql</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>\n<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>\n<p>文件所有者以外的用户又可以分为文件所属组主的同组用户和其他用户。</p>\n<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>\n<p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p>\n<p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>\n<h3 id=\"更改文件属性\"><a href=\"#更改文件属性\" class=\"headerlink\" title=\"更改文件属性\"></a>更改文件属性</h3><p><strong>chgrp：更改文件属组</strong></p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>\n<hr>\n<p><strong>chown：更改文件属主，也可以同时更改文件属组</strong></p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">chown [-R] 属主名 文件名</span><br><span class=\"line\">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</span><br><span class=\"line\">[root@www ~] cd ~</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># chown bin install.log</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># ls -l</span></span><br><span class=\"line\">-rw-r--r--  <span class=\"number\">1</span> bin  users <span class=\"number\">68495</span> Jun <span class=\"number\">25</span> <span class=\"number\">08</span>:<span class=\"number\">53</span> install.log</span><br><span class=\"line\"></span><br><span class=\"line\">将install.log的拥有者与群组改回为root：</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># chown root:root install.log</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># ls -l</span></span><br><span class=\"line\">-rw-r--r--  <span class=\"number\">1</span> root root <span class=\"number\">68495</span> Jun <span class=\"number\">25</span> <span class=\"number\">08</span>:<span class=\"number\">53</span> install.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>\n<p>Linux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他) 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限。</p>\n<p>先复习一下刚刚上面提到的数据：文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照为：r:4，w:2，x:1。(其实就是二进制，有权限rwx就是1，没有权限-就是0)</p>\n<p><strong>chmod ：变更文件权限</strong></p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。<br>-R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># ls -al .bashrc</span></span><br><span class=\"line\">-rw-r--r--  <span class=\"number\">1</span> root root <span class=\"number\">395</span> Jul  <span class=\"number\">4</span> <span class=\"number\">11</span>:<span class=\"number\">45</span> .bashrc</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># chmod 777 .bashrc</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># ls -al .bashrc</span></span><br><span class=\"line\">-rwxrwxrwx  <span class=\"number\">1</span> root root <span class=\"number\">395</span> Jul  <span class=\"number\">4</span> <span class=\"number\">11</span>:<span class=\"number\">45</span> .bashrc</span><br><span class=\"line\">那如果要将权限变成 -rwxr-xr-- 呢？那么权限的分数就成为 [<span class=\"number\">4</span>+<span class=\"number\">2</span>+<span class=\"number\">1</span>][<span class=\"number\">4</span>+<span class=\"number\">0</span>+<span class=\"number\">1</span>][<span class=\"number\">4</span>+<span class=\"number\">0</span>+<span class=\"number\">0</span>]=<span class=\"number\">754</span>。</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"符号类型改变文件权限\"><a href=\"#符号类型改变文件权限\" class=\"headerlink\" title=\"符号类型改变文件权限\"></a>符号类型改变文件权限</h3><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p>\n<p>user：用户<br>group：组<br>others：其他<br>那么我们就可以使用 u, g, o 来代表三种身份的权限。</p>\n<p>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：</p>\n\n\n<p>如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 <code>chmod u=rwx,g=rx,o=r 文件名</code> 来设定。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#  touch test1    <span class=\"comment\">// 创建 test1 文件</span></span></span><br><span class=\"line\"><span class=\"meta\"># ls -al test1    <span class=\"comment\">// 查看 test1 默认权限</span></span></span><br><span class=\"line\">-rw-r--r-- <span class=\"number\">1</span> root root <span class=\"number\">0</span> Nov <span class=\"number\">15</span> <span class=\"number\">10</span>:<span class=\"number\">32</span> test1</span><br><span class=\"line\"><span class=\"meta\"># chmod u=rwx,g=rx,o=r  test1    <span class=\"comment\">// 修改 test1 权限</span></span></span><br><span class=\"line\"><span class=\"meta\"># ls -al test1</span></span><br><span class=\"line\">-rwxr-xr-- <span class=\"number\">1</span> root root <span class=\"number\">0</span> Nov <span class=\"number\">15</span> <span class=\"number\">10</span>:<span class=\"number\">32</span> test1</span><br></pre></td></tr></table></figure>\n\n<p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#  chmod  a-x test1</span></span><br><span class=\"line\"><span class=\"meta\"># ls -al test1</span></span><br><span class=\"line\">-rw-r--r-- <span class=\"number\">1</span> root root <span class=\"number\">0</span> Nov <span class=\"number\">15</span> <span class=\"number\">10</span>:<span class=\"number\">32</span> test1</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Linux-文件与目录管理\"><a href=\"#Linux-文件与目录管理\" class=\"headerlink\" title=\"Linux 文件与目录管理\"></a>Linux 文件与目录管理</h2><p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。</p>\n<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>\n<p>我们需要先知道什么是绝对路径与相对路径：</p>\n<ul>\n<li><p>绝对路径：<br>路径的写法，由根目录 &#x2F; 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p>\n</li>\n<li><p>相对路径：<br>路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： cd ..&#x2F;man 这就是相对路径的写法。</p>\n</li>\n</ul>\n<h3 id=\"处理目录的常用命令\"><a href=\"#处理目录的常用命令\" class=\"headerlink\" title=\"处理目录的常用命令\"></a>处理目录的常用命令</h3><p>接下来我们就来看几个常见的处理目录的命令吧：</p>\n<p>ls（英文全拼：list files）: 列出目录及文件名<br>cd（英文全拼：change directory）：切换目录<br>pwd（英文全拼：print work directory）：显示目前的目录<br>mkdir（英文全拼：make directory）：创建一个新的目录<br>rmdir（英文全拼：remove directory）：删除一个空的目录<br>cp（英文全拼：copy file）: 复制文件或目录<br>rm（英文全拼：remove）: 删除文件或目录<br>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</p>\n<p>你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。</p>\n<hr>\n<p>ls (列出目录)</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@www ~]<span class=\"meta\"># ls [-aAdfFhilnrRSt] 目录名称</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># ls [--color=&#123;never,auto,always&#125;] 目录名称</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># ls [--full-time] 目录名称</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># ls -al ~   <span class=\"comment\">// 查看~目录下的所有文件，以列表形式给出，</span></span></span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)<br>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)<br>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)<br>-h:  将文件的大小以人类能看懂的形式表现出来，如kb,mb，本来默认以b(byte)为单位。</p>\n<hr>\n<p>cd (切换目录)<br>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>pwd (显示目前所在的目录)<br>pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@www ~]<span class=\"meta\"># pwd [-P]</span></span><br></pre></td></tr></table></figure>\n<p>选项与参数：<br>-P ：显示出确实的路径，而非使用链接 (link) 路径。</p>\n<p>当<strong>启动一个终端程序的时候默认是在HOME目录中打开</strong>，HOME目录就是用户的主目录，也就是&#x2F;home&#x2F;“用户名”，我的就是在&#x2F;home&#x2F;lczhang，即HOME&#x3D;&#x2F;home&#x2F;lczhang，特殊符号是~，cd不输入参数也会回到HOME这里。如果进入了root，~就代表&#x2F;root这个目录，pwd也会打印&#x2F;root，cd不输入参数回到&#x2F;root。</p>\n<hr>\n<p>mkdir (创建新目录)<br>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">实例：在/tmp底下尝试创建数个新目录：</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># cd /tmp</span></span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># mkdir test    &lt;==创建一名为 test 的新目录</span></span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># mkdir test1/test2/test3/test4</span></span><br><span class=\"line\">mkdir: cannot create directory `test1/test2/test3/test4<span class=\"number\">&#x27;</span>: </span><br><span class=\"line\">No such file <span class=\"keyword\">or</span> directory       &lt;== 没办法直接创建此目录啊！</span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># mkdir -p test1/test2/test3/test4</span></span><br><span class=\"line\">加了这个 -p 的选项，可以自行帮你创建多层目录！</span><br><span class=\"line\"></span><br><span class=\"line\">实例：创建权限为 rwx--x--x 的目录。</span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># mkdir -m 711 test2   <span class=\"comment\">// 这里我们使用 -m 711 来给予新的目录 drwx--x--x 的权限。</span></span></span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># ls -l</span></span><br><span class=\"line\">drwxr-xr-x  <span class=\"number\">3</span> root  root <span class=\"number\">4096</span> Jul <span class=\"number\">18</span> <span class=\"number\">12</span>:<span class=\"number\">50</span> test</span><br><span class=\"line\">drwxr-xr-x  <span class=\"number\">3</span> root  root <span class=\"number\">4096</span> Jul <span class=\"number\">18</span> <span class=\"number\">12</span>:<span class=\"number\">53</span> test1</span><br><span class=\"line\">drwx--x--x  <span class=\"number\">2</span> root  root <span class=\"number\">4096</span> Jul <span class=\"number\">18</span> <span class=\"number\">12</span>:<span class=\"number\">54</span> test2</span><br><span class=\"line\">上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>cp (复制文件或目录)<br>cp 即拷贝文件和目录。</p>\n<p>语法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@www ~]<span class=\"meta\"># cp [-adfilprsu] 来源档(source) 目标档(destination)</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># cp [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)<br>-d：若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；<br>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)<br>-l：进行硬式链接(hard link)的链接档创建，而非复制文件本身；<br>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；<br>-r：递归持续复制，用於目录的复制行为；(常用)<br>-s：复制成为符号链接档 (symbolic link)，亦即『捷径』文件；<br>-u：若 destination 比 source 旧才升级 destination ！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># cp ~/.bashrc /tmp/bashrc</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># cp -i ~/.bashrc /tmp/bashrc</span></span><br><span class=\"line\">cp: overwrite `/tmp/bashrc<span class=\"number\">&#x27;</span>? n  &lt;==n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>rm (移除文件或目录)</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">将刚刚在 cp 的实例中创建的 bashrc 删除掉！</span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># rm -i bashrc</span></span><br><span class=\"line\">rm: remove regular file `bashrc<span class=\"number\">&#x27;</span>? y</span><br><span class=\"line\">如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>mv (移动文件与目录，或修改名称)</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@www ~]<span class=\"meta\"># mv [-fiu] source destination</span></span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># mv [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">复制一文件，创建一目录，将文件移动到目录中</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># cd /tmp</span></span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># cp ~/.bashrc bashrc</span></span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># mkdir mvtest</span></span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># mv bashrc mvtest</span></span><br><span class=\"line\">将某个文件移动到某个目录去，就是这样做！</span><br><span class=\"line\"></span><br><span class=\"line\">将刚刚的目录名称更名为 mvtest2（这里是因为不存在mvtest2这个文件夹，不然就会将mvtest这个文件夹移动到mvtest2下面）</span><br><span class=\"line\">[root@www tmp]<span class=\"meta\"># mv mvtest mvtest2</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Linux-文件内容查看\"><a href=\"#Linux-文件内容查看\" class=\"headerlink\" title=\"Linux 文件内容查看\"></a>Linux 文件内容查看</h3><p>Linux系统中使用以下命令来查看文件的内容：</p>\n<p>cat  由第一行开始显示文件内容<br>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！<br>nl   显示的时候，顺道输出行号！<br>more 一页一页的显示文件内容<br>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！<br>head 只看头几行<br>tail 只看尾巴几行</p>\n<p>cat<br>由第一行开始显示文件内容</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat [-AbEnTv]</span><br></pre></td></tr></table></figure>\n\n<p>选项与参数：<br>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；<br>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！<br>-E ：将结尾的断行字节 $ 显示出来；<br>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；<br>-T ：将 [tab] 按键以 ^I 显示出来；<br>-v ：列出一些看不出来的特殊字符</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">检看 /etc/issue 这个文件的内容：</span><br><span class=\"line\">[root@www ~]<span class=\"meta\"># cat /etc/issue</span></span><br><span class=\"line\">CentOS release <span class=\"number\">6.4</span> (Final)</span><br><span class=\"line\">Kernel \\r on an \\m</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Linux-链接概念\"><a href=\"#Linux-链接概念\" class=\"headerlink\" title=\"Linux 链接概念\"></a>Linux 链接概念</h3><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。</p>\n<h4 id=\"硬连接\"><a href=\"#硬连接\" class=\"headerlink\" title=\"硬连接\"></a>硬连接</h4><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>\n<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>\n<h4 id=\"软连接\"><a href=\"#软连接\" class=\"headerlink\" title=\"软连接\"></a>软连接</h4><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">通过实验加深理解</span><br><span class=\"line\">[oracle@Linux]$ touch f1          #创建一个测试文件f1</span><br><span class=\"line\">[oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2</span><br><span class=\"line\">[oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3</span><br><span class=\"line\">[oracle@Linux]$ ls -li            # -i参数显示文件的inode节点信息</span><br><span class=\"line\">total <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">9797648</span> -rw-r--r--  <span class=\"number\">2</span> oracle oinstall <span class=\"number\">0</span> Apr <span class=\"number\">21</span> <span class=\"number\">08</span>:<span class=\"number\">11</span> f1</span><br><span class=\"line\"><span class=\"number\">9797648</span> -rw-r--r--  <span class=\"number\">2</span> oracle oinstall <span class=\"number\">0</span> Apr <span class=\"number\">21</span> <span class=\"number\">08</span>:<span class=\"number\">11</span> f2</span><br><span class=\"line\"><span class=\"number\">9797649</span> lrwxrwxrwx  <span class=\"number\">1</span> oracle oinstall <span class=\"number\">2</span> Apr <span class=\"number\">21</span> <span class=\"number\">08</span>:<span class=\"number\">11</span> f3 -&gt; f1</span><br><span class=\"line\">从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 <span class=\"number\">9797648</span>，然而符号连接文件的 inode 节点不同。</span><br><span class=\"line\"></span><br><span class=\"line\">[oracle@Linux]$ echo <span class=\"string\">&quot;I am f1 file&quot;</span> &gt;&gt;f1</span><br><span class=\"line\">[oracle@Linux]$ cat f1</span><br><span class=\"line\">I am f1 file</span><br><span class=\"line\">[oracle@Linux]$ cat f2</span><br><span class=\"line\">I am f1 file</span><br><span class=\"line\">[oracle@Linux]$ cat f3</span><br><span class=\"line\">I am f1 file</span><br><span class=\"line\">[oracle@Linux]$ rm -f f1</span><br><span class=\"line\">[oracle@Linux]$ cat f2</span><br><span class=\"line\">I am f1 file</span><br><span class=\"line\">[oracle@Linux]$ cat f3</span><br><span class=\"line\">cat: f3: No such file <span class=\"keyword\">or</span> directory</span><br><span class=\"line\">通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>\n<ol>\n<li>删除符号连接f3,对f1,f2无影响；</li>\n<li>删除硬连接f2，对f1,f3也无影响；</li>\n<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>\n<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>\n</ol>\n<h2 id=\"Linux-用户和用户组管理\"><a href=\"#Linux-用户和用户组管理\" class=\"headerlink\" title=\"Linux 用户和用户组管理\"></a>Linux 用户和用户组管理</h2><p>Linux系统是一个<strong>多用户多任务的分时操作系统</strong>，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>\n<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>\n<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>\n<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的<strong>主目录</strong>。</p>\n<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>\n<ol>\n<li>用户账号的添加、删除与修改。</li>\n<li>用户口令的管理。</li>\n<li>用户组的管理。</li>\n</ol>\n<h2 id=\"Linux-磁盘管理\"><a href=\"#Linux-磁盘管理\" class=\"headerlink\" title=\"Linux 磁盘管理\"></a>Linux 磁盘管理</h2><p>Linux 磁盘管理好坏直接关系到整个系统的性能问题。</p>\n<p>Linux 磁盘管理常用三个命令为 <strong>df、du 和 fdisk</strong>。</p>\n<p>df（英文全称：disk free）：列出文件系统的整体磁盘使用量<br>du（英文全称：disk used）：检查磁盘空间使用量<br>fdisk：用于磁盘分区</p>\n<h2 id=\"Linux-vi-x2F-vim\"><a href=\"#Linux-vi-x2F-vim\" class=\"headerlink\" title=\"Linux vi&#x2F;vim\"></a>Linux vi&#x2F;vim</h2><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>\n<p>但是目前我们使用比较多的是 <strong>vim 编辑器</strong>。</p>\n<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>\n<h3 id=\"什么是vim\"><a href=\"#什么是vim\" class=\"headerlink\" title=\"什么是vim\"></a>什么是vim</h3><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>\n<p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、<strong>编译</strong>及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<p>简单的来说， vi 是老式的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>\n<p>连 <a href=\"https://www.vim.org/\">vim 的官方网站 </a> 自己也说 vim 是一个<strong>程序开发工具</strong>而不是文字处理软件。</p>\n<img src=\"/2023/04/19/ubuntuNote/classic1.gif\" class=\"\">\n\n<p><strong>中文版</strong>：</p>\n<img src=\"/2023/04/19/ubuntuNote/classic1_cn.gif\" class=\"\">\n\n\n<h3 id=\"vi-x2F-vim-的使用\"><a href=\"#vi-x2F-vim-的使用\" class=\"headerlink\" title=\"vi&#x2F;vim 的使用\"></a>vi&#x2F;vim 的使用</h3><p>基本上 vi&#x2F;vim 共分为三种模式，<strong>命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）</strong>。</p>\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><p><strong>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</strong></p>\n<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p>\n<p>以下是<strong>普通模式</strong>常用的几个命令：</p>\n<blockquote>\n<p><strong>i</strong> – 切换到<strong>输入模式</strong>，在<strong>光标当前位置</strong>开始输入文本。<br>x – 删除当前光标所在处的字符。<br><strong>:</strong> – 切换到<strong>底线命令行模式</strong>，以在<strong>最底一行输入命令</strong>。<br><strong>a</strong> – 进入<strong>插入模式</strong>，在<strong>光标下一个位置</strong>开始输入文本。<br>o：在当前行的下方插入一个新行，并进入插入模式。<br>O – 在当前行的上方插入一个新行，并进入插入模式。<br>dd – 删除当前行。<br>yy – 复制当前行。<br>p（小写） – 粘贴剪贴板内容到光标下方。<br>P（大写）– 粘贴剪贴板内容到光标上方。<br><strong>u</strong> – <strong>撤销上一次操作</strong>。<br><strong>Ctrl + r</strong> – <strong>重做上一次撤销的操作</strong>。<br><strong>:w</strong> – <strong>保存文件</strong>。<br><strong>:q</strong> – <strong>退出 Vim 编辑器</strong>。<br><strong>:wq</strong> – <strong>保存并退出 Vim 编辑器</strong>。<br>:q! – 强制退出Vim 编辑器，不保存修改。(有用的，有时候不想保存又懒得删了)</p>\n</blockquote>\n<p>若想要编辑文本，只需要启动 Vim，进入了命令模式，按下 i 切换到输入模式即可。<br><strong>命令模式只有一些最基本的命令，因此仍要依靠底线命令行模式输入更多命令</strong>。</p>\n<h4 id=\"输入模式\"><a href=\"#输入模式\" class=\"headerlink\" title=\"输入模式\"></a>输入模式</h4><p>在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到普通模式(命令模式)。</p>\n<p>在输入模式中，可以使用以下按键：</p>\n<blockquote>\n<p><strong>字符按键以及Shift组合</strong>，输入字符<br>ENTER，回车键，换行<br>BACK SPACE，退格键，删除<strong>光标前一个字符</strong><br>DEL，删除键，删除<strong>光标后一个字符</strong><br>方向键，在文本中移动光标<br>HOME&#x2F;END，移动光标到行首&#x2F;行尾<br>Page Up&#x2F;Page Down，<strong>上&#x2F;下翻页</strong><br>Insert(INS)，切换光标为<strong>输入&#x2F;替换模式</strong>，光标将变成<strong>竖线&#x2F;下划线</strong><br>ESC，退出输入模式，切换到命令模式</p>\n</blockquote>\n<h4 id=\"底线命令模式\"><a href=\"#底线命令模式\" class=\"headerlink\" title=\"底线命令模式\"></a>底线命令模式</h4><p>在命令模式下按下 :（英文冒号）就进入了底线命令模式。</p>\n<p>底线命令模式可以输入<strong>单个或多个字符的命令</strong>，可用的命令非常多。</p>\n<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>\n<blockquote>\n<p>:w：保存文件。<br>:q：退出 Vim 编辑器。<br>:wq：保存文件并退出 Vim 编辑器。<br>:q!：强制退出Vim编辑器，不保存修改。<br>按 <strong>ESC</strong> 键可随时退出底线命令模式。</p>\n</blockquote>\n<img src=\"/2023/04/19/ubuntuNote/10.png\" class=\"\">\n\n\n<h3 id=\"vi-x2F-vim-使用实例\"><a href=\"#vi-x2F-vim-使用实例\" class=\"headerlink\" title=\"vi&#x2F;vim 使用实例\"></a>vi&#x2F;vim 使用实例</h3><p>你想要使用 vim 来建立一个名为 runoob.txt 的文件时，你可以这样做：<br><code>vim runoob.txt</code></p>\n<p>直接输入 vim 文件名 就能够进入 vim 的一般模式了。请注意，记得 vim 后面一定要加文件名，不管该文件存在与否！</p>\n<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式(编辑模式)了！</p>\n<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>\n<p>这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>\n<p>在一般模式中按下 :wq 即可保存并退出 vim。</p>\n<h3 id=\"vi-x2F-vim-按键说明\"><a href=\"#vi-x2F-vim-按键说明\" class=\"headerlink\" title=\"vi&#x2F;vim 按键说明\"></a>vi&#x2F;vim 按键说明</h3><p>特别注意，在 vi&#x2F;vim 中，数字是很有意义的！数字通常代表<strong>重复做几次</strong>的意思！ 也有可能是代表<strong>去到第几个什么什么</strong>的意思。</p>\n<p>举例来说，要剪切 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p>\n<p>另外要注意：这些都是在一般模式(命令模式)下操作的。</p>\n<h4 id=\"一般模式-光标移动、复制粘贴、搜索替换\"><a href=\"#一般模式-光标移动、复制粘贴、搜索替换\" class=\"headerlink\" title=\"一般模式 (光标移动、复制粘贴、搜索替换)\"></a>一般模式 (光标移动、复制粘贴、搜索替换)</h4><blockquote>\n<p><strong>光标移动</strong></p>\n<ul>\n<li>[Ctrl] + [f]\t屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</li>\n<li>[Ctrl] + [b]\t屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</li>\n<li>0 或功能键[Home]\t这是数字『 0 』：移动到这一行的最前面字符处 (常用)</li>\n<li>$(shift+4) 或功能键[End]\t移动到这一行的最后面字符处(常用)</li>\n<li>nG\t: n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</li>\n<li>G\t移动到这个档案的最后一行(常用)</li>\n<li>gg\t移动到这个档案的第一行，相当于 1G 啊！ (常用)</li>\n<li>n<Enter>\tn 为数字。光标向下移动 n 行(常用)</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>删除、复制与粘贴</strong></p>\n<ul>\n<li>x, X\t在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键，会删除当前光标覆盖的那个字符，因为ubuntu里光标是有宽度的)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键，要先按住shift再按x) (常用)</li>\n<li>dd\t剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</li>\n<li>d1G\t删除光标所在到第一行的所有数据</li>\n<li>dG\t删除光标所在到最后一行的所有数据</li>\n<li>d$\t删除游标所在处，到该行的最后一个字符</li>\n<li>d0\t那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</li>\n<li>yy\t复制游标所在的那一行(常用)</li>\n<li>nyy\tn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</li>\n<li>p, P\tp 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行(只推了第20行)。 (常用)</li>\n<li>u\t复原前一个动作(撤销)。(常用)</li>\n<li>[Ctrl]+r\t重做上一个动作。(常用)<br>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</li>\n<li>.\t不要怀疑！这就是<strong>小数点</strong>！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！(对u、[Ctrl]+r无效，不记录这两个操作) (常用)</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>搜索替换</strong></p>\n<ul>\n<li>&#x2F;word\t向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird(输完按回车进入搜索模式。然后用n&#x2F;N来找) 即可！ (常用)</li>\n<li>n\t这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。</li>\n<li>N\t这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。<br>使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</li>\n<li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g\tn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br>『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</li>\n<li>:1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g\t从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</li>\n<li>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc\t从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</li>\n</ul>\n</blockquote>\n<h4 id=\"一般模式切换到编辑模式的可用的按钮说明\"><a href=\"#一般模式切换到编辑模式的可用的按钮说明\" class=\"headerlink\" title=\"一般模式切换到编辑模式的可用的按钮说明\"></a>一般模式切换到编辑模式的可用的按钮说明</h4><blockquote>\n<p><strong>进入输入或取代的编辑模式</strong></p>\n<ul>\n<li>i, I\t进入输入模式(Insert mode)：<br>i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</li>\n<li>a, A\t进入输入模式(Insert mode)：<br>a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</li>\n<li>o, O\t进入输入模式(Insert mode)：<br>这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</li>\n<li>r, R\t进入取代模式(Replace mode)：<br>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</li>\n<li>[Esc]\t退出编辑模式，回到一般模式中(常用)</li>\n</ul>\n</blockquote>\n<p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</p>\n<h4 id=\"一般模式切换到命令行模式的可用的按钮说明\"><a href=\"#一般模式切换到命令行模式的可用的按钮说明\" class=\"headerlink\" title=\"一般模式切换到命令行模式的可用的按钮说明\"></a>一般模式切换到命令行模式的可用的按钮说明</h4><blockquote>\n<p><strong>指令行的储存、离开等指令</strong></p>\n<ul>\n<li>:w\t将编辑的数据写入硬盘档案中(常用)</li>\n<li>:w!\t若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</li>\n<li>:q\t离开 vim (常用)</li>\n<li>:q!\t若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。<br>注意一下啊，那个惊叹号 (!) 在 vim 当中，常常具有『强制』的意思～</li>\n<li>:wq\t储存后离开，若为 :wq! 则为强制储存后离开 (常用) 虽说强制但也不一定能存上。<br><strong>vim 环境的变更</strong></li>\n<li>:set nu\t显示行号，设定之后，会在每一行的前缀显示该行的行号</li>\n<li>:set nonu\t与 set nu 相反，为取消行号！</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"Extract\"><a href=\"#Extract\" class=\"headerlink\" title=\"Extract\"></a>Extract</h3><h4 id=\"vim-中批量添加注释\"><a href=\"#vim-中批量添加注释\" class=\"headerlink\" title=\"vim 中批量添加注释\"></a>vim 中批量添加注释</h4><h5 id=\"方法一-：块选择模式\"><a href=\"#方法一-：块选择模式\" class=\"headerlink\" title=\"方法一 ：块选择模式\"></a>方法一 ：块选择模式</h5><p><strong>批量注释：</strong></p>\n<p>Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 &#x2F;&#x2F; 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p>\n<p><strong>取消注释：</strong></p>\n<p>Ctrl + v 进入块选择模式，选中<strong>你要删除的行首的注释符号</strong>(选中注释符号，不要多选了)，注意 &#x2F;&#x2F; 要选中两个，选好之后按 d 即可删除注释，ESC 保存退出。</p>\n<h5 id=\"方法二-替换命令\"><a href=\"#方法二-替换命令\" class=\"headerlink\" title=\"方法二: 替换命令\"></a>方法二: 替换命令</h5><p><strong>批量注释：</strong></p>\n<p>使用下面命令在指定的行首添加注释。<br>使用命令格式： :起始行号,结束行号s&#x2F;^&#x2F;注释符&#x2F;g（注意冒号）。</p>\n<p><strong>取消注释：</strong></p>\n<p>使用命令格式： :起始行号,结束行号s&#x2F;^注释符&#x2F;&#x2F;g（注意冒号）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">实例：</span><br><span class=\"line\"><span class=\"number\">1</span>、在 <span class=\"number\">10</span> - <span class=\"number\">20</span> 行添加 <span class=\"comment\">// 注释</span></span><br><span class=\"line\">:<span class=\"number\">10</span>,<span class=\"number\">20</span>s#^#<span class=\"comment\">//#g</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>、在 <span class=\"number\">10</span> - <span class=\"number\">20</span> 行删除 <span class=\"comment\">// 注释</span></span><br><span class=\"line\">:<span class=\"number\">10</span>,<span class=\"number\">20</span>s#^<span class=\"comment\">//##g</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>、在 <span class=\"number\">10</span> - <span class=\"number\">20</span> 行添加 # 注释</span><br><span class=\"line\">:<span class=\"number\">10</span>,<span class=\"number\">20</span>s/^/#/g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>、在 <span class=\"number\">10</span> - <span class=\"number\">20</span> 行删除 # 注释</span><br><span class=\"line\">:<span class=\"number\">10</span>,<span class=\"number\">20</span>s/#<span class=\"comment\">//g</span></span><br><span class=\"line\"></span><br><span class=\"line\">删除注释的时候好像都不需要\\^符号，添加的时候需要\\^。</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"su与sudo-su的区别\"><a href=\"#su与sudo-su的区别\" class=\"headerlink\" title=\"su与sudo su的区别\"></a>su与sudo su的区别</h3><p><strong>sudo &#x3D; Super user do 超级用户do<br>su &#x3D; Shift user 切换用户</strong></p>\n<ol>\n<li><p>su<br>su命令是当前用户用来切换到另一个用户的命令，参数为用户名。执行时会要求输入密码，这个密码是你要切换到的用户的密码。<br>注意，当你是root用户时，切换到本机的其他任何用户都是不需要输入密码的。</p>\n</li>\n<li><p>sudo su<br>sudo su命令和su命令相似，都是用来切换用户的。区别就是两个命令需要输入的密码不一样。<br>sudo su的含义就是要用root权限运行su命令，既然是用root权限运行su命令，那么就不需要输入切换到的用户的密码了。<br>此外，sudo su命令不保留原来shell的环境变量。</p>\n</li>\n</ol>\n<p>本来你如果要从普通用户切换到root用户，你要使用命令：su root 或者 su - 此时你必须要输入root用户的密码，正如上边所讲。<br>但是如果你使用：sudo su 这个命令，直接输入当前用户的密码（也就是当前使用sudo命令的密码）即可切换到root用户。</p>\n<p>要区分这两个密码：</p>\n<ul>\n<li>sudo命令的密码：执行任何sudo开头的命令都要输的密码。</li>\n<li>root用户的密码：su root即切换到root用户时要输的密码。也就是root用户本身的密码。</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.runoob.com/linux/linux-tutorial.html\">Linux 教程</a></p>\n","categories":["System"],"tags":["Ubuntu"]},{"title":"hlsNote","url":"/2022/12/03/hlsNote/","content":"<p><strong>北海虽赊，扶摇可接</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"毕设题目\"><a href=\"#毕设题目\" class=\"headerlink\" title=\"毕设题目\"></a>毕设题目</h1><p><strong>基于HLS的手势识别系统设计</strong></p>\n<p>Design of gesture recognition system based on High Level Synthesis<br>实验室建设，硬件，难</p>\n<p>手势是人们常用的肢体语言之一，符合人类日常习惯的交互手段，是一种自然直观、有效简洁的沟通方式，在日常生活中人们之间的交流通常会辅以手势来传达一些信息或表达某种特定的意图。随着人工智能和计算机视觉技术的迅猛发展，智能化设备逐渐融入到人们生活的方方面面，因此对各类人机交互的需求也在不断增加，手势识别逐渐成为基于计算机视觉的智能人机交互的重要研究领域。 <strong>本项目希望采用面向FPGA应用的高层逻辑综合（HLS）技术，通过学习比较成熟的手势识别相关算法，通过HLS技术将算法转化为FPGA可综合的硬件描述语言（HDL）知识产权（IP）核模块，在FPGA中采用硬件实现基本的手势识别算法，并对比算法的实现性能；通过优化，进一步提高手势识别算法的实时性。</strong> 设计要求如下：</p>\n<blockquote>\n<p>（1）熟悉手势识别处理算法的基本流程，仿真算法的识别效果；<br>（2）利用Xilinx的HLS方法实现算法的优化与性能仿真；<br>（3）搭建FPGA平台，将手势识别算法在FPGA中进行验证，并可以演示；<br>（4）扩展功能：可以进行手势识别与分类显示。</p>\n</blockquote>\n<h1 id=\"HLS简介\"><a href=\"#HLS简介\" class=\"headerlink\" title=\"HLS简介\"></a>HLS简介</h1><h2 id=\"高层综合简介\"><a href=\"#高层综合简介\" class=\"headerlink\" title=\"高层综合简介\"></a>高层综合简介</h2><h2 id=\"HLS设计流程\"><a href=\"#HLS设计流程\" class=\"headerlink\" title=\"HLS设计流程\"></a>HLS设计流程</h2><p>Vivado HLS 的功能简单地来说就是 把 C、 C++ 或 SystemC 的设计转换成 RTL 实现，然后就可以在Xilinx FPGA 或 Zynq 芯片的可编程逻辑中综合并实现了 。需要注意的是，这里我们说的使用 C&#x2F;C++完成的设计与运行在处理器（ ZYNQ中的 ARM处理器或 MicroBlaze软核处理器）中的软件代码是截然不同的。在 HLS中，所有的 C设计都是要在可编程逻辑中实现的，也就是说，我们仍然是在进行硬件设计，只不过使用的不再是硬件描述语言。</p>\n<p>使用Vivado HLS进行设计的流程如下图所示：</p>\n<p>HLS设计的主要输入 是一个 C&#x2F;C++&#x2F;SystemC 设计 ，以及一个基于 C 的测试集 TestBench）。我们首先要知道 C语言的本质就是函数，那么 这个测试集 就是用于验证 C设计中的 函数，验证 过程需要一个 “黄金参考” 。这个 “黄金参考 类似于一个标准答案，用来 和 C设计中 函数所产生的输出做比对。</p>\n<p>在对HLS设计进行综合之前，我们要先对其进行“ 功能性验证 ”，也就是 C仿真，其目的是验证 HLS 输入的 C代码的功能是否正确。验证的方式就是在 TestBench中调用 C设计的函数，然后将其输出与“黄金参考”进行比对，如果与黄金参考有差异就需要先对 C设计进行修改调试。</p>\n<p>接下来就是对设计进行高层综合 ，即 HLS过程本身。该过程涉及到分析和处理基于 C 的代码，加上用户所给出的指令和约束，来创建 RTL描述。高层综合结束后会产生一组输出文件，包括以 Verilog或者VHDL语言编写的 RTL设计文件。</p>\n<p>综合过程结束后得到的RTL模型，可以在 Vivado HLS 中进行 C&#x2F;RTL 协同仿真 ，来进一步验证综合得到的RTL设计的正确性。在这个过程中 Vivado HLS会自动产生一个测试集为 RTL设计提供输入，然后拿它的输出与预期的值做比对。 C功能性验证和 C&#x2F;RTL协同仿真 的区别如下图所示：</p>\n<p>左侧的功能性验证（ C仿真）中，原始测试集是用户输入的测试文件TestBench。而右侧的C&#x2F;RTL协同仿真所需的 RTL测试集是由 Vivado HLS 自动产生的，这样就不再需要人工创建了，所产生的测试集包括了原始测试集和被测 RTL模块之间的数据传递。</p>\n<p>除了对功能进行验证，我们还要评估 RTL设计的实现和性能 。比如，在 FPGA中所需的资源的数量，设计的延迟、所支持的最高时钟频率等是否 满足要求。如果不满足要求，那么就需要设计者通过修改指令和约束，然后再次进行高层综合，一个设计可能要做多次 HLS设计迭代，来找到“最佳 ”的解决方案。如果有必要，设计者也可以返回修改 C设计代码，然后从头开始重新对设计进行验证。</p>\n<p>在设计被验证了之后，而且实现也满足了期望的设计目标，那么就可以集成进更大的系统里了。我们可以直接使用 HLS 过程所产生的 RTL文件（即 VHDL 或 Verilog 代码），更方便的做法是使用 Vivado HLS 的 IP 打包功能。对 Vivado HLS 所产生的输出打包意味着 HLS 设计能够以 IP核的形式引入其他 Xilinx 工具中，比如 Vivado中的 IP 集成器。这两种类型的输出如下图所示：</p>\n<h2 id=\"接口与算法综合\"><a href=\"#接口与算法综合\" class=\"headerlink\" title=\"接口与算法综合\"></a>接口与算法综合</h2><p>设计者需要分析设计的两个主要方面：</p>\n<ul>\n<li>设计的 接口 ，也就是它的顶层连接</li>\n<li>设计的 功能 ，也就是它所实现的算法</li>\n</ul>\n<p>给出一个HLS设计中接口和功能的概念图 </p>\n<p>在上图中，两端的绿色区域表示设计的输入和输出接口，其中展示了部分接口类型，如RAM接口、 FIFO接口，以及总线类型的接口等。这些接口可以是HLS工具从代码中通过 接口综合（ Interface Synthesis 得到的，也可以由设计者手动指定具体的接口类型。</p>\n<p>图中间黄色的区域表示HLS设计具体能够实现的功能，对于不同的应用，其功能也各不相同。 在 Vivado HLS 设计中，功能是从输入的代码中，经过算法综合（ Algorithm Synthesis）的过程得到的 。</p>\n<h3 id=\"接口综合：\"><a href=\"#接口综合：\" class=\"headerlink\" title=\"接口综合：\"></a>接口综合：</h3><p>在这里我们先简单介绍一下接口综合。顾名思义，Interface Synthesis指的是 HLS 设计中对接口的综合，综合出来的接口能够与系统中的其他模块通信，还有可能需要与系统中的处理器进行通信。<br>这里接口的概念既包括端口（port），也包含所使用的协议。所有端口的细节（如类型、位宽和方向是从 C&#x2F;C++ 文件中<strong>顶层函数的参数和返回值</strong>里推断出来的；而协议是从端口的表现（行为）推断出来的。比如，最简单的接口可以是一条 1 比特的线（ wire），而更复杂的接口，可能要用总线或 RAM 接口。接口综合能够推断出来的接口类型包括：线、寄存器、单向和双向握手信号 、 FIFO、存储器和总线等。</p>\n<p><strong>举例：</strong> 下面给出一个简单的C设计的顶层函数，函数名为 find_average_of_best_X()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">find_average_of_best_X</span><span class=\"params\">(<span class=\"type\">int</span> *average, <span class=\"type\">int</span> samples[<span class=\"number\">8</span>], <span class=\"type\">int</span> X)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主题函数（生命，子函数调用等）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数内部工作的详细情况无关紧要，不过<strong>每个参数的读 &#x2F;写操作</strong>将决定综合出来的端口的方向。这个函数定义包含三个参数，数组“sample”和整数 “X”是函数的输入，而 average作为函数的输出。因此，简单来说，这三个函数参数要被 HLS 转换成两个输入接口和一个输出接口，如下图所示：</p>\n<p>需要注意的是，上图只是一个简化了的接口示意图。根据<strong>所用的协议</strong>，这些接口可能包括数据端口以外的控制输入或输出，如下图所示：</p>\n<p>上图是 函数 find_average_of_best_X()经 HLS综合出来的完整的 RTL模块的接口图。从图中可以看到由函数的三个参数所综合出来的接口<strong>分别拥有了各自的协议</strong>，如 ap_memory协议、 ap_none协议和 ap_vld协议。同时模块还多出来了一些端口，如 ap_clk和 ap_rst等，它们使用的是 ap_ctrl_hs 协议。这些协议决定了相应的接口是如何与<strong>系统中其他模块</strong>进行交互的， 至于<strong>各协议具体的含义以及如何为接口选择其协议</strong>，将是学习HLS设计的重点。</p>\n<h3 id=\"算法综合\"><a href=\"#算法综合\" class=\"headerlink\" title=\"算法综合\"></a>算法综合</h3><p>算法综合关注的是设计的功能，即设计所期望的行为，它是由输入的C设计所描述的。算法综合从代码中推出各种运算操作，然后转换成一组 RTL语句。<br>算法综合包括三个主要阶段，依次是：</p>\n<ul>\n<li>解析出数据通路和控制电路；</li>\n<li>调度和绑定；</li>\n<li>优化；</li>\n</ul>\n<h4 id=\"解析出数据通路和控制电路\"><a href=\"#解析出数据通路和控制电路\" class=\"headerlink\" title=\"解析出数据通路和控制电路\"></a>解析出数据通路和控制电路</h4><p>HLS 的第一个阶段是分析 C&#x2F;C++&#x2F;SystemC代码，并且解释所需的功能。 Vivado HLS从以下几个方面分析程序 逻辑和算法的运算、条件语句和分支、 数组运算和循环 等。<br>所产生的实现会具有一个数据通路元件，一般还会有一个控制元件。<del>需要澄清的是，这里的“数据通路”处理指的是在数据样本上作的运算，而“控制”是协同数据流处理所需的电路。</del> 算法的本质定义出数据通路和控制元件，设计者可以在 HLS中采取专门的步骤来最小化控制元件的复杂度。</p>\n<h4 id=\"调度和绑定\"><a href=\"#调度和绑定\" class=\"headerlink\" title=\"调度和绑定\"></a>调度和绑定</h4><p>HLS 是由两个主要过程组成的：调度（ Scheduling）和绑定 Binding）。它们是交替进行的，彼此互相影响，如下图所示：</p>\n<ul>\n<li>调度 是把由 C 代码解释得到的 RTL 语句翻译成一组运算，每个运算都关联着一定的执行时间，以时钟周期为单位。这个阶段所作的决策，受时钟频率和不确定度、目标芯片的技术和用户所施加的指令所影响。</li>\n<li>绑定 是调度好了的运算和目标芯片上的实际资源联系起来的过程。这些资源的功能和时序特征可能会影响调度，因此绑定信息会反馈给调度过程。</li>\n</ul>\n<p>比如，如果综合出来的算法需要做一组算术运算，HLS过程就必须根据目标的时钟频率和不确定度来决定如何调度这些运算（要分配多少个时钟周期来完成），以及如何绑定这些运算（也就是如何把运算映射到 PL上的可计算资源里）。 C源码并不能表达或指定硬件架构，但是通过施加指令，源码确实可以产生不同的架构。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>有两种方法可以用来调整HLS过程的行为，让高层综合朝着设计者的实现目标而努力，从而影响结果：</p>\n<ul>\n<li>约束：设计者可以对设计的某些指标加以限制。比如，可以指定最低的时钟周期。这样就能确保实现结果能够满足要集成进去的系统的要求。类似的，设计者可以选择约束资源的利用情况 或其他的指标，从而优化应用的设计。</li>\n<li>指令：设计者可以通过指令对 RTL的实现参数施加更具体的影响。有各种类型的指令，分别映射在代码的某些特征上，比如让设计者可以指定 HLS引擎如何处理 C代码中识别出来的循环或数组，或是某个特定运算的延迟。这能导致 RTL输出的巨大改变。因此，具有了指令的知识，设计者就可以根据应用的需求来做优化了。</li>\n</ul>\n<h2 id=\"HLS库\"><a href=\"#HLS库\" class=\"headerlink\" title=\"HLS库\"></a>HLS库</h2><p>Vivado HLS中包含了一系列的 C库（包括 C和 C++），方便对一些常用的硬件结构或功能使用 C&#x2F;C++进行建模，并且能够综合成 RTL。 在 Vivado HLS中提供的 C库有下面几种类型：</p>\n<blockquote>\n<ol>\n<li>任意精度数据类型库</li>\n<li>HLS Stream库</li>\n<li>HLS 数学库</li>\n<li>HLS 视频库</li>\n<li>HLS IP库</li>\n<li>HLS 线性代数库</li>\n</ol>\n</blockquote>\n<p>在HLS设计中调用库中的函数可以大大提高开发效率&#x3D;。</p>\n<h1 id=\"HLS-编程\"><a href=\"#HLS-编程\" class=\"headerlink\" title=\"HLS 编程\"></a>HLS 编程</h1><h2 id=\"循环入门\"><a href=\"#循环入门\" class=\"headerlink\" title=\"循环入门\"></a>循环入门</h2><p>为了提升性能，循环常采用“流水打拍”或“展开”，以便充分利用FPGA架构的高度分布化和并行化。</p>\n<h3 id=\"循环流水打拍\"><a href=\"#循环流水打拍\" class=\"headerlink\" title=\"循环流水打拍\"></a>循环流水打拍</h3><p>流水打拍循环允许在前一次循环迭代完成前就启动后一次循环迭代，从而支持部分循环在执行时重叠。默认情况下，循环的每次迭代仅在前一次迭代完成后才会开始。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vadd: <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    c[i] = a[i] + b[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假定在硬件中，一次循环迭代需要三个周期，同时假定循环变量len为20，即vadd循环在内核内运行20次迭代。因此，总计需要60个时钟周期才能完成此循环的所有操作。<br><strong>tips:</strong> 最好始终按照以上实力所示方式来标记循环（vadd:…），这样有助于在Vitis HLS中进行设计调试。</p>\n<p>循环流水打拍支持该循环的后续迭代发生重叠且以并发方式运行，循环流水打拍可以通过在循环主体里添加 <code>pragma HLS PIPELINE</code> 来启用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vadd: <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"meta\"># <span class=\"keyword\">pragma</span> HLS PIPELINE</span></span><br><span class=\"line\">    c[i] = a[i] + b[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动下一次循环迭代所需要的周期数称为流水打拍循环的启动时间间隔（Initiation Interval，II）。II&#x3D;2表示循环的下一次迭代会在当前迭代发生的2个周期后启动。II&#x3D;1是理想情况，即每个周期都会启动一次循环迭代。使用 <code>pragma HLS PIPELINE</code> 时，可以指定编译器要实现的II，默认情况下编译器将尝试实现II&#x3D;1。</p>\n<p>下图展示了流水打拍循环和非流水打拍循环的执行差异。</p>\n<p><img src=\"https://i.postimg.cc/9QnLjBVr/10.jpg\"></p>\n<p><strong>tips：</strong> 循环流水打拍会自动展开流水打拍循环内部嵌套的任意循环</p>\n<p>如果循环内部存在任何数据依赖关系，则有可能无法实现II&#x3D;1，并且可能导致启动时间间隔增大。在以下示例中，循环结果用作循环持续条件或退出条件，只有在前一次迭代结束后后一次循环迭代才能开始。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Minim_Loop: <span class=\"keyword\">while</span>(a != b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a&gt;b) a-= b; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> b -= a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动循环流水打拍\"><a href=\"#自动循环流水打拍\" class=\"headerlink\" title=\"自动循环流水打拍\"></a>自动循环流水打拍</h3><p>config_compile -pipeline_loops 命令会根据迭代次数对循环进行自动流水打拍循环，低于指定迭代次数限值的所有循环都将自动流水打拍，默认值是64。<br>如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (y=<span class=\"number\">0</span>; y&lt;<span class=\"number\">480</span>; y++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x=<span class=\"number\">0</span>; x&lt;<span class=\"number\">640</span>; x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 pipeline_loops 选项设置为 6，那么以上代码片段中最内层的 for 循环将自动流水打拍。这等同于以下代码片段：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (y=<span class=\"number\">0</span>; y&lt;<span class=\"number\">480</span>; y++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x=<span class=\"number\">0</span>; x&lt;<span class=\"number\">640</span>; x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"meta\"># <span class=\"keyword\">pragma</span> HLS PIPELINE II=1</span></span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"HLS-库\"><a href=\"#HLS-库\" class=\"headerlink\" title=\"HLS 库\"></a>HLS 库</h2><h3 id=\"任意精度数据类型库-arbitrary-precision\"><a href=\"#任意精度数据类型库-arbitrary-precision\" class=\"headerlink\" title=\"任意精度数据类型库(arbitrary precision)\"></a>任意精度数据类型库(arbitrary precision)</h3><p><strong>tips:</strong> Vitis HLS 中C语言不支持任意精度数据类型库，只能在C++中使用，参考 <a href=\"https://support.xilinx.com/s/article/75770?language=en_US%E3%80%82\">https://support.xilinx.com/s/article/75770?language=en_US。</a></p>\n<p>Vitis HLS可以为C++提供整数数据类型和定点任意精度数据类型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">语言</th>\n<th align=\"center\">整数数据类型</th>\n<th align=\"center\">所需头文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">C++</td>\n<td align=\"center\">ap_[u]int&lt;W&gt;，位宽为1024，可扩展到4K位</td>\n<td align=\"center\">#include “ap_int.h”</td>\n</tr>\n<tr>\n<td align=\"center\">C++</td>\n<td align=\"center\">ap_[u]fixed&lt;W&gt;</td>\n<td align=\"center\">#include “ap_fixed.h”</td>\n</tr>\n</tbody></table>\n<h4 id=\"用于-C-的任意整数精度类型\"><a href=\"#用于-C-的任意整数精度类型\" class=\"headerlink\" title=\"用于 C++ 的任意整数精度类型\"></a>用于 C++ 的任意整数精度类型</h4><p>头文件ap_int.h用于为C++定义任意精度整数数据类型，要在C++中使用任意精度整数数据类型，请执行以下操作：</p>\n<ol>\n<li>引入头文件 ap_int.h</li>\n<li>针对有符号的类型将位类型更改为ap_int&lt;N&gt;，针对无符号的类型使用ap_uint&lt;N&gt;，其中N为范围介于1~1024之间的位大小。</li>\n</ol>\n<p>以下示例显示了如何添加头文件并实现 2 个变量来使用 9 位整数和 10 位无符号的整数类型：<br><code>#include &quot;ap_int.h&quot;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo_top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ap_int&lt;<span class=\"number\">9</span>&gt; var1;</span><br><span class=\"line\">    ap_uint&lt;<span class=\"number\">10</span>&gt; var2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>tips:</strong> AP数据类型的劣势之一是阵列不会以0值进行自动初始化，如果需要初始化阵列，必须手动执行。</p>\n<h4 id=\"用于-C-的任意精度定点数据类型\"><a href=\"#用于-C-的任意精度定点数据类型\" class=\"headerlink\" title=\"用于 C++ 的任意精度定点数据类型\"></a>用于 C++ 的任意精度定点数据类型</h4><p>使用定点数据类型执行的C++语言 仿真的行为与综合创建的硬件的行为 相匹配，从而能够使用C语言层次快速仿真来分析位精度、量化和上溢的影响，在Vitis HLS中使用定点数据非常重要。</p>\n<h1 id=\"Vitis-使用\"><a href=\"#Vitis-使用\" class=\"headerlink\" title=\"Vitis 使用\"></a>Vitis 使用</h1><p>Vitis 软件平台支持嵌入式软件开发流程作为SDK的新一代技术，也支持Vitis应用加速开发流程，以满足使用基于Xilinx FPGA的最新软件加速功能的需求。</p>\n<p>下图展示了Vitis 嵌入式软件应用开发工作流程：</p>\n<h2 id=\"嵌入式软件开发流程\"><a href=\"#嵌入式软件开发流程\" class=\"headerlink\" title=\"嵌入式软件开发流程\"></a>嵌入式软件开发流程</h2><ul>\n<li>硬件工程师负责设计软件开发（从 Vivado® Design Suite 导出 XSA 存档文件）所需的逻辑和导出信息。</li>\n<li>软件开发者负责通过创建平台来将 XSA（Xilinx Shell Archive） 导入 Vitis 软件平台，平台包含硬件规格和软件环境设置。</li>\n<li>软件环境设置称为域，同样属于平台的一部分。</li>\n<li>软件开发者基于平台和域来创建应用。</li>\n<li>应用可在 Vitis IDE 中进行调试。</li>\n<li>在复杂系统中，可能有多个应用同时运行并彼此通信。因此也需要执行系统级别验证。</li>\n<li>全部就绪后，Vitis IDE 即可帮助创建启动镜像，用于初始化系统和启动应用。</li>\n</ul>\n<h2 id=\"Vitis-软件平台中的工作空间结构\"><a href=\"#Vitis-软件平台中的工作空间结构\" class=\"headerlink\" title=\"Vitis 软件平台中的工作空间结构\"></a>Vitis 软件平台中的工作空间结构</h2><p>在 Vitis 工作空间内有两种类型的工程：</p>\n<ul>\n<li>工作空间：打开 Vitis 软件平台时，会创建工作空间。工作空间即供 Vitis 软件平台用于存储工程数据和元数据的目录位置。初始工作空间位置必须在启动 Vitis 软件平台时提供。</li>\n<li>XSA：XSA 是从 Vivado Design Suite 导出的。它包含各种硬件规格，例如，处理器配置属性、外设连接信息、地址映射和器件初始化代码等。创建平台工程时，必须提供 XSA。</li>\n<li>平台：<strong>目标平台</strong>（或称平台）是由硬件组件 (XSA) 和软件组件（<strong>域&#x2F;BSP</strong>、FSBL 之类的启动组件等）组合而成的。存储库(repository)内的平台不可编辑。 <strong>工作空间内</strong>的平台可编辑(custom 定制化)，称为<strong>平台工程</strong>。</li>\n<li>平台工程：平台工程可以提供硬件信息和软件运行时（runtime）环境。它可定制，您可<strong>添加域和修改域</strong>设置。 平台工程可通过导入 XSA 或者通过导入现有平台的方式来创建。在同一个平台工程上可以创建多个<strong>系统工程</strong>，以便共享硬件和软件环境设置。</li>\n<li>域：域即板级支持包 (BSP) 或操作系统 (OS)，其中包含软件驱动程序集合，您可在其中构建自己的应用。您可创建多个应用并在同一个域上运行。在平台中，每个域都绑定到单个处理器或者一个由同构处理器组成的集群（例如：A53_0 或 A53）。</li>\n<li>系统工程：系统工程用于将任一器件上同时运行的应用组合在一起。在系统工程中，同一个处理器的两个独立应用不能组合在一起。在系统工程中，2 个 Linux 应用可以组合在一起。每个工作空间均可包含多个系统工程。</li>\n<li>应用（软件工程）：每个应用包含一个或多个源文件以及必要的头文件，以允许编译和生成二进制输出 (ELF)文件。每个系统工程均可包含多个应用工程。每个软件工程都必须包含一个对应的域（应用对域是多对一的关系）。</li>\n</ul>\n<h2 id=\"Vitis-软件平台与-SDK-之比较\"><a href=\"#Vitis-软件平台与-SDK-之比较\" class=\"headerlink\" title=\"Vitis 软件平台与 SDK 之比较\"></a>Vitis 软件平台与 SDK 之比较</h2><h1 id=\"使用-pynq-z2-完成HLS流程\"><a href=\"#使用-pynq-z2-完成HLS流程\" class=\"headerlink\" title=\"使用 pynq-z2 完成HLS流程\"></a>使用 pynq-z2 完成HLS流程</h1><p>Overlay由 两个主要部分组成 bitstream文件 和 hwh Hardware Handoff 文件。可以说 <strong>Overlay设计 其实就是一种 PL与PS的交互设计</strong>。<br>PYNQ overlay具有 Python接口 ，从而允许软件程序员像使用其他任何Python软件包一样使用它，程序员可以在运行时将overlay下载到 Zynq PL中，以提供软件应用程序所需的功能。</p>\n<p>因此，想要设计Overlay，需要先学习PS与PL的交互。</p>\n<h2 id=\"PS与PL的交互\"><a href=\"#PS与PL的交互\" class=\"headerlink\" title=\"PS与PL的交互\"></a>PS与PL的交互</h2><h3 id=\"ZYNQ-PS与PL的接口\"><a href=\"#ZYNQ-PS与PL的接口\" class=\"headerlink\" title=\"ZYNQ PS与PL的接口\"></a>ZYNQ PS与PL的接口</h3><p>ZYNQ PS与PL之间有九路AXI接口。<strong>在PL侧，有4路AXI Master HP(高性能)接口，2路AXI Master GP（通用）接口，2路AXI Slave GP接口和1路AXI Master ACP接口。</strong> PS中还有连接到PL的GPIO控制器，如下图：</p>\n<h3 id=\"linux内核-如何与-PL-交互\"><a href=\"#linux内核-如何与-PL-交互\" class=\"headerlink\" title=\"linux内核 如何与 PL 交互\"></a>linux内核 如何与 PL 交互</h3><p>pynq是基于linux的，而linux运行在PS中，那么linux如何与PL进行交互：</p>\n<p>上图中看到了用于交互的linux驱动程序，linux内核与PL的FPGA之间通过<strong>linux驱动fpga_manager, sysgpio, uio, devmem 和 xlnk</strong> 进行交互，这些 <strong>驱动</strong> 和 <strong>PS与PL之间的接口</strong> 的对应关系是： </p>\n<ul>\n<li>fpga_manager 用于下载bitstream（位流）文件到PL</li>\n<li>sysgpio 控制PS与PL之间的EMIO接口</li>\n<li>uio 实现PL到PS的中断管理</li>\n<li>devmem 用于PS侧的AXI <strong>Master</strong> GP接口</li>\n<li>xlnk 用于PS侧的AXI Slave GP接口 和 AXI Slave HP接口</li>\n</ul>\n<h3 id=\"PYNQ-接口类-Python-如何与-linux内核-交互\"><a href=\"#PYNQ-接口类-Python-如何与-linux内核-交互\" class=\"headerlink\" title=\"PYNQ 接口类 (Python 如何与 linux内核 交互)\"></a>PYNQ 接口类 (Python 如何与 linux内核 交互)</h3><p>在 PYNQ 架构图中可以看到，上面所述 <strong>linux驱动</strong> 已经包装在Python库中。</p>\n<p>在PYNQ中除了 <strong>PL类</strong> 用于通过 fpga_manager驱动下载 bitstream文件到 PL外，还有四个 PYNQ接口类 用于管理 ZYNQ PS（包括 PS DRAM）和 PL接口之间的数据移动。这四个类分别是：</p>\n<ul>\n<li>GPIO (General Purpose Input&#x2F;Output 通用输入输出)：用于控制连接到PL侧的 GPIO外设，也可用作IP的终端或复位信号</li>\n<li>MMIO (Memory Mapped IO 内存映射IO)：可以使用Python代码访问与PS AXI Master GP接口相连的具有 PL AXI Slave GP 接口的IP核</li>\n<li>Xlnk (Memory allocation 内存分配)</li>\n<li>DMA (Direct Memory Access 直接内存访问)</li>\n</ul>\n<p><strong>Xlnk类与DMA类：</strong> 具有AXI Master接口的IP不受PS的直接控制，并且这样的IP允许直接访问DRAM。在访问DRAM之前，应先使用Xlnk类 <strong>分配内存</strong> 供IP使用。对于需要实现 PS DRAM 与 IP 之间更高性能的数据传输，可以使用 DMA。为此 PYNQ提供了 DMA类。</p>\n<p>类的使用取决于IP的接口以及连接的 PS端的接口。<br>设计Overlay时应该考虑使用的接口类型以及使用哪些类来驱动IP。</p>\n<h2 id=\"Overlay-设计GPIO-实验\"><a href=\"#Overlay-设计GPIO-实验\" class=\"headerlink\" title=\"Overlay 设计GPIO 实验\"></a>Overlay 设计GPIO 实验</h2><p>ZYNQ有 54个MIO和 64个EMIO 其中EMIO是 PS与PL进行交互 的最简单直接的方式。在 PYNQ的 overlay设计中，自然少不了GPIO（EMIO）的使用。Overlay设计中涉及到的 <strong>GPIO有两种，一种是 EMIO，另一种是 AXI GPIO</strong>。</p>\n<p>Zynq器件具有从 PS到 PL的多达 64个 GPIO。 这些 GPIO也被称为 EMIO 是一个非常简单的接口。</p>\n<p>Zynq的 GPIO使用 Linux内核模块来控制。这意味着操作系统在运行时会为 GPIO分配一个数字。在PYNQ中使用 GPIO 之前，<strong>须将Linux引脚号映射到 Python GPIO实例，GPIO类中的 get_gpio_pin() 函数用于将 Zynq的GPIO的引脚号 映射到 Linux的gpio引脚号 。</strong><br>from pynq import GPIO</p>\n<p>先结束了，暂时用不上python了，电脑串口连接不上 pynq-2 是有些USB线无法传输数据。</p>\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><p>Board_File中的PYNQ-Z2文件夹复制到Vitis安装目录下Vivado\\2022.2\\data\\boards\\board_files后可以在创建工程时直接选择板子，为Vitis和Vitis HLS添加board_files也按这个步骤来。在创建block design时创建ZYNQ IP核后，运行Run Block Automation时应该勾选Apply Board Preset，这样我们前面复制的board file会自动将ddr,时钟等基本配置给设置好,就不用一个一个要我们去设置了。</p>\n<img src=\"/2022/12/03/hlsNote/121.png\" class=\"\">\n\n\n<p>器件的选择参考<a href=\"https://blog.csdn.net/Zenor_one/article/details/89453987\">Xilinx FPGA 芯片命名规则</a></p>\n<h2 id=\"按键控制LED实验\"><a href=\"#按键控制LED实验\" class=\"headerlink\" title=\"按键控制LED实验\"></a>按键控制LED实验</h2><p>本实验使用 Vivado HLS 生成一个带有输入输出接口（ap_none）的IP核。学习使用C Simulation。</p>\n<p>设计的输入有 C&#x2F;C++设计， Testbench测试集 以及 Constraints（约束）&#x2F;directives（指令）。我们可以使用C Testbench对C程序进行仿真验证程序输出的正确性，也就是C Simulation， 此C Testbench也可以用来对综合后得到的RTL设计进行仿真，也即C&#x2F;RTL协同仿真。</p>\n<p>HLS规定了 <strong>协议、端口类型和方向</strong>之间的相关性，在HLS开发过程中，考虑C&#x2F;C++函数参数的类型是十分重要的。Vitis HLS规定可以 传入&#x2F;传出 C&#x2F;C++ 函数的值有四种不同的数据类型，分别是<strong>变量、指针、数组和引用</strong>。一种特定的参数类型只对应有限的几种协议，如：传入一个数组作为形参，能使用的协议只有：ap_hs, ap_memory, bram, ap_fifo, ap_bus, axis 和 m_axi, 其中 ap_memory是默认的，参数类型对应的接口协议如下：</p>\n<p>D：表示default，表示HLS工具默认综合出来的接口类型；<br>S：表示support，表示HLS工具支持综合出来的接口类型；</p>\n<p>使用ap_none协议且<strong>变量作为形参</strong>时，接口只能被综合成输入（I）接口而不能被综合成输出接口。而指针变量作为形参则可以被综合成输入、输出和双向端口。</p>\n<h2 id=\"呼吸灯\"><a href=\"#呼吸灯\" class=\"headerlink\" title=\"呼吸灯\"></a>呼吸灯</h2><p>本实验使用HLS生成一个带有AXI4-Lite总线接口的IP核。学习使用 C&#x2F;RTL Simulation 协同仿真。在ZYNQ PS端通过AXI4-Lite总线来配置呼吸灯IP核的频率和开关。</p>\n<p>AXI的英文全称是 Advanced eXtensible Interface，即高级可扩展接口，它是ARM公司所提出的 AMBA(Advanced Microcontroller Bus Architecture)协议的一部分。 AXI协议包含了 AXI4、 AXI4 Lite和 AXI Stream三种协议。</p>\n<p>AXI4 协议支持突发传输，主要用于处理器访问存储器 等需要指定地址的高速数据传输场景。AXI4-Lite为外设提供单个数据传输，主要用于访问一些低速外设中的 寄存器。<br>AXI-Stream 接口则像 FIFO 一样，数据传输时 不需要地址，在主从设备之间直接<strong>连续读写数据</strong>，主要用于如视频、高速AD、PCIe、DMA接 口等需要高速数据传输的场合。</p>\n<p>AXI4 -Lite 接口是简化版的 AXI4 接口，用于较少数据量的存储映射通信。本次实验只需要配置呼吸灯IP核的频率和 开关 ，因此接口类型选择 AXI4-Lite 接口。</p>\n<h2 id=\"基于xfOpenCV的中值滤波\"><a href=\"#基于xfOpenCV的中值滤波\" class=\"headerlink\" title=\"基于xfOpenCV的中值滤波\"></a>基于xfOpenCV的中值滤波</h2><p>图像的频率指的是空间频率，它和我们认知的物理频率是不同的。图像的频率是表征图像中<strong>灰度变化剧烈程度</strong>的指标，是灰度在平面空间上的梯度。不同频率信息在图像结构中有不同的作用。</p>\n<p>图像的主要成分是低频信息，它形成了图像的基本灰度等级，对图像结构的决定作用较小；<br>中频信息决定了图像的基本结构，形成了图像的主要边缘结构；<br>高频信息形成了图像的边缘和细节，是在中频信息上对图像内容的进一步强化。</p>\n<p>中值滤波是一种基于排序统计理论的非线性信号处理技术，它可以消除孤立的噪声点，从而让图像中的像素值更接近真实值。红外图像中的盲元就是一种孤立噪点的例子，如下图所示：</p>\n<img src=\"/2022/12/03/hlsNote/38.png\" class=\"\">\n\n<p>由于红外探测器制造过程中的缺陷，传感器中某些像元的输出可能会非常大，导致图像中对应的像素点非常亮，我们称之为盲元。盲元在图像中属于脉冲噪声，中值滤波对这类脉冲噪声具有良好的滤除作用，特别是在滤除噪声的同时，能够保护信号的边缘，使之不被模糊。这些优良特性是线性滤波方法所不具备的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>  <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;ov5640_median_filter.h&quot;</span></span></span><br><span class=\"line\"><span class=\"number\">2</span>  </span><br><span class=\"line\"><span class=\"number\">3</span>  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ov5640_median_filter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">4</span>          hls::stream&lt; ap_axiu&lt;<span class=\"number\">24</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&gt; &gt;&amp; _src,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">5</span>          hls::stream&lt; ap_axiu&lt;<span class=\"number\">24</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&gt; &gt;&amp; _dst</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">6</span>          )</span></span>&#123;</span><br><span class=\"line\"><span class=\"number\">7</span>  </span><br><span class=\"line\"><span class=\"number\">8</span>  <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE axis register both  port=_src</span></span><br><span class=\"line\"><span class=\"number\">9</span>  <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE axis register both  port=_dst</span></span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE ap_ctrl_none port=return</span></span><br><span class=\"line\"><span class=\"number\">11</span> <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS dataflow</span></span><br><span class=\"line\"><span class=\"number\">12</span> </span><br><span class=\"line\"><span class=\"number\">13</span>     <span class=\"comment\">//定义xf::mat格式变量</span></span><br><span class=\"line\"><span class=\"number\">14</span>      xf::Mat&lt;XF_8UC3, HEIGHT, WIDTH, XF_NPPC1&gt; imgInput1;</span><br><span class=\"line\"><span class=\"number\">15</span>      xf::Mat&lt;XF_8UC1, HEIGHT, WIDTH, XF_NPPC1&gt; imgGray;</span><br><span class=\"line\"><span class=\"number\">16</span>      xf::Mat&lt;XF_8UC1, HEIGHT, WIDTH, XF_NPPC1&gt; imgMedian;</span><br><span class=\"line\"><span class=\"number\">17</span>      xf::Mat&lt;XF_8UC3, HEIGHT, WIDTH, XF_NPPC1&gt; imgOutput1;</span><br><span class=\"line\"><span class=\"number\">18</span> </span><br><span class=\"line\"><span class=\"number\">19</span> <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS stream variable=imgInput1.data dim=1 depth=1</span></span><br><span class=\"line\"><span class=\"number\">20</span> <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS stream variable=imgGray.data   dim=1 depth=1</span></span><br><span class=\"line\"><span class=\"number\">21</span> <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS stream variable=imgMedian.data dim=1 depth=1</span></span><br><span class=\"line\"><span class=\"number\">22</span> <span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS stream variable=imgOutput1.data dim=1 depth=1</span></span><br><span class=\"line\"><span class=\"number\">23</span> </span><br><span class=\"line\"><span class=\"number\">24</span>     <span class=\"comment\">//将AXI Stream格式的视频转成xf::mat格式</span></span><br><span class=\"line\"><span class=\"number\">25</span>     xf::<span class=\"built_in\">AXIvideo2xfMat</span>(_src, imgInput1);</span><br><span class=\"line\"><span class=\"number\">26</span> </span><br><span class=\"line\"><span class=\"number\">27</span>     <span class=\"comment\">//将RGB格式图像转成灰度图像</span></span><br><span class=\"line\"><span class=\"number\">28</span>     xf::<span class=\"built_in\">rgb2gray</span>&lt;XF_8UC3,XF_8UC1,HEIGHT, WIDTH, XF_NPPC1&gt;(imgInput1, imgGray);</span><br><span class=\"line\"><span class=\"number\">29</span> </span><br><span class=\"line\"><span class=\"number\">30</span>     <span class=\"comment\">//对灰度图像进行中值滤波</span></span><br><span class=\"line\"><span class=\"number\">31</span>     xf::medianBlur&lt;<span class=\"number\">3</span>,XF_BORDER_REPLICATE,XF_8UC1,HEIGHT, WIDTH, XF_NPPC1&gt;</span><br><span class=\"line\"><span class=\"number\">32</span>         (imgGray, imgMedian);</span><br><span class=\"line\"><span class=\"number\">33</span> </span><br><span class=\"line\"><span class=\"number\">34</span>     <span class=\"comment\">//将灰度图像转成RGB三个通道的灰度图像</span></span><br><span class=\"line\"><span class=\"number\">35</span>     xf::<span class=\"built_in\">gray2rgb</span>&lt;XF_8UC1,XF_8UC3,HEIGHT, WIDTH, XF_NPPC1&gt;(imgMedian,imgOutput1);</span><br><span class=\"line\"><span class=\"number\">36</span> </span><br><span class=\"line\"><span class=\"number\">37</span>     <span class=\"comment\">//将xf::mata格式的图像转成AXI Stream格式</span></span><br><span class=\"line\"><span class=\"number\">38</span>     xf::<span class=\"built_in\">xfMat2AXIvideo</span>(imgOutput1, _dst);</span><br><span class=\"line\"><span class=\"number\">39</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>参数NPC表示每个时钟处理的像素个数（Number of pixels per clock），在代码中设置为XF_NPPC1，表示每个时钟处理一个像素。</p>\n<p>代码的19至22行的编译指令用于指示xf::Mat格式变量中的<strong>data成员</strong>使用<strong>流（stream）数据来通信</strong>，<strong>即采用FIFO</strong>来实现，而<strong>不是默认的RAM</strong>。后面的选项<strong>dim&#x3D;1</strong>表示用于转换成FIFO的数组是一维的，<strong>depth&#x3D;1</strong>表示<strong>FIFO的深度为1</strong>。在应用<strong>dataflow</strong>优化时，<strong>多个函数之间</strong>以<strong>流水线的形式</strong>处理<strong>图像数据流</strong>，因为每个时钟只处理一个像素，因此FIFO的深度没有必要太大，设置成1可以减少FPGA存储资源的消耗。</p>\n<p>以上参考自<a href=\"https://www.amobbs.com/thread-5740463-1-1.html\">基于xfOpenCV的中值滤波实验</a></p>\n<h2 id=\"基于BRAM的PS与PL的数据交互\"><a href=\"#基于BRAM的PS与PL的数据交互\" class=\"headerlink\" title=\"基于BRAM的PS与PL的数据交互\"></a>基于BRAM的PS与PL的数据交互</h2><p>在 ZYNQ SOC 开发过程中，PL和PS之间经常需要做数据交互。对于传输速度要求较高、数据量大、地址连续的场合，可以通过 AXI DMA 来完成。而对于数据量较少、地址不连续、长度不规则的情况，此时 DMA 便不再适用了。针对这种情况可以通过 BRAM 来进行数据的交互。<br>BRAM（Block RAM）是 <strong>PL 部分的存储器阵列</strong>，PS和PL通过对BRAM进行读写操作，来实现数据的交互。在PL中，通过输出时钟、地址、读写控制等信号来对 BRAM 进行读写操作，而在 PS 中，处理器并不需要直接驱动 BRAM 的端口，而是通过 AXI BRAM 控制器来对 BRAM 进行读写操作。 AXI BRAM 控制器是集成在 Vivado 设计软件中的软核，可以配置成 AXI4 lite 接口模式或者 AXI4 接口模式。<br>AXI4接口模式的BRAM控制器支持数据位宽为32、64、128、512、1024位，而AXI4-Lite接口仅支持32位数据位宽。AXI BRAM控制器作为AXI总线的从接口与AXI主接口实现互联来对BRAM进行读写操作。针对不同应用场合，该IP核支持单次传输与突发传输两种方式。</p>\n\n\n<p>PS 端的M_ AXI_GP0作为主端口与PL端的AXI BRAM控制器IP核和PL读BRAM IP核（pl_bram_rd）通过AXI4总线进行连接.AXI BRAM控制器作为PS端读写BRAM的IP核，pl_bram_rd是自定义IP核用来实现PL端读取BRAM数据的功能，同时，PS端通过AXI总线来配置该IP核（pl_bram_rd）<strong>读取BRAM的起始地址和个数</strong>等。</p>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"VDMA\"><a href=\"#VDMA\" class=\"headerlink\" title=\"VDMA\"></a>VDMA</h2><p>VDMA用于将AXI Stream格式的数据流转换为Memory Map格式或者将Memory Map格式的数据转换为AXI Stream数据流，也就是说VDMA内核旨在提供从AXI4域到AXI4-Stream域的视频读&#x2F;写传输功能，从而实现系统内存（DDR3）和基于AXI4-Stream的目标视频IP之间的高速数据移动。</p>\n<p>VDMA框图如下：</p>\n<img src=\"/2022/12/03/hlsNote/1.jpg\" class=\"\">\n\n<h3 id=\"同步锁相（Genlock）\"><a href=\"#同步锁相（Genlock）\" class=\"headerlink\" title=\"同步锁相（Genlock）\"></a>同步锁相（Genlock）</h3><p>在很多的视频应用中，图像输入端和输出端的数据传输速率不匹配 ，通常使用帧缓存来避免因速率不匹配而导致的潜在错误。为了解决单帧缓存区域带来的图像叠加问题，通过分配多个帧缓存区域来保存数据，图像输入端在写入其中一个帧缓存时，输出端读取其它的帧缓存。</p>\n<p>VDMA支持四种同步锁相模式，分别是Genlock Master （同步锁相主模式）、Genlock Slave（同步锁相从模式）、Dynamic Genlock Master（动态同步锁相主模式）和 Dynamic Genlock Slave （动态同步锁相从模式）。VDMA 有一个写通道（ S2MM ）和一个读通道 MM2SMM2S），用户通过写通道将输入端数据写入帧缓存，通过读通道将从帧缓存中读出数据，VDMA 的每一个通道都可以选择以上四种模式中的一种。</p>\n<h2 id=\"驱动ov5640\"><a href=\"#驱动ov5640\" class=\"headerlink\" title=\"驱动ov5640\"></a>驱动ov5640</h2><p>emio编号从54开始数，根据emio的宽度，如果宽度为2，则引脚编号分别为54、55。</p>\n<p>OV5640和OV7725都是采用SCCB接口总线来配置寄存器，但不同的是，OV7725使用8位（一个字节）来表示寄存器地址，OV5640使用16位（两个字节）来表示寄存器地址。</p>\n<p>OV5640 SCCB写传输协议：</p>\n<img src=\"/2022/12/03/hlsNote/1.png\" class=\"\">\n\n<p>ID ADDRESS 由七位器件地址和一位读写控制位构成（0：写，1：读），七位在前，所以读写时需要发送不同的ID ADDRESS。</p>\n<img src=\"/2022/12/03/hlsNote/88.png\" class=\"\">\n\n<h3 id=\"ISP-图像信号处理\"><a href=\"#ISP-图像信号处理\" class=\"headerlink\" title=\"ISP 图像信号处理\"></a>ISP 图像信号处理</h3><p><strong>ISP输入窗口设置（ISP Input Size）</strong> 允许用户设置整个传感器显示区域（physical pixel size，2632*1951，其中2592*1944像素是有效的），开窗范围从0*0~2632*1951都可以任意设置，也就是上图中的<strong>X_ADDR_ST</strong>（寄存器地址0x3800、0x3801）、<strong>Y_ADDR_ST</strong>（寄存器地址0x3802、0x3803）、<strong>X_ADDR_END</strong>（寄存器地址0x3804、0x3805）和<strong>Y_ADDR_END</strong>（寄存器地址0x3806、0x3807）寄存器。该窗口设置范围中的像素数据将进入ISP进行图像处理。<br><strong>预缩放窗口设置（pre-scaling size）</strong> 允许用户在ISP输入窗口的基础上进行裁剪，用于设置将进行缩放的窗口大小，该设置<strong>仅在ISP输入窗口内进行X&#x2F;Y方向的偏移</strong>。可以通过<strong>X_OFFSET</strong>（寄存器地址0x3810、0x3811）和<strong>Y_OFFSET</strong>（寄存器地址0x3812、0x3813）进行配置。<br><strong>输出大小窗口设置（data output size）</strong> 是在<strong>预缩放窗口</strong>的基础上，经过内部DSP进行缩放处理，并将处理后的数据输出给外部的图像窗口，<strong>图像窗口控制着最终的图像输出尺寸</strong>。可以通过<strong>X_OUTPUT_SIZE</strong>（寄存器地址0x3808、0x3809）和<strong>Y_OUTPUT_SIZE</strong>（寄存器地址0x380A、0x380B）进行配置。注意：当<strong>输出大小窗口与预缩放窗口比例</strong>不一致时，图像将进行缩放处理（图像变形），仅当两者比例一致时，输出比例才是1:1（正常图像）。</p>\n<p><strong>总结就是：</strong><br>ISP输入窗口范围由[Y_ADDR_ST : Y_ADDR_END][X_ADDR_ST : X_ADDR_END]确定；预缩放窗口在ISP基础上进行X&#x2F;Y方向的偏移，偏移大小由X_OFFSET和Y_OFFSET确定；输出大小窗口同时也是OV5640输出给外部的图像尺寸，也就是显示在显示器上的图像大小，输出大小窗口由[X_OUTPUT_SIZE][Y_OUTPUT_SIZE]直接确定；需要注意的是，输出大小窗口由预缩放窗口缩放而来，如果二者不成比例，那么显示器上看到的图像将会变形。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x380c</span>, total_h_pixel &gt;&gt; <span class=\"number\">8</span>    );  <span class=\"comment\">//水平总像素大小高5位</span></span><br><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x380d</span>, total_h_pixel &amp; <span class=\"number\">0x00FF</span>);  <span class=\"comment\">//水平总像素大小低8位</span></span><br><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x380e</span>, total_v_pixel &gt;&gt; <span class=\"number\">8</span>    );  <span class=\"comment\">//垂直总像素大小高5位</span></span><br><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x380f</span>, total_v_pixel &amp; <span class=\"number\">0x00FF</span>);  <span class=\"comment\">//垂直总像素大小低8位</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//X_OUTPUT_SIZE</span></span><br><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x3808</span>, cmos_h_pixel &gt;&gt; <span class=\"number\">8</span>     );  <span class=\"comment\">//DVP 输出水平像素点数高4位</span></span><br><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x3809</span>, cmos_h_pixel &amp; <span class=\"number\">0x00FF</span> );  <span class=\"comment\">//DVP 输出水平像素点数低8位</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Y_OUTPUT_SIZE</span></span><br><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x380a</span>, cmos_v_pixel &gt;&gt; <span class=\"number\">8</span>     );  <span class=\"comment\">//DVP 输出垂直像素点数高3位</span></span><br><span class=\"line\"><span class=\"built_in\">sccb_write_reg16</span>(<span class=\"number\">0x380b</span>, cmos_v_pixel &amp; <span class=\"number\">0x00FF</span> );  <span class=\"comment\">//DVP 输出垂直像素点数低8位</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<img src=\"/2022/12/03/hlsNote/88.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/89.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/90.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/91.png\" class=\"\">\n\n<p>我配置的摄像头只能显示一半，对于我左手边的部分在显示屏上不能显示，正对摄像头时人像显示在显示器的边缘。<br>实际上原来的工程是没有问题的，应该是我在拿到工程之后改了某些配置导致的。</p>\n<h2 id=\"色彩空间\"><a href=\"#色彩空间\" class=\"headerlink\" title=\"色彩空间\"></a>色彩空间</h2><p>YUV（YCbCr）是欧洲电视系统采用的一种颜色编码方法，<strong>Y代表明亮度</strong>（luminance或luma），也就是灰阶值，<strong>U与V表示色度</strong>，用于描述影像的饱和度与色调。RGB与YUV的转换实际上是<strong>色彩空间的转换</strong>，即将RGB的三原色色彩空间转换为YUV所代表的亮度与色度的色彩空间模型。YUV主要用于模拟系统，而YCbCr则是经过校正的主要应用于数字视频中的一种编码方法，<strong>YCbCr适用于计算机用的显示器</strong>。<br>RGB着重于人眼对色彩的感知，YUV则着重于视觉对于亮度的敏感程度。。使用 YUV 描述图像的好处在于，（ 1）亮度 Y 与色度 U、V 是独立的 ；（2）人眼能够识别数千种不同的色彩，但只能识别 20多种灰阶值，采用 YUV 标准可以降低数字彩色图像所需的储存容量。因而 数字彩色图像所需的储存容量。因而YUV 在数字图像处理中是一种很常用的颜色标准。</p>\n<p>YUV信号的提出，是因为国际上出现彩色电视，为了兼容黑白电视的信号而设计的， 在视频码率，压缩，兼容性 等方面有很大优势，我们最常用的主要是<strong>YUV4:4:4</strong>和 <strong>YUV 4:2:2</strong>两种采样格式的 YUV 信号。<br>下面我们将介绍这两种格式的信号:</p>\n<blockquote>\n<ul>\n<li>YUV4:4:4<br>在YUV4:4:4中，YUV 三个信道的采样率相同。因此在生成的图像里，每个像素都有各自独立的三个分量，每个分量通常为8bit，故每个像素占用3个字节。下图为 YUV444 单个像素的模型图，可以看出，每个Y都对应一组U、V数据 ，共同组成一个像素。</li>\n</ul>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/5.jpg\" class=\"\">\n<blockquote>\n<ul>\n<li>YUV4:2:2<br>在 YUV4:2:2格式中， U和 V的采样率是 Y的一半 （两个相邻的像素共用一对 U、V数据 ）。如 下图 所示，图中包含 两个相邻的像素 。第一个像素的三个YUV 分量分别是 Y1、U1、V1，第二个像素 的三个YUV 分量分别是 Y2、U1、V1，两个像素共用一组 U1、V1。</li>\n</ul>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/6.jpg\" class=\"\">\n\n<p>YUV4:4:4格式和 YUV4:2:2格式的<strong>数据流</strong>也是不同的。 数据流也是不同的。如一组连续的四个像素 P1、P2、P3、P4，采用 YUV444 的采样格式时 ，数据流为 Y0 U0 V0 、Y1 U1 V1 、Y2 U2 V2 、Y3 U3 V3 ，每组数据代表一个像素点。<br>而用 YUV422 的采样格式时，数据流为 <strong>Y0 U0 Y1 V1 、Y2 U2 Y3 V3</strong> 。其中， Y0 U0 Y1 V1 表示 P1、P2两 个像素， Y2 U2 Y3 V3 表示 P3 、P4 两个像素。</p>\n<img src=\"/2022/12/03/hlsNote/7.jpg\" class=\"\">\n\n<p>实际上 OV5640 本身支持输出 RGB 、YUV 格式的数据，当摄像头设置为 RGB565 格式，需要显示器显示灰度图时，我们只需要将<strong>转换后的Y值作为 R、G、B 三原色通道的输入</strong>就可以实现了。尽管摄像头设置为RGB565格式，图像采集模块一般采用低位补0的方法使输出的数据为RGB888格式一共24位，如果采用了rgb2ycbcr模块，输出的也是24位的YCbCr数据。</p>\n<h2 id=\"sobel\"><a href=\"#sobel\" class=\"headerlink\" title=\"sobel\"></a>sobel</h2><p>边缘检测和区域划分是图像分割的两种不同的方法，二者具有相互补充的特点。在边缘检测中，是提取图像中不连续部分的特征，根据闭合的边缘确定区域。而在区域划分中，是把图像分割成特征相同的区域，区域之间的边界就是边缘。</p>\n<p>由于边缘检测方法不需要将图像逐个像素地分割，因此更适合大图像的分割。边缘大致可以分为两种，一种是阶跃状边缘，边缘两边像素的灰度值明显不同；另一种为屋顶状边缘，边缘处于灰度值由小到大再到小的变化转折点处。边缘检测的主要工具是边缘检测模板。边缘检测的有很多，典型的有索贝尔算子、普里维特算子、罗伯茨交叉边缘检测等边缘检测技术，这里用的是sobel算子。</p>\n<p><strong>索贝尔算子</strong>（Sobel operator）主要用作边缘检测，在技术上，它是一离散性差分算子，在<strong>图像的任何一点</strong>使用此算子，将会产生对应的<strong>灰度矢量或是其法矢量</strong>。</p>\n<img src=\"/2022/12/03/hlsNote/2.jpg\" class=\"\">\n\n<p>该算子包含两组 3x3 的矩阵，分别为<strong>横向及纵向</strong>，将之与图像作<strong>平面卷积</strong>，如果以 A 代表原始图像， Gx 及 Gy 分别代表<strong>经横向及纵向边缘检测的图像灰度值</strong>，<br>其公式如下：</p>\n<img src=\"/2022/12/03/hlsNote/3.jpg\" class=\"\">\n\n<p>图像的<strong>每一个像素</strong>的<strong>横向及纵向灰   度值</strong>通过以下公式<strong>结合</strong>，来<strong>计算该点梯度的大小</strong>：</p>\n<img src=\"/2022/12/03/hlsNote/4.jpg\" class=\"\">\n\n<p>如果<strong>梯度 G 大于某一阀值</strong>，则认为该点(x,y)为<strong>边缘点</strong>。</p>\n<p>(1)\tRobert算子：Robert算子是一种最简单的算子，它主要利用局部差分算子寻找边缘。Robert算子采用对角线方向相邻两像素之差近似梯度幅值检测边缘，检测垂直边缘的效果好于斜向边缘，边缘定位精度高，但对噪声敏感，无法抑制噪声的影响；<br>(2)\tPrewitt算子：Prewitt算子利用像素点上下、左右邻点的灰度差在边缘处达到极值来检测边缘，去掉部分伪边缘，对噪声具有平滑作用。Prewitt算子定位精度不如Sobel算子，实际上一般不会使用此算子；<br>(3)\tLaplacian算子：Laplace算子是一种各向同性算子，不同于Sobel算子，它是一个二阶微分算子。由于Laplacian算子对噪声具有无法接受的敏感性，在使用之前往往要对图像做一些预处理；</p>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><h3 id=\"C-inline内联函数\"><a href=\"#C-inline内联函数\" class=\"headerlink\" title=\"C++ inline内联函数\"></a>C++ inline内联函数</h3><p>一个 C&#x2F;C++ 程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序。</p>\n<p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p>\n<p>如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。</p>\n<p>为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直<strong>接嵌入函数体的函数称为内联函数</strong>（Inline Function），又称内嵌函数或者内置函数。</p>\n<p>指定内联函数的方法很简单，只需要在函数定义处增加 inline 关键字。请看下面的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//内联函数，交换两个数的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> *b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> temp;</span><br><span class=\"line\">    temp = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">    cout&lt;&lt;m&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(&amp;m, &amp;n);</span><br><span class=\"line\">    cout&lt;&lt;m&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>45 99↙<br>45, 99<br>99, 45</p>\n<p>注意，要在<strong>函数定义处</strong>添加 inline 关键字，在<strong>函数声明处</strong>添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。</p>\n<p>当编译器遇到函数调用swap(&amp;m, &amp;n)时，会用 swap() 函数的代码替换swap(&amp;m, &amp;n)，同时用实参(&amp;m, &amp;n)代替形参(a,b)。这样，程序第 16 行就被置换成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> temp;</span><br><span class=\"line\">temp = *(&amp;m);</span><br><span class=\"line\">*(&amp;m) = *(&amp;n);</span><br><span class=\"line\">*(&amp;n) = temp;</span><br></pre></td></tr></table></figure>\n<p>编译器可能会将 <em>(&amp;m)、</em>(&amp;n) 分别优化为 m、n。</p>\n<p>当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。</p>\n<p>由于内联函数比较短小，我们通常的做法是省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。下面的例子是一个反面教材，这样的写法是不被推荐的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明内联函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap1</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> *b)</span></span>;  <span class=\"comment\">//也可以添加inline，但编译器会忽略</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">    cout&lt;&lt;m&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">swap1</span>(&amp;m, &amp;n);</span><br><span class=\"line\">    cout&lt;&lt;m&lt;&lt;<span class=\"string\">&quot;, &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义内联函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">swap1</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> *b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> temp;</span><br><span class=\"line\">    temp = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。</p>\n<p>最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。</p>\n<hr>\n<p>关于函数原型：<br>函数原型（Function Prototype）：即函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息。</p>\n<p>函数原型的作用：告诉编译器与该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。</p>\n<p>有了函数声明，函数定义就可以出现在任何地方了，甚至是其他文件、静态链接库、动态链接库等。但是如果函数本身带static修饰，那么作用域是当前文件，从声明位置或者定义位置，到文件结尾。如果函数没有static，那么作用域为整个工程或者说是项目。</p>\n<p>有人会说：将函数原型删去，并且直接在原来的位置上使用函数定义，对程序本身的使用是没有任何影响的。<br>事实上举个简单例子：当两个函数互相调用的时候，函数原型的作用就凸显出来了。</p>\n<p>对于单个源文件的程序，通常是将函数定义放到 main() 的后面，将函数声明放到 main() 的前面，这样就使得代码结构清晰明了，主次分明。</p>\n<p>使用者往往只关心函数的功能和函数的调用形式，很少关心函数的实现细节，将函数定义放在最后，就是尽量屏蔽不重要的信息，凸显关键的信息。将函数声明放到 main() 的前面，在定义函数时也不用关注它们的调用顺序了，哪个函数先定义，哪个函数后定义，都无所谓了。</p>\n<p>而在实际开发中，几千上万行、百万行的代码很常见，将这些代码都放在一个源文件中不仅检索麻烦，而且打开文件慢，所以必须将这些代码分散到多个文件中。对于多个文件的程序，通常是将函数定义放到源文件（.c文件）中，将函数的声明放到头文件（.h文件）中，使用函数时引入对应的头文件就可以，编译器会在链接阶段找到函数体。</p>\n<p>我们在使用 printf()、puts()、scanf() 等函数时引入了 stdio.h 头文件，很多初学者认为 stdio.h 中包含了函数定义（也就是函数体），只要有了头文件就能运行，其实不然，头文件中包含的都是函数声明，而不是函数定义，函数定义都放在了其它的源文件中，这些源文件已经提前编译好了，并以动态链接库或者静态链接库的形式存在，只有头文件没有系统库的话，在链接阶段就会报错，程序根本不能运行。</p>\n<h3 id=\"C-模板\"><a href=\"#C-模板\" class=\"headerlink\" title=\"C++ 模板\"></a>C++ 模板</h3><p>类模板可定义一系列相关性，这些类基于在实例化时传递到类的类型参数，函数模板定义的是一系列函数，利用函数模板，你可以指定基于相同代码但作用于不同类型或类的函数集。</p>\n<h1 id=\"How-to-Use-Vitis-Vision-Library\"><a href=\"#How-to-Use-Vitis-Vision-Library\" class=\"headerlink\" title=\"How to Use Vitis Vision Library\"></a>How to Use Vitis Vision Library</h1><p>自从Xilinx推出Vivado HLS以来，越来越多的工程师，尤其是软件工程师开始转向FPGA设计与开发这一领域。其中一个主要原因是通常这些软件工程师都具有较为深厚的C&#x2F;C++功底，这给他们的开发带来了一定的优势，但毕竟最终在FPGA上运行的是实实在在的电路，需要获得更高的性能就要对<strong>工具使用方法、器件结构、面向HLS的C&#x2F;C++代码风格、各种pragma（Directive）、各种优化流程与优化方法</strong>都要有所了解。为此，Xilinx在推出这个工具的同时，也发布了相应的教程和用户指南。</p>\n<p><strong>ug871</strong></p>\n<p>ug871可以说是入门级首选教程。该教程讲解详细，案例丰富，非常适合初学者。该教程共11章，22个实验，可以帮助工程师理解HLS基本概念，掌握Vivado HLS工具设计流程、接口综合、任意精度数据类型、设计分析方法、设计优化方法、设计验证方法以及在IPI和System Generator中如何使用HLS的综合结果。</p>\n<p><strong>ug902</strong></p>\n<p>相比于只有257页的ug871，ug902多达589页，是前者的两倍还要多。因此，一页一页地翻看效率会很低。一种可行的方法是把它当作HLS的字典，在ug871中看到不明白的或者讲解不够深入的内容可以到ug902中去查阅，这样有的放矢，可以事半功倍。<br>有关HLS Video的介绍可以参考UG902。需要注意的是，只有在v2018.2及之前版本的UG902文档中，才对HLS视频库作了详细介绍。<br>之后的版本开始使用xfOpenCV库（<strong>Xilinx xfOpenCV Library</strong> : htps:&#x2F;&#x2F;github.com&#x2F;Xilinx&#x2F;xfopencv），到现在使用最新的Vitis Vision库。</p>\n<p><strong>ug1270</strong></p>\n<p>ug1270系统、全面地介绍了VivadoHLS的优化方法，属于高级教程，适合于已经掌握了HLS设计方法和基本的优化方法的工程师。ug1270阐述了HLS的优化方法流程，详细介绍了各种pragmas的含义，对于进一步提升工程师的HLS技能非常有帮助。</p>\n<p><strong>ug1233</strong></p>\n<p>如果想在Vivado HLS下使用OpenCV，可以查看ug1233。该文档对<strong>HLS所支持的OpenCV函数</strong>有具体说明。</p>\n<p><strong>GitHub上的资源</strong></p>\n<p>此外，在GitHub上，Xilinx也提供了丰富的案例。</p>\n<p>OpenCV案例：<br><a href=\"https://github.com/Xilinx/xfopencv\">https://github.com/Xilinx/xfopencv</a></p>\n<p><strong>Vivado HLS自带案例</strong><br>打开Vivado HLS，在其Welcome Page上，点击Open ExampleProject，会弹出如下界面。可以看到Example Project既包含<strong>设计案例</strong>也包括<strong>代码风格相关的案例</strong>，对于快速理解<strong>面向HLS的C&#x2F;C++代码风格</strong>大有裨益。</p>\n<img src=\"/2022/12/03/hlsNote/39.png\" class=\"\">\n\n<p>以上参考自<a href=\"https://cloud.tencent.com/developer/article/1628623?from=article.detail.1652648&areaSource=106000.1&traceId=hn2Vvwr3M64KxJjVRcew3\">Vivado HLS学习资料有哪些</a></p>\n<p><strong>Vitis HLS自带案例</strong><br><a href=\"https://github.com/Xilinx/Vitis-HLS-Introductory-Examples\">https://github.com/Xilinx/Vitis-HLS-Introductory-Examples</a></p>\n<p>这些例程被分成了以下几类：</p>\n<img src=\"/2022/12/03/hlsNote/45.png\" class=\"\">\n\n<p>我将例程下载在<code>C:\\Users\\Admin\\.Xilinx\\vitis_hls\\2022.2</code>。</p>\n<p><strong>Vitis Vision Lib例程</strong><br><a href=\"https://github.com/Xilinx/Vitis_Libraries/tree/master/vision\">https://github.com/Xilinx/Vitis_Libraries/tree/master/vision</a></p>\n<img src=\"/2022/12/03/hlsNote/47.png\" class=\"\">\n<p>看看L1文件夹的介绍：</p>\n<img src=\"/2022/12/03/hlsNote/48.png\" class=\"\">\n\n<p>运行这些例程可以通过vitis_hls_cmd或者GUI界面来完成：</p>\n<img src=\"/2022/12/03/hlsNote/46.png\" class=\"\">\n<p>注意：需要使用vitis_hls_cmd执行该命令后生成.prj文件夹才能在Vitis HLS GUI中打开。</p>\n<p>vitis_hls_cmd的位置应该在：<br><code>C:\\Users\\Admin\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Xilinx Design Tools\\Vitis_HLS 2022.2\\Vitis HLS 2022.2 Command Prompt</code>也即<br><code>C:\\Xilinx\\Vitis_HLS\\2022.2\\bin\\vitis_hls_cmd.bat</code>。</p>\n<p>运行C simulation产生csim.exe可执行文件，在目录solution1&#x2F;csim&#x2F;build放入要作为TB输入的图片，在此处打开终端，执行命令<code>./csim.exe ./param1.jpg ./param2.jpg</code>即可将param1.jpg和param2.jpg作为TB的输入来产生仿真结果。</p>\n<p><strong>关于TB中main函数(int argc, char *argv[])的理解</strong>：<br>这两个参数实际上都是对于 <strong>你在终端执行的命令</strong> 的描述，要知道csim.exe就是TB编译链接后产生的可执行文件，而前文提到的命令能将两张图片传递给main函数，而如何传递呢，你输入的只是字符串呀。就靠argc和argv两个参数了，argc指示程序启动时命令行参数的个数，argv则包含具体的参数字符串，也就是用argv这个字符串数组把命令行参数存起来。注意：命令行参数要空格分隔，也就是输入<code>./csim.exe ./param1.jpg ./param2.jpg</code>这条命令时，argc&#x3D;3，argv[0]&#x3D;.&#x2F;csim.exe, argv[1]&#x3D;.&#x2F;param1.jpg, argv[2]&#x3D;.&#x2F;param2.jpg。通过这两个参数，程序便可以获知自身启动时的命令信息。<br><strong>参考</strong>：<br><a href=\"https://blog.csdn.net/fenhong91/article/details/54863718\">https://blog.csdn.net/fenhong91/article/details/54863718</a><br><a href=\"https://blog.51cto.com/u_15338641/3630248\">https://blog.51cto.com/u_15338641/3630248</a></p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>在Windows的vitis补全只需要按下<code>alt + / </code>头文件和变量名都能补全出来</p>\n<h3 id=\"CFLAGS\"><a href=\"#CFLAGS\" class=\"headerlink\" title=\"CFLAGS\"></a>CFLAGS</h3><p>-IC:\\Xilinx\\Vitis_Libraries\\Vitis_Libraries-main\\vision\\L1\\include -std&#x3D;c++0x -II:\\Professional\\opencv_lib\\opencv\\Latest4Vitis\\install\\include<br><strong>synthesis不要-std&#x3D;c++0x及之后的语句</strong></p>\n<h3 id=\"Linker-Flags\"><a href=\"#Linker-Flags\" class=\"headerlink\" title=\"Linker Flags\"></a>Linker Flags</h3><p>-LI:\\Professional\\opencv_lib\\opencv\\Latest4Vitis\\install\\x64\\mingw\\lib -llibopencv_core470 -llibopencv_imgcodecs470 -llibopencv_imgproc470 -llibopencv_highgui470<br>需要什么库自己链接就可以了</p>\n<h2 id=\"Vitis-Vision-Library-API-Reference\"><a href=\"#Vitis-Vision-Library-API-Reference\" class=\"headerlink\" title=\"Vitis Vision Library API Reference\"></a>Vitis Vision Library API Reference</h2><h3 id=\"xf-cv-Mat-Image-Container-Class\"><a href=\"#xf-cv-Mat-Image-Container-Class\" class=\"headerlink\" title=\"xf::cv::Mat Image Container Class\"></a>xf::cv::Mat Image Container Class</h3><p><strong>xf::cv::Mat</strong> is a template class that serves as a <strong>container for storing image data and its attributes</strong>.</p>\n<p><strong>Class Definition:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> T, <span class=\"type\">int</span> ROWS, <span class=\"type\">int</span> COLS, <span class=\"type\">int</span> NPC, <span class=\"type\">int</span> XFCVDEPTH = _XFCVDEPTH_DEFAULT&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Mat &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"type\">unsigned</span> <span class=\"type\">char</span> allocatedFlag; <span class=\"comment\">// flag to mark memory allocation in this class</span></span><br><span class=\"line\">   <span class=\"type\">int</span> rows, cols, size;        <span class=\"comment\">// actual image size</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">XF_TNAME</span><span class=\"params\">(T, NPC)</span> DATATYPE</span>;</span><br><span class=\"line\">   <span class=\"keyword\">using</span> _DATATTYPE = <span class=\"keyword\">typename</span> std::conditional&lt;</span><br><span class=\"line\">      (XFCVDEPTH &lt; <span class=\"number\">0</span>),</span><br><span class=\"line\">      DATATYPE*,                 <span class=\"comment\">// Case of Memory Mapped pointer</span></span><br><span class=\"line\">      <span class=\"keyword\">typename</span> std::conditional&lt; <span class=\"comment\">// Case of Stream</span></span><br><span class=\"line\">         (XFCVDEPTH == <span class=\"number\">0</span>),</span><br><span class=\"line\">         hls::stream&lt;DATATYPE&gt;,           <span class=\"comment\">// Case of default Dtream depth or user can override outside</span></span><br><span class=\"line\">         hls::stream&lt;DATATYPE, XFCVDEPTH&gt; <span class=\"comment\">// Case of Stream depth specified</span></span><br><span class=\"line\">         &gt;::type&gt;::type;</span><br><span class=\"line\">   _DATATTYPE data;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">Mat</span>(); <span class=\"comment\">// default constructor</span></span><br><span class=\"line\">   <span class=\"built_in\">Mat</span>(Size _sz);</span><br><span class=\"line\">   <span class=\"built_in\">Mat</span>(<span class=\"type\">int</span> _rows, <span class=\"type\">int</span> _cols);</span><br><span class=\"line\">   <span class=\"built_in\">Mat</span>(<span class=\"type\">int</span> _size, <span class=\"type\">int</span> _rows, <span class=\"type\">int</span> _cols);</span><br><span class=\"line\">   <span class=\"built_in\">Mat</span>(<span class=\"type\">int</span> _rows, <span class=\"type\">int</span> _cols, <span class=\"type\">void</span>* _data);</span><br><span class=\"line\">   <span class=\"built_in\">Mat</span>(<span class=\"type\">const</span> Mat&amp;); <span class=\"comment\">// copy constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">   ~<span class=\"built_in\">Mat</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   Mat&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Mat&amp;); <span class=\"comment\">// Assignment operator</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &lt; <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">alloc_data</span>() &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __SYNTHESIS__</span></span><br><span class=\"line\">      data = (DATATYPE*)<span class=\"built_in\">malloc</span>(size * <span class=\"built_in\">sizeof</span>(DATATYPE));</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (data == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;\\nFailed to allocate memory\\n&quot;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         allocatedFlag = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &gt;= <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">alloc_data</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// This is a stream</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &lt; <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">free_data</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (data != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __SYNTHESIS__</span></span><br><span class=\"line\">         <span class=\"built_in\">free</span>(data);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &gt;= <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">free_data</span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &lt; <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">copyData</span>(<span class=\"type\">const</span> Mat&amp; src) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; (rows * ((cols + NPC - <span class=\"number\">1</span>) &gt;&gt; <span class=\"built_in\">XF_BITSHIFT</span>(NPC))); ++i) &#123;</span><br><span class=\"line\">         data[i] = src.data[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &gt;= <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">copyData</span>(<span class=\"type\">const</span> Mat&amp; src) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// This is a stream</span></span><br><span class=\"line\">      <span class=\"built_in\">assert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &lt; <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">assignDataPtr</span>(<span class=\"type\">void</span>* _data) &#123;</span><br><span class=\"line\">      data = (DATATYPE*)_data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &gt;= <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">assignDataPtr</span>(<span class=\"type\">void</span>* _data) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// This is a stream</span></span><br><span class=\"line\">      <span class=\"built_in\">assert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &lt; <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"built_in\">XF_TNAME</span>(T, NPC)</span><br><span class=\"line\">   <span class=\"built_in\">read</span>(<span class=\"type\">int</span> index) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &gt;= <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"built_in\">XF_TNAME</span>(T, NPC)</span><br><span class=\"line\">   <span class=\"built_in\">read</span>(<span class=\"type\">int</span> index) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> data.<span class=\"built_in\">read</span>();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">read_float</span><span class=\"params\">(<span class=\"type\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &lt; <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">write</span>(<span class=\"type\">int</span> index, <span class=\"built_in\">XF_TNAME</span>(T, NPC) val) &#123;</span><br><span class=\"line\">      data[index] = val;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &gt;= <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">write</span>(<span class=\"type\">int</span> index, <span class=\"built_in\">XF_TNAME</span>(T, NPC) val) &#123;</span><br><span class=\"line\">      data.<span class=\"built_in\">write</span>(val);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">write_float</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">float</span> val)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &gt;= <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">init</span>(<span class=\"type\">int</span> _rows, <span class=\"type\">int</span> _cols, <span class=\"type\">void</span>* _data) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">init</span>(_rows, _cols);</span><br><span class=\"line\">      <span class=\"built_in\">copyTo</span>(_data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> D = XFCVDEPTH, <span class=\"keyword\">typename</span> std::enable_if&lt;(D &lt; <span class=\"number\">0</span>)&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\">   <span class=\"type\">void</span> <span class=\"built_in\">init</span>(<span class=\"type\">int</span> _rows, <span class=\"type\">int</span> _cols, <span class=\"type\">void</span>* _data) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">init</span>(_rows, _cols, <span class=\"literal\">false</span>);</span><br><span class=\"line\">      <span class=\"built_in\">assignDataPtr</span>(_data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> _rows, <span class=\"type\">int</span> _cols, <span class=\"type\">bool</span> allocate = <span class=\"literal\">true</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">copyTo</span><span class=\"params\">(<span class=\"type\">void</span>* fromData)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span>* <span class=\"title\">copyFrom</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">int</span> <span class=\"title\">depth</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">int</span> <span class=\"title\">channels</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> DST_T&gt;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">convertTo</span><span class=\"params\">(Mat&lt;DST_T, ROWS, COLS, NPC, XFCVDEPTH&gt;&amp; dst, <span class=\"type\">int</span> otype, <span class=\"type\">double</span> alpha = <span class=\"number\">1</span>, <span class=\"type\">double</span> beta = <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Class-definition\"><a href=\"#Class-definition\" class=\"headerlink\" title=\"Class definition\"></a>Class definition</h4><blockquote>\n<p><strong>Parameter Descriptions:</strong></p>\n<img src=\"/2022/12/03/hlsNote/35.png\" class=\"\">\n<p><strong>size</strong>参数比较重要，描述Mat类data成员中存储的<strong>word</strong>数，这个数使用<code>rows*cols/(number of pixels packed per word)</code>来计算，<strong>分母就是NPC</strong>。Mat的data成员是一维数组，其中每个数据元素应该就是word。word应该就是pixel按NPC打包成的，一个clock传输一个word相当于传输了number of pixels。<br><strong>data</strong> 是指向<code>the words that store the pixels of the image</code>的指针，也可以理解为data数组的数组名，指向了这个数组第一个元素。</p>\n</blockquote>\n<blockquote>\n<p><strong>member functions and their descriptions:</strong></p>\n<img src=\"/2022/12/03/hlsNote/36.png\" class=\"\">\n</blockquote>\n<blockquote>\n<p><strong>template parameters:</strong></p>\n<img src=\"/2022/12/03/hlsNote/37.png\" class=\"\">\n<p><strong>TYPE</strong>：Type of the pixel data. For example, XF_8UC1 八位无符号单通道像素。<br><strong>NPC</strong>：<strong>The number of pixels to be packed per word</strong>. For instance, XF_NPPC1 for 1 pixel per word; and XF_NPPC8 for 8 pixels per word.<br><strong>XFCVDEPTH</strong>：<strong>Depth of the hls::stream in the xf::cv::Mat</strong>不懂。应该和Mat中定义的数据类型_DATATYPE有关。</p>\n</blockquote>\n<h5 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h5><blockquote>\n<img src=\"/2022/12/03/hlsNote/40.png\" class=\"\">\n<p>所谓图像深度指的是定义在 xf::cv::Mat 中的 hls::stream 的深度，也就是XFCVDEPTH。</p>\n</blockquote>\n<h4 id=\"Parallelism\"><a href=\"#Parallelism\" class=\"headerlink\" title=\"Parallelism\"></a>Parallelism</h4><p>对一个函数指定并行处理的像素数</p>\n<p>可选参数如下：</p>\n<img src=\"/2022/12/03/hlsNote/41.png\" class=\"\">\n\n<p>定义Parallelism会用到的两个宏：</p>\n<img src=\"/2022/12/03/hlsNote/42.png\" class=\"\">\n<p>第二个宏XF_BITSHIFT的目的是解析出图像大小需要右移的次数以便得到传输次数，比如XF_NPPC8，一次传输八个像素，那传输次数便是总像素数&#x2F;8，也就是总像素数&gt;&gt;8。</p>\n<h4 id=\"Data-Types\"><a href=\"#Data-Types\" class=\"headerlink\" title=\"Data Types\"></a>Data Types</h4><p>像素数据类型是由像素数据深度和像素通道数结合而来的，通用命名法为：<br><code>XF_&lt;Number of bits per pixel&gt;&lt;signed (S) or unsigned (U) or float (F)&gt;C&lt;number of channels&gt;</code></p>\n<img src=\"/2022/12/03/hlsNote/43.png\" class=\"\">\n\n\n<h5 id=\"Manipulating-Data-Type\"><a href=\"#Manipulating-Data-Type\" class=\"headerlink\" title=\"Manipulating Data Type\"></a>Manipulating Data Type</h5><p>基于 number of pixels to process per clock cycle 和 Data Types of Pixel，视觉库使用了一些数据类型用于xf::cv::Mat以及内部数据处理，举例如下：</p>\n<img src=\"/2022/12/03/hlsNote/44.png\" class=\"\">\n\n<p>For more information, see the Vitis HLS User Guide: High-Level Synthesis (UG1399 ).</p>\n<h6 id=\"Note-1\"><a href=\"#Note-1\" class=\"headerlink\" title=\"Note\"></a>Note</h6><p>ap_uint&lt;&gt;, ap_int&lt;&gt;, ap_fixed&lt;&gt;, and ap_ufixed&lt;&gt; types belong to the high-level synthesis (HLS) library.</p>\n<h4 id=\"Class-Function\"><a href=\"#Class-Function\" class=\"headerlink\" title=\"Class Function\"></a>Class Function</h4><ul>\n<li>xf::cv::imread  从文件读图</li>\n<li>xf::cv::imwrite  将图像写入文件中</li>\n<li>xf::cv::absDiff</li>\n<li>xf::cv::convertTo<br>详见<a href=\"https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/api-reference.html_1_3\">Class function</a></li>\n</ul>\n<h3 id=\"Vitis-Vision-Library-Functions\"><a href=\"#Vitis-Vision-Library-Functions\" class=\"headerlink\" title=\"Vitis Vision Library Functions\"></a>Vitis Vision Library Functions</h3><p>The Vitis Vision library is a set of <strong>select OpenCV functions</strong> optimized for Zynq-7000, Zynq UltraScale+ MPSoC, Versal VCK190, Alveo U200 and U50 devices. </p>\n<h4 id=\"Note-2\"><a href=\"#Note-2\" class=\"headerlink\" title=\"Note\"></a>Note</h4><blockquote>\n<p>All the functions in the library are implemented in streaming model except 7. Bounding box, Canny, Cornertracker, Crop, EdgeTracing, MeanShiftTracking, Rotate are memory mapped implemenations. These functions need to have the flag <strong>SDA_MEM_MAP</strong> set for compiling correctly<br>除了这七个函数使用内存映射实现的，其他的都是流模型实现的，使用这七个函数时要设置对应的flag。</p>\n<p>Default depth value for all the memory mapped implemenations(Bounding box, Canny, Cornertracker, Crop, EdgeTracing, MeanShiftTracking, Rotate) is “_XFCVDEPTH_DEFAULT &#x3D; -1”. Default depth value for all the streaming model implemenations is “_XFCVDEPTH_DEFAULT &#x3D; 2”.<br>对于内存映射实现的默认深度值_XFCVDEPTH_DEFAULT &#x3D; -1，对于流模型实现的默认深度值_XFCVDEPTH_DEFAULT &#x3D; -2，这个在编程中要用到的。</p>\n<p>Number of pixel per clock depends on the maximum bus width a device can support. For example: Zynq-7000 SoC has 64-bit interface and so for a pixel type 16UC1, maximum of four pixel per clock (XF_NPPC4) is possible.<br>每个时钟周期处理的像素数NPC。</p>\n</blockquote>\n<p>具体函数介绍见<a href=\"https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/api-reference.html_2_0\">Vitis Vision Library Functions</a></p>\n<h2 id=\"Getting-Started-with-HLS\"><a href=\"#Getting-Started-with-HLS\" class=\"headerlink\" title=\"Getting Started with HLS\"></a>Getting Started with HLS</h2><h3 id=\"AXI-Video-Interface-Functions\"><a href=\"#AXI-Video-Interface-Functions\" class=\"headerlink\" title=\"AXI Video Interface Functions\"></a>AXI Video Interface Functions</h3><blockquote>\n<p>基本特征</p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/26.png\" class=\"\">\n\n\n\n<blockquote>\n<p>看 Vitis Vision Library 文件夹包含的内容，table是重点<br><a href=\"https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/overview.html_0_2\">Vitis Vision Library Contents</a></p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/27.png\" class=\"\">\n\n\n\n<blockquote>\n<p>看包含库函数的头文件及其对应的文件夹名，table是重点<br><a href=\"https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/overview.html_1_3\">Using the Vitis vision Library</a></p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/28.png\" class=\"\">\n<p>文件夹common和core包含库函数所需要的基础设施，包括<code>basic functions, Mat class, and macros</code>，库函数按类分成四个文件夹：<code>features, video, dnn, and imgproc </code>，为了使用这些库函数，必须在VitisProject中添加文件夹的路径，之后便可以include相关的头文件，应该是要添加文件夹的路径到CFlags。<br>比如，在添加上文的CFlags之后，在源文件中用这样的语句便可以添加头文件：</p>\n<img src=\"/2022/12/03/hlsNote/29.png\" class=\"\">\n\n\n\n<blockquote>\n<p><a href=\"https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/overview.html_2_0\">AXI Video Interface Functions</a></p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/30.png\" class=\"\">\n\n<h3 id=\"Migrating-HLS-Video-Library-to-Vitis-vision\"><a href=\"#Migrating-HLS-Video-Library-to-Vitis-vision\" class=\"headerlink\" title=\"Migrating HLS Video Library to Vitis vision\"></a>Migrating HLS Video Library to Vitis vision</h3><blockquote>\n<p><a href=\"\">Migrating HLS Video Library to Vitis vision</a><br>HLS video视频库已经被弃用，其中所有函数和大部分的基础结构都能够在Vitis vision库中找到，但是有一些变化。</p>\n<ol>\n<li>命名空间由hls::变为xf::cv::，hls::Mat使用hls::stream存储数据但是xf::cv::Mat使用指针，所以前者无法被后者完全代替。</li>\n</ol>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/31.png\" class=\"\">\n<blockquote>\n<ol start=\"2\">\n<li>hls::window 和 hls::LineBuffer 分别由xf::cv::window 和xf::cv::LineBuffer代替，定义在<strong>xf_video_mem.h</strong>。</li>\n<li>convert OpenCV Mat format to&#x2F;from HLS AXI types在Vitis vision Lib中只剩下两个函数，分别是：cvMat2AXIvideo and AXIvideo2cvMat，定义在<strong>xf_axi.h</strong>。</li>\n<li>convert Mat format data to&#x2F;from AXI4-Stream compatible data type 的函数原来是 hls::AXIvideo2Mat and hls::Mat2AXIvideo，已经被xf::cv::AXIvideo2xfMat and xf::cv:: xfMat2AXIvideo 替换，定义在<strong>xf_infra.hpp</strong>。</li>\n<li><strong>要使用以上这些函数，必须包含这些头文件。</strong></li>\n</ol>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/32.png\" class=\"\">\n\n\n\n<blockquote>\n<p><strong>xf::cv::window</strong><br>一个代表二维窗口缓存的模板类，使用三个参数去定义行数，列数和像素数据类型。<br>类定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> ROWS, <span class=\"type\">int</span> COLS, <span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">&gt;<span class=\"keyword\">class</span> <span class=\"title class_\">Window</span> &#123;</span><br><span class=\"line\">&gt;<span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"built_in\">Window</span>()</span><br><span class=\"line\">  <span class=\"comment\">/* Window main APIs */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shift_pixels_left</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shift_pixels_right</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shift_pixels_up</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shift_pixels_down</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_pixel</span><span class=\"params\">(T value, <span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_row</span><span class=\"params\">(T value[COLS], <span class=\"type\">int</span> row)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_top_row</span><span class=\"params\">(T value[COLS])</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_bottom_row</span><span class=\"params\">(T value[COLS])</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_col</span><span class=\"params\">(T value[ROWS], <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_left_col</span><span class=\"params\">(T value[ROWS])</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_right_col</span><span class=\"params\">(T value[ROWS])</span></span>;</span><br><span class=\"line\">   <span class=\"function\">T&amp; <span class=\"title\">getval</span><span class=\"params\">(<span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">   <span class=\"function\">T&amp; <span class=\"title\">operator</span> <span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">   T val[ROWS][COLS];</span><br><span class=\"line\">&gt;<span class=\"meta\">#<span class=\"keyword\">ifdef</span> __DEBUG__</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restore_val</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">window_print</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   T <span class=\"type\">val_t</span>[ROWS][COLS];</span><br><span class=\"line\">&gt;<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&gt;&#125;;</span><br></pre></td></tr></table></figure>\n<p>xf::cv::Window主要参数<code>val</code>是一个二维数组，hold the contents of buffer。<br><a href=\"https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/overview.html_2_1_3_2\">Member Function Description</a><br>Sample code for window buffer declaration</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;Window&lt;K_ROWS, K_COLS, <span class=\"type\">unsigned</span> <span class=\"type\">char</span>&gt; kernel;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>xf::cv::LineBuffer</strong><br>一个代表二维线缓存的模板类，用三个参数指定line buffer中的行数，列数和像素数据类型。<br>定义如下：</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> ROWS, <span class=\"type\">int</span> COLS, <span class=\"keyword\">typename</span> T, XF_ramtype_e MEM_TYPE=RAM_S2P_BRAM, <span class=\"type\">int</span> RESHAPE_FACTOR=<span class=\"number\">1</span>&gt;</span><br><span class=\"line\"> <span class=\"keyword\">class</span> LineBuffer &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">LineBuffer</span>()</span><br><span class=\"line\">       <span class=\"comment\">/* LineBuffer main APIs */</span></span><br><span class=\"line\">    <span class=\"comment\">/* LineBuffer main APIs */</span></span><br><span class=\"line\">    <span class=\"type\">void</span> <span class=\"built_in\">shift_pixels_up</span>(<span class=\"type\">int</span> col);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shift_pixels_down</span><span class=\"params\">(<span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_bottom_row</span><span class=\"params\">(T value, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_top_row</span><span class=\"params\">(T value, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_col</span><span class=\"params\">(T value[ROWS], <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">T&amp; <span class=\"title\">getval</span><span class=\"params\">(<span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">T&amp; <span class=\"title\">operator</span> <span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Back compatible APIs */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shift_up</span><span class=\"params\">(<span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shift_down</span><span class=\"params\">(<span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_bottom</span><span class=\"params\">(T value, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_top</span><span class=\"params\">(T value, <span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    T val[ROWS][COLS];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __DEBUG__</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restore_val</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">linebuffer_print</span><span class=\"params\">(<span class=\"type\">int</span> col)</span></span>;</span><br><span class=\"line\">    T <span class=\"type\">val_t</span>[ROWS][COLS];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>主要成员<code>val</code>表示<code>2-D array to hold the contents of line buffer</code>。</p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/33.png\" class=\"\" title=\"Member Functions Description\">\n<img src=\"/2022/12/03/hlsNote/34.png\" class=\"\" title=\"Template Parameter Description\">\n<p>Sample code for line buffer declaration:</p>\n<blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;LineBuffer&lt;<span class=\"number\">3</span>, <span class=\"number\">1920</span>, XF_8UC3, RAM_S2P_URAM,<span class=\"number\">1</span>&gt;     buff;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><a href=\"https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/overview.html_2_1_5\">Video Processing Functions</a><br>这个table总结了从HLS Video库移植到Vitis Vision库中的视频处理函数。</p>\n</blockquote>\n<h1 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h1><h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><p><a href=\"https://blog.csdn.net/xzs520xzs/article/details/126673128\">接口，优化指令</a></p>\n<p>在vivado HLS软件右侧中有个Directive栏（如果没有可以在功能栏中的window将其显示出来），里边列出了所有的<strong>变量、函数、循环</strong>结构，右键点击就可以对其进行配置；简单讲解一下如何进行配置，对于循环结构体，一般选择<strong>unroll</strong>（展开循环），可以自己设定展开的因子factor；对于函数，为了提高程序的并行处理能力，可以右键选择<strong>PIPELINE</strong>；对于数组，可以设置为<strong>ARRAY_PARTITION</strong>，数组维数根据需求设置。每一个优化的方案都可以保存在一个solution中，可以创建多个solution。</p>\n<p><a href=\"https://blog.csdn.net/mmphhh/article/details/115655208\">HLS：接口完整学习与综合测试</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_42418557/article/details/121130337?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-121130337-blog-75909681.pc_relevant_multi_platform_whitelistv6&spm=1001.2101.3001.4242.1&utm_relevant_index=3\">HLS第三十五课（XAPP1167，基于videolib实现图像处理）</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> hls::Mat&lt;MAX_HEIGHT, MAX_WIDTH, HLS_8UC2&gt;     IMAGE_C2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">image_filter</span><span class=\"params\">(AXI_STREAM&amp; video_in, AXI_STREAM&amp; video_out, <span class=\"type\">int</span> rows, <span class=\"type\">int</span> cols)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Create AXI streaming interfaces for the core</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE axis port=video_in bundle=INPUT_STREAM</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE axis port=video_out bundle=OUTPUT_STREAM</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE s_axilite port=return bundle=CONTROL_BUS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE s_axilite port=rows bundle=CONTROL_BUS offset=0x14</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE s_axilite port=cols bundle=CONTROL_BUS offset=0x1C</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE ap_stable port=rows</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS INTERFACE ap_stable port=cols</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">IMAGE_C2 <span class=\"title\">img_0</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">IMAGE_C2 <span class=\"title\">img_1_0</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">IMAGE_C2 <span class=\"title\">img_1_1</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">IMAGE_C1 <span class=\"title\">img_1_Y</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">IMAGE_C1 <span class=\"title\">img_1_UV</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">IMAGE_C2 <span class=\"title\">img_2</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">IMAGE_C1 <span class=\"title\">mask</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">IMAGE_C1 <span class=\"title\">dmask</span><span class=\"params\">(rows, cols)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">PIXEL_C2 <span class=\"title\">color</span><span class=\"params\">(<span class=\"number\">255</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS dataflow</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> HLS stream depth=20000 variable=img_1_1.data_stream</span></span><br><span class=\"line\">    hls::<span class=\"built_in\">AXIvideo2Mat</span>(video_in, img_0);</span><br><span class=\"line\">    hls::<span class=\"built_in\">Duplicate</span>(img_0, img_1_0, img_1_1);</span><br><span class=\"line\">    hls::<span class=\"built_in\">Split</span>(img_1_0, img_1_Y, img_1_UV);</span><br><span class=\"line\">    hls::<span class=\"built_in\">Consume</span>(img_1_UV);</span><br><span class=\"line\">    hls::<span class=\"built_in\">FASTX</span>(img_1_Y, mask, <span class=\"number\">20</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    hls::<span class=\"built_in\">Dilate</span>(mask, dmask);</span><br><span class=\"line\">    hls::<span class=\"built_in\">PaintMask</span>(img_1_1, dmask, img_2, color);</span><br><span class=\"line\">    hls::<span class=\"built_in\">Mat2AXIvideo</span>(img_2, video_out);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里重点是img_1_1的使用问题。<br>在整体<strong>dataflow</strong>的情况下，<strong>HLS对上下游任务的数据交接</strong>，使用<strong>FIFO</strong>方式。<br>但是复制后的img_1_0和img_1_1，它们的消费速度是不同步的。<br>在数据路径上，img_1_0很快就被下游的任务split消费掉了。但是img_1_1却要等到更下游的paintmask处才能被消费掉。<br>这段时间内，duplicate仍然在不断的生产数据，同时提供给img_1_0和img_1_1。（流数据是这样的）<br>所以，<strong>img_1_1需要具备足够大的FIFO depth</strong>。<br><code>#pragma HLS stream depth=20000 variable=img_1_1.data_stream</code><br>这条约束，指定了<strong>Mat对象的内部存储数组（data_stream）</strong>，显式地被HLS理解为<strong>FIFO（stream）</strong>，并且深度为<strong>20000</strong>。</p>\n<p><a href=\"https://blog.csdn.net/crazyeden/article/details/86594027\">HLS学习（二）Using AXI4 Interfaces</a><br>在这里学到了把数组用于顶层函数的形参，并且指定为m_axi的接口。</p>\n \n\n\n<p><a href=\"https://discuss.pynq.io/t/sobel-filter-vitis-vision-library-implementation-on-pynq-z-board/3753\">Sobel 滤波器（Vitis 视觉库）在 Pynq-Z 板上的实现</a></p>\n<h2 id=\"Hu不变矩\"><a href=\"#Hu不变矩\" class=\"headerlink\" title=\"Hu不变矩\"></a>Hu不变矩</h2><p>对于一个提取出来的手势，我们需要有固定且唯一的特征来对其进行记录，且该特征不会受到手势的大小，旋转，平移而变化，且鲁棒性较好，所以此处引入Hu不变矩算法。</p>\n<blockquote>\n<p>连续情况下，图像像素分布为f(x,y)，则图像的p+q阶不变矩（标准矩，普通矩）为：</p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/80.png\" class=\"\">\n<p>p+q阶中心矩为：</p>\n<img src=\"/2022/12/03/hlsNote/81.png\" class=\"\">\n<p>其中矩心（x0, y0）为：</p>\n<img src=\"/2022/12/03/hlsNote/82.png\" class=\"\">\n\n<blockquote>\n<p>对于数字图像，引入适用于离散图像的Hu不变矩：</p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/83.png\" class=\"\">\n<p>式中p、q&#x3D;0，1，2…</p>\n<p>直接用普通矩或中心矩进行特征表示，不能使特征同时具有平移、旋转和比例不变性，因此我们下面进行归一化。</p>\n<blockquote>\n<p>归一化中心矩定义：</p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/84.png\" class=\"\">\n<p>利用归一化中心矩的话则可以同时拥有平移不变性和比例不变性。</p>\n<img src=\"/2022/12/03/hlsNote/85.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/86.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/87.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/88.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/89.png\" class=\"\">\n\n\n<p><a href=\"https://blog.csdn.net/qq_26898461/article/details/47123405\">Hu不变矩原理及opencv实现</a></p>\n<p><a href=\"http://gezhilai.com/2021/07/09/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/\">基于FPGA的手势识别系统设计</a></p>\n<h3 id=\"仿真\"><a href=\"#仿真\" class=\"headerlink\" title=\"仿真\"></a>仿真</h3><table>\n<thead>\n<tr>\n<th align=\"center\">SPACE</th>\n<th align=\"center\">一指</th>\n<th align=\"center\">二指</th>\n<th align=\"center\">三指</th>\n<th align=\"center\">四指</th>\n<th align=\"center\">五指残缺</th>\n<th align=\"center\">拳头</th>\n<th align=\"center\">五指完整</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">MATLAB_M[0]</td>\n<td align=\"center\">21572</td>\n<td align=\"center\">22686</td>\n<td align=\"center\">21016</td>\n<td align=\"center\">18895</td>\n<td align=\"center\">15173</td>\n<td align=\"center\">13516</td>\n<td align=\"center\">16360</td>\n</tr>\n<tr>\n<td align=\"center\">OPENCV_M[0]</td>\n<td align=\"center\">21571</td>\n<td align=\"center\">22686</td>\n<td align=\"center\">21016</td>\n<td align=\"center\">18895</td>\n<td align=\"center\">15156</td>\n<td align=\"center\">13498</td>\n<td align=\"center\">16360</td>\n</tr>\n<tr>\n<td align=\"center\">MATLAB_M[1]</td>\n<td align=\"center\">17.6367</td>\n<td align=\"center\">19.2464</td>\n<td align=\"center\">15.5429</td>\n<td align=\"center\">10.5509</td>\n<td align=\"center\">4.0185</td>\n<td align=\"center\">3.4057</td>\n<td align=\"center\">6.7028</td>\n</tr>\n<tr>\n<td align=\"center\">OPENCV_M[1]</td>\n<td align=\"center\">17</td>\n<td align=\"center\">19</td>\n<td align=\"center\">15</td>\n<td align=\"center\">10</td>\n<td align=\"center\">4</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n</tr>\n</tbody></table>\n<h2 id=\"PS与PL数据交互\"><a href=\"#PS与PL数据交互\" class=\"headerlink\" title=\"PS与PL数据交互\"></a>PS与PL数据交互</h2><p><a href=\"https://support.xilinx.com/s/question/0D52E00006hppE0SAI/hls-%E5%9B%A0%E4%B8%BA%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E7%BB%84%E5%A4%AA%E5%A4%A7%E5%AF%BC%E8%87%B4bram%E4%B8%8D%E5%A4%9F%E7%94%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ddr%E5%A4%96%E6%8E%A5%E5%86%85%E5%AD%98%E5%91%A2?language=en_US\">有人想在HLS中访问DDR</a></p>\n<p>提到：将数组作为HLS函数参数，然后将其声明为AXI接口，再将接口连接至MIG IP核，就可以访问DDR中的数据了</p>\n<h2 id=\"图像处理中的数据类型\"><a href=\"#图像处理中的数据类型\" class=\"headerlink\" title=\"图像处理中的数据类型\"></a>图像处理中的数据类型</h2><p>xf::cv::Mat中存储像素数据的是成员是data，data定义如下：</p>\n<img src=\"/2022/12/03/hlsNote/87.png\" class=\"\">\n\n<p>这里的T是像素数据类型，如XF_8UC3，DATATYPE是XF_TNAME(T, NPC)的别名，从前面的Manipulating Data Type章节了解到XF_TNAME(T, NPC)会解析成ap_uint&lt;像素宽度*通道数*NPC&gt;，如XF_TNAME(XF_8UC3, XF_NPPC1)解析成ap_uint&lt;8*3*1&gt;&#x3D;ap_uint&lt;24&gt;，因此我们可以推导出DATATYPE的类型。<br>接着看到_DATATYPE的定义，虽然定义复杂但我们可以逐层推断，conditional相比是条件判断，程序中使用流模型所以XFCVDEPTH为默认值也就是2，进入第二层条件判断可以发现_DATATYPE被定义成了hls::stream&lt;DATATYPE, XFCVDEPTH&gt;::type::type，重点关注hls::stream&lt;DATATYPE, XFCVDEPTH&gt;。所以data也是一种流数据模型。</p>\n<h1 id=\"已阅文献\"><a href=\"#已阅文献\" class=\"headerlink\" title=\"已阅文献\"></a>已阅文献</h1><h2 id=\"连通域在复杂背景肤色检测中的应用\"><a href=\"#连通域在复杂背景肤色检测中的应用\" class=\"headerlink\" title=\"连通域在复杂背景肤色检测中的应用\"></a>连通域在复杂背景肤色检测中的应用</h2><p>在对YCbCr空间和YCgCr空间中的肤色进行<strong>建模检测</strong>的基础上，引入连通域进行二次检测，以此消除背景中小面积类肤色区域对检测结果的影响。</p>\n<p>传统肤色检测方法主要分为两步：<strong>颜色空间变换和肤色建模</strong>，具有认知属性的、可以将亮度和色度分开处理的颜色空间有利于肤色检测。目前常用的色度与亮度相互独立的色彩空间有YUV，YCbCr。</p>\n<p>肤色检测获得的二值化图像中，同一目标的像素通常具有连通性，为提取肤色特征，可根据像素的连通性采用<strong>连通域标记算法区分出不同的目标</strong>。</p>\n<blockquote>\n<ul>\n<li><strong>肤色建模</strong><br>通过分析肤色数据集中的各种肤色像素的颜色信息来确定不同肤色模型中的模型参数，将建好的模型运用到具体的图像中来判断图像中的色像素是否为肤色像素。针对YCbCr<br>建立椭圆模型来对肤色进行检测。<br>将肤色样本在YCbCr颜色空间中进行统计，得到分布如下：</li>\n</ul>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/3.png\" class=\"\">\n<p>可以看出，肤色的亮度Y分布不具备聚集性，而色度分布则聚集在一个较小的范围内，如Cr值分布范围大致在100<del>200，Cb值大致分布在80</del>140之间，同时，肤色在CbCr平面的分布近似于一个椭圆，可用椭圆进行模拟。</p>\n<img src=\"/2022/12/03/hlsNote/4.png\" class=\"\">\n<p>可得椭圆的表达式如下：</p>\n<img src=\"/2022/12/03/hlsNote/5.png\" class=\"\">\n<p>通过此椭圆表达式即建立了一个检测肤色的椭圆模型，通过颜色空间变换后的Cb,Cr值求出x,y坐标，通过判断坐标是否位于椭圆区域之内来判断其是否属于肤色。上式左边&lt;&#x3D;1则为肤色，反之不属于肤色。此时可二值化。</p>\n<h2 id=\"实时-FPGA-手势识别-算法的设计\"><a href=\"#实时-FPGA-手势识别-算法的设计\" class=\"headerlink\" title=\"实时 FPGA 手势识别 算法的设计\"></a>实时 FPGA 手势识别 算法的设计</h2><p>本文从图像识别技术进行研究，从<strong>手势边缘与肤色信息</strong>出发，借助FPGA平台的高速特性，在<strong>Sobel边缘提取算法</strong>的基础上，提出利用<strong>椭圆颜色域分离法与高斯函数加权来优化手势信息特征值提取</strong>的算法。<br>原始图像<strong>分别</strong>输入 <strong>Sobel 边缘提取模块</strong>与<strong>色彩空间分离模块</strong>，经处理后的信号<strong>共同输入高斯加权模块</strong>，<strong>与肤色相关的边缘信息</strong>得到加强 ，无关信息得到抑制。 该算法 结合了手势图像的色彩信息与边缘信息，经过对比验证， 表明通过对<strong>边缘与肤色信息</strong>的算法优化 ，能有效滤去与手势无关的信息 ，在不同光照下测试均获得足够的辨识度 。</p>\n<img src=\"/2022/12/03/hlsNote/7.png\" class=\"\">\n\n<p>首先对手势信息的色彩域进行分析，发现手势信息色彩域集中在一个椭圆区域，为了保证一定的<strong>环境适应性</strong>，采用<strong>二维高斯函数</strong>对<strong>手势的色彩域</strong>进行权值计算，最后<strong>高斯加权</strong>到<strong>Sobel边缘提取算法输出的边缘信息</strong>中，实现了针对60fps下对手势边缘信息的提取和无关边缘信息的过滤。</p>\n<p>为使用sobel算法，先将RGB信号转化为灰度值，先求Y值。<br>对于色彩域分离，需要考虑将手部的肤色尽可能落在色彩空间的一小片区域里。采用YCgCr色彩空间并且修改色彩信息转换公式，摄像头获取的样本经过计算，可见手部肤色形成的聚类可近似用一个<strong>椭圆域</strong>进行描述。通过<strong>二维高斯函数</strong>使得颜色值落在此椭圆域里的像素获得较高的增益，远离此椭圆域的像素被抑制，实现了肤色的提取。<br>高斯函数的拟合思路为：</p>\n<ul>\n<li>先求聚类区域<strong>包络椭圆曲线</strong>。</li>\n<li>对得到的椭圆曲线匹配相应的二维高斯函数，使在椭圆域边界处的像素的像素值对应的权值为1。</li>\n</ul>\n<img src=\"/2022/12/03/hlsNote/8.png\" class=\"\">\n<img src=\"/2022/12/03/hlsNote/9.png\" class=\"\">\n\n<p>采用的二维高斯模型为：</p>\n<img src=\"/2022/12/03/hlsNote/10.png\" class=\"\">\n<img src=\"/2022/12/03/hlsNote/11.png\" class=\"\">\n\n<p><strong>自适应 sobel 边缘提取 模块设计</strong></p>\n<p>前面提到，灰度信息会从颜色域转换模块输出。灰度信息输入自适应sobel边缘提取模块，该模块<strong>目的在于提取出图像中的所有边缘信息</strong>。( <strong>中值滤波</strong>可以有效滤除脉冲噪声中值滤波可以有效滤除脉冲噪声，对高斯噪声也有一定的滤波效果，能够很好地保持边缘特性，<strong>Sobel 算子</strong>计算简单，对噪声有一定的平滑作用，能够提供较为准确的边缘方向信息。)</p>\n<p>sobel边缘提取算法可以参考</p>\n<p>sobel模块输出的值将通过阈值判断进行二值化处理，这里的阈值为<strong>中值滤波的输出值</strong>，用于实现<strong>自适应机制</strong>。</p>\n<img src=\"/2022/12/03/hlsNote/12.png\" class=\"\">\n\n\n\n<h2 id=\"基于PYNQ软硬结合的二维手势交互设计\"><a href=\"#基于PYNQ软硬结合的二维手势交互设计\" class=\"headerlink\" title=\"基于PYNQ软硬结合的二维手势交互设计\"></a>基于PYNQ软硬结合的二维手势交互设计</h2><img src=\"/2022/12/03/hlsNote/14.png\" class=\"\">\n\n<p>识别的手势包括 平移，缩放</p>\n<p>手势识别部分主要实现了对提取的手势类型的识别，并对手势进行了定位操<br>作，并将手势类型与定位信息传输给手势动作解析模块。</p>\n<p>手势交互控制信息的解析与输出部分主要结合手势识别的结果以及手势的位<br>置信息，做出手势动作含义的解读，将手势含义解读出来并将信息输出，用于进行相应的控制操作。</p>\n<p>需要使用到两个图像缓存，一个是在采集图像时对图像进行缓存，另一个是在图像输出时对图像进行缓存。2 个VDMA 图像缓存模块</p>\n<img src=\"/2022/12/03/hlsNote/15.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/16.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/17.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/18.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/19.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/20.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/21.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/22.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/23.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/24.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/25.png\" class=\"\">\n\n<p>手势区域截取，手势特征提取，手势识别，手势参数输出。</p>\n<p><strong>手势区域截取</strong><br><strong>基于统计规律的手势识别</strong><br>手势的基本特征主要有，手势的面积大小、手势的宽长比以及<strong>手势部分与矩形面积的比值</strong></p>\n<h2 id=\"基于FPGA-的手势识别系统\"><a href=\"#基于FPGA-的手势识别系统\" class=\"headerlink\" title=\"基于FPGA 的手势识别系统\"></a>基于FPGA 的手势识别系统</h2><p><strong>手势分割模块、手势特征提取模块、手型自适应模块和手势识别模块</strong></p>\n<img src=\"/2022/12/03/hlsNote/50.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/51.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/52.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/53.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/54.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/56.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/57.png\" class=\"\">\n\n<p>面积周长比，有效面积特征作为初步识别的特征参量，最后提取五阶Hu矩特征</p>\n<img src=\"/2022/12/03/hlsNote/58.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/59.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/60.png\" class=\"\">\n\n\n\n\n<h2 id=\"基于FPGA-动态手势识别系统研究与实现\"><a href=\"#基于FPGA-动态手势识别系统研究与实现\" class=\"headerlink\" title=\"基于FPGA 动态手势识别系统研究与实现\"></a>基于FPGA 动态手势识别系统研究与实现</h2><img src=\"/2022/12/03/hlsNote/67.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/68.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/69.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/70.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/71.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/72.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/73.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/74.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/75.png\" class=\"\">\n\n<blockquote>\n<p><strong>对于二值图像</strong><br>腐蚀：过滤无意义的点，过滤效果与腐蚀窗口形状大小有关。<br>膨胀：平滑边缘线，连接断裂的边缘线，<br>开：先用腐蚀消除噪声点，再膨胀平滑物体的边缘<br>这里作者使用了两次腐蚀和一次膨胀。</p>\n</blockquote>\n<img src=\"/2022/12/03/hlsNote/76.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/77.png\" class=\"\">\n\n<p>如前所说，膨胀能平滑边缘，所以在Sobel边缘提取后可以使用膨胀来</p>\n<img src=\"/2022/12/03/hlsNote/78.png\" class=\"\">\n\n<img src=\"/2022/12/03/hlsNote/79.png\" class=\"\">\n\n\n\n<h1 id=\"论文初稿\"><a href=\"#论文初稿\" class=\"headerlink\" title=\"论文初稿\"></a>论文初稿</h1><h2 id=\"提纲\"><a href=\"#提纲\" class=\"headerlink\" title=\"提纲\"></a>提纲</h2><p>HLS先验知识：HLS原理，HLS设计流程，vision library介绍（相当于OpenCV的移植，可以从Mat类等细节来介绍），HLS优化指令，HLS接口综合</p>\n<p>搭建基础结构：OV5640，VDMA读取视频缓存，BRAM实现PS、PL数据交互</p>\n<p>进行手势识别：中值滤波，肤色检测，开运算，边缘检测，Resize，Hu不变矩</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><blockquote>\n<p>第一章 绪论<br><strong>主要介绍了本课题的研究背景和研究意义，在分析了国内外的主要研究现状的基础上提出了本课题的主要研究内容，并给出了组织论文结构。</strong><br>1.1 课题背景及研究意义<br>1.2 国内外研究现状<br>1.3 论文主要研究内容及结构</p>\n<p>第二章 系统总体方案设计与关键技术<br><strong>首先介绍了本课题的系统结构，以系统实现框图的形式介绍系统总体结构。然后介绍基于ZYNQ体系结构的软硬件协同思想。此外还对HLS的基本原理以及设计流程进行了介绍，重点分析了使用HLS实现手势识别系统的优势。</strong><br>2.1 系统总体结构（画一张结构框图）<br>2.2 ZYNQ体系结构<br>2.2 HLS介绍<br>2.2.1 HLS原理<br>2.2.2 HLS设计流程<br>2.2.3 HLS优势<br>本章小结</p>\n<p>第三章 手势识别FPGA硬件平台的设计与实现<br><strong>介绍了如何使用HLS来实现图像的预处理，手势特征提取等算法的硬件加速。并且根据算法来调整代码结构，指定合适的优化指令来指导HLS综合C++代码得到RTL模块的过程。</strong><br>3.1 硬件部分总体方案设计<br>3. 手势识别算法<br>3.1.1 中值滤波<br>3.1.2 肤色检测<br>3.1.3  开运算<br>3.1.4  有效面积比（初步）特征<br>3.1.5  resize<br>3.1.6 边缘检测<br>本章小结</p>\n<p>第四章 手势识别软件工程的设计与实现<br><strong>主要包括硬件平台的搭建以完成各个模块的互联和控制；设计嵌入式软件应用程序来实现对硬件模块的控制，根据提取的手势特征值对手势进行识别并显示。</strong><br>本章小结</p>\n<p>第五章 系统调试与实验结果分析<br><strong>对系统进行测试，从系统功能实现、实时性以及资源占用情况对系统性能进行分析。</strong><br>本章小结</p>\n</blockquote>\n<h2 id=\"优化指令\"><a href=\"#优化指令\" class=\"headerlink\" title=\"优化指令\"></a>优化指令</h2><p>#pragma HLS ARRAY_PARTITION dim&#x3D;1 factor&#x3D;300 type&#x3D;block variable&#x3D;Array：</p>\n<p>#pragma HLS ARRAY_MAP：</p>\n<p>#pragma HLS ARRAY_RESHAPE dim&#x3D;1 factor&#x3D;300 type&#x3D;block variable&#x3D;Array：</p>\n<p>#pragma HLS UNROLL：</p>\n<p>#pragma HLS INTERFACE mode&#x3D;m_axi bundle&#x3D;RESULT depth&#x3D;50 port&#x3D;result offset&#x3D;slave：</p>\n<p>#pragma HLS LOOP_FLATTEN：</p>\n<p>#pragma HLS PIPELINE II&#x3D;1 rewind：</p>\n<p>#pragma HLS DATAFLOW</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>导入参考文献：</p>\n<ol>\n<li>可以用本地的pdf文件来导入</li>\n<li>引用格式采用endnote</li>\n</ol>\n<p><a href=\"https://sustech.libguides.com/c.php?g=929626&p=6717028\">EndNote专题: 导入文献</a><br><a href=\"https://sustech.libguides.com/c.php?g=929626&p=6717030\">EndNote专题: 引用文献</a></p>\n<p><a href=\"https://blog.csdn.net/dl962454/article/details/122600980\">论文写作技巧 : Endnote参考文献统一输出格式</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/114057977\">EndNote详细使用教程</a></p>\n<h1 id=\"Some-Words\"><a href=\"#Some-Words\" class=\"headerlink\" title=\"Some Words\"></a>Some Words</h1><p>Accumulate   积累，累积<br>accumulator  累加器<br>attribute   属性</p>\n<p>bitwise      按位</p>\n<p>constructor  构造器（构造函数）<br>coordinate   坐标<br>convolve&#x2F;convolution     卷积<br>criteria     标准<br>compatible   兼容的<br>constitute   构成</p>\n<p>digilent     勤快的<br>deviation    偏差<br>depict       描绘</p>\n<p>extract      提取<br>enumerate    枚举</p>\n<p>facilitate   促进</p>\n<p>intensity    亮度&#x2F;灰阶值<br>infrastructure  基础架构<br>iterative    迭代的</p>\n<p>luminence    亮度</p>\n<p>manipulate   操纵<br>mandatory    强制性的</p>\n<p>optimized    优化的<br>optical      光学的</p>\n<p>parallelism  并行性<br>ported       移植<br>pyramidal    金字塔形的</p>\n<p>quantized    量化</p>\n<p>rectangle    矩形<br>Retrieve     取回<br>register     寄存器，登记</p>\n<p>scalar       标量<br>spatial      空间的<br>suppression  抑制<br>subtract     减去<br>saturate     饱和</p>\n<p>throghput    吞吐率</p>\n<h1 id=\"Some-Problems\"><a href=\"#Some-Problems\" class=\"headerlink\" title=\"Some Problems\"></a>Some Problems</h1><p><a href=\"https://github.com/dgschwend/zynqnet/issues/30\">在 VHLS 中导出 RTL 时出现问题</a><br><a href=\"https://blog.csdn.net/Chitanda_Eru_/article/details/122287842?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-122287842-blog-122312505.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-122287842-blog-122312505.pc_relevant_default&utm_relevant_index=1\">HLS BUG</a><br><a href=\"https://blog.csdn.net/u014798590/article/details/122312505\">HLS ERROR: [IMPL 213-28] Failed to generate IP.</a></p>\n<img src=\"/2022/12/03/hlsNote/13.png\" class=\"\">\n\n<p>通过修改版本号（原来为1.0，修改为2.0.0）解决问题，也可以插入补丁。<br>参考<a href=\"https://support.xilinx.com/s/article/76960?language=en_US\">补丁</a></p>\n<p><a href=\"http://hunkshi.github.io/2013/08/09/2013-08-09-cpp-typename-keyword-usage/\">C++中typename关键字的使用方法和注意事项</a></p>\n<p><a href=\"https://blog.csdn.net/M_jianjianjiao/article/details/84109955\">头文件中能否进行函数的定义?</a></p>\n<p>首先要知道，stream数据是一种流数据，只能按顺序读取，并且不能读取第二次，它就如同水流一般向前行。对于HLS中的Stream数据来说，有输入就必须有输出，在testbench中赋予了stream一些数据但并没有全部读出的话意味着song data left over，而一个流数据读取两次的话，第二次肯定read while empty。这些可能会造成RTL hanging，在FPGA中则会形成dead lock。<br><a href=\"https://support.xilinx.com/s/article/57876?language=en_US\">Vivado HLS 2013.2: how to investigate WARNING: Hls::stream ‘hls::stream.XX’ is read while empty, or WARNING: Hls::stream ‘hls::stream<XX>.2’ contains leftover data, which may result in RTL simulation hanging</a><br><a href=\"https://support.xilinx.com/s/question/0D52E00006hpaJeSAI/c-simulation-warning?language=en_US\">C simulation Warning</a></p>\n<p>这个问题与帧差法两个输入数据流的缓存有关。<br><a href=\"https://support.xilinx.com/s/question/0D52E00006hpe5LSAQ/how-to-subtract-hlserode-output-from-the-hlsduplicate-output-to-create-boundries?language=en_US\">https://support.xilinx.com/s/question/0D52E00006hpe5LSAQ/how-to-subtract-hlserode-output-from-the-hlsduplicate-output-to-create-boundries?language=en_US</a><br><a href=\"https://support.xilinx.com/s/question/0D52E00006hpLJZSA2/%E5%B8%A7%E5%B7%AE%E6%B3%95%E6%A3%80%E6%B5%8B%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93?language=en_US\">帧差法检测运动物体</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://e-elements.com/product/show/id/60.shtml\">pynq-z2资料下载</a><br><a href=\"https://www.tulembedded.com/FPGA/ProductsPYNQ-Z2.html\">TUL pynq-z2</a></p>\n<p><a href=\"https://www.hackster.io/adam-taylor/fpga-based-edge-detection-using-hls-192ad2\">使用 HLS 进行基于 FPGA 的边缘检测</a><br><a href=\"https://aijishu.com/a/1060000000287977\">同上</a></p>\n<p><a href=\"https://xilinx.eetrend.com/content/2018/100014521.html\">基于Vivado HLS的Canny算法实时加速设计</a> 提到行缓存和窗口缓存</p>\n<p><a href=\"https://xupsh.gitbook.io/pp4fpgas-cn/readme/readme\">中文版 FPGA Parallel Programming</a></p>\n<p><a href=\"https://hitsz-cslab.gitee.io/dla/lab2/theory/\">基于HLS的YOLO算法量化加速</a>某位哈工大老师的博客，很不错。</p>\n<p><a href=\"https://www.xilinx.com/htmldocs/xilinx2017_4/sdaccel_doc/jit1504034365862.html\">SDAccel Development Environment Help</a>有优化指定的讲解。</p>\n<p><a href=\"https://bbs.eetop.cn/thread-566420-1-1.html\">时序警告</a><br><a href=\"https://support.xilinx.com/s/question/0D52E00006hpqrNSAQ/implementation%E5%90%8Ewns%E4%B8%BA%E8%B4%9F%E4%BD%86%E8%83%BD%E7%94%9F%E6%88%90bit%E6%96%87%E4%BB%B6%E8%AF%B7%E9%97%AEwns%E4%B8%BA%E8%B4%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3?language=en_US\">implementation后WNS为负</a><br><strong>时序错误</strong></p>\n<p><a href=\"https://www.eefocus.com/course/1074552.html\">与非网视觉库教程视频</a><strong>未看</strong></p>\n<p><strong>还有几篇较有价值的文章没看</strong><br><a href=\"https://xilinx.eetrend.com/d6-xilinx/article/2014-09/7700.html\">Vivado HLS图像拼接系统原理及实现</a><br><a href=\"https://chhzh123.github.io/blogs/2020-03-11-vivado-hls/\">Vivado HLS in a Nutshell</a><br><a href=\"https://xilinx.eetrend.com/d6-xilinx/article/2013-07/4230.html\">利用赛灵思Vivado HLS 实现浮点设计</a><br><a href=\"https://blog.csdn.net/jerwey/article/details/107541077\">XAPP599-Vivado HLS的浮点设计</a></p>\n<p><a href=\"https://readdevdocs.com/blog/makemoney/%E4%B8%AD%E5%9B%BD%E5%8C%BA%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7%E8%AF%95%E7%94%A8ChatGPT%E6%8C%87%E5%8D%97.html#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87\">注册chatgpt 4</a><br>用台湾ip可以进chatgpt注册网页</p>\n<p><a href=\"https://github.com/Xilinx/Vitis_Libraries/tree/master/vision\">Vitis Vision Library</a></p>\n","categories":["FPGA"],"tags":["C++","HLS","CV"]},{"title":"javaNote","url":"/2024/02/23/javaNote/","content":"<p><em><strong>三十功名尘与土，八千里路云和月</strong></em></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h1><h2 id=\"源文件规则\"><a href=\"#源文件规则\" class=\"headerlink\" title=\"源文件规则\"></a>源文件规则</h2><p>一个完整的Java。源程序应该包括下列部分：</p>\n<p> <strong>package</strong>语句，该部分至多只有一句，必须放在源程序的第一句。<br> <strong>import</strong>语句，该部分可以有若干import语句或者没有，必须放在所有的类定义之前。<br> <strong>public classDefinition</strong>，公共类定义部分，至多只有一个公共类的定义，Java语言规定该Java源程序的文件名必须与该公共类名完全一致。<br> <strong>classDefinition</strong>，类定义部分，可以有0个或者多个类定义。<br><strong>interfaceDefinition</strong>，接口定义部分，可以有0个或者多个接口定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> javawork.helloworld;</span><br><span class=\"line\"><span class=\"comment\">/*把编译生成的所有．class文件放到包javawork.helloworld中*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java awt.*;</span><br><span class=\"line\"><span class=\"comment\">//告诉编译器本程序中用到系统的AWT包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> javawork.newcentury;</span><br><span class=\"line\"><span class=\"comment\">/*告诉编译器本程序中用到用户自定义的包javawork.newcentury*/</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldApp</span>&#123;...｝</span><br><span class=\"line\"><span class=\"comment\">/*公共类HelloWorldApp的定义，名字与文件名相同*/</span> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TheFirstClass</span>｛...｝;</span><br><span class=\"line\"><span class=\"comment\">//第一个普通类TheFirstClass的定义 </span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">TheFirstInterface</span>&#123;......&#125;</span><br><span class=\"line\"><span class=\"comment\">/*定义一个接口TheFirstInterface*/</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Public类-amp-amp-main\"><a href=\"#Public类-amp-amp-main\" class=\"headerlink\" title=\"Public类 &amp;&amp; main\"></a>Public类 &amp;&amp; main</h3><p>为什么JAVA文件中只能含有一个Public类?</p>\n<p>java 程序是从一个 public 类的 main 函数开始执行的，(其实是main线程)，就像 C 程序 是从 main() 函数开始执行一样。 只能有一个 public 类是为了给类装载器提供方便。 一个 public 类只能定义在以它的类名为文件名的文件中。</p>\n<p>每个编译单元(文件)都只有一个 public 类。因为每个编译单元都只能有一个公共接口，用 public 类来表现。如果有一个以上的 public 类，编译器就会报错。 并且 public类的名称必须与文件名相同(严格区分大小写)。 当然一个编译单元内也可以没有 public 类。</p>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><p>package的命名: package 的名字由全部小写的字母组成，例如：com.runoob。<br>class和interface的命名: class和interface的名字由<strong>大写字母开头</strong>而其他字母都小写的单词组成(大驼峰)，例如：Person，RuntimeException。<br>class中变量的命名: 变量的名字用一个<strong>小写字母开头</strong>，后面的单词用大写字母开头,例如：index，currentImage。<br>class中方法的命名: 方法的名字用一个<strong>小写字母开头</strong>，后面的单词用大写字母开头,例如：run()，getBalance()。<br>staticfinal变量的命名: static final变量的名字所有字母都大写，并且能表示完整含义。例如：PI，PASSWORD。</p>\n<h3 id=\"import-amp-amp-package-规则\"><a href=\"#import-amp-amp-package-规则\" class=\"headerlink\" title=\"import &amp;&amp; package 规则\"></a>import &amp;&amp; package 规则</h3><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>\n<p>一个源文件中只能有一个 public 类<br>一个源文件可以有多个非 public 类<br>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。<br>如果一个类定义在某个<strong>包</strong>中，那么 <strong>package</strong> 语句应该在源文件的首行。<br>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。<br>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p>\n<h4 id=\"Java-package\"><a href=\"#Java-package\" class=\"headerlink\" title=\"Java package\"></a>Java package</h4><p>包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>\n<p>package 的作用就是 c++ 的 namespace 的作用，防止名字相同的类产生冲突。Java 编译器在编译时，直接根据 package 指定的信息直接将生成的 class 文件生成到对应目录下。如 package aaa.bbb.ccc 编译器就将该 .java 文件下的各个类生成到 .&#x2F;aaa&#x2F;bbb&#x2F;ccc&#x2F; 这个目录。</p>\n<h4 id=\"Java-import\"><a href=\"#Java-import\" class=\"headerlink\" title=\"Java import\"></a>Java import</h4><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>\n<p>例如，下面的命令行将会命令编译器载入 java_installation&#x2F;java&#x2F;io 路径下的所有类<br><code>import java.io.*;</code><br>java因强制要求类名（唯一的public类）和文件名统一，因此在引用其它类时无需显式声明。在编译时，编译器会根据类名去寻找同名文件。</p>\n<p>import 是为了简化使用 package 之后的实例化的代码。假设 .&#x2F;aaa&#x2F;bbb&#x2F;ccc&#x2F; 下的 A 类，假如没有 import，实例化A类为：new aaa.bbb.ccc.A()，使用 import aaa.bbb.ccc.A 后，就可以直接使用 new A() 了，也就是编译器匹配并扩展了 aaa.bbb.ccc. 这串字符串。</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"变量命名规则\"><a href=\"#变量命名规则\" class=\"headerlink\" title=\"变量命名规则\"></a>变量命名规则</h3><p>实例变量、局部变量、静态变量 、参数<br>驼峰命名法（Camel Case）： 在变量名中使用驼峰命名法，即将每个单词的首字母大写，除了第一个单词外，其余单词的首字母都采用大写形式。例如：myVariableName。<br>静态变量（类变量）通常也可以使用大写蛇形命名法（Upper Snake Case），全大写字母，单词之间用下划线分隔。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用驼峰命名法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> myStaticVariable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用大写蛇形命名法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<p>常量<br>使用全大写字母，单词之间用下划线分隔。<br>常量通常使用 final 修饰。<br>类名<br>使用驼峰命名法(大驼峰)。<br>应该以大写字母开头。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类的成员和方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"普通变量\"><a href=\"#普通变量\" class=\"headerlink\" title=\"普通变量\"></a>普通变量</h3><p>一个类可以包含以下类型变量：</p>\n<p><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。<br>局部变量是在栈上分配的。<br>局部变量没有默认值，所以局部变量被声明后，必须经过初始化(初始化可以在声明时或后面的代码中进行)，才可以使用。如果在使用局部变量之前不初始化它，编译器会报错。</p>\n<p><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。<br><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 <strong>static</strong> 类型。<br>由static修饰的变量称为静态变量，其实质上就是一个全局变量。如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；没有被静态修饰的内容，其实是属于对象的特殊描述。<br>不同的对象的实例变量将被分配不同的内存空间， 如果类中的成员变量有类变量，那么所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量，也就是说对象共享类变量。</p>\n<p>调用方式不同<br>成员变量只能被对象调用。<br>静态变量可以被对象调用，还可以被类名调用。</p>\n<p>static 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。<br>特点：<br>1、想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。<br>2、被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。<br>3、<strong>静态随着类的加载而加载</strong>。而且优先于对象存在。</p>\n<p>成员变量和静态变量的区别：</p>\n<p>   1、成员变量所属于对象。所以也称为实例变量。</p>\n<pre><code>  静态变量所属于类。所以也称为类变量。\n</code></pre>\n<p>   2、成员变量存在于堆内存中。</p>\n<pre><code>  静态变量存在于方法区中。\n</code></pre>\n<p>   3、成员变量随着对象创建而存在。随着对象被回收而消失。</p>\n<pre><code>  静态变量随着类的加载而存在。随着类的消失而消失。\n</code></pre>\n<p>   4、成员变量只能被对象所调用 。</p>\n<pre><code>  静态变量可以被对象调用，也可以被类名调用。\n</code></pre>\n<p>   所以，<strong>成员变量可以称为对象的特有数据，静态变量称为对象的共享数据</strong>。</p>\n<p>生命周期<br>静态变量的生命周期与程序的生命周期一样长，即它们在类加载时被创建，在整个程序运行期间都存在，直到程序结束才会被销毁。因此，静态变量可以用来存储整个程序都需要使用的数据，如配置信息、全局变量等。</p>\n<p>静态变量的线程安全性<br>Java 中的静态变量是属于类的，而不是对象的实例。因此，当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。</p>\n<p>静态变量在内存中只有一份拷贝，被所有实例共享。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题。</p>\n<p>为了确保静态变量的线程安全性，需要采取适当的同步措施，如<strong>同步机制、原子类或 volatile 关键字</strong>，以便在多线程环境中正确地读取和修改静态变量的值。</p>\n<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：<br><code>final double PI = 3.1415927;</code></p>\n<p>前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：<br>int decimal &#x3D; 100;<br>int octal &#x3D; 0144;<br>int hexa &#x3D;  0x64;</p>\n<p>通常使用大写字母表示常量。</p>\n<h3 id=\"引用类型变量\"><a href=\"#引用类型变量\" class=\"headerlink\" title=\"引用类型变量\"></a>引用类型变量</h3><p>在Java中，引用类型的变量非常类似于C&#x2F;C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。<br>对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null。</p>\n<p>引用类型变量在声明后必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问。</p>\n<p>MyDate today;          &#x2F;&#x2F;将变量分配一个保存引用的空间<br>today &#x3D; new MyDate();     &#x2F;&#x2F; 这句话是2步，首先执行new MyDate（），给today变量开辟数据空间，然后再执行赋值操作<br>引用变量赋值：</p>\n<p>MyDate a，b;       &#x2F;&#x2F; 在内存开辟两个引用空间<br>a &#x3D; new MyDate();       &#x2F;&#x2F; 开辟MyDate对象的数据空间，并把该空间的首地址赋给a<br>b &#x3D; a;                   &#x2F;&#x2F; 将a存储空间中的地址写到b的存储空间中</p>\n<h3 id=\"参数变量\"><a href=\"#参数变量\" class=\"headerlink\" title=\"参数变量\"></a>参数变量</h3><p>方法参数变量的值传递方式有两种：<strong>值传递和引用传递</strong>。</p>\n<p>值传递：在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的<strong>基本数据类型都采用值传递方式</strong>传递参数变量的值。</p>\n<p>引用传递：在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的<strong>对象类型采用引用传递方式</strong>传递参数变量的值。</p>\n<h2 id=\"static和final\"><a href=\"#static和final\" class=\"headerlink\" title=\"static和final\"></a>static和final</h2><p>在Java中，static和final是两个常用的关键字，用于修饰类的成员变量和方法。static和final的区别是：1、作用范围；2、关联性；3、修改能力；4、继承和重写。作用范围是指，static用于修饰类成员（静态变量和静态方法），而final用于修饰类、成员变量和方法。使用static修饰的成员变量称为静态变量，也称为类变量。</p>\n<p>重写(Override)：是子类对父类允许方位的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心重写。</p>\n<p>重载(Overload)：是在一个类里面，方法名字相同，二参数不同。返回类型可以相同也可以不同，每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>\n\n\n<p>一、static关键字<br>static是一个用于修饰类成员的关键字，可以用于静态变量和静态方法。</p>\n<ol>\n<li><p>静态变量（静态属性）： 使用static修饰的成员变量称为静态变量，也称为类变量。静态变量在类加载时被初始化，只有一个副本存在于内存中，并且所有该类的实例共享相同的静态变量。可以通过类名直接访问静态变量，无需创建对象。</p>\n</li>\n<li><p>静态方法： 使用static修饰的方法称为静态方法。静态方法属于类而不属于对象，可以通过类名直接调用，无需创建对象。静态方法中只能访问静态成员变量，而不能访问非静态成员变量，因为非静态成员变量是属于对象的，而静态方法是属于类的。</p>\n</li>\n</ol>\n<p>注意：</p>\n<p>静态方法中不能使用this关键字，因为this代表当前对象，而静态方法不属于任何对象。<br>静态方法中不能使用super关键字，因为super代表父类对象，而静态方法与对象无关。</p>\n<p>二、final关键字<br>final是一个用于修饰类、成员变量和方法的关键字。</p>\n<ol>\n<li><p>final类： 使用final修饰的类称为final类。final类是不能被继承的，即不能有子类。通常用于确保类的完整性和安全性。</p>\n</li>\n<li><p>final成员变量（常量）： 使用final修饰的成员变量称为final变量或常量。final成员变量必须在声明时或构造函数中进行初始化，并且一旦初始化后就不能再修改其值。常量通常用大写字母表示，并且在多个单词之间用下划线分隔。</p>\n</li>\n<li><p>final方法： 使用final修饰的方法称为final方法。final方法不能被子类重写，即不能被子类进行覆盖。通常用于确保方法的行为不会被子类修改。</p>\n</li>\n</ol>\n<p>注意：</p>\n<p>final成员变量可以在声明时初始化，也可以在构造函数中初始化，但一旦初始化后就不能再修改。<br>final方法不能被子类重写，但可以被继承。</p>\n<p>三、区别和联系<br>作用范围： static用于修饰类成员（静态变量和静态方法），而final用于修饰类、成员变量和方法。<br>关联性： static关键字是与类相关联的，可以通过类名直接访问静态成员。而final关键字是与类的实例相关联的，用于限制类、变量或方法的特性。<br>修改能力： 静态变量可以被修改，其值可以在程序运行过程中发生变化。而final成员变量一旦被初始化后，其值不可再变更，成为常量。<br>继承和重写： final修饰的类不能被继承，final修饰的方法不能被重写（覆盖），但static修饰的方法<strong>可以被重写，但不能被覆盖</strong>。<br>主要参考：<br><a href=\"https://docs.pingcode.com/ask/46663.html\">static和final的区别是什么</a></p>\n<p>上面提到对static修饰的方法的重写(Override)和覆盖，总结地说：static修饰的方法可以在子类重写，但是不会起到任何作用，因为父类的静态方法在编译前已经加载，只与类有关，与类的实例对象无关。即：<br>在Java中，如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上<strong>只是将父类中的该同名方法进行了隐藏</strong>，而非重写（就是上面“可以重写，但没有覆盖”的意思）。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性。正如同《Java编程思想》中所说：“一旦你了解了多态机制，可能就会认为所有事物都可以多态地发生。然而，只有普通方法的调用可以是多态的。如果你直接访问某个域，（不管是否是静态static），这个访问就<strong>将在编译期间进行解析</strong>。”这也很好地理解了，为什么在Java中，static方法和final方法（private方法属于final方法）是<strong>前期绑定</strong>，而其他所有的方法都是后期绑定了。</p>\n<p>参考：<br><a href=\"https://juejin.cn/post/6844903603010797582\">父类静态方法可以重写吗？</a><br><a href=\"https://blog.csdn.net/fcvtb/article/details/89193844\">【面试】Java static方法能否被重写或重载</a></p>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"Java-Number-amp-amp-Math-类\"><a href=\"#Java-Number-amp-amp-Math-类\" class=\"headerlink\" title=\"Java Number  &amp;&amp; Math 类\"></a>Java Number  &amp;&amp; Math 类</h3><p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。</p>\n<p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 <strong>Number</strong> 的子类。</p>\n<img src=\"/2024/02/23/javaNote/1.png\" class=\"\">\n\n<p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p>\n<p>Java 的 <strong>Math</strong> 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>\n<p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。<br><code>System.out.println(&quot;90 度的正弦值：&quot; + Math.sin(Math.PI/2));  </code></p>\n<p>以下列出 Number &amp; Math 类常用的一些<strong>方法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>\txxxValue()</span><br><span class=\"line\">将 Number 对象转换为xxx数据类型的值并返回。</span><br><span class=\"line\">      <span class=\"type\">Integer</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 返回 byte 原生数据类型</span></span><br><span class=\"line\">      System.out.println( x.byteValue() );  <span class=\"number\">5</span></span><br><span class=\"line\">      <span class=\"comment\">// 返回 double 原生数据类型</span></span><br><span class=\"line\">      System.out.println(x.doubleValue());  <span class=\"number\">5.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>\tcompareTo()</span><br><span class=\"line\">将Number对象与参数比较。该方法用于两个相同数据类型的比较，两个不同类型的数据不能用此方法来比较。指定的数与参数相等返回 <span class=\"number\">0</span>，小于参数返回 -<span class=\"number\">1</span>，大于参数返回 <span class=\"number\">1</span>。</span><br><span class=\"line\">      <span class=\"type\">Integer</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">      System.out.println(x.compareTo(<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>\tequals()</span><br><span class=\"line\">判断number对象是否与参数相等。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>\tvalueOf()</span><br><span class=\"line\">valueOf() 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String，<span class=\"type\">int</span>等。</span><br><span class=\"line\">以Interge类为例（很多类都可以使用valueOf()方法来返回相应类的对象）：</span><br><span class=\"line\">Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">int</span> i)</span>：返回一个表示指定的 <span class=\"type\">int</span> 值的 Integer 实例。</span><br><span class=\"line\">Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(String s)</span>:返回保存指定的 String 的值的 Integer 对象。</span><br><span class=\"line\">Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(String s, <span class=\"type\">int</span> radix)</span>: 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</span><br><span class=\"line\">例如：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span>Integer.valueOf(<span class=\"number\">9</span>);  <span class=\"number\">9</span></span><br><span class=\"line\">                <span class=\"type\">Double</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Double.valueOf(<span class=\"number\">5</span>);   <span class=\"number\">5.0</span></span><br><span class=\"line\">                <span class=\"type\">Float</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> Float.valueOf(<span class=\"string\">&quot;80&quot;</span>);  <span class=\"number\">80.0</span>（这个好用）</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> Integer.valueOf(<span class=\"string\">&quot;444&quot;</span>,<span class=\"number\">16</span>);  <span class=\"number\">1092</span> ( <span class=\"number\">16</span>进制的<span class=\"number\">444</span>就是<span class=\"number\">1092</span>)   <span class=\"comment\">// 使用 16 进制</span></span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(x); </span><br><span class=\"line\">                System.out.println(c);</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">                System.out.println(b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span>\ttoString()</span><br><span class=\"line\">toString() 方法用于返回以一个字符串表示的 Number对象。</span><br><span class=\"line\">如果方法使用了原生的数据类型作为参数，返回原生数据类型的 String 对象值。</span><br><span class=\"line\">如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式。</span><br><span class=\"line\">toString(): 返回表示 Integer 值的 String 对象。</span><br><span class=\"line\">toString(<span class=\"type\">int</span> i): 返回表示指定 <span class=\"type\">int</span> 的 String（或其他Number类） 对象，取决于是哪个类调用这个方法。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(x.toString());  </span><br><span class=\"line\">        System.out.println(Integer.toString(<span class=\"number\">12</span>)); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6</span>\tparseInt() <span class=\"comment\">// 很强大，配合Integer.toBinaryString Integer.toHexString 等</span></span><br><span class=\"line\">将字符串解析为<span class=\"type\">int</span>类型，用于将字符串参数作为有符号的十进制整数进行解析。</span><br><span class=\"line\">如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">parseInt</span><span class=\"params\">(String s)</span>  s -- 十进制表示的字符串。</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">parseInt</span><span class=\"params\">(String s, <span class=\"type\">int</span> radix)</span>  radix -- 指定的基数。</span><br><span class=\"line\">parseInt(String s): 返回用十进制参数表示的整数值。</span><br><span class=\"line\">parseInt(<span class=\"type\">int</span> i): 使用指定基数的字符串参数换算的十进制整数 (基数可以是 <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, 或 <span class=\"number\">16</span> 等进制数) 。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span>Integer.parseInt(<span class=\"string\">&quot;9&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Double.parseDouble(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> Integer.parseInt(<span class=\"string\">&quot;444&quot;</span>,<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(x);  <span class=\"number\">9</span></span><br><span class=\"line\">        System.out.println(c);  <span class=\"number\">5.0</span></span><br><span class=\"line\">        System.out.println(b);  <span class=\"number\">1092</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7</span>\tMath.abs()</span><br><span class=\"line\">返回参数的绝对值。</span><br><span class=\"line\"><span class=\"number\">8</span>\tceil()</span><br><span class=\"line\">返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。</span><br><span class=\"line\"><span class=\"number\">9</span>\tfloor()</span><br><span class=\"line\">返回小于等于（&lt;=）给定参数的最大整数 。</span><br><span class=\"line\"><span class=\"number\">10</span>\trint()</span><br><span class=\"line\">返回与参数最接近的整数。返回类型为<span class=\"type\">double</span>。</span><br><span class=\"line\"><span class=\"number\">11</span>\tround()</span><br><span class=\"line\">它表示四舍五入，算法为 **Math.floor(x+<span class=\"number\">0.5</span>)**，即将原来的数字加上 <span class=\"number\">0.5</span> 后再向下取整，所以，Math.round(<span class=\"number\">11.5</span>) 的结果为<span class=\"number\">12</span>，Math.round(-<span class=\"number\">11.5</span>) 的结果为-<span class=\"number\">11</span>。</span><br><span class=\"line\"><span class=\"number\">12</span>\tmin()</span><br><span class=\"line\">返回两个参数中的最小值。</span><br><span class=\"line\"><span class=\"number\">13</span>\tmax()</span><br><span class=\"line\">返回两个参数中的最大值。</span><br><span class=\"line\"><span class=\"number\">14</span>\texp()</span><br><span class=\"line\">返回自然数底数e的参数次方。</span><br><span class=\"line\"><span class=\"number\">15</span>\tlog()</span><br><span class=\"line\">返回参数的自然数底数的对数值。</span><br><span class=\"line\"><span class=\"number\">16</span>\tpow()</span><br><span class=\"line\">返回第一个参数的第二个参数次方。</span><br><span class=\"line\"><span class=\"number\">17</span>\tsqrt()</span><br><span class=\"line\">求参数的算术平方根。</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.csdn.net/w47_csdn/article/details/126693683\">Integer.parseInt转换二进制数为int整数异常</a><br>关于java中二进制数存储等一些问题。</p>\n<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。<br>在这种情况下，输入和输出都将被指定为有符号整数类型。<br>在 Java 中，编译器使用<a href=\"https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fromtitle=%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81&fromid=5295284\">二进制补码</a>记法来表示有符号整数。<br>注：0和正数补码就是原码，负数的补码是除了符号位取反之后加一。</p>\n<p><code>int pnb3 = Integer.parseUnsignedInt(nb, 2)</code></p>\n<p><a href=\"https://blog.csdn.net/u010502101/article/details/79162587\">Integer.parseInt(s)与Integer.valueOf(s)的区别详解</a> 好文章</p>\n<p>Integer.parseInt(s)的作用就是把字符串s解析成<strong>有符号的int基本类型</strong>。<br>Integer.valueOf(s)把字符串s解析成Integer对象类型，返回的integer 可以调用对象中的方法。</p>\n<p><strong>Integer.parseInt(s)与Integer.valueOf(s)的区别</strong><br><strong>Integer.parseInt(s)</strong><br>Integer.parseInt(s)多次解析同一个字符串得到的<strong>int基本类型数据是相等的</strong>，可以直接通过“&#x3D;&#x3D;”进行判断是否相等。<br>int是基本类型，不含有equals方法，所以只能用“&#x3D;&#x3D;”比较，基本类型用“&#x3D;&#x3D;”比较的是两个值的大小。<br><strong>Integer.valueOf(s)</strong><br>Integer.valueOf(s)多次解析相同的一个字符串时，<strong>得到的是Integer类型的对象</strong>，得到的对象<strong>有时是同一个对象，有时是不同的对象</strong>，要根据把s字符串解析的整数值的大小进行决定：<br>如果s字符串对应的整数值在 <strong>-128~127</strong>之间，则解析出的Integer类型的对象是同一个对象；如果s字符串对应的整数值不在 <strong>-128~127</strong>之间，则解析出的Integer类型的对象不是同一个对象。不管对象是否相等，对象中的value值是相等的。</p>\n<p><strong>原因</strong>： 为什么Integer.valueOf(s)会出现这种情况呢？这是由于JDK中源码已经定义好的。由于在-128<del>127之间的整数值用的比较频繁，当每次要创建一个value值在-128</del>127之间的Integer对象时，直接从缓存中拿到这个对象，所以value值相同的Integer对象都是对应缓存中同一个对象。-128~127之外的整数值用的不是太频繁，每次创建value值相同的Integer对象时，都是重新创建一个对象，所以创建的对象不是同一个对象。</p>\n<p><strong>Integer.parseInt(s)与Integer.valueOf(s)的联系</strong><br>Integer.parseInt(s)是把字符串解析成int基本类型，Integer.valueOf(s)是把字符串解析成Integer对象类型，其实<strong>int就是Integer解包装</strong>，<strong>Integer就是int的包装</strong>，<strong>在jdk8中已经自动实现了自动解包装和自动包装</strong>，所以两种方式都能得到想要的整数值。</p>\n<p>把Integer类型自动解包装成int类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> n;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"Java-Character-类\"><a href=\"#Java-Character-类\" class=\"headerlink\" title=\"Java Character 类\"></a>Java Character 类</h3><p>Character 类用于对单个字符进行操作。<br>Character 类在对象中包装一个基本类型 char 的值</p>\n<p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。</p>\n<p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：<br><code>Character ch = new Character(&#39;a&#39;);</code></p>\n<p>将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>\tisLetter()</span><br><span class=\"line\">是否是一个字母</span><br><span class=\"line\"><span class=\"number\">2</span>\tisDigit()</span><br><span class=\"line\">是否是一个数字字符</span><br><span class=\"line\"><span class=\"number\">3</span>\tisWhitespace()</span><br><span class=\"line\">是否是一个空白字符</span><br><span class=\"line\"><span class=\"number\">4</span>\tisUpperCase()</span><br><span class=\"line\">是否是大写字母</span><br><span class=\"line\"><span class=\"number\">5</span>\tisLowerCase()</span><br><span class=\"line\">是否是小写字母</span><br><span class=\"line\"><span class=\"number\">6</span>\ttoUpperCase()</span><br><span class=\"line\">指定字母的大写形式</span><br><span class=\"line\"><span class=\"number\">7</span>\ttoLowerCase()</span><br><span class=\"line\">指定字母的小写形式</span><br><span class=\"line\"><span class=\"number\">8</span>\ttoString()</span><br><span class=\"line\">返回字符的字符串形式，字符串的长度仅为<span class=\"number\">1</span>（结果是长度为 <span class=\"number\">1</span> 的字符串，仅由指定的 <span class=\"type\">char</span> 组成） </span><br><span class=\"line\">System.out.println(Character.toString(<span class=\"string\">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Java-String-类\"><a href=\"#Java-String-类\" class=\"headerlink\" title=\"Java String 类\"></a>Java String 类</h3><p>java.lang.String类代表字符串。<br>Java程序中所有字符串文字都为此类的对象。</p>\n<p>注意：String类首字母大写，类的首字母都大写。</p>\n<p>以”xx”形式给出的字符串对象，在字符常量池中存储。<br>字符串类型，可以定义字符串引用变量指向字符串对象。(Java中对象存放在堆中，堆的空间不是连续的所以比较大，引用存放在栈中，栈是连续的并且空间比较小)<br>String变量<strong>每次的修改</strong>都是产生了新的字符串对象并且引用修改指向。<br>原来的字符串对象都是没有改变的，所以称<strong>字符串不可变</strong>。</p>\n<p>以<code>&quot;&quot;</code>方式给出的字符串对象，在<strong>字符串常量池</strong>中储存，而且相同内容只会在其中存储一份。<br>通过构造器new对象，<strong>每new一次都会产生一个新对象</strong>，放在<strong>堆内存</strong>中。</p>\n<img src=\"/2024/02/23/javaNote/12.png\" class=\"\">\n\n<p>字符串内容比较<br><strong>直接使用&#x3D;&#x3D;对比的是字符串对象存储的地址</strong>。<br>比较内容要用.<strong>equals</strong>()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建了两个对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//创建了0个对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//输出false</span></span><br><span class=\"line\">System.out.println(s1 == s2);</span><br><span class=\"line\"></span><br><span class=\"line\">第一行代码，分别在字符串常量池和堆区创建了一个<span class=\"string\">&quot;abc&quot;</span>对象，s1引用指向堆区的对象。</span><br><span class=\"line\"> 第二行代码，s2引用指向了字符串常量池中已有的<span class=\"string\">&quot;abc&quot;</span>对象。</span><br><span class=\"line\"> 第三行代码，两个String对象存储的地址不一样，输出<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>字符串常量池应该是独立于堆区的</strong>。</p>\n<p><strong>Java存在编译优化机制</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> s2 + <span class=\"string\">&quot;c&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s4</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span> + <span class=\"string\">&quot;c&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(s1 == s3);</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(s1 == s4);</span><br><span class=\"line\"></span><br><span class=\"line\">程序在编译阶段，<span class=\"string\">&quot;ab&quot;</span>+<span class=\"string\">&quot;c&quot;</span>会直接转成<span class=\"string\">&quot;abc&quot;</span>。</span><br></pre></td></tr></table></figure>\n\n<p>直接使用&#x3D;&#x3D;对比的是字符串对象存储的地址。<br>比较内容要用.equals()方法。<br>.equalsIgnoreCase()可以忽略大小写比较，常用于对比验证码。</p>\n<img src=\"/2024/02/23/javaNote/14.png\" class=\"\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟用户登录功能</span></span><br><span class=\"line\"><span class=\"comment\">//系统后台定义好正确的登录名称、密码。</span></span><br><span class=\"line\"><span class=\"comment\">//使用循环控制三次，让用户输入正确的登录名和密码，判断是否登录成功，登陆成功则不再进行登录，登陆失败则给出提示，并让用户继续登录。</span></span><br><span class=\"line\"><span class=\"comment\">//了解scanner类的用法</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//定义正确的用户名密码</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">okLoginName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Caixukun&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">okPassword</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ctraplq&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//定义一个循环，让用户登录</span></span><br><span class=\"line\"><span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;请输入用户名&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">loginName</span> <span class=\"operator\">=</span> sc.next();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;请输入密码&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> sc.next();</span><br><span class=\"line\">    <span class=\"comment\">//判断登陆是否成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loginName.equals(okLoginName)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断密码是否正确</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (password.equals(okPassword)) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;登陆成功&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;密码错误，还剩&quot;</span> + (<span class=\"number\">3</span> - i) + <span class=\"string\">&quot;次机会&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;用户名错误&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h2 id=\"Java-正则表达式\"><a href=\"#Java-正则表达式\" class=\"headerlink\" title=\"Java 正则表达式\"></a>Java 正则表达式</h2><p>正则表达式定义了字符串的模式。<br>正则表达式可以用来搜索、编辑或处理文本。<br>Java 提供了 java.util.regex 包，它包含了 Pattern 和 Matcher 类，用于处理正则表达式的匹配操作。</p>\n<p>一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World” 字符串。<br>.（点号）也是一个正则表达式，它匹配任何一个字符如：”a” 或 “1”。</p>\n<img src=\"/2024/02/23/javaNote/2.png\" class=\"\">\n\n<p>java.util.regex 包<br>java.util.regex 包是 Java 标准库中用于支持正则表达式操作的包。</p>\n<p>java.util.regex 包主要包括以下三个类：</p>\n<p>Pattern 类：<br>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>\n<p>Matcher 类：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>\n<p>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>\n<p>除了 <strong>Stream、File、IO 和 Scanner类</strong> 其他基本都认真看了。</p>\n<p>用这些<strong>集合框架</strong>前一定要使用import语句：<br><code>import java.util.*;</code></p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>需要注意的是 Java 不支持<strong>多继承</strong>，但支持<strong>多重继承</strong>。</p>\n<img src=\"/2024/02/23/javaNote/7.png\" class=\"\">\n\n<p><strong>继承的特性</strong></p>\n<p>子类拥有父类所有的属性、方法，注意是所有的，但是！private是不可见的，明白了吗？private修饰的只能通过父类的方法去访问，但子类依旧继承了，这点很重要。</p>\n<p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p>\n<p>子类可以用自己的方式实现父类的方法(Override，重写。区别于重载Overload)。</p>\n<p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p>\n<p><strong>继承关键字</strong><br>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object(显式或隐式继承)，当一个类没有继承的两个关键字，则默认继承 Object祖先类（这个类在 java.lang 包中，编译时默认导入这个包，所以不需要 import）。</p>\n<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>\n<p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">C</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">A</span>,B &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>\n<p>this关键字：指向自己的引用。</p>\n<p>final 可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。<br>final 含义为 “最终的”。<br>使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;animal : eat&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;dog : eat&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">eatTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.eat();   <span class=\"comment\">// this 调用自己的方法</span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>.eat();  <span class=\"comment\">// super 调用父类方法</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Animal</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>();</span><br><span class=\"line\">    a.eat();</span><br><span class=\"line\">    <span class=\"type\">Dog</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">    d.eatTest();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">animal : eat</span><br><span class=\"line\">dog : eat</span><br><span class=\"line\">animal : eat</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重写-Override\"><a href=\"#重写-Override\" class=\"headerlink\" title=\"重写(Override)\"></a>重写(Override)</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p>\n<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>\n<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。</p>\n<p>在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">move</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;动物可以移动&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">move</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;狗可以跑和走&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestDog</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">Animal</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(); <span class=\"comment\">// Animal 对象</span></span><br><span class=\"line\">      <span class=\"type\">Animal</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(); <span class=\"comment\">// Dog 对象</span></span><br><span class=\"line\"> </span><br><span class=\"line\">      a.move();<span class=\"comment\">// 执行 Animal 类的方法</span></span><br><span class=\"line\"> </span><br><span class=\"line\">      b.move();<span class=\"comment\">//执行 Dog 类的方法</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">动物可以移动</span><br><span class=\"line\">狗可以跑和走</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</p>\n<p><strong>这是由于在编译阶段，只是检查参数的引用类型</strong>。</p>\n<p><strong>然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法</strong>。</p>\n<p><strong>因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法</strong>。</p>\n<p>思考以下例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">move</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;动物可以移动&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">move</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;狗可以跑和走&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bark</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;狗可以吠叫&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestDog</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">Animal</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(); <span class=\"comment\">// Animal 对象</span></span><br><span class=\"line\">      <span class=\"type\">Animal</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(); <span class=\"comment\">// Dog 对象</span></span><br><span class=\"line\"> </span><br><span class=\"line\">      a.move();<span class=\"comment\">// 执行 Animal 类的方法</span></span><br><span class=\"line\">      b.move();<span class=\"comment\">//执行 Dog 类的方法</span></span><br><span class=\"line\">      b.bark();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。</span><br><span class=\"line\">TestDog.java:<span class=\"number\">30</span>: cannot find symbol</span><br><span class=\"line\">symbol  : method <span class=\"title function_\">bark</span><span class=\"params\">()</span></span><br><span class=\"line\">location: <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span></span><br><span class=\"line\">                b.bark();</span><br><span class=\"line\">                 ^</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"方法的重写规则\"><a href=\"#方法的重写规则\" class=\"headerlink\" title=\"方法的重写规则\"></a>方法的重写规则</h4><p>参数列表与被重写方法的参数列表必须完全相同。</p>\n<p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p>\n<p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p>\n<p>父类的成员方法只能被它的子类重写。</p>\n<p>声明为 final 的方法不能被重写。</p>\n<p>声明为 static 的方法不能被重写，但是能够被再次声明。</p>\n<p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p>\n<p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p>\n<p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p>\n<p>构造方法不能被重写。</p>\n<p>如果不能继承一个类，则不能重写该类的方法。</p>\n<h3 id=\"重载-Overload\"><a href=\"#重载-Overload\" class=\"headerlink\" title=\"重载(Overload)\"></a>重载(Overload)</h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>\n<p>每个重载的方法（或者构造函数）<strong>都必须有一个独一无二的参数类型列表</strong>。</p>\n<p>最常用的地方就是构造器的重载。</p>\n<p>重载规则:</p>\n<p>被重载的方法必须改变参数列表(参数个数或类型不一样)；<br>被重载的方法可以改变返回类型；<br>被重载的方法可以改变访问修饰符；<br>被重载的方法可以声明新的或更广的检查异常；<br>方法能够在同一个类中或者在一个子类中被重载。<br>无法以返回值类型作为重载函数的区分标准。</p>\n<img src=\"/2024/02/23/javaNote/10.png\" class=\"\">\n\n<p>总结<br>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>\n<p>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。<br>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。<br>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p>\n<img src=\"/2024/02/23/javaNote/11.png\" class=\"\">\n\n\n<h3 id=\"构造器-构造函数\"><a href=\"#构造器-构造函数\" class=\"headerlink\" title=\"构造器(构造函数)\"></a>构造器(构造函数)</h3><p>子类是<strong>不继承</strong>父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式，并且一定会调用一个，并且调用语句是子类构造函数的第一句，因为子类包含父类的东西，创建对象时一定是先构造父类，接着才能构造子类）。如果父类的构造器<strong>带有参数</strong>，则必须在子类的构造器中<strong>显式</strong>地通过 super 关键字调用父类的构造器并配以适当的参数列表。</p>\n<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>\n<p>注意一个事实，不写构造函数时编译器默认一个无参构造函数，但如果写了任何一个构造函数，这个无参构造函数便不会再生成了。<br>如果父类有一个有参构造函数，并且子类构造函数没有使用super显式调用这个构造器，程序便会报错，因为没有默认的父类无参构造器给子类的构造器调用，所以此时还要再手动补一个父类无参构造器。</p>\n<p>子类的所有构造方法内部， 第一行会（隐式）自动先调用父类的无参构造函数super()；<br>如果子类构造方法第一行显式调用了父类构造方法，系统就不再调用无参的super()了。</p>\n<p>注意：如果父类没有无参构造函数，创建子类时，不能编译，除非在构造函数代码体中的第一行显式调用父类有参构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SuperClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> n;</span><br><span class=\"line\">  SuperClass()&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SuperClass()&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  SuperClass(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SuperClass(int n)&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.n = n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// SubClass 类继承</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> n;</span><br><span class=\"line\">  </span><br><span class=\"line\">  SubClass()&#123; <span class=\"comment\">// 自动调用父类的无参数构造器</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SubClass&quot;</span>);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">SubClass</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(<span class=\"number\">300</span>);  <span class=\"comment\">// 调用父类中带有参数的构造器</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SubClass(int n):&quot;</span>+n);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.n = n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// SubClass2 类继承</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SubClass2</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> n;</span><br><span class=\"line\">  </span><br><span class=\"line\">  SubClass2()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(<span class=\"number\">300</span>);  <span class=\"comment\">// 调用父类中带有参数的构造器</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SubClass2&quot;</span>);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">SubClass2</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123; <span class=\"comment\">// 自动调用父类的无参数构造器</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SubClass2(int n):&quot;</span>+n);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.n = n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestSuperSub</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span> <span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;------SubClass 类继承------&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">SubClass</span> <span class=\"variable\">sc1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>();</span><br><span class=\"line\">    <span class=\"type\">SubClass</span> <span class=\"variable\">sc2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>(<span class=\"number\">100</span>); </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;------SubClass2 类继承------&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">SubClass2</span> <span class=\"variable\">sc3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass2</span>();</span><br><span class=\"line\">    <span class=\"type\">SubClass2</span> <span class=\"variable\">sc4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass2</span>(<span class=\"number\">200</span>); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------SubClass 类继承------</span><br><span class=\"line\">SuperClass()</span><br><span class=\"line\">SubClass</span><br><span class=\"line\"><span class=\"title function_\">SuperClass</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">SubClass(<span class=\"type\">int</span> n):<span class=\"number\">100</span></span><br><span class=\"line\">------SubClass2 类继承------</span><br><span class=\"line\">SuperClass(<span class=\"type\">int</span> n)</span><br><span class=\"line\">SubClass2</span><br><span class=\"line\"><span class=\"title function_\">SuperClass</span><span class=\"params\">()</span></span><br><span class=\"line\">SubClass2(<span class=\"type\">int</span> n):<span class=\"number\">200</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"super-amp-amp-this\"><a href=\"#super-amp-amp-this\" class=\"headerlink\" title=\"super &amp;&amp; this\"></a>super &amp;&amp; this</h3><p><strong>super 关键字</strong><br>super 表示使用它的类的父类。super 可用于：<br>调用父类的构造方法；<br>调用父类的方法（<strong>子类覆盖了父类的方法时</strong>）；<br>访问父类的数据域或其他未被重写的方法（可以这样用但没有必要这样用）。</p>\n<p><strong>this 关键字</strong><br>this 关键字表示当前对象。可用于：<br>限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num &#x3D; num。this.num 表示当前对象的<strong>数据域变量</strong> num，而 num 表示方法中的局部变量。就是局部变量和类变量或成员变量(实例变量)重名了。</p>\n<p><strong>继承中的private</strong></p>\n<p>子类不能直接使用父类中的 private 属性和方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**建立一个公共动物父类*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"comment\">/*由于name和id都是私有的，所以子类不能直接继承，</span></span><br><span class=\"line\"><span class=\"comment\">    需要通过有参构造函数进行继承*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Animal</span><span class=\"params\">(String myname,<span class=\"type\">int</span> myid)</span> &#123;</span><br><span class=\"line\">        name = myname;</span><br><span class=\"line\">        id = myid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">&quot;正在吃&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sleep</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">&quot;正在睡&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">introduction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;大家好！我是&quot;</span>  +id+<span class=\"string\">&quot;号&quot;</span>+name +<span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Penguin</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Penguin</span><span class=\"params\">(String myname,<span class=\"type\">int</span> myid)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(myname,myid); <span class=\"comment\">// 声明继承父类中的两个属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">小冰正在吃</span><br><span class=\"line\">小冰正在睡</span><br><span class=\"line\">大家好！我是<span class=\"number\">10086</span>号小冰.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承中的转型-IMPORTANT\"><a href=\"#继承中的转型-IMPORTANT\" class=\"headerlink\" title=\"继承中的转型 (IMPORTANT)\"></a>继承中的转型 (IMPORTANT)</h3><p><strong>这个很重要</strong>！！！</p>\n<p>Java 转型问题其实并不复杂，只要记住一句话：父类引用指向子类对象。</p>\n<p>什么叫父类引用指向子类对象，且听我慢慢道来。</p>\n<p>从 2 个名词开始说起：向上转型(upcasting) 、向下转型(downcasting)。</p>\n<p>举个例子：有2个类，Father 是父类，Son 类继承自 Father。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Father</span> <span class=\"variable\">f1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>();   <span class=\"comment\">// 这就叫 upcasting （向上转型)</span></span><br><span class=\"line\"><span class=\"comment\">// 现在 f1 引用指向一个Son对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Son</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> (Son)f1;   <span class=\"comment\">// 这就叫 downcasting (向下转型)</span></span><br><span class=\"line\"><span class=\"comment\">// 现在f1 还是指向 Son对象</span></span><br></pre></td></tr></table></figure>\n<p>你或许会问，第1个例子中：Son s1 &#x3D; (Son)f1; 为什么是正确的呢。</p>\n<p>很简单因为 f1 指向一个子类对象，Father f1 &#x3D; new Son(); 子类 s1 引用当然可以指向子类对象了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Father</span> <span class=\"variable\">f2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Father</span>();</span><br><span class=\"line\"><span class=\"type\">Son</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> (Son)f2;       <span class=\"comment\">// 出错，子类引用不能指向父类对象</span></span><br></pre></td></tr></table></figure>\n<p>而 f2 被传给了一个 Father 对象，Father f2 &#x3D; new Father(); 子类 s1 引用不能指向父类对象。</p>\n<p>总结：<br>1、父类引用指向子类对象，而子类引用不能指向父类对象。</p>\n<p>2、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转换吗，如：</p>\n<p>Father f1 &#x3D; new Son();<br>3、把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转换，如：</p>\n<p>f1 就是一个指向子类对象的父类引用。把f1赋给子类引用 s1 即 Son s1 &#x3D; (Son)f1;</p>\n<p>其中 f1 前面的(Son)必须加上，进行强制转换。</p>\n<p><a href=\"https://www.runoob.com/w3cnote/java-transformation-problem.html\">Java 转型问题</a><br>这篇文章也很重要 不懂就看。</p>\n<p><a href=\"https://blog.csdn.net/weixin_44556968/article/details/109326727\">Java – 父类和子类拥有同名的成员变量的情况</a><br><a href=\"https://blog.csdn.net/qq_38685503/article/details/113739747\">java向上转型后方法变量详细使用规则（父类引用创建子类对象实例）</a></p>\n<h3 id=\"理解继承\"><a href=\"#理解继承\" class=\"headerlink\" title=\"理解继承\"></a>理解继承</h3><p>对理解继承来说，最重要的事情是，知道哪些东西被继承了，或者说，子类从父类那里得到了什么。答案是：所有的东西，所有的父类的成员，包括变量和方法，都成为了子类的成员，除了构造方法。构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p>\n<p>但是得到不等于可以随便使用。每个成员有不同的访问属性，子类继承得到了父类所有的成员，但是不同的访问属性使得子类在使用这些成员时有所不同：有些父类的成员直接成为子类的对外的界面，有些则被深深地隐藏起来，即使子类自己也不能直接访问。下表列出了不同访问属性的父类成员在子类中的访问属性：</p>\n<img src=\"/2024/02/23/javaNote/8.png\" class=\"\">\n\n<p>public的成员直接成为子类的public的成员，protected的成员也直接成为子类的protected的成员。Java的protected的意思是包内和子类可访问，所以它比缺省的访问属性要宽一些。而对于父类的缺省的未定义访问属性的成员来说，他们是在父类所在的包内可见，如果子类不属于父类的包，那么在子类里面，这些缺省属性的成员和private的成员是一样的：不可见。父类的private的成员在子类里仍然是存在的，只是子类中不能直接访问。我们不可以在子类中重新定义继承得到的成员的访问属性。如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响。</p>\n<p>在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用。在程序运行过程中，子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何传递参数就很重要了。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>\n<p>多态存在的<strong>三个必要条件:</strong><br><strong>继承</strong><br><strong>重写</strong><br><strong>父类引用指向子类对象</strong>：<br>Parent p &#x3D; new Child();（其实就是上面提到的向上向下转型，真的很重要）</p>\n<img src=\"/2024/02/23/javaNote/9.png\" class=\"\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">draw</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">draw</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Circle.draw()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">draw</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Square.draw()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">draw</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Triangle.draw()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法</strong>。</p>\n<p><strong>多态的好处:</strong> 可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      show(<span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>());  <span class=\"comment\">// 以 Cat 对象调用 show 方法</span></span><br><span class=\"line\">      show(<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>());  <span class=\"comment\">// 以 Dog 对象调用 show 方法</span></span><br><span class=\"line\">                </span><br><span class=\"line\">      <span class=\"type\">Animal</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();  <span class=\"comment\">// 向上转型  </span></span><br><span class=\"line\">      a.eat();               <span class=\"comment\">// 调用的是 Cat 的 eat</span></span><br><span class=\"line\">      <span class=\"type\">Cat</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (Cat)a;        <span class=\"comment\">// 向下转型  </span></span><br><span class=\"line\">      c.work();        <span class=\"comment\">// 调用的是 Cat 的 work</span></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">(Animal a)</span>  &#123;</span><br><span class=\"line\">      a.eat();  </span><br><span class=\"line\">        <span class=\"comment\">// 类型判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a <span class=\"keyword\">instanceof</span> Cat)  &#123;  <span class=\"comment\">// 猫做的事情 </span></span><br><span class=\"line\">            <span class=\"type\">Cat</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (Cat)a;  </span><br><span class=\"line\">            c.work();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a <span class=\"keyword\">instanceof</span> Dog) &#123; <span class=\"comment\">// 狗做的事情 </span></span><br><span class=\"line\">            <span class=\"type\">Dog</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (Dog)a;  </span><br><span class=\"line\">            c.work();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;吃鱼&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">work</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;抓老鼠&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;吃骨头&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">work</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;看家&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果public static void show(Animal a)  参数不用不用(Animal a)，那是不是得写public static void show(Cat a) 和public static void show(Dog a)两个函数，那不是有几个子类要写几个show吗？这就是多态的意义之一。</p>\n<p><strong>多态的实现方式</strong><br>方式一：<strong>重写</strong><br>这个内容已经详细讲过，就不再阐述。</p>\n<p>方式二：<strong>接口</strong></p>\n<p>方式三：<strong>抽象类和抽象方法</strong></p>\n<h3 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h3><p>虚函数的存在是为了多态。</p>\n<p><strong>Java 中其实没有虚函数的概念</strong>，<strong>它的普通函数就相当于 C++ 的虚函数</strong>(Java 中类的每个普通成员函数都可以被子类重写)，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>\n<h3 id=\"抽象类-amp-amp-抽象方法\"><a href=\"#抽象类-amp-amp-抽象方法\" class=\"headerlink\" title=\"抽象类 &amp;&amp; 抽象方法\"></a>抽象类 &amp;&amp; 抽象方法</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>\n<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>\n<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>\n<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>\n<p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>\n<p><strong>抽象方法</strong><br>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>\n<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>\n<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String address;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">int</span> number;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">double</span> <span class=\"title function_\">computePay</span><span class=\"params\">()</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//其余代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>声明抽象方法会造成以下两个结果</strong>：<br>如果一个类包含抽象方法，那么该类必须是抽象类。<br>任何子类必须重写父类的抽象方法，<strong>或者</strong>声明自身为抽象类。<br>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>\n<p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 文件名 : Salary.java */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Salary</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Employee</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">double</span> salary; <span class=\"comment\">// Annual salary</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">computePay</span><span class=\"params\">()</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Computing salary pay for &quot;</span> + getName());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> salary/<span class=\"number\">52</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">//其余代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>抽象类总结规定</strong></p>\n<ol>\n<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>\n<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>\n<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>\n<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>\n<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>\n</ol>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>\n<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>\n<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>\n<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>\n<p><strong>接口与类相似点：</strong><br>一个接口可以有多个方法。<br>接口文件保存在 .java 结尾的文件中，文件名使用接口名。<br>接口的字节码文件保存在 .class 结尾的文件中。<br>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</p>\n<p><strong>接口与类的区别：</strong><br>接口不能用于实例化对象。<br>接口没有构造方法。<br>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。<br>接口不能包含成员变量，除了 static 和 final 变量。<br>接口不是被类继承了，而是要被类实现。<br>接口支持多继承。</p>\n<p>接口的声明语法格式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 声明变量</span></span><br><span class=\"line\">        <span class=\"comment\">// 抽象方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 文件名 : NameOfInterface.java */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.*;</span><br><span class=\"line\"><span class=\"comment\">//引入包</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">NameOfInterface</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">//任何类型 final, static 字段</span></span><br><span class=\"line\">   <span class=\"comment\">//抽象方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口有以下<strong>特性</strong>：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。</p>\n<p><strong>抽象类和接口的区别</strong></p>\n<ol>\n<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>\n<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>\n<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>\n<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ol>\n<p><strong>标记接口</strong><br>最常用的继承接口是没有包含任何方法的接口。<br>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br><strong>标记接口作用</strong>：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>\n<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EventListener</span></span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>没有任何方法的接口被称为标记接口</strong>。标记接口主要用于以下<strong>两种目的</strong>：</p>\n<ol>\n<li>建立一个公共的父接口：<br>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li>\n<li>向一个类添加数据类型：<br>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li>\n</ol>\n<h2 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h2><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>\n<p>包的作用<br>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</p>\n<p>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</p>\n<p>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p>\n<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>\n<p>包语句的语法格式为：<br><code>package pkg1[．pkg2[．pkg3…]];</code></p>\n<p>例如,一个Something.java 文件它的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.java.util;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Something</span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么它的路径应该是 net&#x2F;java&#x2F;util&#x2F;Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。</p>\n<p>一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。</p>\n<p>以下是一些 Java 中的包：</p>\n<p>java.lang-打包基础的类<br>java.io-包含输入输出功能的函数<br>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p>\n<p>由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p>\n<p>创建包<br>创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。</p>\n<p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</p>\n<p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package，默认应该是放到java.lang包）中。</p>\n<p>import 关键字<br>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。</p>\n<p>在 Java 中，import 关键字用于导入其他类或包中定义的类型，以便在当前源文件中使用这些类型。</p>\n<p>import 关键字用于引入其他包中的类、接口或静态成员，它允许你在代码中直接使用其他包中的类，而不需要完整地指定类的包名。</p>\n<p>在 java 源文件中 import 语句必须位于 Java 源文件的头部，其语法格式为：</p>\n<p><code>import package1[.package2…].(classname|*);</code></p>\n<p>import 语句位于 package 语句之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一行非注释行是 package 语句</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// import 语句引入其他包中的类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 类的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类的成员和方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。</p>\n<p>可以使用 import语句来引入一个特定的类：</p>\n<p>import com.runoob.MyClass;<br>这样，你就可以在当前源文件中直接使用 MyClass 类的方法、变量或常量。</p>\n<p>也可以使用通配符 * 来引入整个包或包的子包：</p>\n<p>import com.runoob.mypackage.*;<br>这样，你可以导入 com.runoob.mypackage 包中的所有类，从而在当前源文件中使用该包中的任何类的方法、变量或常量。注意，使用通配符 * 导入整个包时，只会导入包中的类，而不会导入包中的子包。</p>\n<p>在导入类或包时，你需要提供类的完全限定名或包的完全限定名。完全限定名包括包名和类名的组合，以点号 . 分隔。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList; <span class=\"comment\">// 引入 java.util 包中的 ArrayList 类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*; <span class=\"comment\">// 引入 java.util 包中的所有类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.MyClass; <span class=\"comment\">// 引入 com.example 包中的 MyClass 类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.*; <span class=\"comment\">// 引入 com.example 包中的所有类</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Java-集合框架\"><a href=\"#Java-集合框架\" class=\"headerlink\" title=\"Java 集合框架\"></a>Java 集合框架</h2><p>实线继承 虚线实现</p>\n<img src=\"/2024/02/23/javaNote/13.png\" class=\"\">\n\n\n<h3 id=\"Java-ArrayList\"><a href=\"#Java-ArrayList\" class=\"headerlink\" title=\"Java ArrayList\"></a>Java ArrayList</h3><p>ArrayList 类是一个可以动态修改的<strong>数组</strong>(当数组用就可以了)，<strong>与普通数组的区别就是它是没有固定大小的限制</strong>，我们可以添加或删除元素。</p>\n<p>ArrayList(数组列表) 继承了 AbstractList ，并实现了 List 接口。</p>\n<img src=\"/2024/02/23/javaNote/3.png\" class=\"\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList; <span class=\"comment\">// 引入 ArrayList 类</span></span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;E&gt; objectName = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();　 <span class=\"comment\">// 初始化</span></span><br></pre></td></tr></table></figure>\n<p>E: <strong>泛型数据类型</strong>，用于设置 objectName 的数据类型，只能为<strong>引用数据类型</strong>（对立的是普通变量）。也就是E是由类定义的对象变量，即ArrayList 中的元素实际上是对象。<br>objectName: 对象名。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RunoobTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; sites = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Google&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Runoob&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Taobao&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Weibo&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites); <span class=\"comment\">// 这里可以直接println ArrayList</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[Google, Runoob, Taobao, Weibo]</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要存储其他类型，而 &lt;E&gt; 只能为引用数据类型，这时我们就需要使用到<strong>基本类型的包装类</strong>。<br>基本类型对应的包装类表如下：</p>\n<img src=\"/2024/02/23/javaNote/4.png\" class=\"\">\n\n<p><strong>Collections 类</strong>(算法类)也是一个非常有用的类，位于 java.util 包中，提供的 sort() 方法可以对字符或数字列表进行排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;  <span class=\"comment\">// 引入 Collections 类</span></span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;String&gt; sites = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">Collections.sort(sites);  <span class=\"comment\">// 字母排序</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">add()\t将元素插入到指定位置的 arraylist 中</span><br><span class=\"line\">addAll()\t添加集合中的所有元素到 arraylist 中</span><br><span class=\"line\">clear()\t删除 arraylist 中的所有元素</span><br><span class=\"line\">clone()\t复制一份 arraylist</span><br><span class=\"line\"><span class=\"title function_\">contains</span><span class=\"params\">()</span>\t判断元素是否在 arraylist</span><br><span class=\"line\"><span class=\"title function_\">get</span><span class=\"params\">()</span>\t通过索引值获取 arraylist 中的元素</span><br><span class=\"line\">indexOf()\t返回 arraylist 中元素的索引值</span><br><span class=\"line\">removeAll()\t删除存在于指定集合中的 arraylist 里的所有元素</span><br><span class=\"line\">remove()\t删除 arraylist 里的单个元素</span><br><span class=\"line\">size()\t返回 arraylist 里元素数量</span><br><span class=\"line\">isEmpty()\t判断 arraylist 是否为空</span><br><span class=\"line\">subList()\t截取部分 arraylist 的元素</span><br><span class=\"line\">set()\t替换 arraylist 中指定索引的元素</span><br><span class=\"line\">sort()\t对 arraylist 元素进行排序</span><br><span class=\"line\">toArray()\t将 arraylist 转换为数组</span><br><span class=\"line\">toString()\t将 arraylist 转换为字符串</span><br></pre></td></tr></table></figure>\n\n<p>集合与数组类似，是一种容器，用于装数据。</p>\n<p> 数组的特点：<br>数组定义完成并启动后，<strong>类型确定，长度固定</strong>。<br>问题：在个数不确定，且要进行增删数据操作时，数组是不太合适的。</p>\n<p>集合的特点：<br>集合的大小不固定，<strong>启动后可以动态变化，类型也可以选择不固定</strong>。<br>集合非常适合做元素个数不确定，且要进行增删操作的业务场景。<br><strong>集合提供了许多丰富好用的功能</strong>，而数组的功能很单一。</p>\n<p>ArrayList集合的对象添加与获取：<br><strong>ArrayList是集合的一种，它支持索引</strong>。<br> <code>.add()</code>返回值为boolean，一般不会添加失败，因此我们一般不会注意它的返回值。<br><code> System.out.println(list)</code>会直接输出集合内容，而不是地址</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建ArrayList集合对象</span></span><br><span class=\"line\"><span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\"><span class=\"comment\">//添加数据</span></span><br><span class=\"line\">list.add(<span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">2.5</span>);</span><br><span class=\"line\">list.add(<span class=\"literal\">false</span>);</span><br><span class=\"line\">System.out.println(list.add(<span class=\"string\">&#x27;可&#x27;</span>));</span><br><span class=\"line\">System.out.println(list);<span class=\"comment\">//[java, 1, 2.5, false, 可]</span></span><br><span class=\"line\"><span class=\"comment\">//在指定索引位置插入元素</span></span><br><span class=\"line\">list.add(<span class=\"number\">1</span>, <span class=\"string\">&quot;插入&quot;</span>);</span><br><span class=\"line\">System.out.println(list);<span class=\"comment\">//[java, 插入, 1, 2.5, false, 可]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>ArrayList&lt;E&gt;</code>就是一个泛型，可以在<strong>编译阶段约束集合对象</strong>，只能操作某种数据类型。</p>\n<p><code>ArrayList&lt;String&gt;</code>：此集合只能操作字符串类型的元素。<br><code>ArrayList&lt;Integer&gt;</code>：此集合只能操作整数类型的元素。</p>\n<p>注意：集合中只能存储引用类型，不支持基本数据类型。<code>ArrayList&lt;Integer&gt;</code>不能填<code>&lt;int&gt;</code>。<br> 代码规范：使用泛型来定义和使用集合</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\"><span class=\"comment\">//JDK1.7开始，泛型后面的类型声明可以不写</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//使用Object存储所有数据类型</span></span><br><span class=\"line\">ArrayList&lt;Object&gt; list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>ArrayList常用API、遍历<br>.get()&#x2F;&#x2F;获取某个索引位置处的元素值<br>.size()&#x2F;&#x2F;获取集合大小<br>.remove()&#x2F;&#x2F;<strong>删除某个索引位置处的值</strong>，<strong>并返回被删除的值</strong><br>.set()&#x2F;&#x2F;<strong>修改某个索引位置的值</strong>，<strong>会返回修改前的值</strong></p>\n<img src=\"/2024/02/23/javaNote/15.png\" class=\"\">\n\n<p><strong>集合中存储的元素并不是对象本身，而是对象地址</strong>。<br>如果用println直接打印集合那输出的就是地址，后面分析println的时候会讲。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Movie</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> score;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String actor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Movie</span><span class=\"params\">(String name, <span class=\"type\">double</span> score, String actor)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.actor = actor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getScore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getActor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> actor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Movie</span> <span class=\"variable\">m1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Movie</span>(<span class=\"string\">&quot;流浪地球&quot;</span>, <span class=\"number\">9.0</span>, <span class=\"string\">&quot;吴京&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//创建一个Movie类型的ArrayList，存储电影对象</span></span><br><span class=\"line\">ArrayList&lt;Movie&gt; arrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">arrayList.add(m1);</span><br><span class=\"line\">arrayList.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Movie</span>(<span class=\"string\">&quot;熊出没&quot;</span>, <span class=\"number\">9.9</span>, <span class=\"string\">&quot;光头强&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//直接输出自定义数据类型，结果是地址</span></span><br><span class=\"line\">System.out.println(arrayList);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历每一个对象，访问信息</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class=\"line\">    System.out.println(arrayList.get(i).getName() + <span class=\"string\">&quot; &quot;</span> + arrayList.get(i).getScore() + <span class=\"string\">&quot; &quot;</span> + arrayList.get(i).getActor());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"comment\">// [Test$1Movie@2f4d3709, Test$1Movie@4e50df2e]</span></span><br><span class=\"line\"><span class=\"comment\">// 流浪地球 9.0 吴京</span></span><br><span class=\"line\"><span class=\"comment\">// 熊出没 9.9 光头强</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>学生信息系统的数据搜索</strong></p>\n<p>需求：<br>后台程序需要存储学生信息并展示，然后要提供按照学号搜索的功能。</p>\n<p>分析：<br>定义Student类，定义ArrayList存储学生对象信息，并遍历展示出来。<br>提供一个方法，可以接收ArrayList集合，和要搜索的学号，返回搜索到的学生对象信息，并展示。<br>使用死循环，让用户可以不停的搜索。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String studyNumber;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">(String studyNumber, String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这里用this 的原因是函数参数名与实例变量(成员变量)同名</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.studyNumber = studyNumber;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getStudyNumber</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> studyNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建集合存储学生对象，创建学生对象封装学生信息</span></span><br><span class=\"line\">        ArrayList&lt;Student&gt; studentArrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        studentArrayList.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;001&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">        studentArrayList.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;002&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>, <span class=\"number\">12</span>));</span><br><span class=\"line\">        studentArrayList.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;003&quot;</span>, <span class=\"string\">&quot;王五&quot;</span>, <span class=\"number\">11</span>));</span><br><span class=\"line\">        <span class=\"comment\">//遍历学生信息展示</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; studentArrayList.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Student</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> studentArrayList.get(i);</span><br><span class=\"line\">            System.out.println(tmp.getStudyNumber() + <span class=\"string\">&quot;\\t&quot;</span> + tmp.getName() + <span class=\"string\">&quot;\\t&quot;</span> + tmp.getAge());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//定义方法，完成按照学号搜索的功能</span></span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;请输入学号&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">studyNumber</span> <span class=\"operator\">=</span> sc.next();</span><br><span class=\"line\">            <span class=\"comment\">//调用方法查询</span></span><br><span class=\"line\">            <span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> getStudentById(studentArrayList, studyNumber);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (student == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;查无此人&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> System.out.println(student.getStudyNumber() + <span class=\"string\">&quot;\\t&quot;</span> + student.getName() + <span class=\"string\">&quot;\\t&quot;</span> + student.getAge());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据学生学号，查询学生对象返回</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> a             存储全部学生对象的集合</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> studentNumber 搜索的学生的学号</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 学生对象 | null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Student <span class=\"title function_\">getStudentById</span><span class=\"params\">(ArrayList&lt;Student&gt; a, String studentNumber)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//遍历全部学生对象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//询问当前遍历的这个学生对象的学号，是否是我们要找的学号</span></span><br><span class=\"line\">            <span class=\"type\">Student</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> a.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.getStudyNumber().equals(studentNumber)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到了</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//没找到</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Java-LinkedList\"><a href=\"#Java-LinkedList\" class=\"headerlink\" title=\"Java LinkedList\"></a>Java LinkedList</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p>\n<p>以下情况使用 ArrayList :<br>频繁访问列表中的随机元素（只是ArrayList更高效，不是说LinkedList不能按索引访问元素，LinkedList有方法 get(i)）。<br>只需要在列表末尾进行添加和删除元素操作。</p>\n<p>以下情况使用 LinkedList :<br>你需要通过循环迭代来访问列表中的某些元素。<br>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</p>\n<p>LinkedList 继承了 AbstractSequentialList 类。<br>LinkedList 实现了 Queue 接口，可作为队列使用。<br>LinkedList 实现了 List 接口，可进行列表的相关操作。<br>LinkedList 实现了 Deque 接口，可作为队列使用。<br>LinkedList 实现了 Cloneable 接口，可实现克隆。<br>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。<br>（实箭头继承类，虚箭头实现；接口）</p>\n<img src=\"/2024/02/23/javaNote/5.png\" class=\"\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入 LinkedList 类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList; </span><br><span class=\"line\"></span><br><span class=\"line\">LinkedList&lt;E&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;E&gt;();   <span class=\"comment\">// 普通创建方法</span></span><br><span class=\"line\">或者</span><br><span class=\"line\">LinkedList&lt;E&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>(Collection&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">E</span>&gt; c); <span class=\"comment\">// 使用集合创建链表</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">LinkedList&lt;String&gt; sites = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;String&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> sites.size(), i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">     System.out.println(sites.get(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String i : sites) &#123;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span>\t链表末尾添加元素，返回是否成功，成功为 <span class=\"literal\">true</span>，失败为 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span>\t向指定位置插入元素。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(Collection c)</span>\t将一个集合的所有元素添加到链表后面，返回是否成功，成功为 <span class=\"literal\">true</span>，失败为 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(<span class=\"type\">int</span> index, Collection c)</span>\t将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 <span class=\"literal\">true</span>，失败为 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addFirst</span><span class=\"params\">(E e)</span>\t元素添加到头部。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addLast</span><span class=\"params\">(E e)</span>\t元素添加到尾部。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">offer</span><span class=\"params\">(E e)</span>\t向链表末尾添加元素，返回是否成功，成功为 <span class=\"literal\">true</span>，失败为 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">offerFirst</span><span class=\"params\">(E e)</span>\t头部插入元素，返回是否成功，成功为 <span class=\"literal\">true</span>，失败为 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">offerLast</span><span class=\"params\">(E e)</span>\t尾部插入元素，返回是否成功，成功为 <span class=\"literal\">true</span>，失败为 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clear</span><span class=\"params\">()</span>\t清空链表。</span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">removeFirst</span><span class=\"params\">()</span>\t删除并返回第一个元素。</span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">removeLast</span><span class=\"params\">()</span>\t删除并返回最后一个元素。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span>\t删除某一元素，返回是否成功，成功为 <span class=\"literal\">true</span>，失败为 <span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span>\t删除指定位置的元素。</span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">poll</span><span class=\"params\">()</span>\t删除并返回第一个元素。</span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">()</span>\t删除并返回第一个元素。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">contains</span><span class=\"params\">(Object o)</span>\t判断是否含有某一元素。</span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span>\t返回指定位置的元素。</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Java-HashSet\"><a href=\"#Java-HashSet\" class=\"headerlink\" title=\"Java HashSet\"></a>Java HashSet</h3><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>\n<p>HashSet 允许有 null 值。</p>\n<p>HashSet 是无序的，即不会记录插入的顺序。</p>\n<p>HashSet <strong>不是线程安全</strong>的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在<strong>多线程访问</strong>时<strong>显式同步对 HashSet 的并发访问</strong>。</p>\n<p>HashSet 实现了 Set 接口。</p>\n<img src=\"/2024/02/23/javaNote/6.png\" class=\"\">\n\n<p>HashSet 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet; <span class=\"comment\">// 引入 HashSet 类</span></span><br><span class=\"line\">HashSet&lt;String&gt; sites = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Java-HashMap\"><a href=\"#Java-HashMap\" class=\"headerlink\" title=\"Java HashMap\"></a>Java HashMap</h3><p>Map 遍历</p>\n<p><strong>Entry</strong><br>由于Map中存放的元素均为键值对，故每一个键值对必然存在一个映射关系。<br>Map中采用<strong>Entry内部类</strong>来表示一个映射项，映射项包含Key和Value (我们总说键值对键值对, <strong>每一个键值对也就是一个Entry</strong>)<br>Map.Entry里面包含getKey()和getValue()方法</p>\n<p><strong>entrySet</strong><br>entrySet是 java中 键值对<strong>的集合</strong>，Set里面的类型是<strong>Map.Entry</strong>，一般可以通过<strong>map.entrySet</strong>()得到。</p>\n<p>entrySet实现了Set接口，里面存放的是上面所说的键值对也就是一个Map.Entry。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span>( Map.Entry&lt;Integer, Integer&gt; iter : map.entrySet()) &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey()+<span class=\"string\">&quot;,&quot;</span>+entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以试着用<strong>map.entrySet的</strong>迭代器 iterator</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(it.hasNext()) &#123;</span><br><span class=\"line\">        Map.Entry&lt;Integer,Integer&gt; entry=it.next();</span><br><span class=\"line\">        <span class=\"type\">int</span> key=entry.getKey();</span><br><span class=\"line\">        <span class=\"type\">int</span> value=entry.getValue();</span><br><span class=\"line\">        System.out.println(key+<span class=\"string\">&quot; &quot;</span>+value);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>keySet</strong><br>还有一种是keySet, keySet是键的集合，Set里面的类型即key的类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = map.keySet();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s:set) &#123;</span><br><span class=\"line\">    System.out.println(s+<span class=\"string\">&quot;,&quot;</span>+map.get(s));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"Java-Object-类\"><a href=\"#Java-Object-类\" class=\"headerlink\" title=\"Java Object 类\"></a>Java Object 类</h3><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。</p>\n<p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>\n<p>Object 类可以显式继承，也可以隐式继承，以下两种方式是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">显式继承:</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Runoob</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Object</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">隐式继承:</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Runoob</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈-队列-优先队列\"><a href=\"#栈-队列-优先队列\" class=\"headerlink\" title=\"栈 队列 优先队列\"></a>栈 队列 优先队列</h3><p>栈 队列 用 ArrayDeque 比较好，如：<br><code>Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();</code></p>\n<p><a href=\"https://mp.weixin.qq.com/s/Ba8jrULf8NJbENK6WGrVWg\">Java 程序员，别用 Stack？！</a><br>理解了接口含义，就是封装。<br>原来stack继承vector，继承了多余的方法，破坏了封装性。<br>当然，用<code>Dueue&lt;Integer&gt; stk = new ArrayDeque&lt;Integer&gt;();</code>也有这个问题，但已经是历史遗留问题，无解了。</p>\n<p>优先队列有 PriorityQueue</p>\n<h2 id=\"各种类型相互转化问题\"><a href=\"#各种类型相互转化问题\" class=\"headerlink\" title=\"各种类型相互转化问题\"></a>各种类型相互转化问题</h2><p>Java 中数组即对象。</p>\n<p>只要跟集合交流的数组都是<strong>引用类型的数组</strong>。因为集合本身不与基本类型打交道。如果你要交流，他们的包装类型就是交流的桥梁。而<strong>包装类型和基本类型数组之间的转换</strong>就要你自己写<strong>循环体</strong>去一个一个转型了。</p>\n<h3 id=\"char-与-String-互相转换\"><a href=\"#char-与-String-互相转换\" class=\"headerlink\" title=\"char[] 与 String 互相转换\"></a>char[] 与 String 互相转换</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>[] chars = str.toCharArray();\t\t\t<span class=\"comment\">//通过toCharArray方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"type\">char</span>[] chars);\t\t\t<span class=\"comment\">//通过String构造函数</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> String.valueOf(<span class=\"type\">char</span>[] chars);\t\t<span class=\"comment\">//通过String类型转换，实际上还是String的构造函数(源码)</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"包装类数组-与-List-互相转换\"><a href=\"#包装类数组-与-List-互相转换\" class=\"headerlink\" title=\"包装类数组 与 List 互相转换\"></a>包装类数组 与 List 互相转换</h3><p>copyOfRange是输入java.util包中的<strong>Arrays</strong>类的静态内部方法，可以被类直接调用。下面以int[]型传递参数为例，来测试其用法。</p>\n<p><code>copyOfRange(int []original,int from,int to)</code>,original为原始的int型数组，from为开始角标值，to为终止角标值。（其中包括from角标，不包括to角标。即处于<code>[from,to)</code>状态）</p>\n<p><strong>包装类数组转换为List</strong></p>\n<p><strong>再次强调</strong>List只能和包装类数组之间进行转换，因为集合只支持对包装类进行操作。<br>如果非要进行基本类型数字与List之间的转换(Java对包装和解包装都是自动进行的，包装类数据其实也可以直接用，区别并不太大)，那么必须通过包装类数组这个媒介。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Character[] chars = &#123;<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;4&#x27;</span>,<span class=\"string\">&#x27;5&#x27;</span>,<span class=\"string\">&#x27;6&#x27;</span>,<span class=\"string\">&#x27;7&#x27;</span>,<span class=\"string\">&#x27;8&#x27;</span>,<span class=\"string\">&#x27;9&#x27;</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//方式一</span></span><br><span class=\"line\">List&lt;Character&gt; list1 = Arrays.asList(chars); <span class=\"comment\">//通过Arrays的工具类 注意这里的 asList 产生的 list1 是不能增删元素的，后面会讲，返回的是Arrays类内部的静态内部类ArrayList实例对象</span></span><br><span class=\"line\"><span class=\"comment\">//方式二</span></span><br><span class=\"line\">List&lt;Character&gt; list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();   <span class=\"comment\">//通过Collections工具类</span></span><br><span class=\"line\">Collections.addAll(list2, chars); <span class=\"comment\">//源码是通过遍历数组</span></span><br></pre></td></tr></table></figure>\n\n\n<p><strong>List转换为包装类数组</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listToArray</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tList&lt;Character&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\t\tlist.add(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\tlist.add(<span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\">\t\tCharacter[] chars =  list.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>[list.size()]);<span class=\"comment\">//注意toArray()的参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于源码的实现，就要具体看是那种List了，从List接口中，我们也能知道一些信息：<br><code>&lt;T&gt; T[] toArray(T[] a); //参数是什么类型就返回什么类型的数组</code></p>\n<h3 id=\"String-与-List-互相转换\"><a href=\"#String-与-List-互相转换\" class=\"headerlink\" title=\"String 与 List 互相转换\"></a>String 与 List 互相转换</h3><p><strong>String转换为List</strong><br>原理就是首先将String转换成String[]数组，再通过上面讲过的包装类数组转换为List。<br>注意这里的<strong>str.split(“”)</strong> 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stringToList</span> <span class=\"params\">(String str)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;123456&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//方式一</span></span><br><span class=\"line\">\tList&lt;String&gt;list1  = Arrays.asList(str.split(<span class=\"string\">&quot;&quot;</span>)); <span class=\"comment\">//str.split()返回一个String[]数组，这里要注意</span></span><br><span class=\"line\">\t<span class=\"comment\">//方式二</span></span><br><span class=\"line\">\tList&lt;String&gt;list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\tCollections.addAll(list2, str.split(<span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以有两个步骤是：<br>首先要将String转换为包装类型（如Character[]）或String[]数组<br>再把包装类型数组转换成List。</p>\n<p>注意：<br>要注意的是，通常所说的String转换成List,方式之一通常是<strong>通过split方法转换成String[]数组</strong>。<br>如果你想将str.toCharArray转换成char[]（上面讲过了）,再转换为List,这就比较麻烦了，因为你需要先得把char[]基本类型转换成Character[]。</p>\n<p><strong>List转换为String</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listToString</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> String.join(<span class=\"string\">&quot;&quot;</span>, list); <span class=\"comment\">//&quot;1234&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>List通过<strong>String的join方法</strong>直接转换为String,通过””作为分隔符，就相当于字符之间没有分隔符。</p>\n<h3 id=\"List和Set互相转换\"><a href=\"#List和Set互相转换\" class=\"headerlink\" title=\"List和Set互相转换\"></a>List和Set互相转换</h3><p><strong>List转换为Set</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listToSet</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\t\t Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(list);   <span class=\"comment\">//直接构造函数即可</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Set转换为List</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setToList</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">\t\t List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(set); <span class=\"comment\">//直接构造函数即可</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以<strong>List集合和Set集合之间只要类型参数相同</strong>，既可以通过<strong>构造函数</strong>互相转换。</p>\n<h3 id=\"String-与-Set-互相转换\"><a href=\"#String-与-Set-互相转换\" class=\"headerlink\" title=\"String 与 Set 互相转换\"></a>String 与 Set 互相转换</h3><p><strong>String转换为Set</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stringToSet</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;12345&quot;</span>;</span><br><span class=\"line\">\tString[] strs= str.split(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//方式一</span></span><br><span class=\"line\">\tList&lt;String&gt; list1 = Arrays.asList(strs);</span><br><span class=\"line\">\tSet&lt;String&gt; set1 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(list1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//方式二</span></span><br><span class=\"line\">\tSet&lt;String&gt; set2 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">\tCollections.addAll(set2, strs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方式一有三个步骤：<br>String转换为String[]数组 或包装类型数组（如Character[]）<br>将数组转换为List,<br>再使用Arrays或Collections工具类将list转换为Set。</p>\n<p>方式二有两个步骤<br>String转换为String[]数组 或包装类型数组（如Character[]）<br>使用Collections工具类将数组转换为Set。</p>\n<p><strong>Set转换为String</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setToString</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSet&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">\tString.join(<span class=\"string\">&quot;&quot;</span>, set);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只需要一个步骤，即：<br>使用<strong>String的join方法</strong>把集合转换为String。</p>\n<h3 id=\"包装类数组-与-Set-互相转换\"><a href=\"#包装类数组-与-Set-互相转换\" class=\"headerlink\" title=\"包装类数组 与 Set 互相转换\"></a>包装类数组 与 Set 互相转换</h3><p>Set 与 List 同理， 也只与包装类型打招呼。</p>\n<p><strong>包装类数组转换为Set</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">arrayToSet</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tCharacter[] chars = &#123;<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;4&#x27;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//方式一</span></span><br><span class=\"line\">\t\tList&lt;Character&gt; list = Arrays.asList(chars);</span><br><span class=\"line\">\t\tSet&lt;Character&gt; set1 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(list);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//方式二</span></span><br><span class=\"line\">\t\tSet&lt;Character&gt; set1 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">\t\tCollections.addAll(set1, chars);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两种方式，同样是受到不同工具类的影响。</p>\n<p>第一种方式的两个步骤：<br>数组通过Arrays或Collections工具类(也是Collections.addAll，上面讲过)转换为List<br>再把list转换为set</p>\n<p>第二种方式的一个步骤:<br>通过Collections直接将数组转换为Set</p>\n<p><strong>Set转换为包装类数组</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setToArray</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSet&lt;Character&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">\tCharacter[] chars = set.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>[set.size()]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>集合转为数组的方式也很简单，通常都是集合.toArray(T[] t)。</p>\n<p><a href=\"https://blog.csdn.net/SnailMann/article/details/80614006\">Java8中数组(引用类型)、String、List、Set之间的相互转换问题</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/2254742\">Java-String类&amp;集合ArrayList</a></p>\n<h3 id=\"Arrays-asList使用指南\"><a href=\"#Arrays-asList使用指南\" class=\"headerlink\" title=\"Arrays.asList使用指南\"></a>Arrays.asList使用指南</h3><p>List 是一种很有用的数据结构，如果需要将一个数组转换为 List 以便进行更丰富的操作的话，可以这么实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] myArray = &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span> &#125;； </span><br><span class=\"line\">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; myList = Arrays.asList(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>将需要转化的数组作为参数，或者直接把数组元素作为参数，都可以实现转换。</p>\n<p>下面看一下<strong>极易出现的错误及相应的解决方案</strong>：</p>\n<h4 id=\"错误一-将原生数据类型数据的数组作为参数\"><a href=\"#错误一-将原生数据类型数据的数组作为参数\" class=\"headerlink\" title=\"错误一 将原生数据类型数据的数组作为参数\"></a>错误一 将原生数据类型数据的数组作为参数</h4><p>来看一下asList 方法的签名：<br><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code><br>注意：参数类型是 T ，根据官方文档的描述，T 是数组元素的 class。<br>  如果你对反射技术比较了解的话，那么 class 的含义想必是不言自明。我们知道任何类型的对象都有一个 class 属性，这个属性代表了这个类型本身。原生数据类型，比如 int，short，long等，是没有这个属性的，具有 class 属性的是它们所对应的包装类 Integer，Short，Long。<br>  因此，这个错误产生的原因可解释为：asList 方法的参数<strong>必须是对象或者对象数组</strong>，而原生数据类型不是对象——这也正是包装类出现的一个主要原因。当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组。</p>\n<h4 id=\"解决方案：使用包装类数组\"><a href=\"#解决方案：使用包装类数组\" class=\"headerlink\" title=\"解决方案：使用包装类数组\"></a>解决方案：使用包装类数组</h4><p>如果需要将一个整型数组转换为 List，那么就将数组的类型声明为 Integer 而不是 int。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      Integer[] myArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">      <span class=\"type\">List</span> <span class=\"variable\">myList</span> <span class=\"operator\">=</span> Arrays.asList(myArray);</span><br><span class=\"line\">      System.out.println(myList.size());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"错误二-试图修改-List-的大小\"><a href=\"#错误二-试图修改-List-的大小\" class=\"headerlink\" title=\"错误二 试图修改 List 的大小\"></a>错误二 试图修改 List 的大小</h4><p>我们知道 List 是可以动态扩容的，因此在创建一个 List 之后最常见的操作就是向其中添加新的元素或是从里面删除已有元素，但这样的操作都会出现异常：<code>java.lang.UnsupportedOperationException</code>。<br>仔细阅读官方文档，你会发现对 asList 方法的描述中有这样一句话：<strong>返回一个由指定数组生成的固定大小的 List。</strong></p>\n<p>按道理 List 本就支持动态扩容，那为什么偏偏 asList 方法产生的 List 就是固定大小的呢？如果要回答这一问题，就需要查看相关的源码。Java 8 中 asList 方法的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; List&lt;T&gt; <span class=\"title function_\">asList</span><span class=\"params\">(T... a)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">RandomAccess</span>, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">2764017481108945198L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> E[] a;</span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayList(E[] array) &#123;</span><br><span class=\"line\">        a = Objects.requireNonNull(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个<strong>内部类</strong>也叫 ArrayList ，这个内部类继承了 AbstractList 却没有重写add方法，所以会抛出异常：<code>java.lang.UnsupportedOperationException</code>（在AbstractList中对add方法天然就会抛出此异常，与源码中的final无关。对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。这里是第二种情况）。<br>而我们平时常用的java.util.ArrayList里的ArrayList重写了add方法，所以是可以添加删除元素的。</p>\n<p>因此：asList 方法返回的确实是一个 ArrayList ,但这个 ArrayList 并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类。</p>\n<p>所以，<code>List&lt;String&gt; myList = Arrays.asList(myArray)</code>可不能写成<code>ArrayList&lt;String&gt; myList = Arrays.asList(myArray)</code>。</p>\n<h4 id=\"解决方案：创建一个真正的-ArrayList\"><a href=\"#解决方案：创建一个真正的-ArrayList\" class=\"headerlink\" title=\"解决方案：创建一个真正的 ArrayList\"></a>解决方案：创建一个真正的 ArrayList</h4><p>  既然我们已经知道之所以asList 方法产生的 ArrayList 不能修改大小，是因为这个 ArrayList 并不是“货真价实”的 ArrayList ，那我们就自行创建一个真正的 ArrayList ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      String[] myArray = &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span> &#125;;</span><br><span class=\"line\">      List&lt;String&gt; myList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;(Arrays.asList(myArray));</span><br><span class=\"line\">      myList.add(<span class=\"string\">&quot;Guava&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面这段代码中，我们 new 了一个 java.util.ArrayList ，然后再把 asList 方法的返回值作为构造器的参数传入，最后得到的 myList 自然就是可以动态扩容的了。</p>\n<h4 id=\"用自己的方法实现数组到-List-的转换\"><a href=\"#用自己的方法实现数组到-List-的转换\" class=\"headerlink\" title=\"用自己的方法实现数组到 List 的转换\"></a>用自己的方法实现数组到 List 的转换</h4><p>有时，自己实现一个方法要比使用库中的方法好。鉴于 asList 方法有一些限制，那么我们可以用自己的方法来实现数组到 List 的转换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      String[] myArray = &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span> &#125;;</span><br><span class=\"line\">      List&lt;String&gt; myList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;(); <span class=\"comment\">// 这里其实是向上转型，因为ArrayList实现了List接口，写ArrayList&lt;String&gt; myList当然也可以</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (String str : myArray) &#123;</span><br><span class=\"line\">         myList.add(str);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(myList.size());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做的话代码相对冗长，但是不管有什么特别的需求都可以自己来实现，</p>\n<p><a href=\"https://www.jianshu.com/p/2b113f487e5e\">Arrays.asList使用指南</a></p>\n<h4 id=\"ArrayList-转-String\"><a href=\"#ArrayList-转-String\" class=\"headerlink\" title=\"ArrayList 转 String\"></a>ArrayList<Character> 转 String</h4><p>ArrayList 实现了 List 接口，自然也能使用List.toString()方法获得带中括号的字符串，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Character&gt; chars = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">chars.add(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">chars.add(<span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\">chars.add(<span class=\"string\">&#x27;3&#x27;</span>);</span><br><span class=\"line\">System.out.println(chars.toString()); <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<p>想要获得不带括号的，方法有：</p>\n<ol>\n<li>遍历列表并创建字符串<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(arrayList.size());</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Character ch: arrayList)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   builder.append(ch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(builder.toString()); <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n将<code>StringBuilder</code>的容量设置为列表大小是一个重要的优化。如果不这样做，一些append调用可能会触发Builder内部调整大小。</li>\n</ol>\n<p>另外，toString()返回一个人类可读的ArrayList内容格式。不值得花时间从其中过滤掉不必要的字符。它的实现明天可能会改变，你将不得不重写你的过滤代码。<br>2. 用正则表达式直接替换’[]’，’,’为空字符</p>\n<h3 id=\"数组打印问题\"><a href=\"#数组打印问题\" class=\"headerlink\" title=\"数组打印问题\"></a>数组打印问题</h3><h4 id=\"System-out-println\"><a href=\"#System-out-println\" class=\"headerlink\" title=\"System.out.println()\"></a>System.out.println()</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"keyword\">var</span>);</span><br><span class=\"line\"><span class=\"comment\">// output: [I@74a14482</span></span><br></pre></td></tr></table></figure>\n<p>原因如下：<br>方法  <code>System.out.println()</code>  通过调用  <code>String.valueOf()</code>  把入参对象转换为一个字符串。<br>这里注意到： char[] 转化为 String 可以通过<code>String str = String.valueOf(char[] chars)</code>语句，所以<code>System.out.println()</code>是可以成功打印<strong>字符数组</strong><code>char[]</code>的，但是其他类型的数组都是不可以的。</p>\n<p>如果我们查看  <code>String.valueOf()</code>  方法的实现，会看到如下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">valueOf</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj == <span class=\"literal\">null</span>) ? <span class=\"string\">&quot;null&quot;</span> : obj.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果入参是  null  会返回空， 其它情况会调用  obj.toString()。 最后  System.out.println()  调用  toString()  方法打印出了字符串。</p>\n<p>如果对象的类没有重写  Object.toString()  方法并实现，那就会调用超类  Object  的  Object.toString()  方法。</p>\n<p>Object.toString()  返回的是  <code>getClass().getName()+****‘@’****+Integer.toHexString(hashCode())</code>。 简化格式为：“<code>class name @ object’s hash code</code>”。</p>\n<p>上文中输出的内容是  <code>[I@74a14482</code>，  <code>[ </code> 表示数组， <code>I</code>  表示 int 数据类型（数组的数据类型）。 <code>74a14482</code>  是数组的无符号十六进制 hash 值。</p>\n<p>当<strong>创建自定义类</strong>时，<strong>重写  Object.toString()  方法</strong>是最佳的实践。</p>\n<h4 id=\"for-amp-for-each-amp-Arrays-toString\"><a href=\"#for-amp-for-each-amp-Arrays-toString\" class=\"headerlink\" title=\"for &amp; for-each &amp; Arrays.toString()\"></a>for &amp; for-each &amp; Arrays.toString()</h4><p>用传统for循环或者for each循环<code>for(int a:array)</code>；<br>或利用<strong>Array类</strong>中的toString方法(静态static方法，通过类名Array调用)<strong>Array.toString(var)<strong>，返回一个包含数组元素的字符串，需要</strong>注意这些元素被放置在中括号内，并用逗号分开</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] intArray = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">System.out.println(Arrays.toString(intArray));   <span class=\"comment\">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<p><code>System.out.println(intArray); </code>是不行的，这样打印是的是数组的首地址。</p>\n<p>对于二维数组也对应这三种方法，定义一个二维数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[][]magicSquare =</span><br><span class=\"line\">   \t &#123;</span><br><span class=\"line\">   \t\t &#123;<span class=\"number\">16</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">13</span>&#125;,</span><br><span class=\"line\">   \t\t &#123;<span class=\"number\">5</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">   \t\t &#123;<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">   \t &#125;;</span><br></pre></td></tr></table></figure>\n<p>Java实际没有多维数组，只有一维数组，多维数组被解读为”数组的数组”，例如二维数组magicSquare是包含{magicSquare[0]，magicSquare[1]，magicSquare[2]}三个元素的一维数组，magicSqure[0]是包含{16,3,2,13}四个元素的一维数组，同理magicSquare[1]，magicSquare[2]也一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第三种方法(Arrays.toString)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;magicSquare.length;i++)</span><br><span class=\"line\">    System.out.println(Arrays.toString(magicSquare[i]));</span><br></pre></td></tr></table></figure>\n\n<p>对于引用类型的数组，确保重写该引用类的  Object.toString()  方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Student[] students = &#123;<span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;John&quot;</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;Doe&quot;</span>)&#125;;</span><br><span class=\"line\">    System.out.println(Arrays.toString(students));</span><br><span class=\"line\">    <span class=\"comment\">// output: [Student&#123;name=&#x27;John&#x27;&#125;, Student&#123;name=&#x27;Doe&#x27;&#125;]</span></span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Student&#123;&quot;</span> + <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;&#x27;</span><span class=\"string\">&#x27; + &#x27;</span>&#125;<span class=\"string\">&#x27;;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>此方法不适用于多维数组。在多维数组中，  Object.toString()  会打印数组元素的内存地址而不是内容。</p>\n<h4 id=\"Arrays-deepToString-amp-Arrays-asList\"><a href=\"#Arrays-deepToString-amp-Arrays-asList\" class=\"headerlink\" title=\"Arrays.deepToString() &amp; Arrays.asList()\"></a>Arrays.deepToString() &amp; Arrays.asList()</h4><p>Arrays.deepToString()  返回数组“深层内容”的字符串形式。</p>\n<p>基本类型多维数组示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// creating multidimensional array</span></span><br><span class=\"line\"><span class=\"type\">int</span>[][] multiDimensionalArr = &#123; &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">5</span>,<span class=\"number\">9</span>&#125; &#125;;</span><br><span class=\"line\">System.out.println(Arrays.deepToString(multiDimensionalArr));</span><br><span class=\"line\"><span class=\"comment\">// output: [[2, 3], [5, 9]]</span></span><br></pre></td></tr></table></figure>\n\n<p>对于引用类型数组，通过递归调用  Arrays.deepToString()  方法将其转换为字符串。</p>\n<p><strong>Arrays.asList()</strong> 方法返回固定大小（数组长度）的列表。<br>因为 List 是对象列表集合，与列表打交道的数组都要求是包装类型的数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[] intArray = &#123;<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">46</span>,<span class=\"number\">12</span>,<span class=\"number\">34</span>&#125;;</span><br><span class=\"line\">System.out.println(Arrays.asList(intArray));</span><br><span class=\"line\"><span class=\"comment\">// output: [2, 5, 46, 12, 34]</span></span><br></pre></td></tr></table></figure>\n\n<p>Java 调用  Arrays.<strong>asList</strong>(intArray).<strong>toString()</strong>  。其内部实现是列表(list)元素调用了 toString() 方法(同样会带有括号)，注意，ArrayList实现了List接口，自然也拥有 toString() 方法，同样会带有括号。</p>\n<p>NOTE:  不能使用此方法打印多维数据。</p>\n<h4 id=\"Java-Iterator-interface-amp-Java-Stream-API\"><a href=\"#Java-Iterator-interface-amp-Java-Stream-API\" class=\"headerlink\" title=\"Java Iterator interface &amp; Java Stream API\"></a>Java Iterator interface &amp; Java Stream API</h4><p>Iterator 接口和 for-each 循环类似，可以使用 Iterator 接口遍历数组元素并打印。</p>\n<p><strong>Collection 调用  iterator()</strong>  方法创建 Iterator 对象。Iterator 对象可以遍历该集合的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[] intArray = &#123;<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">46</span>,<span class=\"number\">12</span>,<span class=\"number\">34</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// creating a List of Integer</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(intArray);</span><br><span class=\"line\"><span class=\"comment\">// creating an iterator of Integer List</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"comment\">// if List has elements to be iterated</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()) &#123;</span><br><span class=\"line\">    System.out.print(it.next());</span><br><span class=\"line\">    <span class=\"comment\">// output: 25461234</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// it.next() 迭代器指向下一个元素并返回当前迭代器所指的值，初始的时候迭代器应该指向第一个元素更前面的一个位置</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Stream API</strong> 用于处理对象集合。 流是一个对象序列。流不能改变原始数据结构，它仅根据请求的操作提供结果。</p>\n<p>借助终端操作  forEach()  可以遍历流的每个元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[] intArray = &#123;<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">46</span>,<span class=\"number\">12</span>,<span class=\"number\">34</span>&#125;;</span><br><span class=\"line\">Arrays.stream(intArray).forEach(System.out::print);</span><br><span class=\"line\"><span class=\"comment\">// output: 25461234</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p>(Java 数组的打印方式)[<a href=\"https://www.freecodecamp.org/chinese/news/java-array-methods-how-to-print-an-array-in-java/]\">https://www.freecodecamp.org/chinese/news/java-array-methods-how-to-print-an-array-in-java/]</a></p>\n<h2 id=\"Arrays算法类\"><a href=\"#Arrays算法类\" class=\"headerlink\" title=\"Arrays算法类\"></a>Arrays算法类</h2><h3 id=\"Arrays-sort\"><a href=\"#Arrays-sort\" class=\"headerlink\" title=\"Arrays.sort\"></a>Arrays.sort</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][<span class=\"number\">2</span>];</span><br><span class=\"line\">Arrays.sort(arr, (a, b) -&gt; b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n<p>将对arr按第0列降序排序，太抽象了，写个比较器对新手多友好。<br>可以这样理解，原本默认是<code>Arrays.sort(arr, (a, b) -&gt; (a[0] - b[0]) )</code>将会升序排列，比较的根据是 <code>(a[0] - b[0])</code> 返回 0、1、-1。改成<code>(b[0] - a[0])</code>之后就会按按第0列降序排列。</p>\n<p>Arrays.sort(T[],Comparator&lt;? super T&gt;c)<br>自定义比较器 Comparator ，可以为<strong>对象</strong>实现降序排序，上面的二维数组中的每一个数组其实就可以当作是一个对象，也可以用来为自定义类对象实现排序。</p>\n<p>Arrays.sort()<strong>对二维数组进行排序</strong>:</p>\n<p>int [][]a &#x3D; new int [5][2];</p>\n<p>&#x2F;&#x2F;定义一个二维数组，其中所包含的一维数组具有两个元素</p>\n<p>对于一个已定义的二位数组a进行如下规则排序,首先按照每一个对应的一维数组第一个元素进行升序排序（即a[][0]）,若第一个元素相等,则按照第二个元素进行升序排序（a[][1]）。(特别注意,这里的a[][0]或者a[][1]在java中是不能这么定义的,这里只是想说明是对于某一个一维数组的第0或1个元素进行排序)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Arrays.sort(a, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;<span class=\"type\">int</span>[]&gt;() &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(<span class=\"type\">int</span>[] o1, <span class=\"type\">int</span>[] o2)</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (o1[<span class=\"number\">0</span>]==o2[<span class=\"number\">0</span>]) <span class=\"keyword\">return</span> o1[<span class=\"number\">1</span>]-o2[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">return</span> o1[<span class=\"number\">0</span>]-o2[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>其中o1[1]-o2[1]表示对于第二个元素进行升序排序如果为o2[1]-o1[1]则表示为降序。</p>\n<p><code>Arrays.sort(arr, (a, b) -&gt; b[0] - a[0]);</code>这个应该是lambda表达式的写法，等效于<code>Arrays.sort(arr, (int[] a, int[] b) -&gt; b[0] - a[0]);</code></p>\n<p>参考自 <a href=\"https://www.cnblogs.com/xuwc/p/13945050.html\">二维数组排序</a></p>\n<h4 id=\"Comparator-lt-super-T-gt\"><a href=\"#Comparator-lt-super-T-gt\" class=\"headerlink\" title=\"Comparator&lt;? super T&gt;\"></a>Comparator&lt;? super T&gt;</h4><p>Comparator&lt;? super T&gt;的实现涉及到泛型：</p>\n<p><strong>实现降序排序</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）</span></span><br><span class=\"line\">        <span class=\"comment\">//而要使用它们对应的类</span></span><br><span class=\"line\">        Integer[] a = &#123;<span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//定义一个自定义类MyComparator的对象</span></span><br><span class=\"line\">        <span class=\"type\">Comparator</span> <span class=\"variable\">cmp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyComparator</span>();</span><br><span class=\"line\">        Arrays.sort(a, cmp);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class=\"line\">            System.out.print(a[i] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Comparator是一个接口，所以这里我们自己定义的类MyComparator要implents该接口，而不是extends Comparator</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComparator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果n1小于n2，我们就返回正值，如果n1大于n2我们就返回负值，</span></span><br><span class=\"line\">        <span class=\"comment\">//这样颠倒一下，就可以实现反向排序了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(o1 &lt; o2) &#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(o1 &gt; o2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">//9 8 7 6 5 4 3 2 1 0 </span></span><br></pre></td></tr></table></figure>\n\n<p>&lt;? super T&gt; 的意思是<strong>比较类型可以是T或者它的父类型</strong>。为什么准许父类型。答案是：<br>这种方法<strong>准许为所有的子类使用相同的比较器</strong>，也就是多态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Dog</span><span class=\"params\">(<span class=\"type\">int</span> s)</span>&#123;</span><br><span class=\"line\">        size = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Cat</span><span class=\"params\">(<span class=\"type\">int</span> s)</span>&#123;</span><br><span class=\"line\">        size  = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AnimalSizeComparator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Comparator</span>&lt;Animal&gt;&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Animal o1, Animal o2)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o1.size - o2.size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//in this way, all sub classes of Animal can use this comparator.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArraySort</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">d2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">d3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        Dog[] dogArray = &#123;d1, d2, d3&#125;;</span><br><span class=\"line\">        printDogs(dogArray);</span><br><span class=\"line\"> </span><br><span class=\"line\">        Arrays.sort(dogArray, <span class=\"keyword\">new</span> <span class=\"title class_\">AnimalSizeComparator</span>());  </span><br><span class=\"line\">        printDogs(dogArray);</span><br><span class=\"line\"> </span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//when you have an array of Cat, same Comparator can be used. </span></span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        Cat[] catArray = &#123;c1, c2, c3&#125;;</span><br><span class=\"line\">        printDogs(catArray);</span><br><span class=\"line\"> </span><br><span class=\"line\">        Arrays.sort(catArray, <span class=\"keyword\">new</span> <span class=\"title class_\">AnimalSizeComparator</span>());  </span><br><span class=\"line\">        printDogs(catArray);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printDogs</span><span class=\"params\">(Animal[] animals)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Animal a: animals)</span><br><span class=\"line\">            System.out.print(<span class=\"string\">&quot;size=&quot;</span>+a.size + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一列降序，第二列升序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[][] people</span><br><span class=\"line\"></span><br><span class=\"line\">Arrays.sort(people, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;<span class=\"type\">int</span>[]&gt;() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(<span class=\"type\">int</span>[] person1, <span class=\"type\">int</span>[] person2)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (person1[<span class=\"number\">0</span>] != person2[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> person2[<span class=\"number\">0</span>] - person1[<span class=\"number\">0</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> person1[<span class=\"number\">1</span>] - person2[<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Java-序列化\"><a href=\"#Java-序列化\" class=\"headerlink\" title=\"Java 序列化\"></a>Java 序列化</h2><p>Java 序列化是一种<strong>将对象转换为字节流</strong>的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行<strong>反序列化</strong>，将字节流重新转换为对象。</p>\n<p>序列化在 Java 中是通过 java.io.Serializable 接口来实现的，<strong>该接口没有任何方法</strong>，只是一个<strong>标记接口</strong>，用于标识类可以被序列化。</p>\n<p>当你序列化对象时，你把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。</p>\n<p>序列化是一种用于保存、传输和还原对象的方法，它使得对象可以在不同的计算机之间移动和共享，这对于分布式系统、数据存储和跨平台通信非常有用。</p>\n<p>实现 Serializable 接口： 要使一个类可序列化，需要让该类实现 java.io.Serializable 接口，这告诉 Java 编译器这个类可以被序列化，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类的成员和方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><p><em><strong>反射是框架设计的灵魂</strong></em></p>\n<p>使用的<strong>前提条件</strong>：必须先得到代表字节码文件的Class类对象，其用于表示.class文件（字节码）</p>\n<p>JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种<strong>动态获取</strong>类的信息以及<strong>动态调用</strong>对象的方法的功能称为java语言的反射机制。<br>要想<strong>解剖</strong>一个类,必须先要获取到该类的<strong>字节码文件对象</strong>。而解剖使用的就是<strong>Class类</strong>（就叫Class类，用于定义类的关键字 class 是小写的）中的方法，所以先要获取到<strong>每一个字节码文件对应的Class类对象</strong>。</p>\n<p>以上的总结就是什么是反射</p>\n<p>反射就是把java类中的各种成分映射成一个个的Java对象</p>\n<p>利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>\n<p><a href=\"https://blog.csdn.net/sinat_38259539/article/details/71799078\">Java基础之—反射（非常重要）</a> </p>\n<p>写的很好，学了很多<strong>反射基础</strong>，认真看完了。</p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>java注解是在JDK5时引入的新特性，鉴于目前大部分框架(如Spring)都使用了注解简化代码并提高编码的效率，因此掌握并深入理解注解对于一个Java工程师是来说是很有必要的事。</p>\n<p>Java所有注解都继承了Annotation接口，也就是说　Java使用Annotation接口代表注解元素，该接口是所有Annotation类型的父接口。同时为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口。</p>\n<p><a href=\"https://blog.csdn.net/javazejian/article/details/71860633\">深入理解Java注解类型(@Annotation)</a><br>讲的不错，认真看完了。</p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>泛型与继承息息相关，特别是继承中的向上向下转型，具体的我在继承中已经认真学习过了。</p>\n<p>以下来自博客<a href=\"https://developer.aliyun.com/article/640124\">一文读懂Java泛型中的通配符 ？</a><br>首先学习下泛型中常见的 <strong>？ 通配符</strong>。当然在学习它是什么之前，我们要知道它是为了解决什么问题而产生的。<br>(举个例子)当你要写一个通用的方法，它可以操作对含有某些特定类型元素的<strong>集合</strong>统一操作。</p>\n<p>想象 A 是 B、C 父类， List&lt;A&gt;、 List&lt;B&gt;、 List&lt;C&gt; 是对应的集合，我想实现某些函数能统一对这些 集合 进行访问读写，而不是每个集合写一个相同功能的函数，也即之前提过的向上向下转型。</p>\n<p><strong>泛型通配符 ？</strong><br>泛型通配符可以解决这个问题。泛型通配符主要针对以下两种需求：</p>\n<ul>\n<li>从一个泛型集合里面读取元素</li>\n<li>往一个泛型集合里面插入元素</li>\n</ul>\n<p>这里有三种方式定义一个使用泛型通配符的集合</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;?&gt; listUknown = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;A&gt;();</span><br><span class=\"line\">List&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&gt; listUknown = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;A&gt;();</span><br><span class=\"line\">List&lt;? <span class=\"built_in\">super</span> A&gt; listUknown = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;A&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>无限定通配符 ？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processElements</span><span class=\"params\">(List&lt;?&gt; elements)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(Object o : elements)&#123;</span><br><span class=\"line\">      Sysout.out.println(o);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>List&lt;?&gt; </code> 可以指持有任意数据类型的集合，但<strong>只能指一个</strong>，比如就是List&lt;A&gt;，也可以是List&lt;B&gt;,或者List&lt;C&gt;，但我不知道是哪个，所以只能对这个集合读，并且只能把读取到的元素当成 Object 实例来对待（向上转型，因为 Object 是所有类的父类）</p>\n<p>上界通配符（? extends）<br>List&lt;? extends A&gt; 代表的是一个可以持有 <strong>A及其子类</strong>（如B和C）的实例的List集合。<br>当集合所持有的实例是A或者A的子类的时候，此时从集合里读出元素并把它<strong>强制转换为A</strong>是安全的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">void</span> <span class=\"title\">processElements</span><span class=\"params\">(List&lt;? extends A&gt; elements)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(A a : elements)&#123;</span><br><span class=\"line\">      System.out.<span class=\"built_in\">println</span>(a.<span class=\"built_in\">getValue</span>());  <span class=\"comment\">// getValue是 A 的方法</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候你可以把List&lt;A&gt;,List&lt;B&gt;或者List&lt;C&gt;类型的变量作为参数传入processElements()方法之中。</p>\n<p>processElements()方法仍然是不能给传入的list插入元素的（比如进行list.add()操作），因为你不知道list集合里面的元素是什么类型（A、B还是C等等）。</p>\n<p>下界通配符(? super)<br>List&lt;? super A&gt; 的意思是List集合 list,它可以持有 A 及其父类的实例。<br>当你知道集合里<strong>所持有的元素类型都是A及其父类</strong>的时候，此时往list集合里面插入<strong>A及其子类</strong>（B或C）是安全的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insertElements</span><span class=\"params\">(List&lt;? <span class=\"built_in\">super</span> A&gt; list)</span>&#123;</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">A</span>());</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">B</span>());</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">C</span>());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以往insertElements传入List&lt;A&gt;或者一个持有A的父类的list（这也是 super 的含义）。</p>\n<p>因为此时我们可以确定传入的list集合里的元素是A及其父类，所以我们往这个集合里插入A及其子类是兼容的（向上转型）。</p>\n<p>同样的，这个集合也不能随便读，里面的元素可能是 A 类也可能是 A 的父类，读取方法很简单，找出集合里元素的共同父类并将集合元素转化为这个类型，之后才能用，或者直接转化为 Object类，上面的list&lt;? extends A&gt;可以转换为A的原因是他知道集合里的元素的类型要么是A要么是A的子类，他们都可以转换为A。</p>\n<hr>\n<p><a href=\"https://blog.csdn.net/s10461/article/details/53941091\">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a> 认真看完了，基本都能理解，有讲到上面提到的通配符的应用，大差不差。</p>\n<p>泛型有三种使用方式，分别为：<strong>泛型类、泛型接口、泛型方法</strong>。</p>\n<p>编译之后程序会采取去泛型化的措施。也就是说<strong>Java中的泛型只在编译阶段有效</strong>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p><a href=\"https://blog.csdn.net/hguisu/article/details/6155636\">java(3)-深入理解java异常处理机制</a><br>详解java异常的文章，需要的时候再来看吧。</p>\n<h2 id=\"Java-多线程与并发\"><a href=\"#Java-多线程与并发\" class=\"headerlink\" title=\"Java 多线程与并发\"></a>Java 多线程与并发</h2><h2 id=\"Maven-引入外部依赖\"><a href=\"#Maven-引入外部依赖\" class=\"headerlink\" title=\"Maven 引入外部依赖\"></a>Maven 引入外部依赖</h2><p>pom.xml 的 <strong>dependencies</strong> 列表列出了我们的项目需要构建的所有外部依赖项。</p>\n<p>要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。具体做法为：<br>项目左边栏右键空白处之后选择： <code>Open Module Settings</code>，点击 + 号选择<code>Jars or Directories</code>选项并导入之前创建的 lib 文件夹即可完成配置。</p>\n<img src=\"/2024/02/23/javaNote/16.png\" class=\"\">\n\n<p>第三方库一般都会给出配置的 pom 代码。<br>然后添加以下依赖到 pom.xml 文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!-- 在这里添加你的依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;<span class=\"number\">5.1</span><span class=\"number\">.2</span>&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<p>如果用 systemPath 的话是配置本地依赖，这种情况应该不需要配置lib文件夹，第二种配置方法是需要的。</p>\n<h2 id=\"参考资料-1\"><a href=\"#参考资料-1\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://juejin.cn/post/6844904020780253191\">IDEA新手使用教程（详解）</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/2254742\">Java-String类&amp;集合ArrayList</a></p>\n<p><a href=\"https://blog.csdn.net/sinat_38259539/article/details/71799078\">Java基础之—反射（非常重要）</a> </p>\n"}]