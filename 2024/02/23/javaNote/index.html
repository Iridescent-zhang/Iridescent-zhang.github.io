<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Witcher.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Witcher.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iridescent-zhang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":false,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Disqus","order":-1},"valine":{"text":"Valine","order":-2}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="三十功名尘与土，八千里路云和月">
<meta property="og:type" content="article">
<meta property="og:title" content="javaNote">
<meta property="og:url" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/index.html">
<meta property="og:site_name" content="Iridescent-zhang">
<meta property="og:description" content="三十功名尘与土，八千里路云和月">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/1.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/12.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/14.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/2.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/7.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/10.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/11.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/8.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/9.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/13.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/3.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/4.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/15.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/5.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/6.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/16.png">
<meta property="article:published_time" content="2024-02-22T20:39:48.000Z">
<meta property="article:modified_time" content="2024-04-21T04:30:52.372Z">
<meta property="article:author" content="lichao Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iridescent-zhang.github.io/2024/02/23/javaNote/1.png">

<link rel="canonical" href="https://iridescent-zhang.github.io/2024/02/23/javaNote/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>javaNote | Iridescent-zhang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Iridescent-zhang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醉后不知天在水，满船清梦压星河</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://iridescent-zhang.github.io/2024/02/23/javaNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cloud.jpg">
      <meta itemprop="name" content="lichao Zhang">
      <meta itemprop="description" content="博观而约取，厚积而薄发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Iridescent-zhang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          javaNote
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-22 20:39:48" itemprop="dateCreated datePublished" datetime="2024-02-22T20:39:48Z">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-21 04:30:52" itemprop="dateModified" datetime="2024-04-21T04:30:52Z">2024-04-21</time>
              </span>

          
            <span id="/2024/02/23/javaNote/" class="post-meta-item leancloud_visitors" data-flag-title="javaNote" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/02/23/javaNote/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/02/23/javaNote/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>55k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>50 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><em><strong>三十功名尘与土，八千里路云和月</strong></em></p>
<span id="more"></span>

<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="源文件规则"><a href="#源文件规则" class="headerlink" title="源文件规则"></a>源文件规则</h2><p>一个完整的Java。源程序应该包括下列部分：</p>
<p> <strong>package</strong>语句，该部分至多只有一句，必须放在源程序的第一句。<br> <strong>import</strong>语句，该部分可以有若干import语句或者没有，必须放在所有的类定义之前。<br> <strong>public classDefinition</strong>，公共类定义部分，至多只有一个公共类的定义，Java语言规定该Java源程序的文件名必须与该公共类名完全一致。<br> <strong>classDefinition</strong>，类定义部分，可以有0个或者多个类定义。<br><strong>interfaceDefinition</strong>，接口定义部分，可以有0个或者多个接口定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javawork.helloworld;</span><br><span class="line"><span class="comment">/*把编译生成的所有．class文件放到包javawork.helloworld中*/</span></span><br><span class="line"><span class="keyword">import</span> java awt.*;</span><br><span class="line"><span class="comment">//告诉编译器本程序中用到系统的AWT包</span></span><br><span class="line"><span class="keyword">import</span> javawork.newcentury;</span><br><span class="line"><span class="comment">/*告诉编译器本程序中用到用户自定义的包javawork.newcentury*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldApp</span>&#123;...｝</span><br><span class="line"><span class="comment">/*公共类HelloWorldApp的定义，名字与文件名相同*/</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TheFirstClass</span>｛...｝;</span><br><span class="line"><span class="comment">//第一个普通类TheFirstClass的定义 </span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TheFirstInterface</span>&#123;......&#125;</span><br><span class="line"><span class="comment">/*定义一个接口TheFirstInterface*/</span></span><br></pre></td></tr></table></figure>


<h3 id="Public类-amp-amp-main"><a href="#Public类-amp-amp-main" class="headerlink" title="Public类 &amp;&amp; main"></a>Public类 &amp;&amp; main</h3><p>为什么JAVA文件中只能含有一个Public类?</p>
<p>java 程序是从一个 public 类的 main 函数开始执行的，(其实是main线程)，就像 C 程序 是从 main() 函数开始执行一样。 只能有一个 public 类是为了给类装载器提供方便。 一个 public 类只能定义在以它的类名为文件名的文件中。</p>
<p>每个编译单元(文件)都只有一个 public 类。因为每个编译单元都只能有一个公共接口，用 public 类来表现。如果有一个以上的 public 类，编译器就会报错。 并且 public类的名称必须与文件名相同(严格区分大小写)。 当然一个编译单元内也可以没有 public 类。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>package的命名: package 的名字由全部小写的字母组成，例如：com.runoob。<br>class和interface的命名: class和interface的名字由<strong>大写字母开头</strong>而其他字母都小写的单词组成(大驼峰)，例如：Person，RuntimeException。<br>class中变量的命名: 变量的名字用一个<strong>小写字母开头</strong>，后面的单词用大写字母开头,例如：index，currentImage。<br>class中方法的命名: 方法的名字用一个<strong>小写字母开头</strong>，后面的单词用大写字母开头,例如：run()，getBalance()。<br>staticfinal变量的命名: static final变量的名字所有字母都大写，并且能表示完整含义。例如：PI，PASSWORD。</p>
<h3 id="import-amp-amp-package-规则"><a href="#import-amp-amp-package-规则" class="headerlink" title="import &amp;&amp; package 规则"></a>import &amp;&amp; package 规则</h3><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>
<p>一个源文件中只能有一个 public 类<br>一个源文件可以有多个非 public 类<br>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。<br>如果一个类定义在某个<strong>包</strong>中，那么 <strong>package</strong> 语句应该在源文件的首行。<br>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。<br>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p>
<h4 id="Java-package"><a href="#Java-package" class="headerlink" title="Java package"></a>Java package</h4><p>包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>
<p>package 的作用就是 c++ 的 namespace 的作用，防止名字相同的类产生冲突。Java 编译器在编译时，直接根据 package 指定的信息直接将生成的 class 文件生成到对应目录下。如 package aaa.bbb.ccc 编译器就将该 .java 文件下的各个类生成到 .&#x2F;aaa&#x2F;bbb&#x2F;ccc&#x2F; 这个目录。</p>
<h4 id="Java-import"><a href="#Java-import" class="headerlink" title="Java import"></a>Java import</h4><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>
<p>例如，下面的命令行将会命令编译器载入 java_installation&#x2F;java&#x2F;io 路径下的所有类<br><code>import java.io.*;</code><br>java因强制要求类名（唯一的public类）和文件名统一，因此在引用其它类时无需显式声明。在编译时，编译器会根据类名去寻找同名文件。</p>
<p>import 是为了简化使用 package 之后的实例化的代码。假设 .&#x2F;aaa&#x2F;bbb&#x2F;ccc&#x2F; 下的 A 类，假如没有 import，实例化A类为：new aaa.bbb.ccc.A()，使用 import aaa.bbb.ccc.A 后，就可以直接使用 new A() 了，也就是编译器匹配并扩展了 aaa.bbb.ccc. 这串字符串。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><p>实例变量、局部变量、静态变量 、参数<br>驼峰命名法（Camel Case）： 在变量名中使用驼峰命名法，即将每个单词的首字母大写，除了第一个单词外，其余单词的首字母都采用大写形式。例如：myVariableName。<br>静态变量（类变量）通常也可以使用大写蛇形命名法（Upper Snake Case），全大写字母，单词之间用下划线分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用驼峰命名法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> myStaticVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用大写蛇形命名法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>常量<br>使用全大写字母，单词之间用下划线分隔。<br>常量通常使用 final 修饰。<br>类名<br>使用驼峰命名法(大驼峰)。<br>应该以大写字母开头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的成员和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><p>一个类可以包含以下类型变量：</p>
<p><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。<br>局部变量是在栈上分配的。<br>局部变量没有默认值，所以局部变量被声明后，必须经过初始化(初始化可以在声明时或后面的代码中进行)，才可以使用。如果在使用局部变量之前不初始化它，编译器会报错。</p>
<p><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。<br><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 <strong>static</strong> 类型。<br>由static修饰的变量称为静态变量，其实质上就是一个全局变量。如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；没有被静态修饰的内容，其实是属于对象的特殊描述。<br>不同的对象的实例变量将被分配不同的内存空间， 如果类中的成员变量有类变量，那么所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量，也就是说对象共享类变量。</p>
<p>调用方式不同<br>成员变量只能被对象调用。<br>静态变量可以被对象调用，还可以被类名调用。</p>
<p>static 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。<br>特点：<br>1、想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。<br>2、被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。<br>3、<strong>静态随着类的加载而加载</strong>。而且优先于对象存在。</p>
<p>成员变量和静态变量的区别：</p>
<p>   1、成员变量所属于对象。所以也称为实例变量。</p>
<pre><code>  静态变量所属于类。所以也称为类变量。
</code></pre>
<p>   2、成员变量存在于堆内存中。</p>
<pre><code>  静态变量存在于方法区中。
</code></pre>
<p>   3、成员变量随着对象创建而存在。随着对象被回收而消失。</p>
<pre><code>  静态变量随着类的加载而存在。随着类的消失而消失。
</code></pre>
<p>   4、成员变量只能被对象所调用 。</p>
<pre><code>  静态变量可以被对象调用，也可以被类名调用。
</code></pre>
<p>   所以，<strong>成员变量可以称为对象的特有数据，静态变量称为对象的共享数据</strong>。</p>
<p>生命周期<br>静态变量的生命周期与程序的生命周期一样长，即它们在类加载时被创建，在整个程序运行期间都存在，直到程序结束才会被销毁。因此，静态变量可以用来存储整个程序都需要使用的数据，如配置信息、全局变量等。</p>
<p>静态变量的线程安全性<br>Java 中的静态变量是属于类的，而不是对象的实例。因此，当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。</p>
<p>静态变量在内存中只有一份拷贝，被所有实例共享。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题。</p>
<p>为了确保静态变量的线程安全性，需要采取适当的同步措施，如<strong>同步机制、原子类或 volatile 关键字</strong>，以便在多线程环境中正确地读取和修改静态变量的值。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：<br><code>final double PI = 3.1415927;</code></p>
<p>前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：<br>int decimal &#x3D; 100;<br>int octal &#x3D; 0144;<br>int hexa &#x3D;  0x64;</p>
<p>通常使用大写字母表示常量。</p>
<h3 id="引用类型变量"><a href="#引用类型变量" class="headerlink" title="引用类型变量"></a>引用类型变量</h3><p>在Java中，引用类型的变量非常类似于C&#x2F;C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。<br>对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null。</p>
<p>引用类型变量在声明后必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问。</p>
<p>MyDate today;          &#x2F;&#x2F;将变量分配一个保存引用的空间<br>today &#x3D; new MyDate();     &#x2F;&#x2F; 这句话是2步，首先执行new MyDate（），给today变量开辟数据空间，然后再执行赋值操作<br>引用变量赋值：</p>
<p>MyDate a，b;       &#x2F;&#x2F; 在内存开辟两个引用空间<br>a &#x3D; new MyDate();       &#x2F;&#x2F; 开辟MyDate对象的数据空间，并把该空间的首地址赋给a<br>b &#x3D; a;                   &#x2F;&#x2F; 将a存储空间中的地址写到b的存储空间中</p>
<h3 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h3><p>方法参数变量的值传递方式有两种：<strong>值传递和引用传递</strong>。</p>
<p>值传递：在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的<strong>基本数据类型都采用值传递方式</strong>传递参数变量的值。</p>
<p>引用传递：在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的<strong>对象类型采用引用传递方式</strong>传递参数变量的值。</p>
<h2 id="static和final"><a href="#static和final" class="headerlink" title="static和final"></a>static和final</h2><p>在Java中，static和final是两个常用的关键字，用于修饰类的成员变量和方法。static和final的区别是：1、作用范围；2、关联性；3、修改能力；4、继承和重写。作用范围是指，static用于修饰类成员（静态变量和静态方法），而final用于修饰类、成员变量和方法。使用static修饰的成员变量称为静态变量，也称为类变量。</p>
<p>重写(Override)：是子类对父类允许方位的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心重写。</p>
<p>重载(Overload)：是在一个类里面，方法名字相同，二参数不同。返回类型可以相同也可以不同，每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>


<p>一、static关键字<br>static是一个用于修饰类成员的关键字，可以用于静态变量和静态方法。</p>
<ol>
<li><p>静态变量（静态属性）： 使用static修饰的成员变量称为静态变量，也称为类变量。静态变量在类加载时被初始化，只有一个副本存在于内存中，并且所有该类的实例共享相同的静态变量。可以通过类名直接访问静态变量，无需创建对象。</p>
</li>
<li><p>静态方法： 使用static修饰的方法称为静态方法。静态方法属于类而不属于对象，可以通过类名直接调用，无需创建对象。静态方法中只能访问静态成员变量，而不能访问非静态成员变量，因为非静态成员变量是属于对象的，而静态方法是属于类的。</p>
</li>
</ol>
<p>注意：</p>
<p>静态方法中不能使用this关键字，因为this代表当前对象，而静态方法不属于任何对象。<br>静态方法中不能使用super关键字，因为super代表父类对象，而静态方法与对象无关。</p>
<p>二、final关键字<br>final是一个用于修饰类、成员变量和方法的关键字。</p>
<ol>
<li><p>final类： 使用final修饰的类称为final类。final类是不能被继承的，即不能有子类。通常用于确保类的完整性和安全性。</p>
</li>
<li><p>final成员变量（常量）： 使用final修饰的成员变量称为final变量或常量。final成员变量必须在声明时或构造函数中进行初始化，并且一旦初始化后就不能再修改其值。常量通常用大写字母表示，并且在多个单词之间用下划线分隔。</p>
</li>
<li><p>final方法： 使用final修饰的方法称为final方法。final方法不能被子类重写，即不能被子类进行覆盖。通常用于确保方法的行为不会被子类修改。</p>
</li>
</ol>
<p>注意：</p>
<p>final成员变量可以在声明时初始化，也可以在构造函数中初始化，但一旦初始化后就不能再修改。<br>final方法不能被子类重写，但可以被继承。</p>
<p>三、区别和联系<br>作用范围： static用于修饰类成员（静态变量和静态方法），而final用于修饰类、成员变量和方法。<br>关联性： static关键字是与类相关联的，可以通过类名直接访问静态成员。而final关键字是与类的实例相关联的，用于限制类、变量或方法的特性。<br>修改能力： 静态变量可以被修改，其值可以在程序运行过程中发生变化。而final成员变量一旦被初始化后，其值不可再变更，成为常量。<br>继承和重写： final修饰的类不能被继承，final修饰的方法不能被重写（覆盖），但static修饰的方法<strong>可以被重写，但不能被覆盖</strong>。<br>主要参考：<br><a target="_blank" rel="noopener" href="https://docs.pingcode.com/ask/46663.html">static和final的区别是什么</a></p>
<p>上面提到对static修饰的方法的重写(Override)和覆盖，总结地说：static修饰的方法可以在子类重写，但是不会起到任何作用，因为父类的静态方法在编译前已经加载，只与类有关，与类的实例对象无关。即：<br>在Java中，如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上<strong>只是将父类中的该同名方法进行了隐藏</strong>，而非重写（就是上面“可以重写，但没有覆盖”的意思）。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性。正如同《Java编程思想》中所说：“一旦你了解了多态机制，可能就会认为所有事物都可以多态地发生。然而，只有普通方法的调用可以是多态的。如果你直接访问某个域，（不管是否是静态static），这个访问就<strong>将在编译期间进行解析</strong>。”这也很好地理解了，为什么在Java中，static方法和final方法（private方法属于final方法）是<strong>前期绑定</strong>，而其他所有的方法都是后期绑定了。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903603010797582">父类静态方法可以重写吗？</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fcvtb/article/details/89193844">【面试】Java static方法能否被重写或重载</a></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="Java-Number-amp-amp-Math-类"><a href="#Java-Number-amp-amp-Math-类" class="headerlink" title="Java Number  &amp;&amp; Math 类"></a>Java Number  &amp;&amp; Math 类</h3><p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。</p>
<p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 <strong>Number</strong> 的子类。</p>
<img src="/2024/02/23/javaNote/1.png" class="">

<p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p>
<p>Java 的 <strong>Math</strong> 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>
<p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。<br><code>System.out.println(&quot;90 度的正弦值：&quot; + Math.sin(Math.PI/2));  </code></p>
<p>以下列出 Number &amp; Math 类常用的一些<strong>方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>	xxxValue()</span><br><span class="line">将 Number 对象转换为xxx数据类型的值并返回。</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 返回 byte 原生数据类型</span></span><br><span class="line">      System.out.println( x.byteValue() );  <span class="number">5</span></span><br><span class="line">      <span class="comment">// 返回 double 原生数据类型</span></span><br><span class="line">      System.out.println(x.doubleValue());  <span class="number">5.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>	compareTo()</span><br><span class="line">将Number对象与参数比较。该方法用于两个相同数据类型的比较，两个不同类型的数据不能用此方法来比较。指定的数与参数相等返回 <span class="number">0</span>，小于参数返回 -<span class="number">1</span>，大于参数返回 <span class="number">1</span>。</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      System.out.println(x.compareTo(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>	equals()</span><br><span class="line">判断number对象是否与参数相等。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>	valueOf()</span><br><span class="line">valueOf() 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String，<span class="type">int</span>等。</span><br><span class="line">以Interge类为例（很多类都可以使用valueOf()方法来返回相应类的对象）：</span><br><span class="line">Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>：返回一个表示指定的 <span class="type">int</span> 值的 Integer 实例。</span><br><span class="line">Integer <span class="title function_">valueOf</span><span class="params">(String s)</span>:返回保存指定的 String 的值的 Integer 对象。</span><br><span class="line">Integer <span class="title function_">valueOf</span><span class="params">(String s, <span class="type">int</span> radix)</span>: 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span>Integer.valueOf(<span class="number">9</span>);  <span class="number">9</span></span><br><span class="line">                <span class="type">Double</span> <span class="variable">c</span> <span class="operator">=</span> Double.valueOf(<span class="number">5</span>);   <span class="number">5.0</span></span><br><span class="line">                <span class="type">Float</span> <span class="variable">a</span> <span class="operator">=</span> Float.valueOf(<span class="string">&quot;80&quot;</span>);  <span class="number">80.0</span>（这个好用）</span><br><span class="line"></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;444&quot;</span>,<span class="number">16</span>);  <span class="number">1092</span> ( <span class="number">16</span>进制的<span class="number">444</span>就是<span class="number">1092</span>)   <span class="comment">// 使用 16 进制</span></span><br><span class="line"></span><br><span class="line">                System.out.println(x); </span><br><span class="line">                System.out.println(c);</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>	toString()</span><br><span class="line">toString() 方法用于返回以一个字符串表示的 Number对象。</span><br><span class="line">如果方法使用了原生的数据类型作为参数，返回原生数据类型的 String 对象值。</span><br><span class="line">如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式。</span><br><span class="line">toString(): 返回表示 Integer 值的 String 对象。</span><br><span class="line">toString(<span class="type">int</span> i): 返回表示指定 <span class="type">int</span> 的 String（或其他Number类） 对象，取决于是哪个类调用这个方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x.toString());  </span><br><span class="line">        System.out.println(Integer.toString(<span class="number">12</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>	parseInt() <span class="comment">// 很强大，配合Integer.toBinaryString Integer.toHexString 等</span></span><br><span class="line">将字符串解析为<span class="type">int</span>类型，用于将字符串参数作为有符号的十进制整数进行解析。</span><br><span class="line">如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s)</span>  s -- 十进制表示的字符串。</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s, <span class="type">int</span> radix)</span>  radix -- 指定的基数。</span><br><span class="line">parseInt(String s): 返回用十进制参数表示的整数值。</span><br><span class="line">parseInt(<span class="type">int</span> i): 使用指定基数的字符串参数换算的十进制整数 (基数可以是 <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, 或 <span class="number">16</span> 等进制数) 。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span>Integer.parseInt(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;444&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(x);  <span class="number">9</span></span><br><span class="line">        System.out.println(c);  <span class="number">5.0</span></span><br><span class="line">        System.out.println(b);  <span class="number">1092</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>	Math.abs()</span><br><span class="line">返回参数的绝对值。</span><br><span class="line"><span class="number">8</span>	ceil()</span><br><span class="line">返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。</span><br><span class="line"><span class="number">9</span>	floor()</span><br><span class="line">返回小于等于（&lt;=）给定参数的最大整数 。</span><br><span class="line"><span class="number">10</span>	rint()</span><br><span class="line">返回与参数最接近的整数。返回类型为<span class="type">double</span>。</span><br><span class="line"><span class="number">11</span>	round()</span><br><span class="line">它表示四舍五入，算法为 **Math.floor(x+<span class="number">0.5</span>)**，即将原来的数字加上 <span class="number">0.5</span> 后再向下取整，所以，Math.round(<span class="number">11.5</span>) 的结果为<span class="number">12</span>，Math.round(-<span class="number">11.5</span>) 的结果为-<span class="number">11</span>。</span><br><span class="line"><span class="number">12</span>	min()</span><br><span class="line">返回两个参数中的最小值。</span><br><span class="line"><span class="number">13</span>	max()</span><br><span class="line">返回两个参数中的最大值。</span><br><span class="line"><span class="number">14</span>	exp()</span><br><span class="line">返回自然数底数e的参数次方。</span><br><span class="line"><span class="number">15</span>	log()</span><br><span class="line">返回参数的自然数底数的对数值。</span><br><span class="line"><span class="number">16</span>	pow()</span><br><span class="line">返回第一个参数的第二个参数次方。</span><br><span class="line"><span class="number">17</span>	sqrt()</span><br><span class="line">求参数的算术平方根。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w47_csdn/article/details/126693683">Integer.parseInt转换二进制数为int整数异常</a><br>关于java中二进制数存储等一些问题。</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。<br>在这种情况下，输入和输出都将被指定为有符号整数类型。<br>在 Java 中，编译器使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fromtitle=%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81&fromid=5295284">二进制补码</a>记法来表示有符号整数。<br>注：0和正数补码就是原码，负数的补码是除了符号位取反之后加一。</p>
<p><code>int pnb3 = Integer.parseUnsignedInt(nb, 2)</code></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010502101/article/details/79162587">Integer.parseInt(s)与Integer.valueOf(s)的区别详解</a> 好文章</p>
<p>Integer.parseInt(s)的作用就是把字符串s解析成<strong>有符号的int基本类型</strong>。<br>Integer.valueOf(s)把字符串s解析成Integer对象类型，返回的integer 可以调用对象中的方法。</p>
<p><strong>Integer.parseInt(s)与Integer.valueOf(s)的区别</strong><br><strong>Integer.parseInt(s)</strong><br>Integer.parseInt(s)多次解析同一个字符串得到的<strong>int基本类型数据是相等的</strong>，可以直接通过“&#x3D;&#x3D;”进行判断是否相等。<br>int是基本类型，不含有equals方法，所以只能用“&#x3D;&#x3D;”比较，基本类型用“&#x3D;&#x3D;”比较的是两个值的大小。<br><strong>Integer.valueOf(s)</strong><br>Integer.valueOf(s)多次解析相同的一个字符串时，<strong>得到的是Integer类型的对象</strong>，得到的对象<strong>有时是同一个对象，有时是不同的对象</strong>，要根据把s字符串解析的整数值的大小进行决定：<br>如果s字符串对应的整数值在 <strong>-128~127</strong>之间，则解析出的Integer类型的对象是同一个对象；如果s字符串对应的整数值不在 <strong>-128~127</strong>之间，则解析出的Integer类型的对象不是同一个对象。不管对象是否相等，对象中的value值是相等的。</p>
<p><strong>原因</strong>： 为什么Integer.valueOf(s)会出现这种情况呢？这是由于JDK中源码已经定义好的。由于在-128<del>127之间的整数值用的比较频繁，当每次要创建一个value值在-128</del>127之间的Integer对象时，直接从缓存中拿到这个对象，所以value值相同的Integer对象都是对应缓存中同一个对象。-128~127之外的整数值用的不是太频繁，每次创建value值相同的Integer对象时，都是重新创建一个对象，所以创建的对象不是同一个对象。</p>
<p><strong>Integer.parseInt(s)与Integer.valueOf(s)的联系</strong><br>Integer.parseInt(s)是把字符串解析成int基本类型，Integer.valueOf(s)是把字符串解析成Integer对象类型，其实<strong>int就是Integer解包装</strong>，<strong>Integer就是int的包装</strong>，<strong>在jdk8中已经自动实现了自动解包装和自动包装</strong>，所以两种方式都能得到想要的整数值。</p>
<p>把Integer类型自动解包装成int类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> n;</span><br></pre></td></tr></table></figure>




<h3 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h3><p>Character 类用于对单个字符进行操作。<br>Character 类在对象中包装一个基本类型 char 的值</p>
<p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。</p>
<p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：<br><code>Character ch = new Character(&#39;a&#39;);</code></p>
<p>将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>	isLetter()</span><br><span class="line">是否是一个字母</span><br><span class="line"><span class="number">2</span>	isDigit()</span><br><span class="line">是否是一个数字字符</span><br><span class="line"><span class="number">3</span>	isWhitespace()</span><br><span class="line">是否是一个空白字符</span><br><span class="line"><span class="number">4</span>	isUpperCase()</span><br><span class="line">是否是大写字母</span><br><span class="line"><span class="number">5</span>	isLowerCase()</span><br><span class="line">是否是小写字母</span><br><span class="line"><span class="number">6</span>	toUpperCase()</span><br><span class="line">指定字母的大写形式</span><br><span class="line"><span class="number">7</span>	toLowerCase()</span><br><span class="line">指定字母的小写形式</span><br><span class="line"><span class="number">8</span>	toString()</span><br><span class="line">返回字符的字符串形式，字符串的长度仅为<span class="number">1</span>（结果是长度为 <span class="number">1</span> 的字符串，仅由指定的 <span class="type">char</span> 组成） </span><br><span class="line">System.out.println(Character.toString(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>


<h3 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h3><p>java.lang.String类代表字符串。<br>Java程序中所有字符串文字都为此类的对象。</p>
<p>注意：String类首字母大写，类的首字母都大写。</p>
<p>以”xx”形式给出的字符串对象，在字符常量池中存储。<br>字符串类型，可以定义字符串引用变量指向字符串对象。(Java中对象存放在堆中，堆的空间不是连续的所以比较大，引用存放在栈中，栈是连续的并且空间比较小)<br>String变量<strong>每次的修改</strong>都是产生了新的字符串对象并且引用修改指向。<br>原来的字符串对象都是没有改变的，所以称<strong>字符串不可变</strong>。</p>
<p>以<code>&quot;&quot;</code>方式给出的字符串对象，在<strong>字符串常量池</strong>中储存，而且相同内容只会在其中存储一份。<br>通过构造器new对象，<strong>每new一次都会产生一个新对象</strong>，放在<strong>堆内存</strong>中。</p>
<img src="/2024/02/23/javaNote/12.png" class="">

<p>字符串内容比较<br><strong>直接使用&#x3D;&#x3D;对比的是字符串对象存储的地址</strong>。<br>比较内容要用.<strong>equals</strong>()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了两个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//创建了0个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//输出false</span></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">第一行代码，分别在字符串常量池和堆区创建了一个<span class="string">&quot;abc&quot;</span>对象，s1引用指向堆区的对象。</span><br><span class="line"> 第二行代码，s2引用指向了字符串常量池中已有的<span class="string">&quot;abc&quot;</span>对象。</span><br><span class="line"> 第三行代码，两个String对象存储的地址不一样，输出<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串常量池应该是独立于堆区的</strong>。</p>
<p><strong>Java存在编译优化机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s4);</span><br><span class="line"></span><br><span class="line">程序在编译阶段，<span class="string">&quot;ab&quot;</span>+<span class="string">&quot;c&quot;</span>会直接转成<span class="string">&quot;abc&quot;</span>。</span><br></pre></td></tr></table></figure>

<p>直接使用&#x3D;&#x3D;对比的是字符串对象存储的地址。<br>比较内容要用.equals()方法。<br>.equalsIgnoreCase()可以忽略大小写比较，常用于对比验证码。</p>
<img src="/2024/02/23/javaNote/14.png" class="">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟用户登录功能</span></span><br><span class="line"><span class="comment">//系统后台定义好正确的登录名称、密码。</span></span><br><span class="line"><span class="comment">//使用循环控制三次，让用户输入正确的登录名和密码，判断是否登录成功，登陆成功则不再进行登录，登陆失败则给出提示，并让用户继续登录。</span></span><br><span class="line"><span class="comment">//了解scanner类的用法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义正确的用户名密码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">okLoginName</span> <span class="operator">=</span> <span class="string">&quot;Caixukun&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">okPassword</span> <span class="operator">=</span> <span class="string">&quot;ctraplq&quot;</span>;</span><br><span class="line"><span class="comment">//定义一个循环，让用户登录</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> sc.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line">    <span class="comment">//判断登陆是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (loginName.equals(okLoginName)) &#123;</span><br><span class="line">        <span class="comment">//判断密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (password.equals(okPassword)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;密码错误，还剩&quot;</span> + (<span class="number">3</span> - i) + <span class="string">&quot;次机会&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户名错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h2><p>正则表达式定义了字符串的模式。<br>正则表达式可以用来搜索、编辑或处理文本。<br>Java 提供了 java.util.regex 包，它包含了 Pattern 和 Matcher 类，用于处理正则表达式的匹配操作。</p>
<p>一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World” 字符串。<br>.（点号）也是一个正则表达式，它匹配任何一个字符如：”a” 或 “1”。</p>
<img src="/2024/02/23/javaNote/2.png" class="">

<p>java.util.regex 包<br>java.util.regex 包是 Java 标准库中用于支持正则表达式操作的包。</p>
<p>java.util.regex 包主要包括以下三个类：</p>
<p>Pattern 类：<br>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
<p>Matcher 类：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
<p>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
<p>除了 <strong>Stream、File、IO 和 Scanner类</strong> 其他基本都认真看了。</p>
<p>用这些<strong>集合框架</strong>前一定要使用import语句：<br><code>import java.util.*;</code></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>需要注意的是 Java 不支持<strong>多继承</strong>，但支持<strong>多重继承</strong>。</p>
<img src="/2024/02/23/javaNote/7.png" class="">

<p><strong>继承的特性</strong></p>
<p>子类拥有父类所有的属性、方法，注意是所有的，但是！private是不可见的，明白了吗？private修饰的只能通过父类的方法去访问，但子类依旧继承了，这点很重要。</p>
<p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p>
<p>子类可以用自己的方式实现父类的方法(Override，重写。区别于重载Overload)。</p>
<p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p>
<p><strong>继承关键字</strong><br>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object(显式或隐式继承)，当一个类没有继承的两个关键字，则默认继承 Object祖先类（这个类在 java.lang 包中，编译时默认导入这个包，所以不需要 import）。</p>
<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<p>final 可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。<br>final 含义为 “最终的”。<br>使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;animal : eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;dog : eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">eatTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eat();   <span class="comment">// this 调用自己的方法</span></span><br><span class="line">    <span class="built_in">super</span>.eat();  <span class="comment">// super 调用父类方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">    a.eat();</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    d.eatTest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animal : eat</span><br><span class="line">dog : eat</span><br><span class="line">animal : eat</span><br></pre></td></tr></table></figure>

<h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p>
<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。</p>
<p>在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;动物可以移动&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;狗可以跑和走&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDog</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(); <span class="comment">// Animal 对象</span></span><br><span class="line">      <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Dog 对象</span></span><br><span class="line"> </span><br><span class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line"> </span><br><span class="line">      b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>

<p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</p>
<p><strong>这是由于在编译阶段，只是检查参数的引用类型</strong>。</p>
<p><strong>然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法</strong>。</p>
<p><strong>因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法</strong>。</p>
<p>思考以下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;动物可以移动&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;狗可以跑和走&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;狗可以吠叫&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDog</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(); <span class="comment">// Animal 对象</span></span><br><span class="line">      <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Dog 对象</span></span><br><span class="line"> </span><br><span class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line">      b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">      b.bark();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。</span><br><span class="line">TestDog.java:<span class="number">30</span>: cannot find symbol</span><br><span class="line">symbol  : method <span class="title function_">bark</span><span class="params">()</span></span><br><span class="line">location: <span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">                b.bark();</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>


<h4 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h4><p>参数列表与被重写方法的参数列表必须完全相同。</p>
<p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p>
<p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p>
<p>父类的成员方法只能被它的子类重写。</p>
<p>声明为 final 的方法不能被重写。</p>
<p>声明为 static 的方法不能被重写，但是能够被再次声明。</p>
<p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p>
<p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p>
<p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p>
<p>构造方法不能被重写。</p>
<p>如果不能继承一个类，则不能重写该类的方法。</p>
<h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）<strong>都必须有一个独一无二的参数类型列表</strong>。</p>
<p>最常用的地方就是构造器的重载。</p>
<p>重载规则:</p>
<p>被重载的方法必须改变参数列表(参数个数或类型不一样)；<br>被重载的方法可以改变返回类型；<br>被重载的方法可以改变访问修饰符；<br>被重载的方法可以声明新的或更广的检查异常；<br>方法能够在同一个类中或者在一个子类中被重载。<br>无法以返回值类型作为重载函数的区分标准。</p>
<img src="/2024/02/23/javaNote/10.png" class="">

<p>总结<br>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<p>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。<br>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。<br>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p>
<img src="/2024/02/23/javaNote/11.png" class="">


<h3 id="构造器-构造函数"><a href="#构造器-构造函数" class="headerlink" title="构造器(构造函数)"></a>构造器(构造函数)</h3><p>子类是<strong>不继承</strong>父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式，并且一定会调用一个，并且调用语句是子类构造函数的第一句，因为子类包含父类的东西，创建对象时一定是先构造父类，接着才能构造子类）。如果父类的构造器<strong>带有参数</strong>，则必须在子类的构造器中<strong>显式</strong>地通过 super 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<p>注意一个事实，不写构造函数时编译器默认一个无参构造函数，但如果写了任何一个构造函数，这个无参构造函数便不会再生成了。<br>如果父类有一个有参构造函数，并且子类构造函数没有使用super显式调用这个构造器，程序便会报错，因为没有默认的父类无参构造器给子类的构造器调用，所以此时还要再手动补一个父类无参构造器。</p>
<p>子类的所有构造方法内部， 第一行会（隐式）自动先调用父类的无参构造函数super()；<br>如果子类构造方法第一行显式调用了父类构造方法，系统就不再调用无参的super()了。</p>
<p>注意：如果父类没有无参构造函数，创建子类时，不能编译，除非在构造函数代码体中的第一行显式调用父类有参构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(<span class="type">int</span> n) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass(int n)&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass 类继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(<span class="type">int</span> n)</span>&#123; </span><br><span class="line">    <span class="built_in">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass(int n):&quot;</span>+n);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass2 类继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass2</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass2()&#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SubClass2</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2(int n):&quot;</span>+n);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSuperSub</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass 类继承------&quot;</span>);</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(<span class="number">100</span>); </span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass2 类继承------&quot;</span>);</span><br><span class="line">    <span class="type">SubClass2</span> <span class="variable">sc3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass2</span>();</span><br><span class="line">    <span class="type">SubClass2</span> <span class="variable">sc4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass2</span>(<span class="number">200</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------SubClass 类继承------</span><br><span class="line">SuperClass()</span><br><span class="line">SubClass</span><br><span class="line"><span class="title function_">SuperClass</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">SubClass(<span class="type">int</span> n):<span class="number">100</span></span><br><span class="line">------SubClass2 类继承------</span><br><span class="line">SuperClass(<span class="type">int</span> n)</span><br><span class="line">SubClass2</span><br><span class="line"><span class="title function_">SuperClass</span><span class="params">()</span></span><br><span class="line">SubClass2(<span class="type">int</span> n):<span class="number">200</span></span><br></pre></td></tr></table></figure>


<h3 id="super-amp-amp-this"><a href="#super-amp-amp-this" class="headerlink" title="super &amp;&amp; this"></a>super &amp;&amp; this</h3><p><strong>super 关键字</strong><br>super 表示使用它的类的父类。super 可用于：<br>调用父类的构造方法；<br>调用父类的方法（<strong>子类覆盖了父类的方法时</strong>）；<br>访问父类的数据域或其他未被重写的方法（可以这样用但没有必要这样用）。</p>
<p><strong>this 关键字</strong><br>this 关键字表示当前对象。可用于：<br>限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num &#x3D; num。this.num 表示当前对象的<strong>数据域变量</strong> num，而 num 表示方法中的局部变量。就是局部变量和类变量或成员变量(实例变量)重名了。</p>
<p><strong>继承中的private</strong></p>
<p>子类不能直接使用父类中的 private 属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**建立一个公共动物父类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">/*由于name和id都是私有的，所以子类不能直接继承，</span></span><br><span class="line"><span class="comment">    需要通过有参构造函数进行继承*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String myname,<span class="type">int</span> myid)</span> &#123;</span><br><span class="line">        name = myname;</span><br><span class="line">        id = myid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在睡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大家好！我是&quot;</span>  +id+<span class="string">&quot;号&quot;</span>+name +<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Penguin</span><span class="params">(String myname,<span class="type">int</span> myid)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(myname,myid); <span class="comment">// 声明继承父类中的两个属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">小冰正在吃</span><br><span class="line">小冰正在睡</span><br><span class="line">大家好！我是<span class="number">10086</span>号小冰.</span><br></pre></td></tr></table></figure>

<h3 id="继承中的转型-IMPORTANT"><a href="#继承中的转型-IMPORTANT" class="headerlink" title="继承中的转型 (IMPORTANT)"></a>继承中的转型 (IMPORTANT)</h3><p><strong>这个很重要</strong>！！！</p>
<p>Java 转型问题其实并不复杂，只要记住一句话：父类引用指向子类对象。</p>
<p>什么叫父类引用指向子类对象，且听我慢慢道来。</p>
<p>从 2 个名词开始说起：向上转型(upcasting) 、向下转型(downcasting)。</p>
<p>举个例子：有2个类，Father 是父类，Son 类继承自 Father。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();   <span class="comment">// 这就叫 upcasting （向上转型)</span></span><br><span class="line"><span class="comment">// 现在 f1 引用指向一个Son对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> (Son)f1;   <span class="comment">// 这就叫 downcasting (向下转型)</span></span><br><span class="line"><span class="comment">// 现在f1 还是指向 Son对象</span></span><br></pre></td></tr></table></figure>
<p>你或许会问，第1个例子中：Son s1 &#x3D; (Son)f1; 为什么是正确的呢。</p>
<p>很简单因为 f1 指向一个子类对象，Father f1 &#x3D; new Son(); 子类 s1 引用当然可以指向子类对象了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="type">Son</span> <span class="variable">s2</span> <span class="operator">=</span> (Son)f2;       <span class="comment">// 出错，子类引用不能指向父类对象</span></span><br></pre></td></tr></table></figure>
<p>而 f2 被传给了一个 Father 对象，Father f2 &#x3D; new Father(); 子类 s1 引用不能指向父类对象。</p>
<p>总结：<br>1、父类引用指向子类对象，而子类引用不能指向父类对象。</p>
<p>2、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转换吗，如：</p>
<p>Father f1 &#x3D; new Son();<br>3、把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转换，如：</p>
<p>f1 就是一个指向子类对象的父类引用。把f1赋给子类引用 s1 即 Son s1 &#x3D; (Son)f1;</p>
<p>其中 f1 前面的(Son)必须加上，进行强制转换。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/java-transformation-problem.html">Java 转型问题</a><br>这篇文章也很重要 不懂就看。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44556968/article/details/109326727">Java – 父类和子类拥有同名的成员变量的情况</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38685503/article/details/113739747">java向上转型后方法变量详细使用规则（父类引用创建子类对象实例）</a></p>
<h3 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h3><p>对理解继承来说，最重要的事情是，知道哪些东西被继承了，或者说，子类从父类那里得到了什么。答案是：所有的东西，所有的父类的成员，包括变量和方法，都成为了子类的成员，除了构造方法。构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p>
<p>但是得到不等于可以随便使用。每个成员有不同的访问属性，子类继承得到了父类所有的成员，但是不同的访问属性使得子类在使用这些成员时有所不同：有些父类的成员直接成为子类的对外的界面，有些则被深深地隐藏起来，即使子类自己也不能直接访问。下表列出了不同访问属性的父类成员在子类中的访问属性：</p>
<img src="/2024/02/23/javaNote/8.png" class="">

<p>public的成员直接成为子类的public的成员，protected的成员也直接成为子类的protected的成员。Java的protected的意思是包内和子类可访问，所以它比缺省的访问属性要宽一些。而对于父类的缺省的未定义访问属性的成员来说，他们是在父类所在的包内可见，如果子类不属于父类的包，那么在子类里面，这些缺省属性的成员和private的成员是一样的：不可见。父类的private的成员在子类里仍然是存在的，只是子类中不能直接访问。我们不可以在子类中重新定义继承得到的成员的访问属性。如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响。</p>
<p>在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用。在程序运行过程中，子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何传递参数就很重要了。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态存在的<strong>三个必要条件:</strong><br><strong>继承</strong><br><strong>重写</strong><br><strong>父类引用指向子类对象</strong>：<br>Parent p &#x3D; new Child();（其实就是上面提到的向上向下转型，真的很重要）</p>
<img src="/2024/02/23/javaNote/9.png" class="">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Triangle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法</strong>。</p>
<p><strong>多态的好处:</strong> 可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      show(<span class="keyword">new</span> <span class="title class_">Cat</span>());  <span class="comment">// 以 Cat 对象调用 show 方法</span></span><br><span class="line">      show(<span class="keyword">new</span> <span class="title class_">Dog</span>());  <span class="comment">// 以 Dog 对象调用 show 方法</span></span><br><span class="line">                </span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">      <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;        <span class="comment">// 向下转型  </span></span><br><span class="line">      c.work();        <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Animal a)</span>  &#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)  &#123;  <span class="comment">// 猫做的事情 </span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123; <span class="comment">// 狗做的事情 </span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">c</span> <span class="operator">=</span> (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果public static void show(Animal a)  参数不用不用(Animal a)，那是不是得写public static void show(Cat a) 和public static void show(Dog a)两个函数，那不是有几个子类要写几个show吗？这就是多态的意义之一。</p>
<p><strong>多态的实现方式</strong><br>方式一：<strong>重写</strong><br>这个内容已经详细讲过，就不再阐述。</p>
<p>方式二：<strong>接口</strong></p>
<p>方式三：<strong>抽象类和抽象方法</strong></p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数的存在是为了多态。</p>
<p><strong>Java 中其实没有虚函数的概念</strong>，<strong>它的普通函数就相当于 C++ 的虚函数</strong>(Java 中类的每个普通成员函数都可以被子类重写)，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<h3 id="抽象类-amp-amp-抽象方法"><a href="#抽象类-amp-amp-抽象方法" class="headerlink" title="抽象类 &amp;&amp; 抽象方法"></a>抽象类 &amp;&amp; 抽象方法</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p><strong>抽象方法</strong><br>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明抽象方法会造成以下两个结果</strong>：<br>如果一个类包含抽象方法，那么该类必须是抽象类。<br>任何子类必须重写父类的抽象方法，<strong>或者</strong>声明自身为抽象类。<br>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : Salary.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> salary; <span class="comment">// Annual salary</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Computing salary pay for &quot;</span> + getName());</span><br><span class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象类总结规定</strong></p>
<ol>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<p><strong>接口与类相似点：</strong><br>一个接口可以有多个方法。<br>接口文件保存在 .java 结尾的文件中，文件名使用接口名。<br>接口的字节码文件保存在 .class 结尾的文件中。<br>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</p>
<p><strong>接口与类的区别：</strong><br>接口不能用于实例化对象。<br>接口没有构造方法。<br>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。<br>接口不能包含成员变量，除了 static 和 final 变量。<br>接口不是被类继承了，而是要被类实现。<br>接口支持多继承。</p>
<p>接口的声明语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件名 : NameOfInterface.java */</span></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="comment">//引入包</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NameOfInterface</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//任何类型 final, static 字段</span></span><br><span class="line">   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口有以下<strong>特性</strong>：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。</p>
<p><strong>抽象类和接口的区别</strong></p>
<ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
<p><strong>标记接口</strong><br>最常用的继承接口是没有包含任何方法的接口。<br>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br><strong>标记接口作用</strong>：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>没有任何方法的接口被称为标记接口</strong>。标记接口主要用于以下<strong>两种目的</strong>：</p>
<ol>
<li>建立一个公共的父接口：<br>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li>
<li>向一个类添加数据类型：<br>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li>
</ol>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>
<p>包的作用<br>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</p>
<p>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</p>
<p>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p>
<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>
<p>包语句的语法格式为：<br><code>package pkg1[．pkg2[．pkg3…]];</code></p>
<p>例如,一个Something.java 文件它的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么它的路径应该是 net&#x2F;java&#x2F;util&#x2F;Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。</p>
<p>一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。</p>
<p>以下是一些 Java 中的包：</p>
<p>java.lang-打包基础的类<br>java.io-包含输入输出功能的函数<br>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p>
<p>由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p>
<p>创建包<br>创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。</p>
<p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</p>
<p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package，默认应该是放到java.lang包）中。</p>
<p>import 关键字<br>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。</p>
<p>在 Java 中，import 关键字用于导入其他类或包中定义的类型，以便在当前源文件中使用这些类型。</p>
<p>import 关键字用于引入其他包中的类、接口或静态成员，它允许你在代码中直接使用其他包中的类，而不需要完整地指定类的包名。</p>
<p>在 java 源文件中 import 语句必须位于 Java 源文件的头部，其语法格式为：</p>
<p><code>import package1[.package2…].(classname|*);</code></p>
<p>import 语句位于 package 语句之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一行非注释行是 package 语句</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// import 语句引入其他包中的类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的成员和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。</p>
<p>可以使用 import语句来引入一个特定的类：</p>
<p>import com.runoob.MyClass;<br>这样，你就可以在当前源文件中直接使用 MyClass 类的方法、变量或常量。</p>
<p>也可以使用通配符 * 来引入整个包或包的子包：</p>
<p>import com.runoob.mypackage.*;<br>这样，你可以导入 com.runoob.mypackage 包中的所有类，从而在当前源文件中使用该包中的任何类的方法、变量或常量。注意，使用通配符 * 导入整个包时，只会导入包中的类，而不会导入包中的子包。</p>
<p>在导入类或包时，你需要提供类的完全限定名或包的完全限定名。完全限定名包括包名和类名的组合，以点号 . 分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 java.util 包中的 ArrayList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 引入 java.util 包中的所有类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.MyClass; <span class="comment">// 引入 com.example 包中的 MyClass 类</span></span><br><span class="line"><span class="keyword">import</span> com.example.*; <span class="comment">// 引入 com.example 包中的所有类</span></span><br></pre></td></tr></table></figure>


<h2 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h2><p>实线继承 虚线实现</p>
<img src="/2024/02/23/javaNote/13.png" class="">


<h3 id="Java-ArrayList"><a href="#Java-ArrayList" class="headerlink" title="Java ArrayList"></a>Java ArrayList</h3><p>ArrayList 类是一个可以动态修改的<strong>数组</strong>(当数组用就可以了)，<strong>与普通数组的区别就是它是没有固定大小的限制</strong>，我们可以添加或删除元素。</p>
<p>ArrayList(数组列表) 继承了 AbstractList ，并实现了 List 接口。</p>
<img src="/2024/02/23/javaNote/3.png" class="">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;E&gt; objectName = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();　 <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure>
<p>E: <strong>泛型数据类型</strong>，用于设置 objectName 的数据类型，只能为<strong>引用数据类型</strong>（对立的是普通变量）。也就是E是由类定义的对象变量，即ArrayList 中的元素实际上是对象。<br>objectName: 对象名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites); <span class="comment">// 这里可以直接println ArrayList</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[Google, Runoob, Taobao, Weibo]</span><br></pre></td></tr></table></figure>

<p>如果我们要存储其他类型，而 &lt;E&gt; 只能为引用数据类型，这时我们就需要使用到<strong>基本类型的包装类</strong>。<br>基本类型对应的包装类表如下：</p>
<img src="/2024/02/23/javaNote/4.png" class="">

<p><strong>Collections 类</strong>(算法类)也是一个非常有用的类，位于 java.util 包中，提供的 sort() 方法可以对字符或数字列表进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;  <span class="comment">// 引入 Collections 类</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Collections.sort(sites);  <span class="comment">// 字母排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">add()	将元素插入到指定位置的 arraylist 中</span><br><span class="line">addAll()	添加集合中的所有元素到 arraylist 中</span><br><span class="line">clear()	删除 arraylist 中的所有元素</span><br><span class="line">clone()	复制一份 arraylist</span><br><span class="line"><span class="title function_">contains</span><span class="params">()</span>	判断元素是否在 arraylist</span><br><span class="line"><span class="title function_">get</span><span class="params">()</span>	通过索引值获取 arraylist 中的元素</span><br><span class="line">indexOf()	返回 arraylist 中元素的索引值</span><br><span class="line">removeAll()	删除存在于指定集合中的 arraylist 里的所有元素</span><br><span class="line">remove()	删除 arraylist 里的单个元素</span><br><span class="line">size()	返回 arraylist 里元素数量</span><br><span class="line">isEmpty()	判断 arraylist 是否为空</span><br><span class="line">subList()	截取部分 arraylist 的元素</span><br><span class="line">set()	替换 arraylist 中指定索引的元素</span><br><span class="line">sort()	对 arraylist 元素进行排序</span><br><span class="line">toArray()	将 arraylist 转换为数组</span><br><span class="line">toString()	将 arraylist 转换为字符串</span><br></pre></td></tr></table></figure>

<p>集合与数组类似，是一种容器，用于装数据。</p>
<p> 数组的特点：<br>数组定义完成并启动后，<strong>类型确定，长度固定</strong>。<br>问题：在个数不确定，且要进行增删数据操作时，数组是不太合适的。</p>
<p>集合的特点：<br>集合的大小不固定，<strong>启动后可以动态变化，类型也可以选择不固定</strong>。<br>集合非常适合做元素个数不确定，且要进行增删操作的业务场景。<br><strong>集合提供了许多丰富好用的功能</strong>，而数组的功能很单一。</p>
<p>ArrayList集合的对象添加与获取：<br><strong>ArrayList是集合的一种，它支持索引</strong>。<br> <code>.add()</code>返回值为boolean，一般不会添加失败，因此我们一般不会注意它的返回值。<br><code> System.out.println(list)</code>会直接输出集合内容，而不是地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合对象</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2.5</span>);</span><br><span class="line">list.add(<span class="literal">false</span>);</span><br><span class="line">System.out.println(list.add(<span class="string">&#x27;可&#x27;</span>));</span><br><span class="line">System.out.println(list);<span class="comment">//[java, 1, 2.5, false, 可]</span></span><br><span class="line"><span class="comment">//在指定索引位置插入元素</span></span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">&quot;插入&quot;</span>);</span><br><span class="line">System.out.println(list);<span class="comment">//[java, 插入, 1, 2.5, false, 可]</span></span><br></pre></td></tr></table></figure>

<p><code>ArrayList&lt;E&gt;</code>就是一个泛型，可以在<strong>编译阶段约束集合对象</strong>，只能操作某种数据类型。</p>
<p><code>ArrayList&lt;String&gt;</code>：此集合只能操作字符串类型的元素。<br><code>ArrayList&lt;Integer&gt;</code>：此集合只能操作整数类型的元素。</p>
<p>注意：集合中只能存储引用类型，不支持基本数据类型。<code>ArrayList&lt;Integer&gt;</code>不能填<code>&lt;int&gt;</code>。<br> 代码规范：使用泛型来定义和使用集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//JDK1.7开始，泛型后面的类型声明可以不写</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//使用Object存储所有数据类型</span></span><br><span class="line">ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>ArrayList常用API、遍历<br>.get()&#x2F;&#x2F;获取某个索引位置处的元素值<br>.size()&#x2F;&#x2F;获取集合大小<br>.remove()&#x2F;&#x2F;<strong>删除某个索引位置处的值</strong>，<strong>并返回被删除的值</strong><br>.set()&#x2F;&#x2F;<strong>修改某个索引位置的值</strong>，<strong>会返回修改前的值</strong></p>
<img src="/2024/02/23/javaNote/15.png" class="">

<p><strong>集合中存储的元素并不是对象本身，而是对象地址</strong>。<br>如果用println直接打印集合那输出的就是地址，后面分析println的时候会讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">private</span> String actor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> score, String actor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.actor = actor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getActor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> actor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Movie</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;流浪地球&quot;</span>, <span class="number">9.0</span>, <span class="string">&quot;吴京&quot;</span>);</span><br><span class="line"><span class="comment">//创建一个Movie类型的ArrayList，存储电影对象</span></span><br><span class="line">ArrayList&lt;Movie&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(m1);</span><br><span class="line">arrayList.add(<span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;熊出没&quot;</span>, <span class="number">9.9</span>, <span class="string">&quot;光头强&quot;</span>));</span><br><span class="line"><span class="comment">//直接输出自定义数据类型，结果是地址</span></span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历每一个对象，访问信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    System.out.println(arrayList.get(i).getName() + <span class="string">&quot; &quot;</span> + arrayList.get(i).getScore() + <span class="string">&quot; &quot;</span> + arrayList.get(i).getActor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// [Test$1Movie@2f4d3709, Test$1Movie@4e50df2e]</span></span><br><span class="line"><span class="comment">// 流浪地球 9.0 吴京</span></span><br><span class="line"><span class="comment">// 熊出没 9.9 光头强</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>学生信息系统的数据搜索</strong></p>
<p>需求：<br>后台程序需要存储学生信息并展示，然后要提供按照学号搜索的功能。</p>
<p>分析：<br>定义Student类，定义ArrayList存储学生对象信息，并遍历展示出来。<br>提供一个方法，可以接收ArrayList集合，和要搜索的学号，返回搜索到的学生对象信息，并展示。<br>使用死循环，让用户可以不停的搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String studyNumber;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String studyNumber, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="comment">// 这里用this 的原因是函数参数名与实例变量(成员变量)同名</span></span><br><span class="line">        <span class="built_in">this</span>.studyNumber = studyNumber;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStudyNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studyNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合存储学生对象，创建学生对象封装学生信息</span></span><br><span class="line">        ArrayList&lt;Student&gt; studentArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        studentArrayList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        studentArrayList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        studentArrayList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;003&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">11</span>));</span><br><span class="line">        <span class="comment">//遍历学生信息展示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; studentArrayList.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">tmp</span> <span class="operator">=</span> studentArrayList.get(i);</span><br><span class="line">            System.out.println(tmp.getStudyNumber() + <span class="string">&quot;\t&quot;</span> + tmp.getName() + <span class="string">&quot;\t&quot;</span> + tmp.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义方法，完成按照学号搜索的功能</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学号&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">studyNumber</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="comment">//调用方法查询</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> getStudentById(studentArrayList, studyNumber);</span><br><span class="line">            <span class="keyword">if</span> (student == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;查无此人&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> System.out.println(student.getStudyNumber() + <span class="string">&quot;\t&quot;</span> + student.getName() + <span class="string">&quot;\t&quot;</span> + student.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据学生学号，查询学生对象返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a             存储全部学生对象的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> studentNumber 搜索的学生的学号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 学生对象 | null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">getStudentById</span><span class="params">(ArrayList&lt;Student&gt; a, String studentNumber)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历全部学生对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//询问当前遍历的这个学生对象的学号，是否是我们要找的学号</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> a.get(i);</span><br><span class="line">            <span class="keyword">if</span> (s.getStudyNumber().equals(studentNumber)) &#123;</span><br><span class="line">                <span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Java-LinkedList"><a href="#Java-LinkedList" class="headerlink" title="Java LinkedList"></a>Java LinkedList</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p>
<p>以下情况使用 ArrayList :<br>频繁访问列表中的随机元素（只是ArrayList更高效，不是说LinkedList不能按索引访问元素，LinkedList有方法 get(i)）。<br>只需要在列表末尾进行添加和删除元素操作。</p>
<p>以下情况使用 LinkedList :<br>你需要通过循环迭代来访问列表中的某些元素。<br>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</p>
<p>LinkedList 继承了 AbstractSequentialList 类。<br>LinkedList 实现了 Queue 接口，可作为队列使用。<br>LinkedList 实现了 List 接口，可进行列表的相关操作。<br>LinkedList 实现了 Deque 接口，可作为队列使用。<br>LinkedList 实现了 Cloneable 接口，可实现克隆。<br>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。<br>（实箭头继承类，虚箭头实现；接口）</p>
<img src="/2024/02/23/javaNote/5.png" class="">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 LinkedList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"></span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;E&gt;();   <span class="comment">// 普通创建方法</span></span><br><span class="line">或者</span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c); <span class="comment">// 使用集合创建链表</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sites.size(), i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">     System.out.println(sites.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String i : sites) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>	链表末尾添加元素，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>	向指定位置插入元素。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection c)</span>	将一个集合的所有元素添加到链表后面，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection c)</span>	将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>	元素添加到头部。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>	元素添加到尾部。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>	向链表末尾添加元素，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>	头部插入元素，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>	尾部插入元素，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>	清空链表。</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span>	删除并返回第一个元素。</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span>	删除并返回最后一个元素。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>	删除某一元素，返回是否成功，成功为 <span class="literal">true</span>，失败为 <span class="literal">false</span>。</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>	删除指定位置的元素。</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>	删除并返回第一个元素。</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span>	删除并返回第一个元素。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>	判断是否含有某一元素。</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>	返回指定位置的元素。</span><br></pre></td></tr></table></figure>


<h3 id="Java-HashSet"><a href="#Java-HashSet" class="headerlink" title="Java HashSet"></a>Java HashSet</h3><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>
<p>HashSet 允许有 null 值。</p>
<p>HashSet 是无序的，即不会记录插入的顺序。</p>
<p>HashSet <strong>不是线程安全</strong>的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在<strong>多线程访问</strong>时<strong>显式同步对 HashSet 的并发访问</strong>。</p>
<p>HashSet 实现了 Set 接口。</p>
<img src="/2024/02/23/javaNote/6.png" class="">

<p>HashSet 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet; <span class="comment">// 引入 HashSet 类</span></span><br><span class="line">HashSet&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>


<h3 id="Java-HashMap"><a href="#Java-HashMap" class="headerlink" title="Java HashMap"></a>Java HashMap</h3><p>Map 遍历</p>
<p><strong>Entry</strong><br>由于Map中存放的元素均为键值对，故每一个键值对必然存在一个映射关系。<br>Map中采用<strong>Entry内部类</strong>来表示一个映射项，映射项包含Key和Value (我们总说键值对键值对, <strong>每一个键值对也就是一个Entry</strong>)<br>Map.Entry里面包含getKey()和getValue()方法</p>
<p><strong>entrySet</strong><br>entrySet是 java中 键值对<strong>的集合</strong>，Set里面的类型是<strong>Map.Entry</strong>，一般可以通过<strong>map.entrySet</strong>()得到。</p>
<p>entrySet实现了Set接口，里面存放的是上面所说的键值对也就是一个Map.Entry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>( Map.Entry&lt;Integer, Integer&gt; iter : map.entrySet()) &#123;</span><br><span class="line">  System.out.println(entry.getKey()+<span class="string">&quot;,&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以试着用<strong>map.entrySet的</strong>迭代器 iterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;Integer,Integer&gt; entry=it.next();</span><br><span class="line">        <span class="type">int</span> key=entry.getKey();</span><br><span class="line">        <span class="type">int</span> value=entry.getValue();</span><br><span class="line">        System.out.println(key+<span class="string">&quot; &quot;</span>+value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>keySet</strong><br>还有一种是keySet, keySet是键的集合，Set里面的类型即key的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String s:set) &#123;</span><br><span class="line">    System.out.println(s+<span class="string">&quot;,&quot;</span>+map.get(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Java-Object-类"><a href="#Java-Object-类" class="headerlink" title="Java Object 类"></a>Java Object 类</h3><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。</p>
<p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>
<p>Object 类可以显式继承，也可以隐式继承，以下两种方式是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">显式继承:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runoob</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">隐式继承:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runoob</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈-队列-优先队列"><a href="#栈-队列-优先队列" class="headerlink" title="栈 队列 优先队列"></a>栈 队列 优先队列</h3><p>栈 队列 用 ArrayDeque 比较好，如：<br><code>Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();</code></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Ba8jrULf8NJbENK6WGrVWg">Java 程序员，别用 Stack？！</a><br>理解了接口含义，就是封装。<br>原来stack继承vector，继承了多余的方法，破坏了封装性。<br>当然，用<code>Dueue&lt;Integer&gt; stk = new ArrayDeque&lt;Integer&gt;();</code>也有这个问题，但已经是历史遗留问题，无解了。</p>
<p>优先队列有 PriorityQueue</p>
<h2 id="各种类型相互转化问题"><a href="#各种类型相互转化问题" class="headerlink" title="各种类型相互转化问题"></a>各种类型相互转化问题</h2><p>Java 中数组即对象。</p>
<p>只要跟集合交流的数组都是<strong>引用类型的数组</strong>。因为集合本身不与基本类型打交道。如果你要交流，他们的包装类型就是交流的桥梁。而<strong>包装类型和基本类型数组之间的转换</strong>就要你自己写<strong>循环体</strong>去一个一个转型了。</p>
<h3 id="char-与-String-互相转换"><a href="#char-与-String-互相转换" class="headerlink" title="char[] 与 String 互相转换"></a>char[] 与 String 互相转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = str.toCharArray();			<span class="comment">//通过toCharArray方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] chars);			<span class="comment">//通过String构造函数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(<span class="type">char</span>[] chars);		<span class="comment">//通过String类型转换，实际上还是String的构造函数(源码)</span></span><br></pre></td></tr></table></figure>


<h3 id="包装类数组-与-List-互相转换"><a href="#包装类数组-与-List-互相转换" class="headerlink" title="包装类数组 与 List 互相转换"></a>包装类数组 与 List 互相转换</h3><p>copyOfRange是输入java.util包中的<strong>Arrays</strong>类的静态内部方法，可以被类直接调用。下面以int[]型传递参数为例，来测试其用法。</p>
<p><code>copyOfRange(int []original,int from,int to)</code>,original为原始的int型数组，from为开始角标值，to为终止角标值。（其中包括from角标，不包括to角标。即处于<code>[from,to)</code>状态）</p>
<p><strong>包装类数组转换为List</strong></p>
<p><strong>再次强调</strong>List只能和包装类数组之间进行转换，因为集合只支持对包装类进行操作。<br>如果非要进行基本类型数字与List之间的转换(Java对包装和解包装都是自动进行的，包装类数据其实也可以直接用，区别并不太大)，那么必须通过包装类数组这个媒介。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Character[] chars = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">List&lt;Character&gt; list1 = Arrays.asList(chars); <span class="comment">//通过Arrays的工具类 注意这里的 asList 产生的 list1 是不能增删元素的，后面会讲，返回的是Arrays类内部的静态内部类ArrayList实例对象</span></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">List&lt;Character&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">//通过Collections工具类</span></span><br><span class="line">Collections.addAll(list2, chars); <span class="comment">//源码是通过遍历数组</span></span><br></pre></td></tr></table></figure>


<p><strong>List转换为包装类数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listToArray</span><span class="params">()</span>&#123;</span><br><span class="line">		List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">		list.add(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">		Character[] chars =  list.toArray(<span class="keyword">new</span> <span class="title class_">Character</span>[list.size()]);<span class="comment">//注意toArray()的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于源码的实现，就要具体看是那种List了，从List接口中，我们也能知道一些信息：<br><code>&lt;T&gt; T[] toArray(T[] a); //参数是什么类型就返回什么类型的数组</code></p>
<h3 id="String-与-List-互相转换"><a href="#String-与-List-互相转换" class="headerlink" title="String 与 List 互相转换"></a>String 与 List 互相转换</h3><p><strong>String转换为List</strong><br>原理就是首先将String转换成String[]数组，再通过上面讲过的包装类数组转换为List。<br>注意这里的<strong>str.split(“”)</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stringToList</span> <span class="params">(String str)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">	<span class="comment">//方式一</span></span><br><span class="line">	List&lt;String&gt;list1  = Arrays.asList(str.split(<span class="string">&quot;&quot;</span>)); <span class="comment">//str.split()返回一个String[]数组，这里要注意</span></span><br><span class="line">	<span class="comment">//方式二</span></span><br><span class="line">	List&lt;String&gt;list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	Collections.addAll(list2, str.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以有两个步骤是：<br>首先要将String转换为包装类型（如Character[]）或String[]数组<br>再把包装类型数组转换成List。</p>
<p>注意：<br>要注意的是，通常所说的String转换成List,方式之一通常是<strong>通过split方法转换成String[]数组</strong>。<br>如果你想将str.toCharArray转换成char[]（上面讲过了）,再转换为List,这就比较麻烦了，因为你需要先得把char[]基本类型转换成Character[]。</p>
<p><strong>List转换为String</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listToString</span><span class="params">()</span>&#123;</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.join(<span class="string">&quot;&quot;</span>, list); <span class="comment">//&quot;1234&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List通过<strong>String的join方法</strong>直接转换为String,通过””作为分隔符，就相当于字符之间没有分隔符。</p>
<h3 id="List和Set互相转换"><a href="#List和Set互相转换" class="headerlink" title="List和Set互相转换"></a>List和Set互相转换</h3><p><strong>List转换为Set</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listToSet</span><span class="params">()</span>&#123;</span><br><span class="line">		 List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		 Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);   <span class="comment">//直接构造函数即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Set转换为List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setToList</span><span class="params">()</span>&#123;</span><br><span class="line">		 Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		 List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set); <span class="comment">//直接构造函数即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以<strong>List集合和Set集合之间只要类型参数相同</strong>，既可以通过<strong>构造函数</strong>互相转换。</p>
<h3 id="String-与-Set-互相转换"><a href="#String-与-Set-互相转换" class="headerlink" title="String 与 Set 互相转换"></a>String 与 Set 互相转换</h3><p><strong>String转换为Set</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stringToSet</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">	String[] strs= str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方式一</span></span><br><span class="line">	List&lt;String&gt; list1 = Arrays.asList(strs);</span><br><span class="line">	Set&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式二</span></span><br><span class="line">	Set&lt;String&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	Collections.addAll(set2, strs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式一有三个步骤：<br>String转换为String[]数组 或包装类型数组（如Character[]）<br>将数组转换为List,<br>再使用Arrays或Collections工具类将list转换为Set。</p>
<p>方式二有两个步骤<br>String转换为String[]数组 或包装类型数组（如Character[]）<br>使用Collections工具类将数组转换为Set。</p>
<p><strong>Set转换为String</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setToString</span><span class="params">()</span>&#123;</span><br><span class="line">	Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	String.join(<span class="string">&quot;&quot;</span>, set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要一个步骤，即：<br>使用<strong>String的join方法</strong>把集合转换为String。</p>
<h3 id="包装类数组-与-Set-互相转换"><a href="#包装类数组-与-Set-互相转换" class="headerlink" title="包装类数组 与 Set 互相转换"></a>包装类数组 与 Set 互相转换</h3><p>Set 与 List 同理， 也只与包装类型打招呼。</p>
<p><strong>包装类数组转换为Set</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arrayToSet</span><span class="params">()</span>&#123;</span><br><span class="line">		Character[] chars = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//方式一</span></span><br><span class="line">		List&lt;Character&gt; list = Arrays.asList(chars);</span><br><span class="line">		Set&lt;Character&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//方式二</span></span><br><span class="line">		Set&lt;Character&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		Collections.addAll(set1, chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方式，同样是受到不同工具类的影响。</p>
<p>第一种方式的两个步骤：<br>数组通过Arrays或Collections工具类(也是Collections.addAll，上面讲过)转换为List<br>再把list转换为set</p>
<p>第二种方式的一个步骤:<br>通过Collections直接将数组转换为Set</p>
<p><strong>Set转换为包装类数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setToArray</span><span class="params">()</span>&#123;</span><br><span class="line">	Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	Character[] chars = set.toArray(<span class="keyword">new</span> <span class="title class_">Character</span>[set.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合转为数组的方式也很简单，通常都是集合.toArray(T[] t)。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SnailMann/article/details/80614006">Java8中数组(引用类型)、String、List、Set之间的相互转换问题</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2254742">Java-String类&amp;集合ArrayList</a></p>
<h3 id="Arrays-asList使用指南"><a href="#Arrays-asList使用指南" class="headerlink" title="Arrays.asList使用指南"></a>Arrays.asList使用指南</h3><p>List 是一种很有用的数据结构，如果需要将一个数组转换为 List 以便进行更丰富的操作的话，可以这么实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;； </span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将需要转化的数组作为参数，或者直接把数组元素作为参数，都可以实现转换。</p>
<p>下面看一下<strong>极易出现的错误及相应的解决方案</strong>：</p>
<h4 id="错误一-将原生数据类型数据的数组作为参数"><a href="#错误一-将原生数据类型数据的数组作为参数" class="headerlink" title="错误一 将原生数据类型数据的数组作为参数"></a>错误一 将原生数据类型数据的数组作为参数</h4><p>来看一下asList 方法的签名：<br><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code><br>注意：参数类型是 T ，根据官方文档的描述，T 是数组元素的 class。<br>  如果你对反射技术比较了解的话，那么 class 的含义想必是不言自明。我们知道任何类型的对象都有一个 class 属性，这个属性代表了这个类型本身。原生数据类型，比如 int，short，long等，是没有这个属性的，具有 class 属性的是它们所对应的包装类 Integer，Short，Long。<br>  因此，这个错误产生的原因可解释为：asList 方法的参数<strong>必须是对象或者对象数组</strong>，而原生数据类型不是对象——这也正是包装类出现的一个主要原因。当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组。</p>
<h4 id="解决方案：使用包装类数组"><a href="#解决方案：使用包装类数组" class="headerlink" title="解决方案：使用包装类数组"></a>解决方案：使用包装类数组</h4><p>如果需要将一个整型数组转换为 List，那么就将数组的类型声明为 Integer 而不是 int。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">      <span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">      System.out.println(myList.size());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误二-试图修改-List-的大小"><a href="#错误二-试图修改-List-的大小" class="headerlink" title="错误二 试图修改 List 的大小"></a>错误二 试图修改 List 的大小</h4><p>我们知道 List 是可以动态扩容的，因此在创建一个 List 之后最常见的操作就是向其中添加新的元素或是从里面删除已有元素，但这样的操作都会出现异常：<code>java.lang.UnsupportedOperationException</code>。<br>仔细阅读官方文档，你会发现对 asList 方法的描述中有这样一句话：<strong>返回一个由指定数组生成的固定大小的 List。</strong></p>
<p>按道理 List 本就支持动态扩容，那为什么偏偏 asList 方法产生的 List 就是固定大小的呢？如果要回答这一问题，就需要查看相关的源码。Java 8 中 asList 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2764017481108945198L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">    ArrayList(E[] array) &#123;</span><br><span class="line">        a = Objects.requireNonNull(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<strong>内部类</strong>也叫 ArrayList ，这个内部类继承了 AbstractList 却没有重写add方法，所以会抛出异常：<code>java.lang.UnsupportedOperationException</code>（在AbstractList中对add方法天然就会抛出此异常，与源码中的final无关。对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。这里是第二种情况）。<br>而我们平时常用的java.util.ArrayList里的ArrayList重写了add方法，所以是可以添加删除元素的。</p>
<p>因此：asList 方法返回的确实是一个 ArrayList ,但这个 ArrayList 并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类。</p>
<p>所以，<code>List&lt;String&gt; myList = Arrays.asList(myArray)</code>可不能写成<code>ArrayList&lt;String&gt; myList = Arrays.asList(myArray)</code>。</p>
<h4 id="解决方案：创建一个真正的-ArrayList"><a href="#解决方案：创建一个真正的-ArrayList" class="headerlink" title="解决方案：创建一个真正的 ArrayList"></a>解决方案：创建一个真正的 ArrayList</h4><p>  既然我们已经知道之所以asList 方法产生的 ArrayList 不能修改大小，是因为这个 ArrayList 并不是“货真价实”的 ArrayList ，那我们就自行创建一个真正的 ArrayList ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">      List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(myArray));</span><br><span class="line">      myList.add(<span class="string">&quot;Guava&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，我们 new 了一个 java.util.ArrayList ，然后再把 asList 方法的返回值作为构造器的参数传入，最后得到的 myList 自然就是可以动态扩容的了。</p>
<h4 id="用自己的方法实现数组到-List-的转换"><a href="#用自己的方法实现数组到-List-的转换" class="headerlink" title="用自己的方法实现数组到 List 的转换"></a>用自己的方法实现数组到 List 的转换</h4><p>有时，自己实现一个方法要比使用库中的方法好。鉴于 asList 方法有一些限制，那么我们可以用自己的方法来实现数组到 List 的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">      List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 这里其实是向上转型，因为ArrayList实现了List接口，写ArrayList&lt;String&gt; myList当然也可以</span></span><br><span class="line">      <span class="keyword">for</span> (String str : myArray) &#123;</span><br><span class="line">         myList.add(str);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(myList.size());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的话代码相对冗长，但是不管有什么特别的需求都可以自己来实现，</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2b113f487e5e">Arrays.asList使用指南</a></p>
<h4 id="ArrayList-转-String"><a href="#ArrayList-转-String" class="headerlink" title="ArrayList 转 String"></a>ArrayList<Character> 转 String</h4><p>ArrayList 实现了 List 接口，自然也能使用List.toString()方法获得带中括号的字符串，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Character&gt; chars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">chars.add(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">chars.add(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">chars.add(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">System.out.println(chars.toString()); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>想要获得不带括号的，方法有：</p>
<ol>
<li>遍历列表并创建字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(arrayList.size());</span><br><span class="line"><span class="keyword">for</span>(Character ch: arrayList)</span><br><span class="line">&#123;</span><br><span class="line">   builder.append(ch);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(builder.toString()); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
将<code>StringBuilder</code>的容量设置为列表大小是一个重要的优化。如果不这样做，一些append调用可能会触发Builder内部调整大小。</li>
</ol>
<p>另外，toString()返回一个人类可读的ArrayList内容格式。不值得花时间从其中过滤掉不必要的字符。它的实现明天可能会改变，你将不得不重写你的过滤代码。<br>2. 用正则表达式直接替换’[]’，’,’为空字符</p>
<h3 id="数组打印问题"><a href="#数组打印问题" class="headerlink" title="数组打印问题"></a>数组打印问题</h3><h4 id="System-out-println"><a href="#System-out-println" class="headerlink" title="System.out.println()"></a>System.out.println()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">var</span>);</span><br><span class="line"><span class="comment">// output: [I@74a14482</span></span><br></pre></td></tr></table></figure>
<p>原因如下：<br>方法  <code>System.out.println()</code>  通过调用  <code>String.valueOf()</code>  把入参对象转换为一个字符串。<br>这里注意到： char[] 转化为 String 可以通过<code>String str = String.valueOf(char[] chars)</code>语句，所以<code>System.out.println()</code>是可以成功打印<strong>字符数组</strong><code>char[]</code>的，但是其他类型的数组都是不可以的。</p>
<p>如果我们查看  <code>String.valueOf()</code>  方法的实现，会看到如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="literal">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果入参是  null  会返回空， 其它情况会调用  obj.toString()。 最后  System.out.println()  调用  toString()  方法打印出了字符串。</p>
<p>如果对象的类没有重写  Object.toString()  方法并实现，那就会调用超类  Object  的  Object.toString()  方法。</p>
<p>Object.toString()  返回的是  <code>getClass().getName()+****‘@’****+Integer.toHexString(hashCode())</code>。 简化格式为：“<code>class name @ object’s hash code</code>”。</p>
<p>上文中输出的内容是  <code>[I@74a14482</code>，  <code>[ </code> 表示数组， <code>I</code>  表示 int 数据类型（数组的数据类型）。 <code>74a14482</code>  是数组的无符号十六进制 hash 值。</p>
<p>当<strong>创建自定义类</strong>时，<strong>重写  Object.toString()  方法</strong>是最佳的实践。</p>
<h4 id="for-amp-for-each-amp-Arrays-toString"><a href="#for-amp-for-each-amp-Arrays-toString" class="headerlink" title="for &amp; for-each &amp; Arrays.toString()"></a>for &amp; for-each &amp; Arrays.toString()</h4><p>用传统for循环或者for each循环<code>for(int a:array)</code>；<br>或利用<strong>Array类</strong>中的toString方法(静态static方法，通过类名Array调用)<strong>Array.toString(var)<strong>，返回一个包含数组元素的字符串，需要</strong>注意这些元素被放置在中括号内，并用逗号分开</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] intArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(intArray));   <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p><code>System.out.println(intArray); </code>是不行的，这样打印是的是数组的首地址。</p>
<p>对于二维数组也对应这三种方法，定义一个二维数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][]magicSquare =</span><br><span class="line">   	 &#123;</span><br><span class="line">   		 &#123;<span class="number">16</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">13</span>&#125;,</span><br><span class="line">   		 &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">8</span>&#125;,</span><br><span class="line">   		 &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;</span><br><span class="line">   	 &#125;;</span><br></pre></td></tr></table></figure>
<p>Java实际没有多维数组，只有一维数组，多维数组被解读为”数组的数组”，例如二维数组magicSquare是包含{magicSquare[0]，magicSquare[1]，magicSquare[2]}三个元素的一维数组，magicSqure[0]是包含{16,3,2,13}四个元素的一维数组，同理magicSquare[1]，magicSquare[2]也一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三种方法(Arrays.toString)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;magicSquare.length;i++)</span><br><span class="line">    System.out.println(Arrays.toString(magicSquare[i]));</span><br></pre></td></tr></table></figure>

<p>对于引用类型的数组，确保重写该引用类的  Object.toString()  方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] students = &#123;<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;John&quot;</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Doe&quot;</span>)&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(students));</span><br><span class="line">    <span class="comment">// output: [Student&#123;name=&#x27;John&#x27;&#125;, Student&#123;name=&#x27;Doe&#x27;&#125;]</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;&#x27;</span><span class="string">&#x27; + &#x27;</span>&#125;<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此方法不适用于多维数组。在多维数组中，  Object.toString()  会打印数组元素的内存地址而不是内容。</p>
<h4 id="Arrays-deepToString-amp-Arrays-asList"><a href="#Arrays-deepToString-amp-Arrays-asList" class="headerlink" title="Arrays.deepToString() &amp; Arrays.asList()"></a>Arrays.deepToString() &amp; Arrays.asList()</h4><p>Arrays.deepToString()  返回数组“深层内容”的字符串形式。</p>
<p>基本类型多维数组示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// creating multidimensional array</span></span><br><span class="line"><span class="type">int</span>[][] multiDimensionalArr = &#123; &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">5</span>,<span class="number">9</span>&#125; &#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(multiDimensionalArr));</span><br><span class="line"><span class="comment">// output: [[2, 3], [5, 9]]</span></span><br></pre></td></tr></table></figure>

<p>对于引用类型数组，通过递归调用  Arrays.deepToString()  方法将其转换为字符串。</p>
<p><strong>Arrays.asList()</strong> 方法返回固定大小（数组长度）的列表。<br>因为 List 是对象列表集合，与列表打交道的数组都要求是包装类型的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] intArray = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">46</span>,<span class="number">12</span>,<span class="number">34</span>&#125;;</span><br><span class="line">System.out.println(Arrays.asList(intArray));</span><br><span class="line"><span class="comment">// output: [2, 5, 46, 12, 34]</span></span><br></pre></td></tr></table></figure>

<p>Java 调用  Arrays.<strong>asList</strong>(intArray).<strong>toString()</strong>  。其内部实现是列表(list)元素调用了 toString() 方法(同样会带有括号)，注意，ArrayList实现了List接口，自然也拥有 toString() 方法，同样会带有括号。</p>
<p>NOTE:  不能使用此方法打印多维数据。</p>
<h4 id="Java-Iterator-interface-amp-Java-Stream-API"><a href="#Java-Iterator-interface-amp-Java-Stream-API" class="headerlink" title="Java Iterator interface &amp; Java Stream API"></a>Java Iterator interface &amp; Java Stream API</h4><p>Iterator 接口和 for-each 循环类似，可以使用 Iterator 接口遍历数组元素并打印。</p>
<p><strong>Collection 调用  iterator()</strong>  方法创建 Iterator 对象。Iterator 对象可以遍历该集合的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer[] intArray = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">46</span>,<span class="number">12</span>,<span class="number">34</span>&#125;;</span><br><span class="line"><span class="comment">// creating a List of Integer</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(intArray);</span><br><span class="line"><span class="comment">// creating an iterator of Integer List</span></span><br><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="comment">// if List has elements to be iterated</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    System.out.print(it.next());</span><br><span class="line">    <span class="comment">// output: 25461234</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it.next() 迭代器指向下一个元素并返回当前迭代器所指的值，初始的时候迭代器应该指向第一个元素更前面的一个位置</span></span><br></pre></td></tr></table></figure>

<p><strong>Stream API</strong> 用于处理对象集合。 流是一个对象序列。流不能改变原始数据结构，它仅根据请求的操作提供结果。</p>
<p>借助终端操作  forEach()  可以遍历流的每个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] intArray = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">46</span>,<span class="number">12</span>,<span class="number">34</span>&#125;;</span><br><span class="line">Arrays.stream(intArray).forEach(System.out::print);</span><br><span class="line"><span class="comment">// output: 25461234</span></span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>(Java 数组的打印方式)[<a target="_blank" rel="noopener" href="https://www.freecodecamp.org/chinese/news/java-array-methods-how-to-print-an-array-in-java/]">https://www.freecodecamp.org/chinese/news/java-array-methods-how-to-print-an-array-in-java/]</a></p>
<h2 id="Arrays算法类"><a href="#Arrays算法类" class="headerlink" title="Arrays算法类"></a>Arrays算法类</h2><h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort"></a>Arrays.sort</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">Arrays.sort(arr, (a, b) -&gt; b[<span class="number">0</span>] - a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>将对arr按第0列降序排序，太抽象了，写个比较器对新手多友好。<br>可以这样理解，原本默认是<code>Arrays.sort(arr, (a, b) -&gt; (a[0] - b[0]) )</code>将会升序排列，比较的根据是 <code>(a[0] - b[0])</code> 返回 0、1、-1。改成<code>(b[0] - a[0])</code>之后就会按按第0列降序排列。</p>
<p>Arrays.sort(T[],Comparator&lt;? super T&gt;c)<br>自定义比较器 Comparator ，可以为<strong>对象</strong>实现降序排序，上面的二维数组中的每一个数组其实就可以当作是一个对象，也可以用来为自定义类对象实现排序。</p>
<p>Arrays.sort()<strong>对二维数组进行排序</strong>:</p>
<p>int [][]a &#x3D; new int [5][2];</p>
<p>&#x2F;&#x2F;定义一个二维数组，其中所包含的一维数组具有两个元素</p>
<p>对于一个已定义的二位数组a进行如下规则排序,首先按照每一个对应的一维数组第一个元素进行升序排序（即a[][0]）,若第一个元素相等,则按照第二个元素进行升序排序（a[][1]）。(特别注意,这里的a[][0]或者a[][1]在java中是不能这么定义的,这里只是想说明是对于某一个一维数组的第0或1个元素进行排序)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (o1[<span class="number">0</span>]==o2[<span class="number">0</span>]) <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中o1[1]-o2[1]表示对于第二个元素进行升序排序如果为o2[1]-o1[1]则表示为降序。</p>
<p><code>Arrays.sort(arr, (a, b) -&gt; b[0] - a[0]);</code>这个应该是lambda表达式的写法，等效于<code>Arrays.sort(arr, (int[] a, int[] b) -&gt; b[0] - a[0]);</code></p>
<p>参考自 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/13945050.html">二维数组排序</a></p>
<h4 id="Comparator-lt-super-T-gt"><a href="#Comparator-lt-super-T-gt" class="headerlink" title="Comparator&lt;? super T&gt;"></a>Comparator&lt;? super T&gt;</h4><p>Comparator&lt;? super T&gt;的实现涉及到泛型：</p>
<p><strong>实现降序排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）</span></span><br><span class="line">        <span class="comment">//而要使用它们对应的类</span></span><br><span class="line">        Integer[] a = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//定义一个自定义类MyComparator的对象</span></span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyComparator</span>();</span><br><span class="line">        Arrays.sort(a, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Comparator是一个接口，所以这里我们自己定义的类MyComparator要implents该接口，而不是extends Comparator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="comment">//如果n1小于n2，我们就返回正值，如果n1大于n2我们就返回负值，</span></span><br><span class="line">        <span class="comment">//这样颠倒一下，就可以实现反向排序了</span></span><br><span class="line">        <span class="keyword">if</span>(o1 &lt; o2) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1 &gt; o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果如下：</span></span><br><span class="line"><span class="comment">//9 8 7 6 5 4 3 2 1 0 </span></span><br></pre></td></tr></table></figure>

<p>&lt;? super T&gt; 的意思是<strong>比较类型可以是T或者它的父类型</strong>。为什么准许父类型。答案是：<br>这种方法<strong>准许为所有的子类使用相同的比较器</strong>，也就是多态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">        size  = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalSizeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Animal&gt;&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Animal o1, Animal o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.size - o2.size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//in this way, all sub classes of Animal can use this comparator.</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySort</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        Dog[] dogArray = &#123;d1, d2, d3&#125;;</span><br><span class="line">        printDogs(dogArray);</span><br><span class="line"> </span><br><span class="line">        Arrays.sort(dogArray, <span class="keyword">new</span> <span class="title class_">AnimalSizeComparator</span>());  </span><br><span class="line">        printDogs(dogArray);</span><br><span class="line"> </span><br><span class="line">        System.out.println();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//when you have an array of Cat, same Comparator can be used. </span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        Cat[] catArray = &#123;c1, c2, c3&#125;;</span><br><span class="line">        printDogs(catArray);</span><br><span class="line"> </span><br><span class="line">        Arrays.sort(catArray, <span class="keyword">new</span> <span class="title class_">AnimalSizeComparator</span>());  </span><br><span class="line">        printDogs(catArray);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDogs</span><span class="params">(Animal[] animals)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Animal a: animals)</span><br><span class="line">            System.out.print(<span class="string">&quot;size=&quot;</span>+a.size + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一列降序，第二列升序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] people</span><br><span class="line"></span><br><span class="line">Arrays.sort(people, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] person1, <span class="type">int</span>[] person2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (person1[<span class="number">0</span>] != person2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> person2[<span class="number">0</span>] - person1[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> person1[<span class="number">1</span>] - person2[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>


<h2 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h2><p>Java 序列化是一种<strong>将对象转换为字节流</strong>的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行<strong>反序列化</strong>，将字节流重新转换为对象。</p>
<p>序列化在 Java 中是通过 java.io.Serializable 接口来实现的，<strong>该接口没有任何方法</strong>，只是一个<strong>标记接口</strong>，用于标识类可以被序列化。</p>
<p>当你序列化对象时，你把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。</p>
<p>序列化是一种用于保存、传输和还原对象的方法，它使得对象可以在不同的计算机之间移动和共享，这对于分布式系统、数据存储和跨平台通信非常有用。</p>
<p>实现 Serializable 接口： 要使一个类可序列化，需要让该类实现 java.io.Serializable 接口，这告诉 Java 编译器这个类可以被序列化，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 类的成员和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><em><strong>反射是框架设计的灵魂</strong></em></p>
<p>使用的<strong>前提条件</strong>：必须先得到代表字节码文件的Class类对象，其用于表示.class文件（字节码）</p>
<p>JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种<strong>动态获取</strong>类的信息以及<strong>动态调用</strong>对象的方法的功能称为java语言的反射机制。<br>要想<strong>解剖</strong>一个类,必须先要获取到该类的<strong>字节码文件对象</strong>。而解剖使用的就是<strong>Class类</strong>（就叫Class类，用于定义类的关键字 class 是小写的）中的方法，所以先要获取到<strong>每一个字节码文件对应的Class类对象</strong>。</p>
<p>以上的总结就是什么是反射</p>
<p>反射就是把java类中的各种成分映射成一个个的Java对象</p>
<p>利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java基础之—反射（非常重要）</a> </p>
<p>写的很好，学了很多<strong>反射基础</strong>，认真看完了。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>java注解是在JDK5时引入的新特性，鉴于目前大部分框架(如Spring)都使用了注解简化代码并提高编码的效率，因此掌握并深入理解注解对于一个Java工程师是来说是很有必要的事。</p>
<p>Java所有注解都继承了Annotation接口，也就是说　Java使用Annotation接口代表注解元素，该接口是所有Annotation类型的父接口。同时为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/71860633">深入理解Java注解类型(@Annotation)</a><br>讲的不错，认真看完了。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型与继承息息相关，特别是继承中的向上向下转型，具体的我在继承中已经认真学习过了。</p>
<p>以下来自博客<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/640124">一文读懂Java泛型中的通配符 ？</a><br>首先学习下泛型中常见的 <strong>？ 通配符</strong>。当然在学习它是什么之前，我们要知道它是为了解决什么问题而产生的。<br>(举个例子)当你要写一个通用的方法，它可以操作对含有某些特定类型元素的<strong>集合</strong>统一操作。</p>
<p>想象 A 是 B、C 父类， List&lt;A&gt;、 List&lt;B&gt;、 List&lt;C&gt; 是对应的集合，我想实现某些函数能统一对这些 集合 进行访问读写，而不是每个集合写一个相同功能的函数，也即之前提过的向上向下转型。</p>
<p><strong>泛型通配符 ？</strong><br>泛型通配符可以解决这个问题。泛型通配符主要针对以下两种需求：</p>
<ul>
<li>从一个泛型集合里面读取元素</li>
<li>往一个泛型集合里面插入元素</li>
</ul>
<p>这里有三种方式定义一个使用泛型通配符的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; listUknown = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;A&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">A</span>&gt; listUknown = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;A&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> A&gt; listUknown = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;A&gt;();</span><br></pre></td></tr></table></figure>

<p>无限定通配符 ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElements</span><span class="params">(List&lt;?&gt; elements)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(Object o : elements)&#123;</span><br><span class="line">      Sysout.out.println(o);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>List&lt;?&gt; </code> 可以指持有任意数据类型的集合，但<strong>只能指一个</strong>，比如就是List&lt;A&gt;，也可以是List&lt;B&gt;,或者List&lt;C&gt;，但我不知道是哪个，所以只能对这个集合读，并且只能把读取到的元素当成 Object 实例来对待（向上转型，因为 Object 是所有类的父类）</p>
<p>上界通配符（? extends）<br>List&lt;? extends A&gt; 代表的是一个可以持有 <strong>A及其子类</strong>（如B和C）的实例的List集合。<br>当集合所持有的实例是A或者A的子类的时候，此时从集合里读出元素并把它<strong>强制转换为A</strong>是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">processElements</span><span class="params">(List&lt;? extends A&gt; elements)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(A a : elements)&#123;</span><br><span class="line">      System.out.<span class="built_in">println</span>(a.<span class="built_in">getValue</span>());  <span class="comment">// getValue是 A 的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候你可以把List&lt;A&gt;,List&lt;B&gt;或者List&lt;C&gt;类型的变量作为参数传入processElements()方法之中。</p>
<p>processElements()方法仍然是不能给传入的list插入元素的（比如进行list.add()操作），因为你不知道list集合里面的元素是什么类型（A、B还是C等等）。</p>
<p>下界通配符(? super)<br>List&lt;? super A&gt; 的意思是List集合 list,它可以持有 A 及其父类的实例。<br>当你知道集合里<strong>所持有的元素类型都是A及其父类</strong>的时候，此时往list集合里面插入<strong>A及其子类</strong>（B或C）是安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertElements</span><span class="params">(List&lt;? <span class="built_in">super</span> A&gt; list)</span>&#123;</span><br><span class="line">   list.add(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">   list.add(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">   list.add(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>你可以往insertElements传入List&lt;A&gt;或者一个持有A的父类的list（这也是 super 的含义）。</p>
<p>因为此时我们可以确定传入的list集合里的元素是A及其父类，所以我们往这个集合里插入A及其子类是兼容的（向上转型）。</p>
<p>同样的，这个集合也不能随便读，里面的元素可能是 A 类也可能是 A 的父类，读取方法很简单，找出集合里元素的共同父类并将集合元素转化为这个类型，之后才能用，或者直接转化为 Object类，上面的list&lt;? extends A&gt;可以转换为A的原因是他知道集合里的元素的类型要么是A要么是A的子类，他们都可以转换为A。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s10461/article/details/53941091">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a> 认真看完了，基本都能理解，有讲到上面提到的通配符的应用，大差不差。</p>
<p>泛型有三种使用方式，分别为：<strong>泛型类、泛型接口、泛型方法</strong>。</p>
<p>编译之后程序会采取去泛型化的措施。也就是说<strong>Java中的泛型只在编译阶段有效</strong>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hguisu/article/details/6155636">java(3)-深入理解java异常处理机制</a><br>详解java异常的文章，需要的时候再来看吧。</p>
<h2 id="Java-多线程与并发"><a href="#Java-多线程与并发" class="headerlink" title="Java 多线程与并发"></a>Java 多线程与并发</h2><h2 id="Maven-引入外部依赖"><a href="#Maven-引入外部依赖" class="headerlink" title="Maven 引入外部依赖"></a>Maven 引入外部依赖</h2><p>pom.xml 的 <strong>dependencies</strong> 列表列出了我们的项目需要构建的所有外部依赖项。</p>
<p>要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。具体做法为：<br>项目左边栏右键空白处之后选择： <code>Open Module Settings</code>，点击 + 号选择<code>Jars or Directories</code>选项并导入之前创建的 lib 文件夹即可完成配置。</p>
<img src="/2024/02/23/javaNote/16.png" class="">

<p>第三方库一般都会给出配置的 pom 代码。<br>然后添加以下依赖到 pom.xml 文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- 在这里添加你的依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.1</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>如果用 systemPath 的话是配置本地依赖，这种情况应该不需要配置lib文件夹，第二种配置方法是需要的。</p>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904020780253191">IDEA新手使用教程（详解）</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2254742">Java-String类&amp;集合ArrayList</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java基础之—反射（非常重要）</a> </p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>lichao Zhang
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://iridescent-zhang.github.io/2024/02/23/javaNote/" title="javaNote">https://iridescent-zhang.github.io/2024/02/23/javaNote/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/08/videoCompress/" rel="prev" title="videoCompress">
      <i class="fa fa-chevron-left"></i> videoCompress
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/05/LeetCodeNote/" rel="next" title="LeetCodeNote">
      LeetCodeNote <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E8%A7%84%E5%88%99"><span class="nav-number">1.1.</span> <span class="nav-text">源文件规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Public%E7%B1%BB-amp-amp-main"><span class="nav-number">1.1.1.</span> <span class="nav-text">Public类 &amp;&amp; main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.1.2.</span> <span class="nav-text">命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import-amp-amp-package-%E8%A7%84%E5%88%99"><span class="nav-number">1.1.3.</span> <span class="nav-text">import &amp;&amp; package 规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-package"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Java package</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-import"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Java import</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">普通变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">引用类型变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.4.</span> <span class="nav-text">参数变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E5%92%8Cfinal"><span class="nav-number">1.3.</span> <span class="nav-text">static和final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Number-amp-amp-Math-%E7%B1%BB"><span class="nav-number">1.4.1.</span> <span class="nav-text">Java Number  &amp;&amp; Math 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Character-%E7%B1%BB"><span class="nav-number">1.4.2.</span> <span class="nav-text">Java Character 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-String-%E7%B1%BB"><span class="nav-number">1.4.3.</span> <span class="nav-text">Java String 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">Java 正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99-Override"><span class="nav-number">1.6.1.</span> <span class="nav-text">重写(Override)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">方法的重写规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-Overload"><span class="nav-number">1.6.2.</span> <span class="nav-text">重载(Overload)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.3.</span> <span class="nav-text">构造器(构造函数)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super-amp-amp-this"><span class="nav-number">1.6.4.</span> <span class="nav-text">super &amp;&amp; this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%9E%8B-IMPORTANT"><span class="nav-number">1.6.5.</span> <span class="nav-text">继承中的转型 (IMPORTANT)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.6.</span> <span class="nav-text">理解继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.7.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-amp-amp-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">抽象类 &amp;&amp; 抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.3.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package"><span class="nav-number">1.8.</span> <span class="nav-text">package</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number">1.9.</span> <span class="nav-text">Java 集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-ArrayList"><span class="nav-number">1.9.1.</span> <span class="nav-text">Java ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-LinkedList"><span class="nav-number">1.9.2.</span> <span class="nav-text">Java LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-HashSet"><span class="nav-number">1.9.3.</span> <span class="nav-text">Java HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-HashMap"><span class="nav-number">1.9.4.</span> <span class="nav-text">Java HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Object-%E7%B1%BB"><span class="nav-number">1.9.5.</span> <span class="nav-text">Java Object 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88-%E9%98%9F%E5%88%97-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">1.9.6.</span> <span class="nav-text">栈 队列 优先队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.10.</span> <span class="nav-text">各种类型相互转化问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#char-%E4%B8%8E-String-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.1.</span> <span class="nav-text">char[] 与 String 互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E6%95%B0%E7%BB%84-%E4%B8%8E-List-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.2.</span> <span class="nav-text">包装类数组 与 List 互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E4%B8%8E-List-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.3.</span> <span class="nav-text">String 与 List 互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E5%92%8CSet%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.4.</span> <span class="nav-text">List和Set互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E4%B8%8E-Set-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.5.</span> <span class="nav-text">String 与 Set 互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E6%95%B0%E7%BB%84-%E4%B8%8E-Set-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.6.</span> <span class="nav-text">包装类数组 与 Set 互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-asList%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="nav-number">1.10.7.</span> <span class="nav-text">Arrays.asList使用指南</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80-%E5%B0%86%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">1.10.7.1.</span> <span class="nav-text">错误一 将原生数据类型数据的数组作为参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB%E6%95%B0%E7%BB%84"><span class="nav-number">1.10.7.2.</span> <span class="nav-text">解决方案：使用包装类数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C-%E8%AF%95%E5%9B%BE%E4%BF%AE%E6%94%B9-List-%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.10.7.3.</span> <span class="nav-text">错误二 试图修改 List 的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9C%9F%E6%AD%A3%E7%9A%84-ArrayList"><span class="nav-number">1.10.7.4.</span> <span class="nav-text">解决方案：创建一个真正的 ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%88%B0-List-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.7.5.</span> <span class="nav-text">用自己的方法实现数组到 List 的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-%E8%BD%AC-String"><span class="nav-number">1.10.7.6.</span> <span class="nav-text">ArrayList 转 String</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98"><span class="nav-number">1.10.8.</span> <span class="nav-text">数组打印问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#System-out-println"><span class="nav-number">1.10.8.1.</span> <span class="nav-text">System.out.println()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-amp-for-each-amp-Arrays-toString"><span class="nav-number">1.10.8.2.</span> <span class="nav-text">for &amp; for-each &amp; Arrays.toString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arrays-deepToString-amp-Arrays-asList"><span class="nav-number">1.10.8.3.</span> <span class="nav-text">Arrays.deepToString() &amp; Arrays.asList()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Iterator-interface-amp-Java-Stream-API"><span class="nav-number">1.10.8.4.</span> <span class="nav-text">Java Iterator interface &amp; Java Stream API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.10.8.5.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays%E7%AE%97%E6%B3%95%E7%B1%BB"><span class="nav-number">1.11.</span> <span class="nav-text">Arrays算法类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-sort"><span class="nav-number">1.11.1.</span> <span class="nav-text">Arrays.sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparator-lt-super-T-gt"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">Comparator&lt;? super T&gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.12.</span> <span class="nav-text">Java 序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.13.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.14.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.15.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.15.1.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">1.16.</span> <span class="nav-text">Java 多线程与并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven-%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96"><span class="nav-number">1.17.</span> <span class="nav-text">Maven 引入外部依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-1"><span class="nav-number">1.18.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lichao Zhang"
      src="/images/cloud.jpg">
  <p class="site-author-name" itemprop="name">lichao Zhang</p>
  <div class="site-description" itemprop="description">博观而约取，厚积而薄发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Iridescent-zhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Iridescent-zhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lczhang93@gmail.com" title="E-Mail → mailto:lczhang93@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/18558575/wo-ladki" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;18558575&#x2F;wo-ladki" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/channel/UCv42aVozJF9n4hK8xCacCmg" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCv42aVozJF9n4hK8xCacCmg" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.youtube.com/watch?v=DGa4Xv_tcjE&list=LL&index=6" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v&#x3D;DGa4Xv_tcjE&amp;list&#x3D;LL&amp;index&#x3D;6" rel="noopener" target="_blank">Eiro Nareth INTERSTELLAR</a>
        </li>
    </ul>
  </div>

      </div>

	  
		<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
		<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
		<div class="widget-wrap">
		<div id="myCanvasContainer" class="widget tagcloud">
		<canvas width="220" height="250" id="resCanvas" style="width=100%">
			<ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cmd/" rel="tag">Cmd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Guitar/" rel="tag">Guitar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HLS/" rel="tag">HLS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NAT/" rel="tag">NAT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PYNQ/" rel="tag">PYNQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Powershell/" rel="tag">Powershell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP&#x2F;IP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li></ul>
		</canvas>
		</div>
		</div>
	  

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lichao Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">425k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">6:26</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'zmRLZ8XmVpWBhK4yl2baQmHm-gzGzoHsz',
      appKey     : 'c5e4Xhc2Ec8iU5BMArSxhhAu',
      placeholder: "Say something",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://zmrlz8xm.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fa fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fa fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button" onclick="moonMenuClick()">
    <svg class="moon-menu-svg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
      <g class="moon-menu-points">
        <circle class="moon-menu-point" r=".2rem" cx="0" cy="-.8rem"></circle>
        <circle class="moon-menu-point" r=".2rem"></circle>
        <circle class="moon-menu-point" r=".2rem" cx="0" cy=".8rem"></circle>
      </g>
    </svg>
    <div class="moon-menu-icon">
    </div>
    <div class="moon-menu-text">
    </div>
  </div>
</div>
<script src="/js/injector.js"></script>
    </div>
  <!-- 音乐播放器 -->
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
 <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
 <div id="aplayer" class="aplayer" data-id="3470747396" data-server="tencent" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
 <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
 <!-- 音乐播放器 end -->
</body>
</html>
