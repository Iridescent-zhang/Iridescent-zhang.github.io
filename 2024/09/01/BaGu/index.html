<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Witcher.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Witcher.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iridescent-zhang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":false,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Disqus","order":-1},"valine":{"text":"Valine","order":-2}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="路漫漫其修远兮，吾将上下而求索 加油，享受学习，享受知识！">
<meta property="og:type" content="article">
<meta property="og:title" content="BaGu">
<meta property="og:url" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/index.html">
<meta property="og:site_name" content="Iridescent-zhang">
<meta property="og:description" content="路漫漫其修远兮，吾将上下而求索 加油，享受学习，享受知识！">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://iridescent-zhang.github.io/BaGu/2.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/15.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/16.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/17.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/18.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/19.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/1.jpg">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/20.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/21.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/22.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-10.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-1.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-2.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-3.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-4.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-5.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-6.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-7.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-8.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-9.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-11.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-12.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-13.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/09/01/BaGu/image-14.png">
<meta property="article:published_time" content="2024-08-31T17:07:21.000Z">
<meta property="article:modified_time" content="2025-11-03T11:35:11.277Z">
<meta property="article:author" content="lichao Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iridescent-zhang.github.io/BaGu/2.png">

<link rel="canonical" href="https://iridescent-zhang.github.io/2024/09/01/BaGu/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>BaGu | Iridescent-zhang</title><meta name="robots" content="noindex">
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Iridescent-zhang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醉后不知天在水，满船清梦压星河</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://iridescent-zhang.github.io/2024/09/01/BaGu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cloud.jpg">
      <meta itemprop="name" content="lichao Zhang">
      <meta itemprop="description" content="博观而约取，厚积而薄发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Iridescent-zhang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          BaGu
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-31 17:07:21" itemprop="dateCreated datePublished" datetime="2024-08-31T17:07:21Z">2024-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-03 11:35:11" itemprop="dateModified" datetime="2025-11-03T11:35:11Z">2025-11-03</time>
              </span>

          
            <span id="/2024/09/01/BaGu/" class="post-meta-item leancloud_visitors" data-flag-title="BaGu" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/09/01/BaGu/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/09/01/BaGu/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>100k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:30</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><em><strong>路漫漫其修远兮，吾将上下而求索</strong></em></p>
<p>加油，享受学习，享受知识！</p>
<span id="more"></span>

<p>在开发者工具的设置里面禁用了JavaScript，这样小林coding就可以复制了，后面最好改回来，否则可能有问题【好像也会自动改回来】。<br><img src="/BaGu/2.png"></p>
<h1 id="谷粒商城"><a href="#谷粒商城" class="headerlink" title="谷粒商城"></a>谷粒商城</h1><h2 id="前端学一点"><a href="#前端学一点" class="headerlink" title="前端学一点"></a>前端学一点</h2><p>shift + ! 回车得到html模板</p>
<p>shift + alt +f 整理代码Refractor</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li><p>java 编译版本高于运行版本，我要用java8，所以首先需要配置项目所用的jdk和java compile 那里，然后查看springboot 和 springcloud版本，注意版本对应，就是没注意到springcloud，所以要好好看报错。</p>

</li>
<li><p>lombok版本，出现很奇怪的报错的话就是lombok版本的原因，尽量选择最高版本的30，但是有一次选择了也没用，当时尝试勾选了</p>
 use compiler from module target.. 解决了问题，但是后面再取消勾选也还是可以，所以很奇怪，这个选项可能与（使用指定的jdk或上次使用的jdk）有关。
</li>
<li><p>nacos本地启动然后注册服务，一直注册失败，地址什么的配置都没问题，重启nacos就行了。<br>另外看了一篇文章就在地址配置那里翻车了，因为配置name那里没注意前缀，所以编码无小事。</p>
</li>
<li><p>nacos不再使用ribbon，改用<strong>spring-cloud-loadbalancer依赖</strong>，所以需要导入该依赖，否则远程调用feign无法启动。</p>
</li>
<li><p>nacos配置中心<br>需要用 bootstrap.properties 或 bootstrap.yml 配置文件才行，这个文件优先级比 application.yml 更高，通过这个配置文件建立应用与nacos上的配置之间的联系。</p>
</li>
</ol>
<p>注意<strong>在nacos上的配置文件</strong>的data id是有讲究的，就是前缀prefix加我们激活的application配置文件(之前学过的，可以指定active哪个文件，不指定就没有)加文件的扩展名(默认properties，用yaml要指定，注意只能是yaml不能是yml)。<br><code>$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">friendmall-coupon</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment"># 默认前缀本就是$&#123;spring.application.name&#125;</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">        <span class="comment"># 默认配置文件扩展名为properties</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="comment"># 默认名空间为public</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">public</span>  <span class="comment"># 用其他的要写id才行</span></span><br><span class="line">        <span class="comment"># 默认组为DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br></pre></td></tr></table></figure>

<p>首先需要导入 <strong>spring-cloud-starter-bootstrap 依赖</strong>，因为我无法解析bootstrap.yml 这个配置文件，控制台输出没有显示 located 到某一个配置文件。<br>之后定位到了 <code>[BootstrapPropertySource &#123;name=&#39;bootstrapProperties-friendmall-coupon.yaml,DEFAULT_GROUP&#39;&#125;</code> ，注意这个是可以的。<br>但是依然没法动态刷新数据，搞了半天都不行，结果又是nacos的原因，重启nacos就可以了。</p>
<p>连续在nacos上翻两次车，如果都配置都正确了请重启nacos。</p>
<ol start="6">
<li><p>将项目的版本更新的和教程的一样<br>不然老会遇到新问题，比如网关解决跨域问题时对预检请求处理不成功就是因为springboot2.4之后进行了修改，将addAllowedOrigin函数改为addAllowedOriginPattern，为了之后遇到更多问题，把版本改了吧。之后添加module的时候也要注意jdk版本，java版本都要设置，以及有时候依赖的版本也要设置。</p>

<p>关于lombok的依赖，lombok在jdk21之后要设为1.18.30，common下的都是1.18.8。由于IDEA的原因，新建spring module的时候不能建jdk8的module，所以有时候只改了其他时，上图的依赖会对应于jdk21，此时就会出现lombok的那个经典报错。添加lombok的时候版本随便设也没关系，maven会调成真正需要的。</p>
</li>
<li><p>nacos登录不上<br>原先用nacos1.42，上面换版本后也换成nacos1.14结果nacos&#x2F;nacos登录不上，原因是nacos的缓存造成的。<br>解决：浏览器f12网络面板，勾选禁用缓存，然后刷新<br><a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/issues/2394">nacos账号密码错误</a></p>
</li>
<li><p>NoClassDefFoundError: org&#x2F;springframework&#x2F;boot&#x2F;context&#x2F;properties&#x2F;ConfigurationBeanFactoryMetadata<br>nacos版本和springboot版本不兼容，在spring boot 2.4之后删掉了ConfigurationBeanFactoryMetadata，renrenfast里面是2.66的springboot，我给降了。</p>
</li>
<li><p>降版本带来的问题<br>不知道是不是因为springboot版本降低，mybatis的数据库连接池连不上了，原因在于ssl认证那块，在 application.yml 的url里面加上 <code>?useSSL=false</code> ，比如 <code>url: jdbc:mysql://192.168.56.10:3306/friendmall_pms?useSSL=false</code>，在数据库连接里面不用设置也行。<br>参考这篇文章，虽然没讲为什么。<a target="_blank" rel="noopener" href="https://blog.csdn.net/ayunnuo/article/details/120269377">idea连接mysql报错： No appropriate protocol (protocol is disabled or cipher suites are inappropriate</a></p>
</li>
<li><p>p79里面销售属性里里面不显示快速展示按钮，应该没什么影响，弹幕4:50有人提解决方案 我没改 这俩文件在&#x2F;modules&#x2F;product里</p>


</li>
<li><p>p83 由于前端缺少pubsub-js出现的问题<br>前端的问题多看看评论区</p>
</li>
</ol>
<p>npm install –save pubsub-js又失败了，因为node版本的问题，尝试了<br><code>npm install pubsub-js --legacy-peer-deps</code>  成功了</p>
<ol start="12">
<li>端口占用<br>查看被占用端口对应的 PID<br><code>netstat -aon|findstr &quot;8000&quot;</code></li>
</ol>
<p>查看指定 PID 对应的进程<br><code>tasklist|findstr &quot;9088&quot;</code></p>
<p>结束进程<br>强制（&#x2F;F参数）杀死 pid 为 9088 的所有进程包括子进程（&#x2F;T参数）：<br><code>taskkill /T /F /PID 9088 </code></p>
<p>酷狗音乐老是占8000端口号</p>
<ol start="13">
<li>openfeign调用时出现问题<br>如果是超时引起，加：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 配置 feign 默认请求时间仅几秒钟，配置请求时间长一些(毫秒)</span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: <span class="number">60000</span></span><br><span class="line">  ConnectTimeout: <span class="number">60000</span></span><br></pre></td></tr></table></figure>
后面遇到了其他原因，业务是product调用coupon，再调用方看到了<code>feign.FeignException: status 500 reading</code>，方法中的异常比如除零异常等,都会通过feign.FeignException: status 500 reading…的方式给予你提示。如果检查feign的注册信息有没有写错,比如少一个斜杠什么之类的等之类发现没问题，可以去被调用方那里看看报错，我发现数据库又连接不上了，果然又是如9.所言<code>?useSSL=false</code> 的问题，因为coupon查自己的数据库又不行，加上就可以了</li>
</ol>
<p>用的renrenfastvue是D&#x2F;programfile下面的</p>
<ol start="14">
<li>easyvpn占用10000端口且无法关闭<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46709007/article/details/125140872">端口占用问题，10000端口</a></li>
</ol>
<p>进服务进程 services.msc 手动关</p>


<ol start="15">
<li>理解分页<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;SpuInfoEntity&gt; page = <span class="built_in">this</span>.page(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Query</span>&lt;SpuInfoEntity&gt;().getPage(params),</span><br><span class="line">                wrapper</span><br><span class="line">        );</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageUtils</span>(page) </span><br><span class="line"><span class="keyword">return</span> R.ok().put(<span class="string">&quot;page&quot;</span>, page)</span><br></pre></td></tr></table></figure>
这些都是分页插件带来的方法，this.page有两个参数，第一个是IPage对象，是分页参数如page、limit等 前端传来的参数，第二个为Querywrapper对象，是查询条件，泛型是查询的实体类。最终返回实体类的分页查询结果IPage&lt;实体类&gt; page。</li>
</ol>
<p>return new PageUtils(page)  PageUtils(IPage&lt;实体类&gt; page)用PageUtils封装上一步的page生成标准的分页查询结果集PageUtils对象 page。</p>
<p>return R.ok().put(“page”, page) 在返回结果中将这个PageUtils对象 page 放到结果集中R.ok()中</p>
<ol start="16">
<li>docker yum配置源</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhouho/p/13410306.html">&#x2F;etc&#x2F;yum.repos.d是什么？</a></p>
<p>教程里的163的yum源没法使用，会报错，改用aliyun的源</p>
<p>vagrant用无界面启动就好，用vagrant up启动有可能用默认的网络设置覆盖我们之前的设置。<br><code>curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</code></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN2497242041/article/details/130106331?spm=1001.2014.3001.5506">[Centos7 yum源报错] repodata&#x2F;repomd.xml: [Errno 14] HTTP Error 404 - Not Found 解决方案</a></p>
<ol start="17">
<li>使用Vagrant 后发现虚拟机磁盘空间爆满，无法更新yum源</li>
</ol>
<p>df -h 查看磁盘空间状态</p>
<p>这不是docker的问题，而是虚拟机的问题，虚拟机将vagrantfile所在文件夹的内容拷贝到虚拟机里面到了，导致空间爆满，血泪填坑。刚开始以为是docker的问题，网上一直说是日志什么的，清理来清理去都没用，仔细发现是虚拟机爆满了，是可以在虚拟机里看到一些windows里的文件夹，所以就是东西被拷贝进去了。<br><a target="_blank" rel="noopener" href="https://bbs.sangfor.com.cn/forum.php?mod=viewthread&tid=122659">使用Vagrant 后发现虚拟机磁盘空间爆满的血泪填坑记</a> 这篇文章讲的很好，基本就是我的心路历程。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010398484/article/details/118736617">解决Vagrant 创建的虚拟机磁盘爆满问题</a> 有分析磁盘爆满原因</p>
<p>我们通过启动vagrant up命令，可以看到有这么一句：Rsyncing folder: &#x2F;cygdrive&#x2F;d&#x2F;MyData&#x2F;用户&#x2F; &#x3D;&gt; &#x2F;vagrant<br>这是要将vagrantfile所在的目录下的数据都复制到vagrant下，这就是虚拟机磁盘爆满的根本原因。<br>现在需要将这个目录转换成一个空目录，以后每次启动就不会同步数据到虚拟机了。</p>
<ol start="18">
<li>docker常用命令</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker images 当前安装了哪些镜像（由镜像生成对应的一个个的容器就可以使用了）</span><br><span class="line"></span><br><span class="line">docker ps -a 查看所有的容器（可能没启动）</span><br><span class="line"></span><br><span class="line">docker ps 查看正在运行的容器</span><br><span class="line"></span><br><span class="line">docker update redis --restart=always 设置容器开机自启动</span><br><span class="line"></span><br><span class="line">docker restart mysql 重启容器 （这里的mysql都可以用容器Id来代替）</span><br><span class="line"></span><br><span class="line">docker stop mysql 停掉容器</span><br><span class="line"></span><br><span class="line">docker rm mysql 移除容器</span><br><span class="line"></span><br><span class="line">docker logs nginx 看容器启动日志</span><br></pre></td></tr></table></figure>

<p>以mysql容器为例，mysql容器其实就是一个完整的 mysql 的运行环境，也就是说可以进入容器内部，里面是一个装了mysql的linux环境。<br>比如进入mysql容器内部：（-it表示以交互模式 &#x2F;bin&#x2F;bash表示进入linux的bash控制台）<br>docker exec -it mysql &#x2F;bin&#x2F;bash<br>docker exec -it redis redis-cli  &#x2F;&#x2F; 进 redis client<br>这样就进入到了容器内部，不是在虚拟机vagrant里面了。<br>所以我们也就需要将端口进行映射以及一些文件挂载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p <span class="number">3306</span>:<span class="number">3306</span> --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/<span class="keyword">var</span>/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/<span class="keyword">var</span>/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure>
<p>端口映射：比如容器的3306端口映射出来到虚拟机linux的3306端口，方便访问。<br>文件夹挂载：在mysql容器里面有一些文件夹里面放的是mysql的配置文件，我们把这些文件夹挂载到外部虚拟机的一些文件夹，这样以后直接改这些文件夹就能配置mysql，而不用每次都跑容器里面去配置。</p>
<p>exit  退出容器内部</p>
<p>free -m  看虚拟机内存</p>
<ol start="19">
<li><p>有时候前端数据没有响应数据库的更改</p>
<p>ctrl+F5 更新浏览器缓存 联想再加Fn</p>
</li>
</ol>
<p>这个缓存真恶心啊，有时候会怀疑自己是否哪里弄错了。<br>直接禁用：开发者工具  Disable cache ，有时候最好再确认下，可能失效</p>
<ol start="20">
<li><p>ctrl+H 相当于hierarchy，可以看接口的实现</p>
</li>
<li><p>p187 188 189 直接抄前端了</p>
</li>
<li><p>k8s配置太难了<br>10.0.2.5 k8s-node1<br>10.0.2.15 k8s-node2<br>10.0.2.4 k8s-node3</p>
</li>
<li><p>更新yum的下载源<br>其实yum换源就是把&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo备份之后删除(mv)，然后下载新的源curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/repo/Centos-7.repo%E3%80%82%E6%9C%80%E5%90%8Eyum">http://mirrors.aliyun.com/repo/Centos-7.repo。最后yum</a> clean all yum makecache。<br>docker镜像换源是另外的，这样做：<br>指定Docker镜像源下载地址为阿里云镜像仓库：<br>yum-config-manager –add-repo <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p>
</li>
<li><p>docker拉镜像太容易拉不下来了<br>docker的镜像源一定一定要用这个，不然每次都要被气的吐血</p>
</li>
</ol>
<p>vi &#x2F;etc&#x2F;docker&#x2F;daemon.json<br>{<br>  “registry-mirrors”: [<br>        “<a target="_blank" rel="noopener" href="https://sysxm1uh.mirror.aliyuncs.com&quot;/">https://sysxm1uh.mirror.aliyuncs.com&quot;</a>,<br>        “<a target="_blank" rel="noopener" href="https://docker.m.daocloud.io&quot;/">https://docker.m.daocloud.io&quot;</a>,<br>        “<a target="_blank" rel="noopener" href="https://dockerproxy.com&quot;/">https://dockerproxy.com&quot;</a>,<br>        “<a target="_blank" rel="noopener" href="https://docker.mirrors.ustc.edu.cn&quot;/">https://docker.mirrors.ustc.edu.cn&quot;</a>,<br>        “<a target="_blank" rel="noopener" href="https://docker.nju.edu.cn&quot;/">https://docker.nju.edu.cn&quot;</a><br>    ]<br>}<br>systemctl daemon-reload<br>systemctl restart docker</p>
<ol start="25">
<li><p>k8s flannel网络配置不行<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Harry_mumu/article/details/132099876">https://blog.csdn.net/Harry_mumu/article/details/132099876</a> 这篇文章讲的很好</p>
</li>
<li><p>大部分镜像都能拉下来，但是有的镜像偏偏不行<br>比如 siriuszg&#x2F;nginx-ingress-controller:0.20.0 一直拉不下来，最后换了一个镜像可以用，在<a target="_blank" rel="noopener" href="https://quay.io/repository/kubernetes-ingress-controller/nginx-ingress-controller?tab=tags&tag=latest">quay.io</a>。<br>k8s.gcr.io，gcr.io 是谷歌的镜像仓库，国内访问不了， quay.io 是 RedHat 的镜像仓库</p>
</li>
</ol>
<p>备用方案：实在不行就尝试建一个自己的私人库，把镜像下载进来放进去，也就是自建镜像加速服务。（自 2024-06-06 开始，国内的 Docker Hub 镜像加速器相继停止服务，可选择为 Docker daemon 配置代理或自建镜像加速服务。）</p>
<p>备注：kubectl apply -f xxx.yaml失败时可以用 kubectl delete -f xxx.yaml回滚。</p>
<p>感谢这篇文章，看了这个我才换到了能用的镜像源 (<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hailun1987/p/14162278.html">https://www.cnblogs.com/hailun1987/p/14162278.html</a>)</p>
<p>k8s拉取镜像失败ImagePullBackOff 先看docker能不能拉下来，不能就是docker的原因，如果能再去排查k8s。<br>可以看看这篇(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45439217/article/details/123477846">https://blog.csdn.net/qq_45439217/article/details/123477846</a>)</p>
<p>kubectl delete -f kubesphere-mini.yaml</p>
<h1 id="商城细节"><a href="#商城细节" class="headerlink" title="商城细节"></a>商城细节</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>每张表都有undo_log seata回滚要用的表。</p>
<p>会设计一些冗余字段减少查表次数（也可能前端还需要回显sku信息）。</p>
<h3 id="库存库-wms"><a href="#库存库-wms" class="headerlink" title="库存库 wms"></a>库存库 wms</h3><p><strong>对应后台管理系统的库存系统。</strong></p>
<p><strong>wms_purchase</strong> 采购单：采购人员，时间，采购量和采购结果，放到哪个仓库（仓库号）</p>
<p><strong>wms_purchase_detail</strong> 采购单的详情：采了哪些sku及其信息，采购单的一些冗余字段比如仓库号。</p>
<p><strong>wms_ware_info</strong> 仓库基本信息（地址）</p>
<p><strong>wms_ware_sku</strong> 每个sku在每个仓库的存货量，锁库存也在这，通过库存量减锁定量判断是否有货。</p>
<p><strong>wms_ware_order_task</strong> 库存订单任务单：首先是订单基本信息（order_id，order_sn，收货人电话地址），任务单状态（成功失败？），仓库号（表明在哪个仓库完成这个订单）</p>
<p><strong>wms_ware_order_task_detail</strong> 库存订单任务单详情： 某任务单（task_id）在某仓库锁了多少库存，有一个锁定状态（lock_status）</p>
<h3 id="订单库-oms"><a href="#订单库-oms" class="headerlink" title="订单库 oms"></a>订单库 oms</h3><p>（原来order_id一直没用，一直都是用的 order_sn）</p>
<p><strong>mq_message</strong> 消息队列的消息入库：交换机，路由键，类型，消息状态（新建、已发送、错误、抵达），时间</p>
<p><strong>oms_order</strong> 订单：会员信息（member），订单号（order_sn），金额信息（订单金额减各种优惠抵扣得到支付金额），订单状态（待付款、已付款、已取消），收货人信息</p>
<p><strong>oms_order_item</strong> 订单项信息：订单号（order_sn），商品的skuspu信息，商品购买数量</p>
<p><strong>oms_payment_info</strong> 支付信息表：订单号（对外业务号），支付宝交易流水号（alipay_trade_no），支付金额，支付状态，创建时间和回调时间及内容</p>
<h3 id="商品库-pms"><a href="#商品库-pms" class="headerlink" title="商品库 pms"></a>商品库 pms</h3><p><strong>对应后台管理系统的商品系统。</strong></p>
<p><strong>大部分都是后台管理系统要用到的。</strong><br><strong>spu</strong>是某个商品型号，它属于某个<strong>品牌</strong>（华为），属于某个<strong>分类</strong>（手机），比如	华为 HUAWEI Mate 30 Pro，它有很多<strong>规格参数</strong>比入网型号、机身颜色(理论上这个是销售属性，不过无所谓)、机身长度、CPU品牌、CPU型号，它下面有很多<strong>sku</strong>，比如白色的8+128的版本，黑色的12+256的版本，这几个都是sku，而这些与商品价格相关的叫做<strong>销售属性</strong>。</p>
<p><strong>pms_attr</strong> 属性表：属性id，属性名，属性可选值，是哪个分类的商品具有的属性<br><strong>pms_attr_group</strong> 属性组：属性组名，是哪个分类的商品具有的属性组<br><strong>pms_attr_attrgroup_relation</strong> 哪些属性在哪个属性组：将某些属性分到一个属性组下。<br>结合以上三个比如（手机类有主体、基本信息、屏幕三个属性组，而基本信息组有机身颜色、材质、工艺三个属性）<br><strong>pms_product_attr_value</strong> spu属性值：各个spu都有哪些属性（规格参数）<br><strong>pms_sku_sale_attr_value</strong> sku销售属性值：各个sku都有哪些属性</p>
<p><strong>pms_brand</strong> 品牌信息<br><strong>pms_category</strong> 商品的三级分类：自身所属分类的id，父类id，是第几级分类，<br><strong>pms_category_brand_relation</strong> 某品牌有哪些类别的商品（如华为有手机笔记本耳机）</p>
<p><strong>pms_sku_info</strong> sku信息：属于哪个spu，sku名字，分类、品牌，图片，标题子标题，价格</p>
<p><strong>pms_spu_info</strong>：某品牌、某商品类别下有哪些spu（名字和描述）（如华为的手机商品类有哪些spu）<br><strong>pms_spu_info_desc</strong>：该spu的一系列描述图片</p>
<p><strong>pms_sku_images</strong> sku图片：oss链接<br><strong>pms_spu_images</strong> spu图片：oss链接</p>
<h3 id="会员库-ums"><a href="#会员库-ums" class="headerlink" title="会员库 ums"></a>会员库 ums</h3><p><strong>对应后台管理系统的用户系统。</strong></p>
<p><strong>ums_member</strong> 会员表：会员信息（名称、手机、邮箱等），社交用户的唯一id（social_uid），访问令牌（access_token），令牌过期时间</p>
<p><strong>ums_member_level</strong> 会员等级（铜牌、银牌、金牌会员，与折扣、运费相关）</p>
<p><strong>ums_member_receive_addres</strong> 会员收件人信息</p>
<h3 id="秒杀表-sms"><a href="#秒杀表-sms" class="headerlink" title="秒杀表 sms"></a>秒杀表 sms</h3><p><strong>sms_seckill_session</strong>  秒杀活动场次：场次id，名称，每日开始和结束时间</p>
<p><strong>sms_seckill_sku_relation</strong> 秒杀活动关联的商品：秒杀场次id，哪些sku参与这场秒杀，秒杀价格、可秒杀总量、每人限购量</p>
<p><strong>sms_member_price</strong> 某sku的会员等级价<br><strong>sms_sku_full_reduction</strong>  某sku的满多少钱减多少钱<br><strong>sms_sku_ladder</strong> 某sku的满几件打折<br><strong>sms_spu_bounds</strong> 给多少积分</p>
<h2 id="全局异常信息"><a href="#全局异常信息" class="headerlink" title="全局异常信息"></a>全局异常信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码和错误信息定义类</span></span><br><span class="line"><span class="comment"> * 1. 错误码定义规则为5位数字</span></span><br><span class="line"><span class="comment"> * 2. 前两位表示业务场景，最后三位表示错误码。例如：10001。10:通用001:系统未知</span></span><br><span class="line"><span class="comment"> 异常</span></span><br><span class="line"><span class="comment"> * 3. 维护错误码后需要维护错误描述，将他们定义为枚举形式</span></span><br><span class="line"><span class="comment"> * 错误码列表：</span></span><br><span class="line"><span class="comment"> * 10: 通用</span></span><br><span class="line"><span class="comment"> *     001：参数格式校验</span></span><br><span class="line"><span class="comment"> *     002：短信验证码频率太高</span></span><br><span class="line"><span class="comment"> *     003：请求流量过大被限流</span></span><br><span class="line"><span class="comment"> * 11: 商品</span></span><br><span class="line"><span class="comment"> * 12: 订单</span></span><br><span class="line"><span class="comment"> * 13: 购物车</span></span><br><span class="line"><span class="comment"> * 14: 物流</span></span><br><span class="line"><span class="comment"> * 15：用户</span></span><br><span class="line"><span class="comment"> * 21：库存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BizCodeEnum</span> &#123;</span><br><span class="line">    UNKNOW_EXCEPTION(<span class="number">10000</span>,<span class="string">&quot;系统未知异常&quot;</span>), <span class="comment">// 这里是 逗号</span></span><br><span class="line">    VALID_EXCEPTION(<span class="number">10001</span>,<span class="string">&quot;参数格式校验失败&quot;</span>),</span><br><span class="line">    SMS_CODE_EXCEPTION(<span class="number">10002</span>,<span class="string">&quot;验证码获取频率太高，稍后再试&quot;</span>),</span><br><span class="line">    TOO_MANY_REQUEST(<span class="number">10003</span>,<span class="string">&quot;请求流量过大&quot;</span>),</span><br><span class="line">    PRODUCT_UP_EXCEPTION(<span class="number">11000</span>,<span class="string">&quot;商品上架异常&quot;</span>),</span><br><span class="line">    USER_EXIST_EXCEPTION(<span class="number">15001</span>,<span class="string">&quot;用户存在&quot;</span>),</span><br><span class="line">    PHONE_EXIST_EXCEPTION(<span class="number">15002</span>,<span class="string">&quot;手机号存在&quot;</span>),</span><br><span class="line">    NO_STOCK_EXCEPTION(<span class="number">21000</span>, <span class="string">&quot;商品库存不足&quot;</span>),</span><br><span class="line">    LOGINACCT_PASSWORD_INVALID_EXCEPTION(<span class="number">15003</span>,<span class="string">&quot;账号或密码错误&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型最大的特点就是它是一个私有构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BizCodeEnum(<span class="type">int</span> code, String msg)&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="用过的key、数据结构"><a href="#用过的key、数据结构" class="headerlink" title="用过的key、数据结构"></a>用过的key、数据结构</h3><h3 id="用法（session，分布式锁，幂等性）"><a href="#用法（session，分布式锁，幂等性）" class="headerlink" title="用法（session，分布式锁，幂等性）"></a>用法（session，分布式锁，幂等性）</h3><h3 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有对Redisson的使用都通过RedissonClient对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(destroyMethod=&quot;shutdown&quot;)</span></span><br><span class="line">    RedissonClient <span class="title function_">redisson</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 注意redis://</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.56.10:6379&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 根据Config创建出RedissonClient实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RLock lock &#x3D; redissonClient.getLock(“CatalogJson-Lock”);<br>        lock.lock(); &#x2F;&#x2F; 获取锁并启动看门狗机制，默认锁超时30秒，看门狗线程会每隔10秒进行续期<br>Redisson 客户端实例在创建时，会默认开启一个后台看门狗线程，用于定期发送 “PING” 命令给 Redis 服务器来保持连接的活跃性。如果前述 “看门狗” 线程指向的 Redisson 客户端实例失效，Redis 服务器在发现一段时间内没有收到客户端的 “PING” 命令后，会自动释放该客户端持有的所有锁资源。<br>这个看门狗线程是存在于客户端实例的，如果客户端宕机了自然没办法发ping命令给redis来延长ttl。</p>
<h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><p>Jdk 的两个小工具jconsole、jvisualvm（升级版的jconsole）;通过命令行启动，可监控本地和远程应用。可以看gc、eden、s0、s1、老年代、元空间占用</p>
<p>jmeter进行压力测试</p>
<p>50线程循环5次<br>测试 </p>
<table>
<thead>
<tr>
<th>请求路径</th>
<th>吞吐量</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://search.friendmall.com/list.html?catalog3Id=225">http://search.friendmall.com/list.html?catalog3Id=225</a></td>
<td>7.2</td>
</tr>
<tr>
<td>商品服务item.friendmall.com&#x2F;33.html</td>
<td>8.5</td>
</tr>
</tbody></table>
<h2 id="定时任务-秒杀商品上架"><a href="#定时任务-秒杀商品上架" class="headerlink" title="定时任务 秒杀商品上架"></a>定时任务 秒杀商品上架</h2><p>@EnableAsync 定时任务不应该阻塞，意思是有一个定时任务超时了也不应该阻塞其他的定时任务，但默认是阻塞的。<br>@EnableScheduling<br>写在配置类ScheduledConfig上</p>
<p>@Async所以让定时任务异步执行<br>@Scheduled(cron &#x3D; “* * 3 * * ?”)  &#x2F;&#x2F; 秒分时日月周年(Spring 没有)，且日和周必须不能同时指定，可以使用？来表示其中一个<br>每天凌晨三点上架最近三天需要秒杀的商品<br>写在任务方法uploadSeckillSkuLatest3Days()上</p>
<p>private final String upload_lock &#x3D; “seckill:upload:lock”;  分布式锁</p>
<p>分布式下防止重复上架（分布式锁 + 幂等性处理）两步才能达到<strong>分布式下的幂等</strong><br>1、多台机器的分布式锁【注意，就算代码里已经有幂等性判断了，这个分布式锁也一定要有，如果没分布式锁，假如两台机器同时进来，同时到redis判断键是否存在那里(前一个还没把键设置进去，另一个看诶还没有这键也跟着执行了)，二者同时执行了代码相当于幂等失败了，所以这锁很重要】所以要保证同一时刻只有一台机器执行这段代码，业务完成后更新状态并把状态持久化住，这样别人就无法获得我的中间状态，结合下面的2、才能达到幂等；<br>2、判断那个关键 key 是否已经存在于redis了，key要根据业务决策出一个合理值；（只有这步则只能判断单机的幂等）</p>
<p>private final String SESSION__CACHE_PREFIX &#x3D; “seckill:sessions:”;<br>    private final String SECKILL_CACHE_PREFIX &#x3D; “seckill:skus”;<br>    private final String SKU_STOCK_SEMAPHORE &#x3D; “seckill:stock:”;    &#x2F;&#x2F;+商品随机码(秒杀时间段内点商品发请求时才会带上这个随机码)</p>
<p>&#x2F;&#x2F; 1、缓存活动信息：<br>saveSessionInfos(sessionData);<br>key &#x3D; “seckill:sessions:” + startTime + “<em>“ + endTime;  list的名字<br>这个场次关联的所有sku都会以“场次id”+”</em>“+item.getSkuId()的形式放入这个list。</p>
<p>&#x2F;&#x2F; 2、缓存活动的关联商品信息（表示当前所有的秒杀活动涉及到的所有sku）<br>saveSessionSkuInfos(sessionData);<br>一个hash结构  “seckill:skus” 这个就是hash表的名字。<br>每个商品生成随机码token，秒杀开始的时候带上才能参与秒杀。保存这个sku，以“秒杀场次_skuId”为键(field)（因为不同场次会上架统一sku），一个TO(包含sku基本信息，随机码token，以及秒杀场次信息)为value的形式保存在hash表中</p>
<p>&#x2F;&#x2F; 3、上架商品库存信息<br>RSemaphore semaphore &#x3D; redissonClient.getSemaphore(“seckill:stock:” + token);  &#x2F;&#x2F; 这个分布式锁是一个String，这个就是锁名(因为token是商品独一无二的，所以锁就可以当作这个场次的sku)，值当然就是这个sku的可秒杀量(区别于这个sku的库存)。<br>semaphore.trySetPermits(seckillSkuVo.getSeckillCount());  &#x2F;&#x2F; 设置信号量的值</p>
<p>前端查询秒杀商品信息，定义资源保护<br>@SentinelResource(value &#x3D; “getCurrentSeckillSkusResource”, blockHandler &#x3D; “blockHandler”)<br>加在方法上。blockHandler 在原方法被限流&#x2F;降级时调用<br>blockHandler(BlockException e) {<br>        log.error(“getCurrentSeckillSkusResource被限流了…”);<br>        return null;<br>    }</p>
<p>对代码段流控<br>try (Entry entry &#x3D; SphU.entry(“seckillSkus”))<br>catch (BlockException e) {<br>    log.error(“资源被限流{}”,e.getMessage());<br>}<br>定义一段受保护的资源，从而可以执行流控熔断限流等策略，当被限流时就抛出异常 BlockException。</p>
<h2 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h2><ul>
<li>2、秒杀业务</li>
<li>使用另一套流程，不走原先购物车订单支付那个流程</li>
<li>而是先由秒杀服务快速创建一个订单号(String)，然后全放到消息队列里，订单服务监听队列慢慢处理。</li>
<li>这个消息队列能起到很强的削峰的效果，并且会达到最终一致性</li>
<li>secKill {<br>String orderSn &#x3D; seckillService.kill(killId, key, num); 场次id_skuid、商品token、秒杀量<br>model.addAttribute(“orderSn”, orderSn);<br>}<br>seckillService.kill(killId, key, num) {<br>&#x2F;&#x2F; 前端传来的随机码和skuId要匹配redis里面存的对应的随机码、skuId<br>if (randomCode.equals(key) &amp;&amp; killId.equals(skuId))<br>&#x2F;&#x2F; 3、验证购物数量是否合理<br>if (num &lt;&#x3D; redisTo.getSeckillLimit())<br>&#x2F;&#x2F; 4、一人一单！验证这个人是否购买过了【幂等性字段】：只要准备购买了就去redis占位：<strong>userId_sessionId_skuId</strong>，标志这个人买过了这个东西且买了这么几件(String的值)<br>Boolean ifAbsent &#x3D; redisTemplate.opsForValue().setIfAbsent(redisUserKey, num.toString(), ttl, TimeUnit.MILLISECONDS);<br>&#x2F;&#x2F; 占位成功，说明之前没买过，允许买<br>RSemaphore semaphore &#x3D; redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + randomCode);<br>&#x2F;&#x2F; 一定用tryAcquire不用acqueire，因为acquire没拿到信号量会一直在那阻塞等<br>                  boolean b &#x3D; semaphore.tryAcquire(num);<br>if (b)<br>&#x2F;&#x2F; 秒杀成功，快速下单，给MQ发个消息【订单号】<br>String orderSn &#x3D; IdWorker.getTimeId(); 高效GUID产生算法，基于Snowflake实现64位自增ID算法。 getTimeId()可用于商品订单<br>&#x2F;&#x2F; 发给消息队列<br>rabbitTemplate.convertAndSend(“order-event-exchange”, “order.seckill.order”, orderTo);</li>
</ul>
<p>}</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>配置文件<br>  rabbitmq:<br>    host: 192.168.56.10<br>    port: 5672<br>    virtual-host: &#x2F;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RabbitTemplate <span class="title function_">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>(connectionFactory);</span><br><span class="line">        rabbitTemplate.setMessageConverter(jsonMessageConverter());</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用JSON序列化机制进行消息序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="登录拦截器"><a href="#登录拦截器" class="headerlink" title="登录拦截器"></a>登录拦截器</h2><p>session里面有个属性Attribute叫AuthServerConstant.LOGIN_USER(“login_user”)，它的值就是登录用户的信息(实体)，所谓的拦截器就是拦截请求，然后去看session有没有这个用户实体，有的话拿过来设置到ThreadLocal(因为每个请求从拦截器到controller到service到dao都是一个线程，每个请求都拦截下来然后在这个线程的threadlocal里设置用户信息，所以每个方法都能在threadlocal里拿到属于自己线程的登录用户)里面，没有的话说明没登录，重定向到登录页。很明显session里面的这个属性是登录的时候放进去的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整个订单都要求在登录环境下进行，所以要一个拦截器拦截未登录用户，拦截器都要实现 HandlerInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;MemberRespVo&gt; loginUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  远程调用这个路径/order/order/status/&#123;orderSn&#125;的服务就不拦截了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();  <span class="comment">// url还会加上整个服务器的地址名，URI就是请求后面的那串路径这里就是/order/order/status/&#123;orderSn&#125;</span></span><br><span class="line">        <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> antPathMatcher.match(<span class="string">&quot;/kill&quot;</span>, uri);  <span class="comment">// 只对kill这种路径进行登录拦截，其他放行，因为有的会远程调用秒杀服务查东西</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">            <span class="type">MemberRespVo</span> <span class="variable">attribute</span> <span class="operator">=</span> (MemberRespVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER);</span><br><span class="line">            <span class="keyword">if</span> (attribute != <span class="literal">null</span>) &#123;</span><br><span class="line">                loginUser.set(attribute);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没登录，重定向到登录页面去登录</span></span><br><span class="line">                <span class="comment">// 在 session 里面放一个消息提示一下</span></span><br><span class="line">                request.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;请先进行登录&quot;</span>);</span><br><span class="line">                response.sendRedirect(<span class="string">&quot;http://auth.friendmall.com/login.html&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个拦截器要用在一个配置类里，配置类实现WebMvcConfigurer，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LoginUserInterceptor loginUserInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加上我们自己创建的拦截器：LoginUserInterceptor，.addPathPatterns(&quot;/**&quot;)表示拦截这个服务下的/下的所有请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginUserInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addPathPatterns(“&#x2F;**”)表示拦截这个服务下的&#x2F;所有请求，拦截下来之后调用preHandle方法看是要放行还是重定向去登录。</p>
<p><strong>前端就能登录拦截</strong>：var isLogin &#x3D; [[${session.loginUser!&#x3D;null}]];  &#x2F;&#x2F; true登录了<br>在 Thymeleaf 中，使用 ${} 表示是 EL 表达式，它可以直接访问当前 session 、 request 和 application 作用域中的属性。因此，对于你的示例 [[${session.loginUser!&#x3D;null}]];，它会直接获取当前会话（session）中是否存在名为 loginUser 的属性。<strong>同样是去看session里面有没有那个属性</strong>。</p>
<h3 id="session-跨域"><a href="#session-跨域" class="headerlink" title="session 跨域"></a>session 跨域</h3><p>session 的配置类<br>设置cookie<br>serializer.setCookieName(“FRIENDSESSION”);<br>serializer.setDomainName(“friendmall.com”);</p>
<p>配置文件：<br>  session:<br>    store-type: redis</p>
<p>在redis中存为HASH，键为：spring:session:sessions:bac52bd8-e8f8-46fb-bc6a-d4ae814e4b87</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriendmallSessionConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 设置作用域为父域</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CookieSerializer <span class="title function_">cookieSerializer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultCookieSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultCookieSerializer</span>();</span><br><span class="line">        serializer.setCookieName(<span class="string">&quot;FRIENDSESSION&quot;</span>);</span><br><span class="line">        serializer.setDomainName(<span class="string">&quot;friendmall.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化对象为json存到redis</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title function_">springSessionDefaultRedisSerializer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h3><p>Spring Security是一个广泛的安全框架（身份验证），能够满足应用程序内多种复杂的安全需求。<br>OAuth2是一个授权协议，主要用于资源授权而非身份验证，但在 Spring Security 的集成下，也可用于支持权限管理。</p>
<img src="/2024/09/01/BaGu/15.png" class="">
<p>应用回调地址是授权成功后重定向的地址。<br>应用主页是授权失败重定向的地址。</p>
<p>流程：<br>1、引导用户到如下地址<br>2、用户同意授权，页面跳转至<br>3、使用返回的code，换取access token<br>4、使用AccessToken 调用开发API 获取用户信息</p>
<h2 id="sentinel-进行流控"><a href="#sentinel-进行流控" class="headerlink" title="sentinel 进行流控"></a>sentinel 进行流控</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriendmallSentinelConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义限流时返回数据（流控相应），比如你请求QPS太高前端返回的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriendmallSentinelConfig</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        WebCallbackManager.setUrlBlockHandler(<span class="keyword">new</span> <span class="title class_">UrlBlockHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blocked</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException ex)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">R</span> <span class="variable">error</span> <span class="operator">=</span> R.error(TOO_MANY_REQUEST.getCode(), TOO_MANY_REQUEST.getMsg());</span><br><span class="line">                response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">                response.getWriter().write(JSON.toJSONString(error));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sleuth+Zipkin 服务链路追踪</p>
<h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80.md#14-%E9%80%92%E5%BD%92%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">网关配置跨域</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80.md#2%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%B5%81">文件上传oss</a><br>服务端签名后直传</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80.md#18-jsr303%E6%A0%A1%E9%AA%8C">JSR303校验 异常 统一错误码</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#%E6%90%AD%E5%BB%BA%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E7%8E%AF%E5%A2%83">nginx 反向代理负载均衡 搭建域名环境</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B%E4%B8%8E%E4%BC%98%E5%8C%96">性能压测与优化</a> 在刚做出来一个小业务时进行过压测（1.渲染商城首页，2.获取某个分类下的数据）</p>
<ol>
<li>优化代码减少db查询</li>
<li>加索引</li>
<li>nginx动静分离：将js、css、img等静态资源放置在Nginx端<br>在nginx的html文件夹创建staic文件夹，并将index&#x2F;css等静态资源全部上传到该文件夹中，修改所有静态资源路径，使其全部带有static前缀src&#x3D;”&#x2F;static&#x2F;index&#x2F;img&#x2F;img_09.png”</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /<span class="type">static</span> &#123;</span><br><span class="line">       root   /usr/share/nginx/html;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#%E7%BC%93%E5%AD%98">缓存</a><br>使用springboot自动配置的stringRedisTemplate优化菜单获取业务<br>当进行压力测试时后期后出现堆外内存溢出OutOfDirectMemoryError（直接内存溢出，很多javaNIO(像netty)的框架….Lettuce：基于Netty框架，springboot2.0以后默认使用lettuce操作redis的客户端，lettuce的bug导致netty堆外内存溢出）切换使用jedis或升级lettuce客户端。<br>lettuce 和 jedis 都是操作 redis 的最底层客户端，spring 对其封装为 RedisTemplate<br>高并发下缓存失效问题<br>缓存穿透(全穿透缓存，因为不存在所以每次都还要再去查数据库，加null)雪崩(大面积同时失效，加随机时间，但可能好心办坏事，因为缓存存活时间可能不太一样，不一样的失效时间可能导致它们反而同时过期)击穿(热点, 加锁。大量并发只让一个去查，查完并放入缓存)</p>
</li>
<li><p>锁时序问题<br>如果查数据库和放入缓存这两个构成的事件没加一个大锁，尽管查数据库加锁了，在存缓存时可能其他线程发现缓存还是没有又去查数据库，所以要整个过程加个锁才能锁住。具体代码点链接看</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">分布式缓存</a><br>本地缓存面临问题<br>多个微服务部署在多台机器上，缓存仅能够为该机器上的服务使用，缓存失效时每个服务都要查询一次数据库(数据库压力大)，并且当数据更新时只会更新单个服务的缓存数据，就会造成数据不一致的问题，既然数据库是一致的，自然缓存也要一致，所以要分布式缓存。<br>所有的服务都到同一个redis进行获取数据。<br>分布式缓存<br>分布式锁（这里先用redis的setnx，后面改用redisson，注意区别。redis既作为缓存，又可以作为分布式锁）<br>分布式事务<br>前面说的缓存很明显只能锁住本机的服务(synchronized是本地锁)<br>分布式锁的演进</p>
</li>
<li><p>占坑 “占坑”可以去redis，等待就自旋<br>redis的 setnx(“lock”, 1111);<br>问题： 1、setnx占好了位，业务代码异常或者程序宕机。没有删除锁，这就造成了死锁。(设置锁的自动过期时间)加锁【占位+过期时间】要原子，setnx就可以设置时间。<br>2、如果自己业务超时导致锁过期（然后别人拿到了锁），删锁的时候删了别人正在持有的锁，所以使用随机 UUID匹配是自己的锁才删除；<br>3、还有问题！先从redis获取lock的值然后匹配然后删除，这是两个操作，网络情况极端下可能还是删了别人的锁，所以需要：获取值+对比成功删除&#x3D;原子操作  -》 通过redis+lua脚本完成<br>更难的事情，锁的自动续期&#x3D;&#x3D;》大佬redisson，就是为分布式而生的，促进使用者对Redis的关注分离。<br>redisson强大：</p>
<ul>
<li>锁的自动续期，如果业务超长，运行期间看门狗自动给锁加上新的30s，不用担心业务时间长，锁自动过期被删除</li>
<li>加锁的业务运行完成或者宕机结束了，看门狗不再给当前锁续期，一段时间后自然就解锁了，不用手动解锁也不会死锁</li>
</ul>
</li>
</ol>
<p>包括：（本质其实都还是往redis里面存键值对，像setnx那样，不过封装了，更高级）<br>RReadWriteLock 读写锁<br>RReadWriteLock lock &#x3D; redisson.getReadWriteLock(“rw-lock”);<br>RLock writeLock &#x3D; lock.writeLock();<br>闭锁 RCountDownLatch（当它是计数的，相当于上锁时上了好几个门闩，都解锁了才释放锁）<br>信号量 RSemaphore（停车位，总共这么多，增增减减）可以用来实现分布式限流操作: 比如我的服务可承受的高并发流量就是10000,那10000相当于车位，在流量进来前先去拿一个信号量,能拿到说明我的服务还有空余,这时候才让流量进来<br>缓存数据的一致性（都能满足最终一致性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;CatalogJson-Lock&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    categoryMap = getCategoryMap();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">return</span> categoryMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以Redisson内部提供了一个监控锁的看门狗，它的作用是在<strong>Redisson实例</strong>(这里就是lock)被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟。如果持有锁的客户端宕机或者崩溃，看门狗线程检测到在指定时间内客户端挂掉，看门狗线程则不会进行续期操作，锁在设定的 TTL 到期后会被自动释放，这样其他客户端就可以重新获取该锁。</p>
<ol>
<li>双写模式 写完数据库就去更新缓存<br>会有脏读问题（两个线程并发写，一个线程两个操作夹在另一个线程中间了）通过两操作整体加锁，作为原子行为。</li>
<li>失效模式（我们系统的一致性解决方案：使用 失效模式）（也叫旁路缓存模式）<br>数据库更新时将缓存删除<br>同样会有脏数据问题（并发读写导致的），通过读写锁解决并发读写。大不了自己过期，一样最终一致。</li>
</ol>
<p>无论是双写模式还是失效模式，都会导致缓存的不一致问题。即多个实例同时更新会出事。<br>真追求强一致：去使用canal订阅binlog的方式。canal订阅mysql的binlog，转头取更新redis。总之，不要过度设计，增加系统的复杂性，不应该对缓存的数据追求强一致。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#4-springcache">SpringCache</a><br>整合 SpringCache 简化缓存开发，使用注解即可完成缓存开发。【确实方便多了】<br>写配置文件RedisCacheManager。可以直接指定缓存序列化方式为json，否则之前需要fastjson一直转换来转换去。统一设置配置文件中的各项配置，如过期时间，自定义缓存key前缀名(与缓存分区有关，可以按逻辑分区(比如业务类型分)管理、删除缓存，很方便注意这个只是spring这么分，方便管理)，应对缓存穿透的空值，后期修改配置就可以更新。<br>@Cacheable() 代表当前方法的结果需要进行缓存：如果缓存中有结果，直接缓存中拿；如果缓存中没有，则调用方法，并且最后将结果放入缓存<br>@CacheEvict: 触发将数据从缓存中删除，用于 失效模式<br>@CachePut: 不影响方法执行更新缓存，将返回值（注意要有返回值）也放到Cache，这个就是双写模式<br>@Caching:组合以上多个操作<br>Spring-Cache的不足<br>@Cacheable sync &#x3D; true 加锁解决击穿，这里是本地锁<br> 常规数据（读多写少，即时性、一致性要求不高的数据）完全可以使用Spring-Cache解决<br>Spring-Cache解决了读模式三种缓存问题，最终SpringCache没有考虑写模式，毕竟普通数据只要有过期时间，写缓存也完全没问题</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#%E5%BC%82%E6%AD%A5">异步</a></p>
<p>创建线程池带有coreSize，当当前线程数小于coreSize时，创建线程执行任务，随着任务增多线程数达到coreSize之后，任务入队，大于coreSize时先进队，<strong>队列满了</strong>入队失败才开始增加线程数到max</p>
<p>拒绝策略<br>CompletableFuture组合式异步编程<br>runAsync方法不支持返回值。<br>supplyAsync可以支持返回值。<br>线程串行化<br>thenRun：不能获取上一步的执行结果<br>thenAcceptAsync：能接受上一步结果，但是无返回值<br>thenApplyAsync：能接受上一步结果，有返回值<br> 计算结果完成时的回调方法<br>whenComplete<br>handle 方法和 thenApply 方法处理方式基本一样。不同的是 handle 是在任务完成后再执行，还可以处理异常的任务。thenApply 只可以执行正常的任务<br>(5) 组合任务有好多种<br>thenCombine 合并任务<br>thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。<br>为了使我们的任务进行的更快，我们可以让查询的各个子任务多线程执行，但是由于各个任务之间可能有相互依赖的关系，因此就涉及到了异步编排。</p>
<p>工作流程：<br>         *1、线程池创建，准备好core 数量的核心线程，准备接受任务<br>         *  2、新的任务进来，用 core 准备好的空闲线程执行。<br>         *(1) 、core 满了，就将再进来的任务放入阻塞队列中。空闲的core 就会自己去阻塞队列获取任务执行<br>         *      (2) 、阻塞队列满了，就直接开新线程执行，最大只能开到max 指定的数量<br>         *(3) 、max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自动销毁。最终保持到 core 大小<br>         *      (4) 、如果线程数开到了 max 的数量，队列也满了，还有新任务进来，就会使用 reject 指定的拒绝策略进行处理<br>         *3、所有的线程创建都是由指定的factory 创建的<br>newScheduledThreadPool提交任务时可指定多长时间后执行，专门用于做定时任务的线程池<br>newCachedThreadPool<br>         *       core&#x3D;0，max&#x3D;Integer.MAX_VALUE 所有线程都可回收，灵活创建</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1">认证服务</a><br>注册防刷验证码<br>电话号码key  当前时间和验证码value 存redis<br>如果调用时以当前phone取出的v不为空且当前时间在存储时间的60s以内，说明60s内该号码已发过短信，返回错误信息。<br>注册相当于令牌机制，验证码存在redis，真正提交注册请求的时候我会进行比对验证码是否对。<br>RedirectAttributes 模拟重定向时携带数据<br>重定向相当于模拟 HttpSession session也是在<strong>同服务器内跨页面时用来共享数据</strong>的<br>TODO 重定向携带数据利用的是session原理，将数据放在session中，只要跳到下一个<br>页面取出数据后session里面的数据就会删掉，所以只是一次性的，比如错误校验再刷新一次就没了<br>TODO 分布式下session的问题</p>
<p>社交登录oauth2.0<br>第三方应用<strong>向用户请求认证</strong>（发一个请求跳到认证页面），认证通过后Gitee认证服务器发给应用一个访问令牌，此后应用带着这个令牌去gitee资源服务器获取<strong>开放保护信息</strong><br>第一次使用session，会命令浏览器保存带有<strong>JSESSIONID</strong>的cookie（相当于银行卡号，<strong>JSESSIONID就是用来从服务器里找对应的session的</strong>）以后浏览器访问哪个网站就会带上这个网站的cookie，即便是子域系统发的卡，也要能让整个父域都使用。所以要指定域名为父域名<br>cookie：每次访问网站时，浏览器在发请求时都会将可使用的cookie带上(就放在请求头里)<br>TODO：1.默认发的令牌的session作用域是当前域，我们要改为父域<br>TODO：2.使用JSON的序列化方式来序列化session的对象数据到redis中<br>SpringSession都整合了以上两个问题(不同服务共享session，同服务分布式下共享session(因为session就是内存，是存在特定机器上的，考虑到负载均衡…))</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#5-springsession">SpringSession</a></p>
<p>jsessionid相当于银行卡，存在服务器的session相当于存储的现金，每次通过jsessionid取出保存的数据<br>问题：正常情况下session不可跨域名，它有自己的作用范围（cookie里可以看到的domain），且浏览器关闭后清除cookie。分布式session不同步。</p>
<p>登陆成功后用户保存到session中，然后浏览器在cookie里面存一个jsessionId，下次访问这个域名带上cookie，然后用jsessionid查到对应的session发现用户存在，免登录。<br>hash一致性不错    redis统一存储更好，让webServer统一去redis拿session</p>
<p>SpringSession整合redis<br>通过SpringSession修改session的作用域<br>原始的request、response都被包装为：SessionRepositoryRequestWrapper、SessionRepositoryResponseWrapper<br>原先获取session是request.getSession(),现在变成了SessionRepositoryRequestWrapper.getSession()【装饰者模式】<br>后者是从SessionRepository去获取session的，而联系1)、1.知它正是在redis中找<br>【装饰者模式】，所有请求过来，将原生请求一包装，以后获取session都是调用的我的wrapper里规定的方法(重写了getSession()方法)，我偷偷替它去从redis存取session<br>完全模拟了以前的session的功能，比如不关浏览器会自动延期、关浏览器一段时间后自动过期</p>
<ol start="2">
<li>自定义配置<br>由于默认使用jdk进行序列化，通过导入RedisSerializer修改为json序列化</li>
</ol>
<p>并且通过修改CookieSerializer扩大session的作用域至**.gulimall.com</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#2-threadlocal%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E5%88%AB">ThreadLocal用户身份鉴别 登录拦截器</a><br>Tomcat对从拦截器-&gt;Controller-&gt;Service-&gt;Dao从始至终都是同一个线程，所以用 ThreadLocal 可以很方便的传递数据</p>
<p>&#x2F;&#x2F; 配置拦截器 CartInterceptor“&#x2F;**”表示拦截cart这个服务下所有路径的请求<br>preHandler：在执行目标方法之前拦截下并执行。<br>HTTP request： 由SpringSession装饰者模式包装过的，所以读取到的session都是从redis中读的<br>true放行，false不放行<br>实现登录拦截<br>postHandle<br>业务执行之后让浏览器保存 user-key 这个 cookie</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></p>
<p>本地事务，在分布式系统下，只能控住自己的回滚，控制不了其他服务(远程调用的服务)的回滚<br>使用分布式事务：最大适用场景：解决网络问题+分布式机器下的事务回滚<br>事务隔离级别@Transactional(isolation &#x3D; Isolation.REPEATABLE_READ)<br>库存锁成功了，但是网络原因返回结果超时抛出异常导致订单回滚了<br>高并发下使用分布式事务。两步(两方式)<br>1、让库存服务自己回滚，具体就是订单回滚了然后努力一直发消息去让库存自己回滚，这样就没什么性能损耗了<br>2、库存服务自解锁，使用自动解锁模式，参与消息队列<br>事务传播行为<br>所谓传播行为就是一个事务a调用了其他事务，a事务的所有设置(timeout)传播到了和它共用一个事务的方法<br>propagation &#x3D; Propagation.REQUIRED : 如果当前没有事务(调用方是否存在事务)，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>propagation &#x3D; Propagation.REQUIRES_NEW : 创建新事务，无论当前存不存在事务，都创建新事务。<br>Feign在远程调用之前要构造新的请求【区别于我们这个函数被调用是由于浏览器发过来的&#x2F;toTrade请求】，会调用很多的拦截器 : for (RequestInterceptor interceptor : requestInterceptors)<br>用新的请求模板创建远程服务请求 ： Request request &#x3D; targetRequest(template) ，结果这个模板 template 丢失了我们的请求头数据【cookie里的session】<br>这样创建出来的 request 自然是有问题滴，没有任何请求头，没有session，所以购物车认为没有登录<br>因此我们来构造这些Feign的请求拦截器来为我们最终发送的请求做“增强”<br>FriendmallFeignConfig&#x3D;》public RequestInterceptor requestInterceptor()</p>
<p>同样CompletableFuture进行异步编排<br>在redis中生成一个随机的令牌，过期时间为30min，提交的订单会携带这个令牌，我们将会在订单提交的处理页面核验此令牌，防止重复提交。获取令牌、对比值和删除令牌之间发生错误导入令牌校验出错，我们必须使用脚本保证原子性操作。<br>Feign远程调用丢失请求头问题<br>feign远程调用的请求头中没有含有JSESSIONID的cookie，所以也就不能得到cart服务端的session数据，cart认为没登录，获取不了用户信息<br>RequestContextHolder为SpingMVC中共享request数据的上下文，底层由ThreadLocal实现（线程间存在副本，线程间隔离）所以在开启异步的时候将老请求的RequestContextHolder的数据设置进去。</p>
<p>（3） 分布式事务<br>分布式情况下，可能出现一些服务事务不一致的情况</p>
<p>@GlobalTransactional<br>这里就很适合 Seata 的AT模式，因为这个模式不能适应高并发请求的分布式事务，在这个场景下就很适用</p>
<p>本地事务失效问题：在同一个service(对象)里互相调事务方法相当于代码拷贝意味着没有走代理(绕过了代理对象)，而事务实际上是使用代理来控制的，这样的话事务传播行为设置就无法生效，所以本地事务失效。</p>
<p>订单服务调用锁库存和查积分两个小事务<br>利用消息队列实现最终一致性<br>库存锁成功后给队列发消息（库存工作单），超时后尝试要不要解锁(解锁前确定订单支付状态)</p>
<p>订单失败(其他逻辑失败或者小服务返回结果超时或订单假失败)之后回滚，要求小服务也回滚<br>库存失败，导致订单回滚。</p>
<p>(1) 延迟队列的定义与实现<br>定义：<br>延迟队列<strong>存储的对象肯定是对应的延时消息</strong>，所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。<br>rabbitmq可以通过设置队列的TTL（来控制消息的生存时间）和死信路由(其实就是普通交换机)实现延迟队列<br>消息超时变为dead letter(死信)<br>RabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由转发到指定的交换机。<br>经过TTL的时间后消息会变成死信以order.release.order的路由键<strong>经交换机转发至队列</strong>order.release.order.queue，再通过监听该队列的消息来实现过期订单的处理（我们只监听这个队列）</p>
<p>两个延时队列：订单延时队列，30min后检查订单状态，决定是否关单<br>库存延时队列，40min后检查订单状态，没付钱解锁库存。</p>
<p>定时关单与库存解锁主体逻辑<br>创建订单时消息会被发送至队列order.delay.queue，经过TTL的时间后消息会变成死信以order.release.order的路由键经交换机转发至队列order.release.order.queue，再通过监听该队列的消息来实现过期订单的处理<br>修改该订单的状态并通过路由键order.release.other发送消息至队列stock.release.stock.queue进行库存解锁<br>在库存锁定后通过路由键stock.locked发送至延迟队列stock.delay.queue，延迟时间到，死信通过路由键stock.release转发至stock.release.stock.queue,通过监听该队列进行判断当前订单状态，来确定库存是否需要解锁<br><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#2-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">这里看图</a></p>
<p>为保证消息的可靠到达，我们使用手动确认消息的模式，在解锁成功后确认消息，若出现异常则重新归队<br>为保证<strong>幂等性</strong>，我们分别对<strong>订单的状态和库存工作单的状态</strong>都进行了判断，只有<strong>当订单过期且工作单显示当前库存处于锁定的状态时</strong>，才进行库存的解锁，每次都要查最新的状态，防止重复解锁<br>还有：保证消息一定会发送出去。每个消息做好日志记录(给数据库保存每个消息的详细信息)，之后定期扫描数据库将失败的消息再发送一遍。<br>将没发送成功的消息不断进行重试发送</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#6-%E6%94%AF%E4%BB%98">支付</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/NiceSeason/gulimall-learning/blob/master/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7.md#%E7%A7%92%E6%9D%80%E6%9C%8D%E5%8A%A1">秒杀服务</a></p>
<p>秒杀（高并发）系统关注的问题：读多写少<br>nginx动静分离<br>后面调整到网关层直接进行流控<br>前端：将流量分布到更宽时间上，比如验证码，得先加购物车<br>后台：秒杀服务独立<br>使用定时任务每天三点上架最新秒杀商品，削减高峰期压力，库存预热到redis，信号量控制请求@Scheduled(cron &#x3D; “<em>&#x2F;3</em> ** * ?”)<br>秒杀链接加密(redis为秒杀商品添加唯一商品随机码)，防止恶意攻击<br>队列削峰，秒杀成功后立即返回，然后发送消息进入队列，后台慢慢创建订单慢慢扣库存<br>整体调控：限流：限制次数、总量    快速失败降级运行    熔断隔离防止雪崩</p>
<p>开启对定时任务的支持，由于在分布式情况下该方法可能同时被调用多次，因此加入分布式锁，同时只有一个服务可以调用该方法</p>
<p>幂等性处理：去redis占位<br>不要重复保存秒杀信息，包括场次，商品库存信息等。<br>秒杀时验证这个人是否购买过了。</p>
<p>TODO 幂等性处理，保证不会反复上架已经上架的商品<br>包含两步：1、多台机器要上分布式锁【注意，就算代码里已经有幂等性判断了，这个分布式锁也一定要有，比如两台机器同时进来，同时到redis判断键是否存在那里(前一个还没把键设置进去，另一个看诶还没有这键也跟着执行了)，二者同时执行了代码相当于幂等失败了，所以这锁很重要】<br>所以要保证同一时刻只有一台机器执行这段代码，业务完成后更新状态并把状态持久化住，这样别人就无法获得我的中间状态，结合下面的2、才能达到幂等；<br>2、判断那个关键 key 是否已经存在于redis了，key要根据业务决策出一个合理值，保证体现特殊性，和业务的强绑定性；</p>
<p>控制台设置QPS，流控效果等流控规则<br>FriendmallSentinelConfig自定义限流时返回数据</p>
<p>feign的降级<br>feign.sentinel.enabled&#x3D;true使用Sentinel来保护Feign的远程调用<br>在@FeignClient设置fallback属性<br>@FeignClient(value &#x3D; “gulimall-seckill”,fallback &#x3D; SeckillFallbackService.class)远程调用失败执行的方法</p>
<h1 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>ps -aux</p>
<p>ps -ef|grep &lt;进程名&gt;</p>
<p>kill -9 pid</p>
<p>docker run <br>-d -p 8848:8848 <br>-p 9848:9848 <br>–name nacos2 <br>-e JVM_XMS&#x3D;256m -e JVM_XMX&#x3D;256m <br>-e MODE&#x3D;standalone <br>-e TIME_ZONE&#x3D;’Asia&#x2F;Shanghai’ <br>nacos&#x2F;nacos-server:v2.1.2</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name s.strumcode.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:8003;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>上线修改为<br>nohup &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-17.0.13&#x2F;bin&#x2F;java <br>-Xms1024m -Xmx1024m <br>-jar &#x2F;home&#x2F;shortlink&#x2F;shortlink-gateway.jar &gt; logs&#x2F;shortlink-gateway.file 2&gt;&amp;1 &amp;</p>
<p>nohup &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-17.0.13&#x2F;bin&#x2F;java <br>-Xms2048m -Xmx2048m <br>-Dshort-link.domain.default&#x3D;s.strumcode.com <br>-jar &#x2F;home&#x2F;shortlink&#x2F;shortlink-aggregation.jar &gt;  &#x2F;home&#x2F;shortlink&#x2F;logs&#x2F;shortlink-aggregation.file 2&gt;&amp;1 &amp;</p>
<p>tail -f &#x2F;home&#x2F;shortlink&#x2F;logs&#x2F;shortlink-aggregation.file<br>tail -f &#x2F;home&#x2F;shortlink&#x2F;logs&#x2F;shortlink-gateway.file</p>
<hr>
<p>先在根目录进行 du -sh *，然后<br>cd &#x2F;下一个占用大的目录<br>du -sh *<br>逐级排查哪个文件或目录较大。</p>
<p><strong>研究下 Nginx</strong>:</p>
<p>nginx -t      命令进行检查，确保 Nginx 配置文件没有语法错误。<br>systemctl reload nginx       重新加载或重启 Nginx 服务：</p>
<p>link.strumcode.com  strumcode.com  <a target="_blank" rel="noopener" href="http://www.strumcode.commit都能跳到控制台/">www.strumcode.commit都能跳到控制台</a></p>
<p>实际上监听的是 link.strumcode.com 域名 80 端口 根路径 “&#x2F;“，重定向到</p>
<p>实际上监听的是 s.strumcode.com 域名 80 端口 根路径 “&#x2F;“，重定向到</p>
<p>s.strumcode.com&#x2F; 应该只能作为短链接的前缀</p>
<h2 id="分库分表-以及-表结构"><a href="#分库分表-以及-表结构" class="headerlink" title="分库分表 以及 表结构"></a>分库分表 以及 表结构</h2><p>分片算法都是哈希16分片。</p>
<p>t_link  【0-16】<br>    shardingColumn: <strong>gid</strong><br><code>full_short_url</code> <strong>唯一索引</strong><br><code>domain</code>域名  <code>short_uri</code>短链接uri <code>full_short_url</code>完整短链接 <code>origin_url</code>原始链接 <code>gid</code>分组标识 <code>valid_date</code>有效期<br>还有一堆统计信息</p>
<p>t_link_goto  【0-16】<br>    shardingColumn: <strong>full_short_url</strong><br><code>full_short_url</code> <strong>唯一索引</strong><br><code>full_short_url</code>完整短链接  <code>gid</code>分组标识</p>
<p>t_group  【0-16】<br>    shardingColumn: <strong>username</strong><br><code>username</code> 是<strong>普通索引</strong><br><code>gid</code>分组标识  <code>name</code>分组名称  <code>username</code>创建分组的用户名</p>
<p>t_group_unique<br><code>gid</code>分组标识<br><code>gid</code> 唯一索引</p>
<p>一个用户创建多个短链分组group，所以t_group按用户名分片，因为前端要根据用户名查分组。所以自然也是<code>username</code>普通索引。（因为用户注册的时候用户名已经是唯一索引了）</p>
<p>一个分组下有多个短链接link，所以link按groupid即gid分片。因为前端要按分组查询短链接，如果一个分组的短链接在不同的link表下那不就爆炸了。短链接跳转时自然要根据<code>full_short_url</code>来查，又为了去重，所以用唯一索引。</p>
<p>短链接跳转表link_goto_${0..15}，它根据full_short_url分片<br>可以说的短链接的全局去重表，<code>full_short_url</code>的分片算法加表自身的唯一索引。之所以有个gid字段是为了缓存失效查数据库时先找组再找短链接？存疑</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="短链重复的问题"><a href="#短链重复的问题" class="headerlink" title="短链重复的问题"></a>短链重复的问题</h3><p>关于短链接重复：不同原链接一定不能在短链上重复。再者，用户反复用相同原链接是允许生成新的短连接的，当然这个短链也不重复。所以不管原链接相同否，短链接都不能重复。我们用link表和link_goto表一起来保证。在某个gid分片算法路由下对应的link表下，link是唯一的，但全局不一定唯一，所以用link_goto表兜底。</p>
<p>两个用户可能创建出两个group，他们在这个分组下创建短链接，在某个gid分片算法路由到同一个link表下，因为<code>full_short_url</code> 唯一索引，所以这个表下的短链接不会重复。但是<strong>不同gid分组下创建出相同的短链并存到不同的link表中该如何保证不重复</strong>？使用t_link_goto，每个短链接根据自己的<code>full_short_url</code>分片定位到对应的link_goto表，在这个表<code>full_short_url</code>同样是唯一索引，所以保证了短链接的全局唯一。</p>
<p>短链不能重复。首先我们布隆过滤器（它说存在不一定真存在，他说不在就真不在）判断是否重复，重复就重新生成。<br>但是如果并发对同一原始链接(或哈希冲突)生成短链并同时判断不存在，就会同时操作数据库，那么不管这个短链接的gid是否相同，最终都会由t_link_goto进行兜底判断重复，所以会出现数据库异常（DuplicateKeyException）， 我们通过使用UUID替换当前时间戳，减少这种报错。</p>
<h3 id="访问短链"><a href="#访问短链" class="headerlink" title="访问短链"></a>访问短链</h3><p>访问短链如果没在缓存要查数据库，那么会先查link_goto，其中有gid，然后再用gid去查link表防止读扩散。<br> t_link_goto是短链接和 Gid的路由表。</p>
<p>也许会有问为什么不在goto表的设计那一块，设计成直接短链接到长链接的路由，省的还要拿gid再去link表查原始链接，这样不是更快吗？<br>实际上gid是一定要的，没有这个gid，之后访问短链，要统计原始信息，那你是不是一定要去link表里面找整条link记录进行修改了(today今日访问量以及这条短链自身的访问量信息)，或者查询组的监控信息时，是不是也要去查整条link记录再去和监控表内联然后查询。既然这样，那link表的分片键gid就一定要在路由表link_goto里面了。link表的分片键gid太重要了。</p>
<h3 id="分组的问题"><a href="#分组的问题" class="headerlink" title="分组的问题"></a>分组的问题</h3><p><strong>每个用户创建的所有分组，生成的gid也是唯一的</strong>。</p>
<p>之所以短链接按照gid分片到link表中存放，应该是为了方便前端按组查询短链接。那如果<strong>两个用户创建相同的gid组怎么办</strong>？不行的，我有t_group_unique不允许创建相同gid标识的组。</p>
<p>访问日志有两种，还有一种是link表中某条短链接有记录自身的total_pv、uv、uip，一种是那八张表（短链访问日志、每条短链接各自的按小时和日期访问统计(pvuvuip)、浏览器统计、设备统计、地区统计、网络方式电脑或手机统计、操作系统统计、每条短链接各自的今日访问统计(pvuvuip)）。<br>第一种是每个链接独立的数据。增加访问统计时就要加读锁，而修改短链接的分组时要修改这条link的gid，要加写锁，通过加读写锁防止冲突，比如link表正在按gid查短链(分表，防止读扩散)，此时另一个线程修改了其中一些短链接的gid，那这些短链接增加统计就失败了。<br>第二种七张表是按照分组查的，比如查整个分组的访问情况就要用这七张表。重构之后他们都不带gid，查询的时候通过link表和这些表内联再根据gid分组得到统计信息。</p>
<h1 id="12306"><a href="#12306" class="headerlink" title="12306"></a>12306</h1><p>-Dspring.data.redis.password&#x3D;Sm9sVXBOYJjI030b5tz0trjpzvZzRhtZmEbv0uOImcD1wEDOPfeaqNU4PxHob&#x2F;Wp<br>-Dspring.data.redis.port&#x3D;19389<br>-Dunique-name&#x3D;strumcode<br>-Dframework.cache.redis.prefix&#x3D;strumcode:<br>-Dspring.data.redis.host&#x3D;common-redis-dev.magestack.cn<br>-Drocketmq.name-server&#x3D;common-rocketmq-dev.magestack.cn:9876<br>-Dspring.cloud.nacos.discovery.server-addr&#x3D;common-nacos-dev.magestack.cn:8848</p>
<p>-Dunique-name&#x3D;strumcode<br>-Dframework.cache.redis.prefix&#x3D;strumcode:<br>-Drocketmq.name-server&#x3D;common-rocketmq-dev.magestack.cn:9876</p>
<p>OrderStatusEnum </p>
<pre><code>0  待支付：用户选好车票下单，但还未付款的状态

10  已支付：用户支付订单费用

11  部分退款：用户支付订单费用后部分车票退款

12 全部退款：用户支付订单费用后全部车票退款

20 已完成：用户车票已过上站时间，订单完成

30 已取消：用户选好车票下单，未支付状态下取消订单
</code></pre>
<hr>
<p>TradeStatusEnum </p>
<pre><code>0  交易创建，等待买家付款

10  未付款交易超时关闭，或支付完成后全额退款/部分退款

20  交易支付成功

30  交易结束，不可退款 
</code></pre>
<p>index12306_pay-service_topicstrumcode<br>index12306_pay-service_pay-result-callback_tagstrumcode</p>
<p>index12306_pay-service_topicstrumcode:index12306_pay-service_pay-result-callback_tagstrumcode</p>
<p>index12306-order:pay_result_callback:503450116503808568576_1747558636</p>
<p>（能否创建订单要先去余量令牌桶里面获得到令牌才行）<br>创建订单之后就去数据库（减库存即锁库存）然后canal去更新余量桶，而不是支付后才进行。<br>所以订单超时或取消(数据库订单状态变为30)会再次用canal去redis更新库存。<br>这个数据库更新是通过另一个消息队列完成的。</p>
<h2 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h2><h3 id="订单表（t-order、t-order-item、t-order-item-passenger）"><a href="#订单表（t-order、t-order-item、t-order-item-passenger）" class="headerlink" title="订单表（t_order、t_order_item、t_order_item_passenger）"></a>订单表（t_order、t_order_item、t_order_item_passenger）</h3><p>t_order<br>shardingColumns: <strong>user_id</strong>,<strong>order_sn</strong></p>
<p>t_order_item<br>shardingColumns: <strong>user_id</strong>,<strong>order_sn</strong></p>
<p>t_order_item_passenger<br>shardingColumn: <strong>id_card</strong>  理解，因为乘车人要找票</p>
<h3 id="支付表（t-pay）"><a href="#支付表（t-pay）" class="headerlink" title="支付表（t_pay）"></a>支付表（t_pay）</h3><p>t_pay<br>shardingColumns: <strong>pay_sn</strong>,<strong>order_sn</strong></p>
<h3 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h3><p>t_user<br>shardingColumn: username</p>
<p>t_passenger<br>shardingColumn: username</p>
<p>t_user_mail<br>shardingColumn: mail</p>
<p>t_user_phone<br>shardingColumn: phone</p>
<h2 id="车票服务"><a href="#车票服务" class="headerlink" title="车票服务"></a>车票服务</h2><p>同一个列车编号的车可以跑好几趟从而形成车次train_id ?<br><code>train_type</code>  列车类型 0：高铁 1：动车 2：普通车<br><code>train_tag</code> 列车标签 0：复兴号 1：智能动车组 2：静音车厢 3：支持选铺  （不太重要）<br><code>train_brand</code> 列车品牌 0：GC-高铁&#x2F;城际 1：D-动车 2：Z-直达 3：T-特快 4：K-快速 5：其他 6：复兴号 7：智能动车组</p>
<p>t_train：列车表。   <code>train_number</code>列车编号(G35、G39、D717、Z284)  <code>sale_status</code>0可售1不可售.. <code>start_station</code> <code>end_station</code> 起始终点站</p>
<p>t_train_station：列车车次的路线被中间站点分割而成的段落。 <code>train_id</code>车次id，<code>station_id</code>这一小段的起始车站id，<code>sequence</code>此车站在整个路线中的顺序， <code>departure arrival</code>这一段的起始和终点站  </p>
<p>t_train_station_relation：根据t_train_station中的段落能产生的所有路线，<code>train_id</code>列车车次id，<code>departure arrival</code>这个段落组合的起始和终点站，<code>departure_flag arrival_flag</code>始发或终点标识（对此车次的完整线路来说是否是起始终点站）</p>
<p>t_region：城市地区表。 <code>name</code>城市名  <code>code</code>城市编号  <code>popular_flag</code>热门标识</p>
<p>t_station：车站表(一个城市可能两三个车站)。  <code>id</code>，应该就是station_id，<code>name</code>车站名  <code>code</code>车站的编号  <code>region</code>车站所在的城市的编号</p>
<p>t_carriage：车厢表。 <code>train_id</code>列车车次id（可能是是t_train表的自增id，1、2、3、4），<code>carriage_number</code>车厢号（每趟车01-16个车厢） <code>seat_count</code>每个车厢座位数  <code>carriage_type</code>车厢类型（其实就是座位类型）</p>
<hr>
<p>t_train_station_price：所有段落组合和各自的座位等级笛卡尔积形成的票价（比如2车次有三种段落组合，三种座位，那就有九张票价）。<code>train_id</code>车次id，<code>seat_type</code>座位类型，<code>departure``arrival</code>这张票代表的段落组合的起始和终点， <code>price</code>票价，所有数据t_seat都有。</p>
<p>t_seat：座位表。<code>train_id</code>列车车次id，<code>carriage_number</code>车厢号，<code>seat_number</code>座位号（01A、02C、05F数字是第几排，字母是该排哪个位置，商务座3座，一等座4座，二等座5座），<code>seat_type</code>座位类型（0：商务 1：一等 2： 二等，…13、14等几种类型）， <code>departure``arrival</code>这张票代表的段落组合的起始和终点， <code>price</code>票价，<code>seat_status</code>座位状态（0：可售 1：锁定 2： 已售）</p>
<p><strong>t_train_station_price</strong>是为了得出票价，而<strong>t_seat</strong>不仅有票价，还把票在车厢中的位置编排好了，并且对所有座位进行了枚举，而每个车厢的座位数在<strong>t_carriage</strong>。我们买票都是在<strong>t_seat</strong>上面进行操作（在对应的路线段以及对应座位号上对座位类型进行修改）。</p>
<hr>
<p>t_ticket：用户买的票。<code>username</code>用户名，<code>train_id</code>列车车次id，<code>carriage_number</code>车厢号，<code>seat_number</code>座位号（应该是用车次和车厢号和座位号去座位表查）。<code>passenger_id</code>真正乘客的id，<code>ticket_status</code>车票状态（0：未支付 1：支付 4： 退票…5）。</p>
<hr>
<p><strong>购票逻辑</strong>：一趟车次可以组合出好几种路线段，每个路线段都可以选这么多座位，在买个某个路线段某个座位的票后，那些和这个路线段有交集的路线段的此座位的票就得锁定，比如abcde，买了b-d某个座位，那么这个座位只有ab，de路线段的票能买了。</p>
<p>（假设此车次总共有1000个座位，实际上一个座位的唯一标识应该有车次号待定、车厢号、座位号共同确定，可能还有座位类型?应该没有）<br>余票缓存和token令牌桶的数据理论上是一致的。<br>余票是通过t_seat里面count出来的。<br>再确认下t_seat：一个车次的所有段落都能和这1000个座位进行组合，我买了这个座位在这个路线段的使用权。所以余票缓存和token令牌桶在每个路线段都是有1000个座位即1000张票，所以redis中的key应该包含路线段的起始和终点可能还有车次（对的）？然后value为1000表示有这么多票可以买（实际上是一个map，key是座位类型）。当一个交易完成时，与此路线段交集的所有路线段的value的都要减一，表示这些段的余票数减一(因为座位被占了当然减一)。然后交易段在db中t_seat里找到对应座位seat_status标为已售，其他段可能标为锁定？<br>这个逻辑可能挺好，但代码中实现是否这样有待确定。<br>买到票之后进行座位分配。</p>
<p>String keySuffix &#x3D; StrUtil.join(“_”, each.getTrainId(), item.getDeparture(), item.getArrival());<br>                Object quantityObj &#x3D; stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, seatType);</p>
<p>查询票V1：用户输入出发地目的地（是车站的code）日期，先责任链检查，然后出发地目的地找到各自对应的region城市，然后用两个城市找所有可能的车次（比如	2_北京南_杭州东、1_北京南_杭州东），每个车次（比如	2_北京南_杭州东）都要去查票价（比如查到三个座位等级的票价实体数组），然后每个座位等级结合车次出发地目的地(即2_北京南_杭州东)去seat表count座位余量，最后生成关键的“List&lt;TicketListDTO&gt;”车次集合数据，每个TicketListDTO都是一张票的信息（车次出发站点目的站点），然后里面还有余票信息“List&lt;SeatClassDTO&gt; seatClassList”，一个SeatClassDTO明示了座位等级和余量。</p>
<p>查询票V2：逻辑和V1一样，但是在查询redis上使用了executePipelined进行并行查询优化提升了性能。具体两处是：<br>（1）、比如四个车次都要去查票价，每个都查到的是三个座位等级的票价实体组成的数组的json string<br>（2）、这四个车次，每个都有三、四中票价实体（三、四种座位），于是这么多个并行去redis查座位余量。<br>当然V1有考虑redis缓存失效的情况，V2没考虑。以及使用executePipelined要注意并行查询时相互之间不要有依赖。</p>
<p>如果redis中没有余量数据，那么加载余量会传入两个站点，方法处理流程是：计算此车次这两站之间能得到的所有路线，然后每个路线都去seat中count座位余量。这方法和token是一样的。</p>
<p>看看余量和token的数据区别，2车次是有3种座位类型0、1、2，token相当于把余量中的数据展开了。</p>




<p>购票V2：责任链，去拿token（计算各个座位等级各需要几张票，在计算相关的所有路线，然后lua脚本扣减所有路线各个等级座位的购票数，并且拿不到token是进行相应的兜底策略），上一堆本地锁和分布式锁然后开始执行购票逻辑。购票逻辑具体有：选座，组构远程调用订单服务创建订单的请求参数。</p>
<p>选座逻辑有：根据车类型和座位类型使用策略模式选座（为每个乘客分配好了座位包括车厢和座位号），根据乘客id去用户服务远程查询乘客具体信息，查座位价格，一起封装为结果返回，还要去数据库把那些座位锁定了。具体选座是根据座位类型分类得到各自购买的票数，然后每种座位类型是一个future去并行执行，选座逻辑复杂，分为：总共几张票？比如对商务座来说按2来分割（2人以下简单选座selectSeats，2人以上复杂选座selectComplexSeats）对一等来说4人，原因是这些座位一排有几个座位，方便实现邻座算法；是否有指定座位（用findMatchSeats）？</p>
<p>订单服务创建订单：通过基因法将用户 ID 融入到订单号，生成订单、订单项、乘客项各自插入到数据库中。</p>
<h1 id="简历问题"><a href="#简历问题" class="headerlink" title="简历问题"></a>简历问题</h1><h2 id="12306-1"><a href="#12306-1" class="headerlink" title="12306"></a>12306</h2><p>实际上：每个站数之间的数量都有规则。虽然放票时间都是一致的，但是优先大站之间的票量，避免因为大量用户购买了中间站的车票导致始发站和终点站的购票困难。该问题通过动态放票解决，比如刚开始放票时对小站之间仅开放少量票，大站之间放出来多数票。如果后续接近发车时间，再开放小站间的车票。</p>
<hr>
<p>策略模式<br>canal 监听两个表  订单表和座位表<br>订单表：<br>&#x2F;&#x2F; 座位表解锁座位<br>seatService.unlock(trainId, orderDetailResultData.getDeparture(), orderDetailResultData.getArrival(), BeanUtil.convert(passengerDetails, TrainPurchaseTicketRespDTO.class));<br>&#x2F;&#x2F; 令牌桶回滚<br>ticketAvailabilityTokenBucket.rollbackInBucket(orderDetailResultData);</p>
<p>座位表：<br>更新余票（座位状态变化去更新余票）</p>
<p>座位选择：<br>交通工具类型（高铁、动车）+座位类型（商务座、一等座）为策略标识<br>（因为这些条件变化 座位安排有变化 比如商务座左边是1座，右边是2座）<br>所以高铁商务座选座和动车一等座选座是不一样的。</p>
<p><strong>借助 Spring 满足开闭原则</strong>通过 ioc 实现<br>监听初始化事件 ApplicationListener 将组件放入 ioc 容器</p>
<p> Mybatis 源码Interceptor 拦截器主要使用的就是责任链<br>SpringMvc 中可以定义拦截器，并且可以定义多个。当一个用户发起请求时，顺利的话请求会经过所有拦截器，最终到达业务代码逻辑，SpringMvc 拦截器设计就是使用了责任链模式。</p>
<p>这种责任链执行方式会将所有的 处理器全部执行一遍，不会被打断。Mybatis 拦截器用的正是此类型，这种类型 重点在对请求过程中的数据或者行为进行改变。<br>拿查询语句举例，如果定义了多个查询相关的拦截器，会先经过拦截器的代码加工，所有的拦截器执行完毕后才会走真正查询数据库操作。比如查询 SQL 的分页语句。</p>
<p>就像我们定义在 SpringMvc 中的 Token 拦截器，如果 Token 失效就不能继续访问系统，处理器将请求打回。</p>
<p>责任链模式的优点在于，它可以动态地添加、删除和调整处理者对象，从而灵活地构建处理链。同时，它也避免了请求发送者和接收者之间的紧耦合，增强了系统的灵活性和可扩展性。</p>
<p><strong>责任链处理器接口</strong>，所有子任务都实现该接口以处理具体的业务逻辑。<br>为了方便对责任链流程中的任务进行顺序处理，我们需要继承 Spring 框架中的排序接口 Ordered。这将有助于保证责任链中的任务顺序执行。</p>
<p>假设项目中有两个业务场景：订单下单和用户创建都需要责任链模式去验证，mark 就是用来进行分组，在业务中进行调用责任链时传递不同的 mark 方法参数，通过该参数找到对应的一组责任链具体实现类集合。</p>
<p><strong>责任链中每个实例处理器都是实现一个接口的处理器功能，同时携带mark 和 order。</strong>最终放入容器。</p>
<p><strong>策略模式中每个实例处理器也都是实现一个接口的处理器功能，同时携带mark</strong>最终放入容器。</p>
<p>用户注册<br>&#x2F;&#x2F; 验证参数不为空<br>&#x2F;&#x2F; 验证用户名是否可用<br>&#x2F;&#x2F; 验证证件号是否多次注销，如果是的话加入黑名单</p>
<p>两张路由表：用户手机号表和用户邮箱表。这些表的核心字段是手机号和邮箱，以及它们对应的用户名。通过这样的设计，我们能够在用户登录时，灵活地使用手机号、邮箱或用户名来进行认证。有效地应对了海量用户数据和多样化登录需求</p>
<p>为了解决已注销用户名的可复用问题，注销时相关缓存和数据库表也会被删除，确保用户名的合理复用和数据的一致性。</p>
<ol start="4">
<li><p>如果布隆过滤器中存在该用户名，进一步检查Redis Set结构中是否包含该用户名。如果存在，表示该用户名已被注销，同样可被再次使用。</p>
</li>
<li><p>如果布隆过滤器中存在该用户名，但 Redis Set 结构中不存在，说明该用户名已被使用且尚未被注销，因此不可用。</p>
</li>
<li><p>异常行为限制：每次用户注销时，记录用户的证件号，并限制证件号仅可用于注销五次。超过这个限制的次数，将禁止该证件号再次用于注册账号。</p>
</li>
<li><p>缓存分片处理：对 Username Redis Set 结构进行分片。即使我们对异常行为进行了限制，如果有大量用户注销账户，存储这些数据在一个 Redis Set 结构中可能成为一个灾难，可能出现 Redis 大 Key 问题。因此，我将 Set 结构进行分片，根据用户名的 HashCode 进行取模操作，将数据分散存储在 1024 个 Set 结构中，从而有效地解决了这个问题。<strong>所以你也用过集合了</strong></p>
</li>
</ol>
<p>购票请求验证</p>
<p>在实际购票业务场景中，用户发起一次购票请求后，<strong>购票接口在真正完成创建订单和扣减余票行为前，需要验证当前请求中的参数是否正常请求，或者说是否满足购票情况。</strong></p>
<ol>
<li>购票请求用户传递的参数是否为空，比如：车次 ID、乘车人、出发站点、到达站点等。</li>
<li>购票请求用户传递的参数是否正确，比如：车次 ID 是否存在、出发和到达站点是否存在等。</li>
<li>需要购票的车次是否满足乘车人的数量，也就是列车对应座位的余量是否充足。</li>
<li>乘客是否已购买当前车次，或者乘客是否已购买当天时间冲突的车次。</li>
</ol>
<p><code>getBeansOfType(AbstractChainHandler.class);</code>  AbstractChainHandler是策略类都实现的顶层接口</p>
<hr>
<p>为什么车票搜索为什么用Redis而不是ES？</p>
<p>搜索的时候带的参数<br>● 单程或者往返<br>● 出发地<br>● 目的地<br>● 出发日或者返程日.（<strong>核心就是出发日只能选一天</strong>）<br>● 出发车站<br>● 到达车站<br>● 车次类型 （高铁 动车）<br>● 车次席别 （商务 一等）<br>● 普通或者学生</p>
<p>考虑使用 Redis 和 Elasticsearch 两个技术都是有一定道理的，它们分别有自己的优势和适用场景。<br>作为承受请求最多的列车搜索功能，需要同时兼容实时性、并发性以及部署成本几大要点。为此，我梳理了为什么必须用 Redis 的几个原因。</p>
<p>可以快速响应实时查询请求。这对于需要即时更新的列车数据非常重要。Redis 使用单线程模型，虽然是单线程的，但通过非阻塞 I&#x2F;O 和事件循环，它可以处理大量并发请求，减少了上下文切换和锁竞争，提高了实时性。</p>
<p>Redis 支持原子操作，可以将一系列操作组合成一个原子操作进行提交。通过事务，可以确保多个操作在执行过程中不会被其他客户端中断。<br>Redis 是一款轻量级的数据库，易于部署和维护。它的内存占用相对较低，可以在相对较小的硬件配置上运行，从而减少了部署成本。</p>
<p><strong>搜索条件拆解</strong></p>
<p><strong>它只允许选择一天的出发日期</strong>。<br><strong>设计 Redis 缓存存储 12306 列车查询数据。</strong></p>
<p><strong>这么来设计 Redis 缓存存储 12306 列车查询数据。</strong></p>
<img src="/2024/09/01/BaGu/16.png" class="">

<p>出发日期_起始城市_终点城市  <strong>每个这种数据就是当前用户所有可能要买的车票了。</strong>我们上架车票实际上可能有很多个这种大 key。原因就是某一天一个城市到另一个城市的车次（车id_起始站点_终点站点）根本没几个</p>
<p>hash ： （key  ： 列车id_起始站点_终点站点）（value：列车详细信息）<br><strong>虽然页面上有很多查询条件，但大多数条件都是由前端进行筛选，实际上并没有触发后端的请求。</strong></p>
<p>12306列车数据搜索具有多个搜索条件，包括单程&#x2F;往返、出发地、目的地、出发日期&#x2F;返程日期、乘客类型、车次类型、出发车站、到达车站、车次席别、发车时间、显示积分兑换车次以及显示全部可预订车次等。这些条件使搜索功能变得复杂，<strong>但在实际使用中，大部分条件是前端筛选，而不是每个条件都会发起后端请求</strong>。</p>
<p><strong>前端缓存了出发城市、目的城市、出发日期这三个条件的所有车次，之后前端根据你加的其他条件再次筛选。不管你带多复杂的条件进行查询，实际上发到后端的请求都只带了三巨头，然后前端再筛选</strong>。</p>
<p>因此，Redis 可以用于快速存储和检索列车数据【我们的查询其实很简单，只带了三个条件，其余条件由前端筛选】。而 Elasticsearch 等搜索引擎可以在需要进行全文搜索或复杂查询时使用。</p>
<hr>
<p>分布式雪花算法ID</p>
<p>36 位的 UUID</p>
<p>Twitter 雪花算法生成后是一个 64bit 的 long 型的数值，组成部分引入了时间戳，基本保持了自增。</p>
<ol>
<li>高性能高可用：生成时不依赖于数据库，完全在内存中生成。</li>
<li>高吞吐：每秒钟能生成数百万的自增 ID。</li>
<li>ID 自增：存入数据库中，索引效率高。</li>
</ol>
<p>依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成 ID 冲突或者重复。</p>
<p>1符号位，0 表示正，1 表示负，固定为 0 + 41毫秒级的时间戳 + 5数据中心 + 5工作机器id + 12序列号<br>两个标识位组合起来最多可以支持部署 1024 个节点</p>
<p>序列号：12bit 递增序列号，表示某一个节点毫秒内生成重复，通过序列号表示唯一，12bit 每毫秒可产生 4096 个 ID。<br>一个节点在一个毫秒内生成id的话前面1+41+12&#x3D;54位都是重复的，通过后面12位来表示唯一。</p>
<p>通过序列号 1 毫秒可以产生 4096 个不重复 ID，则单个节点 1 秒可以生成 4096 * 1000 &#x3D; 409w ID。</p>
<p>雪花算法更多是被应用在数据库的主键 ID 和业务关联主键。</p>
<p><strong>如果能保证标识位不重复，那么雪花 ID 也不会重复</strong>。</p>
<p>数据中心 ID（Data Center ID）：用于标识不同的数据中心。例如，如果你有多个物理数据中心或服务集群，可以为每个数据中心分配一个唯一的 ID。<br>机器 ID（Worker ID）：用于标识同一数据中心内的不同机器。例如，如果一个数据中心内部有多台服务器或节点，每个节点都会有一个唯一的机器 ID。</p>
<p>Mybatis-Plus 标识位的获取依赖 Mac 地址和进程 PID，虽然能做到尽量不重复，但仍有小几率。<br>标识位如何定义才能不重复？有两种方案：预分配和动态分配。<br>动态分配<br>通过将标识位存放在 Redis、Zookeeper、MySQL 等中间件，在服务启动的时候去请求标识位，请求后标识位更新为下一个可用的。<br>通过存放标识位，延伸出一个问题：雪花算法的 ID 是 <strong>服务内唯一还是全局唯一</strong>。<br>以 Redis 举例，如果要做服务内唯一，存放标识位的 Redis 节点使用自己项目内的就可以；如果是全局唯一，所有使用雪花算法的应用，要用同一个 Redis 节点。</p>
<p>如果没有全局唯一的需求，最好使<strong>ID 服务内唯一</strong>，因为这样可以避免单点问题。</p>
<p>Redis 存储一个 Hash 结构 Key，包含两个键值对：dataCenterId 和 workerId。<br>在应用启动时，通过 Lua 脚本去 Redis 获取标识位。dataCenterId 和 workerId 的获取与自增在 Lua 脚本中完成，调用返回后就是可用的标示位。</p>
<p>具体 Lua 脚本逻辑如下：</p>
<ol>
<li>第一个服务节点在获取时，Redis 可能是没有 snowflake_work_id_key 这个 Hash 的，应该先判断 Hash 是否存在，不存在初始化 Hash，dataCenterId、workerId 初始化为 0。</li>
<li>如果 Hash 已存在，判断 dataCenterId、workerId 是否等于最大值 31，满足条件初始化 dataCenterId、workerId 设置为 0 返回。</li>
<li>dataCenterId 和 workerId 的排列组合一共是 1024，在进行分配时，先分配 workerId。</li>
<li>判断 workerId 是否 !&#x3D; 31，条件成立对 workerId 自增，并返回；如果 workerId &#x3D; 31，自增 dataCenterId 并将 workerId 设置为 0。</li>
</ol>
<p>Leaf 和 百度 Uid 都有实现雪花算法，Leaf 额外提供了号段模式生成 ID。</p>
<p>Snowflake.nextId() 毫秒内下一个ID，if (timestamp &#x3D;&#x3D; this.lastTimestamp) 要等待下一个时间戳 timestamp &#x3D; tilNextMillis(lastTimestamp);</p>
<p>Snowflake snowflake &#x3D; new Snowflake(workId, dataCenterId, isUseSystemClock);<br>标识位是redis占位拿到的，Snowflake就是核心的id生成器</p>
<h3 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h3><p>整个项目一个 topic，下面不同业务（延时消息 异步接口 缓存一致性的订单取消退款等要关单要影响订单表座位表   座位表更新影响余票）不同 tag<br>Topic 命名    业务线_项目名_topic<br>Tag 命名       业务线_项目_业务_tag<br>生产者组命名         业务线_项目_业务_pg<br>消费者组命名         业务线_项目_业务_cg</p>
<p>创建 Topic 需要走线上申请，申请时补充下述信息。</p>
<ol>
<li><p>消息发送<br>1）【强制】<strong>消息生产者创建时，必须指定生产者组</strong>。<br>2）【强制】<strong>一个系统项目对应一个 Topic，系统下的不同业务根据 Tag 区分</strong>，参考申请规范-消费应用 Tag。<br>3）【强制】发送消息时，<strong>需设置 KEYS。KEYS 建议定义为业务唯一标识，比如订单 ID。</strong><br>4）【强制】发送消息不管发送成功或失败，<strong>需打印 KEYS（订单 id 等唯一标识）、Payload（Message）、执行时间以及 SendResult</strong><br>5）【强制】<strong>发送消息时，需设置超时时间，避免应用被拖垮；建议超时时间设置为 2000ms 内。</strong><br>6）【建议】<strong>针对可靠性要求较高的消息，发送失败后可以存储到 DB，开启定时任务扫描，并重新投递。</strong></p>
</li>
<li><p>消息消费<br>1）【强制】<strong>消费端创建时，必须指定消费者组。</strong><br>2）【强制】<strong>消费端需要保证数据幂等。</strong><br>3）【强制】<strong>消费消息不管成功或失败，需打印 KEYS、MsgId、执行时间以及 Message。</strong><br>4）【强制】不同的应用集群应使用不同的消费者组，如果不同的应用集群需要订阅同一消费者组，需保证 Topic Tag 订阅关系一致。<br>5）【强制】引入 easymall-rocketmq-spring-boot-starter <strong>打印消息消费日志。</strong><br><code>log.info(&quot;Execute result: &#123;&#125;, Keys: &#123;&#125;, Dispatch time: &#123;&#125; ms, Execute time: &#123;&#125; ms, Message: &#123;&#125;&quot;, ...);</code><br>6）【建议】消费时尽量不设置重试，<strong>大部分情况下，执行失败的消息重试后会再次失败，反而会影响消费进度。开发者应该针对特定场景在代码中设置重试逻辑。</strong><br>7）【建议】<strong>消费者并发消费数量默认为 1，即串行化</strong>，<strong>应该基于不同系统场景来设置并发数，同时要考虑消费过程中其它组件的压力</strong>。<br>● 系统 CPU 任务少：CPU 核数 &#x2F; (1 - 阻塞系数 0.8) 。<br>● 系统 CPU 任务较多，建议 CPU 核数 + 1 即可。</p>
</li>
</ol>
<h3 id="学一下-rocketmq"><a href="#学一下-rocketmq" class="headerlink" title="学一下 rocketmq"></a>学一下 rocketmq</h3><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>在网关层的过滤器从请求头中拿 token 然后去 redis用户数据，在请求的请求头里放上用户名和用户id，接着请求往后走。</p>
<p>token 是 login 时检查用户是否存在，存在的话就去redis中缓存那个hash结构，然后返回 token（uuid）。<br>login会被网关放行然后去redis放用户实体。<br>其他请求都要经过网关然后被网关在请求头填充信息比如用户名  用户id，方便后面程序获取用户信息。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>定义日志打印注解，可以标记在类或者方法上。<br>标记在类上，类下所有方法都会打印；标记在方法上，仅打印标记方法；如果类或者方法上都有标记，以方法上注解为准。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ILog &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入参打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 打印结果中是否包含入参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">input</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出参打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 打印结果中是否包含出参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">output</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ILog 日志打印实体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ILogPrintDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String beginTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求入参  对应前面的日志注解参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] inputParams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object outputParams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义日志注解 AOP 扫描类，执行方法执行前后增强，最终打印方法执行日志。</span><br><span class="line"><span class="meta">@within</span> 和 <span class="meta">@annotation</span> 注解分别对注解在类上和在方法上增强。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ILogPrintAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@within(org.opengoofy.index12306.framework.starter.log.annotation.ILog) || @annotation(org.opengoofy.index12306.framework.starter.log.annotation.ILog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">printMLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Around 注解是 Spring AOP 的一部分，用于定义一个切面（Advice），它可以在目标方法的执行前后做一些处理。<br>@Around 注解接收一个 Pointcut 表达式。这里的表达式 @within 和 @annotation 用来匹配目标方法。</p>
<p>Pointcut 切点表达式：<br>@within(org.opengoofy.index12306.framework.starter.log.annotation.ILog)：<br>这个表达式用于匹配所有使用了 @ILog 注解的<strong>类中的所有方法</strong>。<br>@annotation(org.opengoofy.index12306.framework.starter.log.annotation.ILog)：<br>这个表达式用于匹配所有使用了 @ILog 注解的<strong>方法</strong>。<br><strong>原来是这么实现的</strong><code>@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</code></p>
<p>这两个表达式通过 || 连接，因此定义的切面将作用于：<br>任何被标注为 @ILog 的类中的所有方法。<br>任何被标注为 @ILog 的单独的方法。</p>
<p>@Around 声明的切面方法或者说增强 Advice <code>printMLog(ProceedingJoinPoint joinPoint)</code> 会包装(Around)目标方法的执行过程，包括执行前和执行后的逻辑。它能够访问<strong>目标方法的参数、返回值，还可以完全控制方法执行的全过程（通过 ProceedingJoinPoint 做到的）</strong>。简单来说， @Around 切面相当于在目标方法的前后都加上了操作，可以灵活地实现日志记录、性能监控、事务管理等功能。</p>
<p>整个流程就是，定义切面类@Aspect<br>public class ILogPrintAspect ，里面写各个增强Advice方法，比如printMLog(ProceedingJoinPoint joinPoint)，它接收 joinpoint 来对目标方法进行处理，Advice上面要写比如 @Around()，它里面就是写 pointcut 切点，比如 @within(org.opengoofy.index12306.framework.starter.log.annotation.ILog) 切使用了 @ILog 注解的类中的所有方法。通过在具体方法中定义的逻辑和joinpoint来达到想要的比如 日志记录 事务管理等功能。</p>
<p>最终打印的日志<br><code>log.info(&quot;[&#123;&#125;] &#123;&#125;, executeTime: &#123;&#125;ms, info: &#123;&#125;&quot;, methodType, requestURI, SystemClock.now() - startTime, JSON.toJSONString(logPrint));</code><br>ServletRequest 的方法 url 执行时间 以及 ILog 日志打印实体转为json。<br>这些实际上都是通过 slf4j <code>Logger log = LoggerFactory.getLogger(methodSignature.getDeclaringType());  // 获得一个命名的日志记录器而已</code> 来打印出来的。</p>
<p>还是很简单的</p>
<h3 id="接口优化"><a href="#接口优化" class="headerlink" title="接口优化"></a>接口优化</h3><p>最小事务原则<br>在之前的购票与创建订单方法中，我们使用了声明式注解的方式开启 数据库本地事务 ，并将事务控制在方法级别。但是，这种设计在某些情况下可能会带来问题。</p>
<p>方法内如果包含与事务无关的操作，例如缓存查询或非必要的数据库查询，这些操作会延长事务的持续时间，进而影响性能和资源占用。因此，我们需要尽量避免将与事务无关的业务逻辑置于事务控制范围内，以减少事务关闭的延迟，提升整体效率。</p>
<p>通过 TransactionTemplate 编程实现事务管理，手动控制事务的开启、提交和回滚。</p>
<ol>
<li>灵活性高 ：事务范围可以精确控制在代码块中，避免无关操作影响事务性能。</li>
<li>降低事务粒度 ：可以针对特定代码块开启事务，而不是整个方法。</li>
</ol>
<p>在购票方法中，将两个缓存查询的操作从原有的执行购票事务中抽离出来。</p>
<p>最大程度减少数据库事务的执行时间。如果事务长时间占用数据库连接资源，会导致数据库整体性能下降，进而影响系统的吞吐量。额外再说一点：除去非必要场景，事务里最好只有增删改的数据库事务操作，缓存、消息队列以及文件等都不要出现在事务里。</p>
<p>吞吐量：Throughput 简称 TPS，吞吐量，默认情况下表示每秒处理的请求数，也就是指服务器处理能力，TPS 越高说明服务器处理能力越好。</p>
<p><strong>v3</strong><br>重点通过引入<strong>消息队列、分布式锁和前端轮询机制</strong>来提升购票系统的吞吐量和用户体验。</p>
<p>首先，当用户在系统中<strong>请求购票时，系统会尝试扣减 Redis 中的令牌。如果扣减成功，系统将立即发送一条消息到消息队列，并向用户返回一个“半成功”状态</strong>。</p>
<p>什么是半成功状态？ “半成功”状态意味着用户<strong>已成功进入排队流程，但尚未完成实际的抢座下单</strong>。<br>因此，用户<strong>在此时并不会直接进入下单页面，而是停留在“等待出票”的页面</strong>。相信有过12306购票经历的用户会熟悉这种状态——即使扣减成功，仍需等待出票确认。</p>
<img src="/2024/09/01/BaGu/17.png" class="">
<p>12306 对购票流程进行了优化，显示了预计的出票等待时间。这样，用户可以清晰地了解排队情况，避免因等待时间过长而产生误解，进而减少取消购票的行为。</p>
<p>消息队列中的消息会由<strong>消费者进行处理，消费者首先获取分布式锁，锁定的是与列车此车次相关的资源（如列车下的座位类型）</strong>。然后，系统会<strong>以单用户串行的方式执行票务处理</strong>，确保不会出现并发冲突。</p>
<p><strong>处理过程中可能出现的问题</strong>： 假设在缓存中扣减令牌时发生了丢失，例如缓存中的票务数据被误删除，导致虽然系统返回成功，但实际上 Redis 中的令牌未被正确扣减。在这种情况下，消息队列消费者在消费消息时，可能无法正确获取剩余座位信息。</p>
<p>为了避免这种情况，系统设计了“出票失败”状态，标记其为“列车与余票不足”。这样，前端在查询订单状态时，能够及时得知用户是否成功出票。</p>
<img src="/2024/09/01/BaGu/18.png" class="">

<p><strong>前端轮询与实时结果反馈</strong><br><strong>前端通过定时任务（如每两秒一次）轮询后端接口，检查用户的出票状态</strong>。若订单创建成功，用户将看到分配的座位；若出票失败，系统则返回“出票失败”信息。</p>
<p>另外，如果对 WebSocket 技术有所了解，还可以实现一种更高效的通信方式：<strong>使用 WebSocket 实现前后端的实时双向通信</strong>，避免频繁的轮询请求。一旦后端完成出票，系统可以实时将结果推送给前端，减少不必要的等待时间。</p>
<p><strong>新的 orderTrackingId 字段，用于标识用户购票后与订单之间的关联关系。</strong><br><strong>通过业务模式规避复杂度</strong><br>.orderTrackingId(SnowflakeIdUtil.nextIdStr()) 用雪花id<br> &#x2F;&#x2F; 返回全局唯一标识，当做用户购票异步返回和订单之间的关联关系</p>
<p>在消息队列消费者逻辑中，我们首先调用原有的购票服务流程，包括<strong>座位分配、座位锁定以及订单创建</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseTicketsConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageWrapper&lt;PurchaseTicketsEvent&gt;&gt; &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageWrapper&lt;PurchaseTicketsEvent&gt; messageWrapper)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户是否创建订单成功构建订单追踪实体</span></span><br><span class="line">        OrderTrackingDO  orderTrackingDO<span class="comment">// 包含订单创建结果和追踪 id</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增订单追踪记录，方便为购票 v3 接口异步下单后的结果提供查询能力 </span></span><br><span class="line">        orderTrackingMapper.insert(orderTrackingDO);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是将<strong>链路追踪 ID 与订单号绑定</strong>，同时记录请求的处理状态，方便用户查看结果。</p>
<p>前端查询<strong>要添加 username 字段</strong>，以防止非登录用户访问其他用户的数据，<strong>避免数据横向越权</strong><br>另外，在实际的 12306 购票过程中，只有在高峰期才会采用此方案。</p>
<p>真实的 12306 放票机制是动态分配中途票和全程票，既不会一次性放出所有票，也不会只放全程票。</p>
<p>吞吐量明显提高，这得益于消息队列的高性能设计。<br>当前接口的瓶颈主要集中在 Redis 和 RocketMQ，其中 RocketMQ 的吞吐量基本决定了购票接口的整体吞吐量。</p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>通常情况下，我们认为消息中间件是一个可靠的组件。这里的可靠性指的是，只要消息被成功投递到了消息中间件，它就不会丢失，至少能够被消费者成功消费一次。这是消息中间件最基本的特性之一，也就是我们通常所说的 “AT LEAST ONCE”，即消息至少会被成功消费一遍。</p>
<p>分布式锁和 Token 令牌应用于防重复提交，去重表应对于消息重复防重复消费场景。<br>分布式锁、Token 令牌以及去重表。<br>● 分布式锁：PARAM 和 SPEL。<br>● Token 令牌：TOKEN。<br>● 去重表：SPEL。</p>
<p>分布式锁<br>当用户提交请求时，服务器端可以生成一个唯一的标识，例如使用 UUID。</p>
<p>去重表是指在使用 Redis 或者 MySQL 作为存储时，<strong>为了实现幂等性而用于记录已经处理过的请求或操作，以防止重复执行</strong>。大部分场景下，大家会使用 Redis 作为去重组件实现。</p>
<p><strong>去重表只是一个说法，存储到 Redis 的话，其实就是一个 String 的 Key 而已。</strong></p>
<p>具体来说，当客户端发送请求时，<strong>服务端会先查询 Redis 去重表来检查该请求是否已经被处理过。</strong>如果在存在对应的记录，表示请求已经执行过，服务端可以直接返回之，而不再执行重复操作。如果在不存在对应的记录，表示请求是新的，服务端会执行相应的业务逻辑，并在处理完成后将请<strong>求的唯一标识（如请求 ID 或标识）添加到 Redis 去重表中</strong>，以便后续的重复请求可以被正确识别和处理。<br><strong>另外，如果消息已经在消费中，抛出异常，消息会触发延迟消费，在消息队列消费失败的场景下即发送到重试队列 RETRY TOPIC。</strong><br>消费失败要延迟重试。</p>
<img src="/2024/09/01/BaGu/19.png" class="">

<p>幂等标识10分钟有效时间。如果消息正在消费，延迟消费，再次通过重试队列投递一段时间后检查并消费。</p>
<p>Idempotent<br>String key() default “”;<br>IdempotentSceneEnum scene()    验证幂等场景，该字段代表了是接口的防重复提交还是消息队列的防重复消费<br>IdempotentTypeEnum type()    记录了使用什么方式实现幂等，其中 TOKEN 和 PARAM 以及 SPEL 都可以应用于接口防重复提交，SPEL 应用于消息队列防重复消费。<br>String uniqueKeyPrefix() default “”;设置防重令牌 Key 前缀，MQ 幂等去重可选设置<br>long keyTimeout() default 3600L;设置防重令牌 Key 过期时间，单位秒，默认 1 小时，MQ 幂等去重可选设置</p>
<p>只讲 SPEL<br>key    uniqueKeyPrefix    keyTimeout</p>
<p>幂等 AOP(注解只支持用在方法上 @Around[@annotation])<br>只需要在需要保证幂等性的方法上添加 @Idempotent 注解，Aspect 就会对该方法进行增强。<br>简单来说，就是先获取到方法上的幂等注解，然后获取到对应的幂等处理实现类。通过实现类进行幂等前置逻辑，执行完后操作具体被注解修饰的方法，最终执行释放资源的后置逻辑。</p>
<p><strong>这段代码好好看，很清晰</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">IdempotentAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增强方法标记 &#123;<span class="doctag">@link</span> Idempotent&#125; 注解逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.opengoofy.index12306.framework.starter.idempotent.annotation.Idempotent)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">idempotentHandler</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取到方法上的幂等注解实际数据</span></span><br><span class="line">        <span class="type">Idempotent</span> <span class="variable">idempotent</span> <span class="operator">=</span> getIdempotent(joinPoint);</span><br><span class="line">        <span class="comment">// 通过幂等场景以及幂等类型，获取幂等执行处理器</span></span><br><span class="line">        <span class="type">IdempotentExecuteHandler</span> <span class="variable">instance</span> <span class="operator">=</span> IdempotentExecuteHandlerFactory.getInstance(idempotent.scene(), idempotent.type());</span><br><span class="line">        Object resultObj;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行幂等处理逻辑</span></span><br><span class="line">            instance.execute(joinPoint, idempotent);</span><br><span class="line">            <span class="comment">// 如果幂等处理逻辑没有抛异常，处理中间业务</span></span><br><span class="line">            resultObj = joinPoint.proceed();</span><br><span class="line">            <span class="comment">// 处理幂等后置逻辑，比如释放资源或者锁之类的</span></span><br><span class="line">            instance.postProcessing();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RepeatConsumptionException ex) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 该异常为消息队列防重复提交独有，触发幂等逻辑时可能有两种情况：</span></span><br><span class="line"><span class="comment">             *    * 1. 消息还在处理，但是不确定是否执行成功，那么需要返回错误，方便 RocketMQ 再次通过重试队列投递</span></span><br><span class="line"><span class="comment">             *    * 2. 消息处理成功了，该消息直接返回成功即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!ex.getError()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 客户端消费存在异常，需要删除幂等标识方便下次 RocketMQ 再次通过重试队列投递</span></span><br><span class="line">            instance.exceptionProcessing();</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理幂等容器上下文</span></span><br><span class="line">            IdempotentContext.clean();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Idempotent <span class="title function_">getIdempotent</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">targetMethod</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getDeclaredMethod(methodSignature.getName(), methodSignature.getMethod().getParameterTypes());</span><br><span class="line">        <span class="keyword">return</span> targetMethod.getAnnotation(Idempotent.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实核心就是用 joinPoint.getSignature() 拿到目标方法签名，然后<br>signature.getMethod();方法签名去拿方法类对象（反射），最后拿到这个方法上的注解 targetMethod.getAnnotation(Idempotent.class);</p>
<p>我们真正的执行幂等处理器是：<br>.getBean(IdempotentSpELByMQExecuteHandler.class) 他这里用简单工厂去拿的对象。整个注解执行流程通过模板方法确定了，就是先 包装 wrap，然后 handler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ProceedingJoinPoint joinPoint, Idempotent idempotent)</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法模式：构建幂等参数包装器  通过各策略实现类获取 IdempotentParamWrapper 参数</span></span><br><span class="line">    <span class="type">IdempotentParamWrapper</span> <span class="variable">idempotentParamWrapper</span> <span class="operator">=</span> buildWrapper(joinPoint).setIdempotent(idempotent);</span><br><span class="line">    handler(idempotentParamWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">IdempotentSpELByMQExecuteHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractIdempotentExecuteHandler</span> <span class="keyword">implements</span> <span class="title class_">IdempotentSpELService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DistributedCache distributedCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">600</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">WRAPPER</span> <span class="operator">=</span> <span class="string">&quot;wrapper:spEL:MQ&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> IdempotentParamWrapper <span class="title function_">buildWrapper</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是那个切面类提供的静态方法用来拿到注解</span></span><br><span class="line">        <span class="type">Idempotent</span> <span class="variable">idempotent</span> <span class="operator">=</span> IdempotentAspect.getIdempotent(joinPoint);</span><br><span class="line">        <span class="comment">// 通过执行 SpEL 表达式获取值</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 噢噢！！我们注解的就是 onMessage(MessageWrapper&lt;PayResultCallbackOrderEvent&gt; message) 这个消息队列的消费消息的方法</span></span><br><span class="line"><span class="comment">         * 所以此时 不管是方法签名的 Method ，还是joinPoint.getArgs()【这个应该就是message，消息，很重要的东西，SPEL表达式的真实值要从它推出来】</span></span><br><span class="line"><span class="comment">         * 所以现在 String key 就是很关键的与这一则消息强相关的可作为去重表的 键</span></span><br><span class="line"><span class="comment">         * 完全理解了哈哈</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) SpELUtil.parseKey(idempotent.key(), ((MethodSignature) joinPoint.getSignature()).getMethod(), joinPoint.getArgs());</span><br><span class="line">        <span class="keyword">return</span> IdempotentParamWrapper.builder().lockKey(key).joinPoint(joinPoint).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(IdempotentParamWrapper wrapper)</span> &#123;</span><br><span class="line">        <span class="comment">// 拼接前缀和 SpEL 表达式对应的 Key 生成最终放到 Redis 中的唯一标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uniqueKey</span> <span class="operator">=</span> wrapper.getIdempotent().uniqueKeyPrefix() + wrapper.getLockKey();</span><br><span class="line">        <span class="comment">// 向 Redis 触发命令，如果值不存在则存储返回 True，值存在返回 False</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">setIfAbsent</span> <span class="operator">=</span> ((StringRedisTemplate) distributedCache.getInstance())</span><br><span class="line">                .opsForValue()</span><br><span class="line">                .setIfAbsent(uniqueKey, IdempotentMQConsumeStatusEnum.CONSUMING.getCode(), TIMEOUT, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 如果值为 False，那么就代表要么消息已经执行完成了或者执行中，两个不同的状态需要执行不同的逻辑</span></span><br><span class="line">        <span class="comment">// 为此，需要再进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (setIfAbsent != <span class="literal">null</span> &amp;&amp; !setIfAbsent) &#123;</span><br><span class="line">            <span class="comment">// 获取幂等标识对应的值，判断是否为已执行成功</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">consumeStatus</span> <span class="operator">=</span> distributedCache.get(uniqueKey, String.class);</span><br><span class="line">            <span class="comment">// 如果已经执行成功了，那么 error 为 false；执行中 error 为 true</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">error</span> <span class="operator">=</span> IdempotentMQConsumeStatusEnum.isError(consumeStatus);</span><br><span class="line">            LogUtil.getLog(wrapper.getJoinPoint()).warn(<span class="string">&quot;[&#123;&#125;] MQ repeated consumption, &#123;&#125;.&quot;</span>, uniqueKey, error ? <span class="string">&quot;Wait for the client to delay consumption&quot;</span> : <span class="string">&quot;Status is completed&quot;</span>);</span><br><span class="line">            <span class="comment">// 将异常抛出到上层</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RepeatConsumptionException</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        IdempotentContext.put(WRAPPER, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以看到触发幂等逻辑时可能有两种情况：</strong>（触发逻辑就是redis中有这个键就会触发，应为即使消息处理了键也没删掉，而只是改状态而已，所以也会触发逻辑，但抛出的异常里面有一个字段专门判断是否是真错误，那抛出异常就会被最顶层的切面类里面的Advice方法 catch 到，于是在那边也会进行判断）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重复消费异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatConsumptionException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误标识</span></span><br><span class="line"><span class="comment">     * 触发幂等逻辑时可能有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 消息还在处理，但是不确定是否执行成功，那么需要返回错误，方便 RocketMQ 再次通过重试队列投递</span></span><br><span class="line"><span class="comment">     * 2. 消息处理成功了，该消息直接返回成功即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Boolean error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 error 为 true，代表需要抛异常让 RocketMQ 重试。<br>如果 error 为 false，代表消息已经消费过了，不执行业务逻辑，将异常吞掉返回 RocketMQ 消费成功即可。</p>
<p>能保障永久幂等么？<br><strong>不能设置永久幂等</strong>，因为 Redis 内存资源比较珍贵，如果长时间保存幂等 Key，会造成 Redis 内存占用增加。<br>业务需要评估自己的消息队列消费情况，如果队列消费量级很高，keyTimeout 不能设置过长时间。设置 keyTimeout 时间过长，这意味着幂等 Key 将会长时间占用 Redis 内存。<br><strong>我用的10分钟</strong></p>
<p>如果获取到了幂等标识，然后正常业务逻辑也执行成功了，会调用 instance.postProcessing(); <strong>将幂等标识的完成状态设置为已完成。</strong></p>
<p><strong>以支付结果回调订单消费者举例，业务很简单，就是用户支付成功，需要进行订单状态反转等逻辑操作</strong>。支付完也是用消息队列投递的</p>
<p>注意这里 <code>key = &quot;#message.getKeys()+&#39;_&#39;+#message.hashCode()&quot;</code> 这个message的key，实际上它是<strong>符合消息发送的规范的，每条消息不仅要携带消息题，还要携带这个消息的关键标识</strong>，比如订单 id。而且这里用了装饰器模式将这个消息进行包装，getkey就是获得这个订单 id。  <code>public void onMessage(MessageWrapper&lt;PayResultCallbackOrderEvent&gt; message)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = OrderRocketMQConstant.PAY_GLOBAL_TOPIC_KEY,</span></span><br><span class="line"><span class="meta">        selectorExpression = OrderRocketMQConstant.PAY_RESULT_CALLBACK_TAG_KEY,</span></span><br><span class="line"><span class="meta">        consumerGroup = OrderRocketMQConstant.PAY_RESULT_CALLBACK_ORDER_CG_KEY</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayResultCallbackOrderConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageWrapper&lt;PayResultCallbackOrderEvent&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Idempotent(</span></span><br><span class="line"><span class="meta">            uniqueKeyPrefix = &quot;index12306-order:pay_result_callback:&quot;,</span></span><br><span class="line"><span class="meta">            key = &quot;#message.getKeys()+&#x27;_&#x27;+#message.hashCode()&quot;,</span></span><br><span class="line"><span class="meta">            type = IdempotentTypeEnum.SPEL,</span></span><br><span class="line"><span class="meta">            scene = IdempotentSceneEnum.MQ,</span></span><br><span class="line"><span class="meta">            keyTimeout = 7200L</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageWrapper&lt;PayResultCallbackOrderEvent&gt; message)</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前缀 key ： index12306-order:pay_result_callback: 订单支付结果回调。</p>
<p>key 里面的那个参数”#message.getKeys()+’_’+#message.hashCode()”,是不清楚是什么的，这个就是 SpEL 表达式，Spring 提供的自然语言表达式。<br><strong>SpEL（Spring Expression Language）是 Spring 框架提供的一种表达式语言，用于在运行时评估表达式</strong>。它支持在 Spring 应用程序中进行动态求值和访问对象的属性、方法调用、运算符操作等。<strong>我们这里就用到了</strong></p>
<p>主要是用 方法调用和属性访问。<br>SpEL表达式的语法类似于其他编程语言的表达式语言，具有以下特点：</p>
<ol>
<li>属性访问：可以使用点号（.）来访问对象的属性，例如 person.name。</li>
<li>方法调用：可以通过在表达式中使用方法名和参数来调用对象的方法，例如 person.getName()。</li>
</ol>
<p>所以我们的key 主要是针对消息队列的 message（当然，这里可能是包装了才能调用这些方法）<br>第一部分，通过请求入参 message 对象，获取属性 keys 值，然后再获取 message 对象的 hashCode 值，通过 _ 的方式拼接在一起，就得到了本次请求的唯一幂等 Key。</p>
<h3 id="学习-ShardingSphere"><a href="#学习-ShardingSphere" class="headerlink" title="学习 ShardingSphere"></a>学习 ShardingSphere</h3><p>从可用性的方面来讲，<strong>应用服务的无状态性，能够达到较小成本的随意扩容</strong>，这必然导致系统的最终压力都落在数据库之上。 而单一的数据节点，或者简单的主从架构，已经越来越难以承担。数据库的可用性，已成为整个系统的关键。</p>
<p>分库和分表<strong>均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈（一般来讲，单一数据库实例的数据的阈值在 1TB 之内，是比较合理的范围。）</strong>。 除此之外，<strong>分库还能够用于有效的分散对数据库单点的访问量</strong>；分表虽然无法缓解数据库压力，但却能够<strong>提供尽量将分布式事务转化为本地事务的可能(比如问你为什么分库了还要分表)<strong>，</strong>一旦涉及到跨库的分布式更新操作</strong>，分布式事务往往会使问题变得复杂。</p>
<p><strong>垂直分库</strong>：比如：电商库 mall_db，业务拆分后就是 user_db、order_db、pay_db… <strong>按照业务拆分</strong>，又称为纵向拆分，它的核心理念是专库专用。在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。<br><strong>它和垂直分表其实区别很大</strong>，比如：<strong>订单表 order_table，拆分后就是 order_table 以及 order_ext_table</strong>。<strong>通常用在冷热分离</strong>。拆分后每个表的数据量变小（减少了字段数嘛），查询时涉及的磁盘 I&#x2F;O 次数相对减少，提高了查询效率。每个小表的并发写入操作相对较少，<strong>减少了数据库锁的竞争，提高了并发能力</strong>。</p>
<p><strong>核心问题：什么场景分表</strong><br>业务的增长量以及历史数量 或者 <strong>数据库表对应的磁盘文件过大</strong>。<br>Q：多少数据量进行分表？<br>A：单表 1000w 是否要分表？回答不够标准。<strong>假设一个表里 15 个字段，没有特别大的值（不包含 text 或其它超长度的列）数据量超过 5000 万了，依然很丝滑，因为走索引</strong>。（<strong>以后这种量级问题别乱答了</strong>）<br>真正需要考虑的是：<strong>业务的增长量以及历史数量</strong>。</p>
<p>Q：物理文件过大，会有什么问题？<br>A：<strong>会影响公司对数据库表的一个备份</strong>。数据库表文件过大，也间接证明表数据过大，增加或删除字段导致锁表的时间过长。</p>
<p>什么场景分库？<br><strong>当数据库的连接不够客户端使用时</strong>，可以考虑<strong>分库或读写分离</strong>。<br>如果<strong>说当数据库的 QPS 越来越高并且(注意这个并且)数据量越来越大的时候，就需要考虑分库分表</strong>。</p>
<p>当 MySQL 连接不够用时，可能会报错 “Too many connections” 或者类似的错误。这是因为 MySQL 服务器同时可以处理的连接数量是有限制的，当连接数达到这个限制时，服务器就会拒绝新的连接请求，并返回这个错误消息。</p>
<p><strong>什么场景分库分表？</strong><br>高并发写入场景：当应用面临高并发的写入请求时，单一数据库可能无法满足写入压力，此时可以将数据按照一定规则拆分到多个数据库中，每个数据库处理部分数据的写入请求，从而提高写入性能。<br>数据量巨大场景：随着数据量的不断增加，单一数据库的存储和查询性能可能逐渐下降。此时，可以将数据按照一定的规则拆分到多个表中，每个表存储部分数据，从而分散数据的存储压力，提高查询性能。</p>
<hr>
<p>Apache ShardingSphere 是一款分布式的数据库生态系统， <strong>可以将任意数据库转换为分布式数据库</strong>，并通过<strong>数据分片</strong>、弹性伸缩、<strong>加密</strong>等能力对原有数据库进行增强。</p>
<p>Apache ShardingSphere 设计哲学为 Database Plus，旨在<strong>构建异构数据库上层的标准和生态</strong>。 它关注如何<strong>充分合理地利用数据库的计算和存储能力</strong>，而并非实现一个全新的数据库。 它站在数据库的上层视角，关注它们之间的协作多于数据库自身。</p>
<p>ShardingSphere 有两个产品在企业中广泛使用，分别是 ShardingSphere-JDBC 以及 ShardingSphere-Proxy。</p>
<p>ShardingSphere-JDBC</p>
<p>定位为轻量级Java框架，<strong>在Java的JDBC层提供的额外服务</strong>。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，<strong>可理解为增强版的JDBC驱动</strong>，完全兼容JDBC和各种ORM框架。</p>
<p>ShardingSphere-Proxy</p>
<p>ShardingSphere-Proxy 定位为<strong>透明化的数据库代理端</strong>，通过实现数据库二进制协议，对异构语言提供支持。 目前提供 MySQL 和 PostgreSQL 协议，透明化数据库操作，对 DBA 更加友好。<br><strong>向应用程序完全透明，可直接当做 MySQL&#x2F;PostgreSQL 使用</strong>；</p>
<h3 id="业务难题"><a href="#业务难题" class="headerlink" title="业务难题"></a>业务难题</h3><p>感觉大家在回答设计12306票务系统的时候总是倾向于硬设计。真实情况下一趟列车的放票逻辑是（对于刚放票阶段）以区间为基础放票的，也就是围绕几个大型铁路枢纽形成的区间来分别独立预留车票（比如春运期间为了保障长途旅客，一趟车只有过了某某站才有对应的票可买，而同趟车短途其实是完全不放票的）。这样就把一趟车沿途几十个车站的全排列组合变成只有4、5个区间之间的特定组合（一只手能数的过来的组合数量），复杂度立刻降了下来。对于某个区间内的不同站点，只要大区间定下来，剩下的部分就是区间外的部分即两头的小区间，那么则可以转换成短途的席位，而此时短途席位的需求反而并不是很抢手。这就把单次下单复杂的计算问题变为拆成不同阶段的简单库存问题。再加上不同日期、不同车次之间也可以分开处理（对于联程需要考虑多段之间的票务问题），可以进一步减少复杂度。我个人是比较反对先预设好使用某些技术，后看问题本身。优化问题本身往往会比使用某些非常复杂的技术带来的效果大得多。</p>
<p>大概意思可能是。abc这个顺序站点。共100个座位。实际上他放票是先放了60张a-c的票和各20张ab,bc的票<br>也就是实际上a-c有100个座位。但是你想买ab的就只有20张。买ac反而有60张。12306也的确这样设计了</p>
<h2 id="短链接-1"><a href="#短链接-1" class="headerlink" title="短链接"></a>短链接</h2><p>当我们修改了<strong>短链接分组</strong>时，需要获取写锁；当我们自增短链接监控记录全局访问 PV、UV、UIP 时，获取读锁。</p>
<p>当我们修改了短链接分组时，需要获取写锁；当我们自增短链接监控记录全局访问 PV、UV、UIP 时，获取读锁（其实就是访问短链接之后要自增短链接各自的监控信息）。<br>为什么需要读写锁？<br>因为如果 Gid 变更后，新增短链接监控拿的还是旧的 Gid 去自增监控记录就会统计错误问题。</p>
<p>还是线程安全问题</p>
<ol>
<li>线程 A 将短链接分组从 6688ja 变更为 8866ja。注意，这个是准备要修改，还没有执行成功；</li>
<li>同时记录短链接监控线程 B 获取短链接分组为 6688ja，准备进行自增 PV、UV、UIP 数据；</li>
<li>此时线程 A 将短链接分组成功将 6688ja 变更为 8866ja；</li>
<li>线程 B 自增短链接 PV、UV、UIP 开始执行，但执行失败，因为已经没有了对应短链接的 6688ja 分组。</li>
</ol>
<h1 id="ENDB"><a href="#ENDB" class="headerlink" title="ENDB"></a>ENDB</h1><p>MYDB 分为后端和前端，前后端通过 socket 进行交互。<br>前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。<br>MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：</p>
<p>Transaction Manager（TM）<br>Data Manager（DM）<br>Version Manager（VM）<br>Index Manager（IM）<br>Table Manager（TBM）</p>
<img src="/2024/09/01/BaGu/1.jpg" class="">

<h2 id="TM-事务管理器"><a href="#TM-事务管理器" class="headerlink" title="TM 事务管理器"></a>TM 事务管理器</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>TM 通过维护 XID 文件(mydb.xid)来维护事务的状态。</p>
<p>事务三种状态：<br>active，正在进行，尚未结束<br>committed，已提交<br>aborted，已撤销（回滚）</p>
<p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 <code>(xid-1)+8</code> 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。(当一些非事务操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。<strong>XID 为 0 的事务的状态永远是 committed</strong>。)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XID文件头长度</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 每个事务的占用长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务的三种状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>TM 提供接口供其他模块来管理某个事务，以及<strong>接口的两个静态方法</strong> <code>create()</code> 和 <code>open()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 xid 文件并创建 TM</span></span><br><span class="line">    <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">create</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从一个已有的 xid 文件来创建 TM</span></span><br><span class="line">    <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">open</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransactionManagerImpl(RandomAccessFile raf, FileChannel fc) &#123;</span><br><span class="line">    <span class="built_in">this</span>.file = raf;</span><br><span class="line">    <span class="built_in">this</span>.fc = fc;</span><br><span class="line">    counterLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    checkXIDCounter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>checkXIDCounter()</code> 读取 XID 文件头中记录的事务的个数（xidCounter），根据它计算文件的理论长度，对比 XID 文件实际长度校验文件是否合法。</p>
<hr>
<p><code>begin()</code> 方法会开始一个新事务（xidCounter+1），具体的，一共两处对 xid 文件的操作：1、设置 xidCounter+1 事务的状态为 active；2、更新文件头中 xidCounter 自增。</p>
<p><strong>文件操作在执行后都需要立刻刷入文件中</strong>，防止在崩溃后文件丢失数据，fileChannel 的 <code>force()</code> 方法，强制同步缓存内容到文件中，类似于 BIO 中的 <code>flush()</code> 方法。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。这里选择 false ，即 <code>fc.force(false)</code> 。</p>
<h2 id="DM-数据管理器"><a href="#DM-数据管理器" class="headerlink" title="DM 数据管理器"></a>DM 数据管理器</h2><p>DM 直接管理数据库 .db 文件和 .log 日志文件。<br>DM 的主要职责有：</p>
<ol>
<li>分页管理 DB 文件，并进行缓存；</li>
<li>管理日志文件，保证在发生错误时可以根据日志进行恢复；</li>
<li>抽象 DB 文件为 <strong>DataItem</strong> 供上层模块使用，并提供缓存。</li>
</ol>
<p>DM 的功能其实可以归纳为两点：<strong>上层模块和文件系统之间的一个抽象层，向下直接读写文件，向上提供数据的包装</strong>(都提供了缓存)；另外就是日志功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn exec:java -Dexec.mainClass=<span class="string">&quot;top.guoziyang.mydb.backend.Launcher&quot;</span> -Dexec.args=<span class="string">&quot;-create D:\\Program_File\\IdeaProjects\\ENDB\\tmp\\mydb&quot;</span></span><br><span class="line"></span><br><span class="line">mvn exec:java -Dexec.mainClass=<span class="string">&quot;top.guoziyang.mydb.backend.Launcher&quot;</span> -Dexec.args=<span class="string">&quot;-open D:\\Program_File\\IdeaProjects\\ENDB\\tmp\\mydb&quot;</span></span><br><span class="line"></span><br><span class="line">mvn exec:java -Dexec.mainClass=<span class="string">&quot;top.guoziyang.mydb.client.Launcher&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn exec:java -Dexec.mainClass=<span class="string">&quot;com.strumcode.endb.backend.Launcher&quot;</span> -Dexec.args=<span class="string">&quot;-create D:\\Program_File\\IdeaProjects\\ENDB\\tmp\\mydb&quot;</span></span><br><span class="line"></span><br><span class="line">mvn exec:java -Dexec.mainClass=<span class="string">&quot;com.strumcode.endb.backend.Launcher&quot;</span> -Dexec.args=<span class="string">&quot;-open D:\\Program_File\\IdeaProjects\\ENDB\\tmp\\mydb&quot;</span></span><br><span class="line"></span><br><span class="line">mvn exec:java -Dexec.mainClass=<span class="string">&quot;com.strumcode.endb.client.Launcher&quot;</span></span><br></pre></td></tr></table></figure>

<p>服务器部署 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ENDB-<span class="number">1.0</span>-SNAPSHOT-jar-with-dependencies.jar -open tmp/mydb &gt; logs/ENDB.file <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line">tail -f logs/ENDB.file</span><br></pre></td></tr></table></figure>
<p>其中<br>nohup 命令用于在用户退出会话或终端时继续运行给定的命令。如果你运行一个程序并关闭终端，那么这个程序会停止。加上 nohup 后，即使关闭终端，程序也会继续运行。<br>2&gt;&amp;1：将标准错误输出重定向到标准输出。这意味着标准错误（通常是错误或警告信息）将与标准输出合并，且一起写入到 logs&#x2F;shortlink-aggregation.file 文件中。<br>&amp;：表示在后台运行该命令。这使得你可以在启动程序后继续在当前终端窗口中操作，而不会被运行的程序阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table test_table id int32, value int32 (index id)</span><br><span class="line">insert into test_table values 10 33</span><br><span class="line">select * from test_table where id=10</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">insert into test_table values 20 34</span><br><span class="line">commit</span><br><span class="line">select * from test_table where id&gt;0</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">delete from test_table where id=10</span><br><span class="line">abort</span><br><span class="line">select * from test_table where id&gt;0</span><br><span class="line"></span><br><span class="line">delete from test_table where id=10</span><br><span class="line">select * from test_table where id&gt;0</span><br><span class="line"></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>





























<h1 id="面试拷打"><a href="#面试拷打" class="headerlink" title="面试拷打"></a>面试拷打</h1><h2 id="腾讯-cdg-一面"><a href="#腾讯-cdg-一面" class="headerlink" title="腾讯 cdg 一面"></a>腾讯 cdg 一面</h2><p>用用户id 分表了怎么用 订单id去查（基因分片）</p>
<p>如果已经 用户 id 和 订单 id分表了，接下来要用商家 id 查怎么办（数据异构，ES？多查询条件）</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这里的数据异构指的是什么？ES中的数据是存放在内存的吗？以为什么通过ES可以避免读扩散？如果全部数据都在ES中，可以多条件查询没错，但开始的分库分表好像没意义了吧？</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 数据异构指的是什么？</span><br><span class="line">数据异构是指将数据从一种形式或数据源转换为另一种形式或数据源。在这个上下文中，指的是将关系型数据库中的订单数据同步或复制到 ElasticSearch 中。因为结构化数据在 ElasticSearch 中会有不同的使用和存储方式，诸如通过映射（mapping）定义字段类型和索引用途。</span><br><span class="line"><span class="bullet">2.</span> ES 中的数据是存放在内存的吗？</span><br><span class="line">ElasticSearch 中的数据主要存储在磁盘上，而不是内存中。然而，ElasticSearch 通过 Lucene 实现了一种强大的索引和搜索技术，其中部分索引数据和热点数据会缓存到内存中，以提高查询速度。因此，虽然数据的主存储介质是磁盘，但会对内存进行优化和利用。</span><br><span class="line"><span class="bullet">3.</span> 为什么通过 ES 可以避免读扩散？</span><br><span class="line">读扩散问题通常是指在分库分表的数据库架构中，查询某些条件下的数据需要访问多个数据库分片，导致大量分布式读操作。而 ElasticSearch 通过将数据复制到一个索引中并进行优化的数据结构处理，可以在一个查询中高效地完成复杂查询，避免了多次读操作。例如，通过在 ElasticSearch 中根据商家 ID 进行查询，可以在单一位置快速检索所有相关订单，而无需遍历和汇总多个数据库分片的数据。</span><br><span class="line"><span class="bullet">4.</span> ElasticSearch 各种查询示例</span><br><span class="line">由于 ElasticSearch 存储的是全文索引数据，它可以高效地进行多条件、全文搜索等复杂查询，加速了数据的检索过程。例如：</span><br><span class="line"></span><br><span class="line"><span class="code">```json</span></span><br><span class="line"><span class="code">GET /orders/_search</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">  &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="code">    &quot;bool&quot;: &#123;</span></span><br><span class="line"><span class="code">      &quot;must&quot;: [</span></span><br><span class="line"><span class="code">        &#123; &quot;match&quot;: &#123; &quot;merchant_id&quot;: &quot;67890&quot; &#125;&#125;,</span></span><br><span class="line"><span class="code">        &#123; &quot;range&quot;: &#123; &quot;order_total&quot;: &#123; &quot;gte&quot;: 50 &#125;&#125;&#125;,</span></span><br><span class="line"><span class="code">        &#123; &quot;match_phrase&quot;: &#123; &quot;order_status&quot;: &quot;已发货&quot; &#125;&#125;</span></span><br><span class="line"><span class="code">      ]</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">  &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在上述查询中，会通过商家 ID、总金额大于等于 50、以及订单状态为 “已发货” 来检索订单数据，这是在传统数据库中通过复杂的 SQL 或多次分库查询难以高效完成的。<br>5. 分库分表是否还有意义？<br>分库分表的意义在于分散数据库写入压力和提升单库的扩展性。即使全部数据都同步到了 ElasticSearch 中，用于查询加速和读操作优化，分库分表的设计依然可以有效缓解数据库写入时的瓶颈问题，并且在数据量巨大时也有助于进行水平扩展。<br>ElasticSearch 主要用于提升读性能并优化查询操作，而分库分表则针对具体的写入性能和数据分片负责。当二者结合使用时，可以获得读写性能的双重优化：数据库进行高效写入，ElasticSearch 进行高效读操作。<br>整体来看，通过数据同步到 ElasticSearch 进行查询，减少数据库的读负担，从而有效减少读扩散问题，同时保持数据库和 ElasticSearch 各自优势和职责。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">springboot 启动过程？AOP是在哪个过程实现的？</span><br><span class="line"></span><br><span class="line">线程池，怎么往线程池提交任务，具体执行api过程是什么，原理？</span><br><span class="line"></span><br><span class="line">腾讯新闻能不能访问我（有公网ip）</span><br><span class="line"></span><br><span class="line">binlog没写，写了redolog最后有效果没？</span><br><span class="line"></span><br><span class="line">子网掩码是干嘛的？</span><br><span class="line"></span><br><span class="line">json 传二进制数据</span><br><span class="line"></span><br><span class="line">jvm 命令 查看内存、查看线程状态</span><br><span class="line"></span><br><span class="line">线程池的队列有哪些</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">无语了呀，ES那个就这么简单，因为没想出来已经分库分表了为什么还要把数据放到ES中就没说，你可真是的，它们根本不是一个概念。在快结束的时候为什么不再补充一下？还有 jstack 它只要跟一个 pid 就可以了，你为什么不说？下次要勇敢说。不要错过机会。</span><br><span class="line"></span><br><span class="line">***一定要敢说，不说，这就是你的最后一次面试，一定要拼尽全力，自信起来啊不能怂，不要一直盯着腾讯***</span><br><span class="line"></span><br><span class="line">老子他妈是真生气了，操他妈的，那中间表路由表不就很对吗？为什么要搞我！！！！！！！！！我他妈后槽牙都要咬碎了。</span><br><span class="line">这种中间表或者冗余表又叫异构索引表。呵呵呵你想笑死我吗【这种冗余表我们称为异构索引表, 我们通常是建议冗余索引, 不冗余其它订单信息, 否则订单同步的又需要同步这些冗余表维护成本就不小了。】【例如淘宝的商品搜索，很多维度，这时单纯使用SQL是比较困难的， 可以考虑ElasticSearch 和Solr商品录入时做多维度的索引。】</span><br><span class="line">你知道个 jstack 为什么不说！</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">## 分布式数据库 doris 面试</span><br><span class="line"></span><br><span class="line">很多 jvm 命令，自定义类加载器，不指定父加载，从而加载一个类两次</span><br><span class="line">dump 查看 内存泄漏（某个类占用多少堆内存），cpu占用高排查，</span><br><span class="line"></span><br><span class="line">分布式数据库有分区（类似分库分表？），不分区的话似乎可以忽略读扩散，因为他们在 sql 解析层优化层处理好了？</span><br><span class="line"></span><br><span class="line">什么时候 full gc，设置使用 g1，</span><br><span class="line"></span><br><span class="line">atomic 底层</span><br><span class="line"></span><br><span class="line">虚引用</span><br><span class="line"></span><br><span class="line">二面</span><br><span class="line"></span><br><span class="line">查看磁盘 io 速率，看进程 io 使用量</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 腾讯 teg 一面</span><br><span class="line"></span><br><span class="line">最大滑动窗口</span><br><span class="line">最大连续子数组和， left 和 right 都要</span><br><span class="line"></span><br><span class="line">进程 线程</span><br><span class="line">线程 协程，协程具体好在哪（不需要内核态切换）</span><br><span class="line">创建线程（Executor隐式 executor.submit(() -&gt; System.out.println(&quot;Executor running&quot;));）</span><br><span class="line">线程池的线程数怎么设置</span><br><span class="line">一定要四次挥手吗（三次）</span><br><span class="line">msl 具体时间怎么定 已知 ip 层 64 跳</span><br><span class="line">java 的锁 （我几乎全说了）</span><br><span class="line">handlemapping怎么来的 </span><br><span class="line">热上线 （线程池中还有任务，我要上线新版本，怎么办）</span><br><span class="line">大量 syn 请求的上限在哪 </span><br><span class="line">如何提高项目并发，和上面那个有联系，接着它问的 </span><br><span class="line">mysql 插入数据能看到吗</span><br><span class="line">linux 找一个文件 a.txt </span><br><span class="line">打印日志中 error 的那几行</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">解答</span><br><span class="line"></span><br><span class="line">在代码已经上线的情况下，对正在运行的线程池执行 shutdown 相对不太合适。这时可以通过热部署（Rolling Deployment）实现新的代码版本上线，同时确保服务的连续性，以保证用户体验不受影响。</span><br><span class="line">一、热部署（Rolling Deployment）原理</span><br><span class="line">热部署也叫滚动部署，指在不中断服务的情况下逐步替换旧版本代码，将新版本代码上线的过程。其基本原理是逐步将流量从旧版本切换到新版本，具体过程如下：</span><br><span class="line">多实例服务：运行多个服务实例（如应用服务器），确保服务的可靠性。</span><br><span class="line">负载均衡：利用负载均衡器（如 Nginx），实现流量在实例间的分发。</span><br><span class="line">逐步替换：逐个替换服务实例，旧实例停止后，新实例启动，确保流量逐步切换到新版本。</span><br><span class="line">监控与健康检查：实施实时监控，确保新版本实例正常运行。</span><br><span class="line"></span><br><span class="line">轮询（Round Robin）、带权重轮询、最少连接（Least Connections）IP 、哈希（IP Hashing）</span><br><span class="line">更新负载均衡配置，逐步添加新的实例，并逐步移除旧版本实例。</span><br><span class="line">```java</span><br><span class="line">upstream backend &#123;</span><br><span class="line">    server old-version.example.com weight=1;</span><br><span class="line">    server new-version.example.com weight=9;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不停服务的情况下重新载入 Nginx 配置，确保更新生效。<br>nginx -s reload</p>
<p>locate 使用预先构建的数据库，比 find 更快。也可以用来找目录。<br>创建一个文件之后，updatedb 后面就可以用 locate 很快找到文件。<br>locate a.txt</p>
<p>打印日志中 error 的那几行？<br>使用 grep 加入上下文行选项来打印日志中包含 “error” 的行及其上下文：<br>显示包含 “error” 的行（ -n 表示行号也能显示）<br>grep -n ‘error’ logfile.log</p>
<p>显示包含 “error” 的行及其上下文<br>grep -C 5 ‘error’ logfile.log # 打印上下文各5行</p>
<p>grep -rl ‘error’  这个是列出文件内容包含’error’的文件的名字，r是递归，l是列出名字。  这个估计也很常用（rl 要带）</p>
<p>用来查找文件和目录的工具<br>find [搜索路径] [搜索条件]</p>
<p>查找名为 a.txt 的文件：<br>find &#x2F;path&#x2F;to&#x2F;search -name “a.txt”</p>
<p>查找所有普通文件：<br>find &#x2F;path&#x2F;to&#x2F;search -type f<br>f 是普通文件、p是管道文件(mkfifo mypipe创建有名管道)、 d是文件夹</p>
<p>查找大于 100MB 的文件：<br>find &#x2F;path&#x2F;to&#x2F;search -size +100M</p>
<p>大量 syn 请求的上限在哪<br>方式一：调大 netdev_max_backlog<br>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：(相当于一个缓冲数据包的队列)</p>
<p>方式二：增大 TCP 半连接队列<br>增大 TCP 半连接队列，要同时增大下面这三个参数：</p>
<p>方式三：开启 net.ipv4.tcp_syncookies(这个重要)</p>
<p>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p>
<p>因为是 收到一个syn的时候会把这个请求连接放到半连接队列，队列满了就会丢弃收到的syn报文。</p>
<p>所谓绕过就是：收到syn不丢弃，根据算法算出一个 cookie，放到第二次握手报文的序列号里，当服务端收到第三次握手的ack时检查这个ack的合法性，合法就把这个连接直接放到全连接队列【accept】里。当客户端发起连接请求时都是服务端通过accept调用从队列中拿出连接。</p>
<p>客户端    服务端<br>                bind<br>                listen<br>connect<br>    三次握手<br>                accept<br>write<br>                read</p>
<p>方式四：减少 SYN+ACK 重传次数<br>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。</p>
<p>那么针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</p>
<h2 id="teg-二面"><a href="#teg-二面" class="headerlink" title="teg 二面"></a>teg 二面</h2><p>聊了两个小时，给我聊破防了。</p>
<p>基本都防出去了</p>
<p>redis 多线程那里差了点</p>
<p>redis 选型做幂等处理那里也不太好，用mysql也不好，被问到选型有没有多了解一下数据库。</p>
<h2 id="快手一面"><a href="#快手一面" class="headerlink" title="快手一面"></a>快手一面</h2><p>事务消息</p>
<p>时间环（消息队列怎么实现任意延时的消息）</p>
<p>幂等一定要实现在mysql里面，因为redis和mysql不是强一致的，不能做到ACID，所以去重表做在 mysql。可以在 aop 里面去写数据库，但aop和原方法没法用事务圈起来，面试官说方法挺多，可以是用 threadlocal，aop在里面放信息(解析SPEL得到的信息 )，原方法去查，然后写数据库？<br>redis通常是作为辅助作用，高性能但可能在一些严格场景下不能用。MySQL 支持事务，可以确保去重表操作的原子性，适合长期保留处理记录但不建议用于高频操作。</p>
<p>i++ 偏要实现多线程计数，但是不想使用那些串行化的互斥锁</p>
<p>LongAdder 分段</p>
<h2 id="快手二面"><a href="#快手二面" class="headerlink" title="快手二面"></a>快手二面</h2><p>其他公司对mysql的改进</p>
<p>endb死锁检测怎么提高性能</p>
<p>发消息怎么保证可靠性，用事务消息配合写db</p>
<p>canal 做缓存一致性的可靠性怎么保证</p>
<p>又问到事务消息</p>
<p>解决</p>
<p>事务请求资源：当一个事务请求获取一个资源的锁定时，MySQL会检查该资源是否被其他事务占用。如果资源已被其他事务占用，该事务会被阻塞并等待。</p>
<p>等待图构建：当事务等待一个被其他事务占用的资源时，MySQL会在等待图中添加一条从当前事务到被等待事务的边。这样，等待图会反映出事务之间的依赖关系。</p>
<p>环检测：<strong>MySQL定期检查等待图是否存在环</strong>。它使用图算法（如深度优先搜索）遍历等待图，寻找环的存在。如果找到了环，说明发生了死锁。</p>
<p>死锁解决：<strong>一旦检测到死锁，MySQL会选择一个事务作为牺牲者，并回滚该事务，释放其持有的资源。牺牲者事务的回滚会打破死锁</strong>，并允许其他事务继续执行。</p>
<p><strong>我们层面可以做的</strong><br>设置<strong>合理的等待超时时间</strong>：通过设置合理的innodb_lock_wait_timeout参数来控制事务等待锁的最长时间，当超过这个时间后，事务会被自动回滚，从而避免死锁。<br>[<strong>死锁避免算法</strong>]避免循环等待：<strong>确保应用程序在请求锁的顺序上保持一致性</strong>，避免出现循环等待的情况，即事务A等待事务B释放锁，而事务B又等待事务A释放锁，这种情况会导致死锁。<br>在某些情况有用，挺多情况估计效果也一般。</p>
<p>定期检查事务之间的锁关系，以检测是否存在死锁是核心</p>
<p>果然还是遍历，妈的面试官诈我。</p>
<p>MySQL官方提供了InnoDB引擎下，事务死锁的主动检测与丢弃机制，官方允许通过innodb_deadlock_detect这个参数进行控制，默认开启。同时如果禁用此选项，依旧可以通过锁超时参数innodb_lock_wait_timeout来进行控制。<br>对于主动检测到死锁后的丢弃，官方说明是丢弃小事务，此处大小的衡量依据是插入、更新、删除操作受影响的行数。<br>如果开启了死锁检测，那么在每次上锁之前，都会进行一次死锁检测，底层使用图遍历算法，对于并发量比较高的应用，每次进行死锁检测的消耗累积起来还是比较高。<br>图遍历中，过于深的检测会指数级递增的影响检测效率，这方面，MySQL限制最大为200，超过200则事务被认定为死锁，发起死锁检测的事务被回滚。</p>
<p>leaf 分布式 id</p>
<h2 id="pdd-一面"><a href="#pdd-一面" class="headerlink" title="pdd 一面"></a>pdd 一面</h2><p>1、 线程池中任务抛出异常会怎样？<br>任务抛出异常：当任务在线程池中抛出未被捕获的异常，<strong>这个异常会终止任务</strong>，<strong>线程池会记录异常，但线程池本身不会被终止</strong>。并且默认情况下，抛出异常的线程会被线程池重新利用。可以通过使用Future对象捕获并处理任务抛出的异常。</p>
<p><strong>理解 “线程池会记录这个异常”</strong></p>
<p>2、 一个任务提交给线程池中的线程，然后这个线程又提交一个任务给线程池，会有什么问题？</p>
<p>a. 死锁<br>如果线程池的线程数量有限，并且新的任务需要执行的线程恰好被已经执行的任务占用，就会导致死锁。<br>例如，一个单线程的线程池中只有一个线程，如果这个线程在执行任务 A 时提交任务 B，<strong>并等待任务 B 结束</strong>（future.get()），就会发生死锁。<br>【面试官诈我说不是有拒绝策略吗？如果队列还有空间就不会触发拒绝策略，<strong>但是注意，如果原任务不是阻塞等待这个子任务，就不会死锁，但还是会有b问题</strong>】</p>
<p>b. 线程池的任务堆积<br>如果线程池的线程数量有限，且任务提交速度高于任务执行速度，新的任务会堆积在任务队列中，可能最终导致任务队列的耗尽或内存不足。<br>【你已经用了一个线程，结果你又提交任务，这个子任务可能又用一个线程去执行，<strong>那此时相当于你同时占了两个线程</strong>【<strong>如果是阻塞等待这个子任务的话是这样的</strong>，如果不是的话其实也还是可以说占用线程池中的线程太快】 】</p>
<p>单点登录，淘宝和天猫 cors csp？</p>
<p>手撕：<br>长为N的 1,2, … , N 的货物数组，每个货物有自己的重量，用 W 数组表示，每种货物无限，一个机器人从左到右拿货物，它一趟最多拿 C 个货物，最多拿 H 的重量。<br>现在给两个数组 X 和 Y，X 中元素表示要拿哪些货物，Y 中元素和X对应，表示该货物要拿几个。<br>问机器人最少跑几趟？</p>
<p>贪心可以吗？面试官问还有其他方法吗？</p>
<p>得动态规划，规不出来。</p>
<h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><h3 id="腾讯云一面"><a href="#腾讯云一面" class="headerlink" title="腾讯云一面"></a>腾讯云一面</h3><p>redis 执行命令到了秒级的原因【大键 主从同步持久化 】<br>redis lua原子性是什么<br>redis 底层怎么实现？<br>lua脚本执行到一半退出了怎么办？之前的数据写了吗<br>redis io数的限制</p>
<p>接收窗口大小是每个包都带吗<br>linux 怎么抓包</p>
<p>java 构造函数异常怎么办 分配了内存有释放吗<br>C++这些语言怎么处理的</p>
<p>TimeWait状态多会怎样</p>
<p>客户端显示连接上了但是后端没连接（比如 nginx 作为代理和客户端连接，nginx 在另一台机器，而nginx没有和服务端进行连接）</p>
<p>拥塞窗口大小<br>syn队列大小</p>
<p>进程状态 D 信息</p>
<p>Linux进程状态：R (TASK_RUNNING)，可执行状态。<br>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）<strong>被放入对应CPU的可执行队列中</strong>（一个进程最多只能出现在一个CPU的可执行队列中）。<strong>进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行</strong>。</p>
<p>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，<strong>这两种状态在linux下统一为 TASK_RUNNING状态</strong>。</p>
<p>Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。<br>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（通过外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。</p>
<p>通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p>
<p>Linux进程状态：D (TASK_UNINTERRUPTIBLE)，<strong>不可中断的睡眠状态</strong>。<br>与TASK_INTERRUPTIBLE状态类似，<strong>进程处于睡眠状态，但是此刻进程是不可中断的</strong>。不可中断，<strong>指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号</strong>。<br>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！<br>于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。</p>
<p>而 TASK_UNINTERRUPTIBLE 状态<strong>存在的意义就在于，内核的某些处理流程是不能被打断的</strong>。<strong>如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程</strong>（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux内核异步中断浅析》）<br>在进程对某些硬件进行操作时（比如<strong>进程调用read系统调用对某个设备文件进行读操作</strong>，而read系统调用<strong>最终执行到对应设备驱动的代码</strong>，并与对应的物理设备进行交互），可能需要<strong>使用TASK_UNINTERRUPTIBLE状态对进程进行保护</strong>，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p>
<p>D状态下进程不接收信号，只能通过wake_up唤醒。处于这种状态的情况有很多，例如<strong>mutex锁</strong>就可能会设置进程于该状态，有时候进程在等待某种IO资源就绪时(wait_event机制)会设置进程进入该状态。一般情况下，进程处于该状态的时间不会太久，但若IO设备出现故障或者出现进程死锁等情况，进程就可能长期处于该状态而无法再返回到TASK_RUNNING态。</p>
<p>linux系统中也存在容易捕捉的TASK_UNINTERRUPTIBLE状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec（参见《神奇的vfork》）。</p>
<p>Linux进程状态：T (<strong>TASK_STOPPED or TASK_TRACED 两种吗大哥</strong>)，暂停状态或跟踪状态。<br>向进程发送一个<strong>SIGSTOP</strong>信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。<strong>不允许</strong>用户进程通过signal系列的系统调用<strong>重新设置对应的信号处理函数</strong>。）<br>向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。</p>
<p>当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。<strong>比如在gdb中对被跟踪的进程下一个断点</strong>，<strong>进程在断点处停下来的时候就处于TASK_TRACED状态</strong>。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p>
<p>对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是<strong>表示进程暂停下来</strong>。<br>而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。</p>
<p>inux进程状态：Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。<br>进程在退出的过程中，处于TASK_DEAD状态。</p>
<p>在这个退出过程中，进程占有的所有资源将被回收，<strong>除了task_struct结构</strong>（以及少数资源）以外。<strong>于是进程就只剩下task_struct这么个空壳，故称为僵尸</strong>。<br>之所以保留task_struct，是因为task_struct里面保存了<strong>进程的退出码</strong>、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。<br>当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p>
<p>父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。<br>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。</p>
<p>1号进程，pid为1的进程，又称init进程。<br>linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：<br>1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；<br>2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；</p>
<h3 id="腾讯云二面"><a href="#腾讯云二面" class="headerlink" title="腾讯云二面"></a>腾讯云二面</h3><p>聊天   面试官还是很友善的很尊重人<br>算了吧 和藤子无缘 不强求</p>
<p>布隆过滤器  为什么多哈希能放更多元素<br>责任策略 开闭<br>24点游戏  四张扑克牌通过加减乘除得到 24  【刚开始说 dp 不行，用回溯穷举可以】</p>
<p>面试官分享 腾讯云 崩溃的事情<br>新业务老业务完全迭代好<br>老业务是实际物理机器，新业务是实际物理机器上运行各个 虚拟服务器，可以这样理解，同样这些虚拟服务器公用实际物理网络，然后这些新老业务之间的交互好像是通过网关？然后网关崩了，上层的容灾也没做好【已知下层业务很久没有迭代了，上层就应该做好容灾】，所以只能等待广东机房去恢复。同样的主要的两个问题就是 1、数据一致性，脏数据的处理  2、尽快负载均衡恢复系统运行。<br>面试官提到这次之所以处理很久就是一直有新规则进来，不好处理。<br>逻辑关系复杂，最后也有可能将错误结果落实到用户处，比如建的规则怎么不见了。</p>
<h2 id="淘天"><a href="#淘天" class="headerlink" title="淘天"></a>淘天</h2><h3 id="淘天一面"><a href="#淘天一面" class="headerlink" title="淘天一面"></a>淘天一面</h3><p>消息队列重发消息几次</p>
<h3 id="淘天二面"><a href="#淘天二面" class="headerlink" title="淘天二面"></a>淘天二面</h3><p>闲聊</p>
<p>短链接无法用邮箱注册</p>
<p>短链接访问人数不对啊<br>访问人数的逻辑是什么</p>
<p>短链接懒删除</p>
<p>饿了吗送外卖，用户有个接口获得他周边的商家【不考虑好评等推荐信息，只考虑距离】，商家信息用商家实体表示，要实现这个功能商家信息需要增加什么字段？<br>答  用区域分割，比如经纬线切割的矩形。</p>
<h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><h2 id="美团一面"><a href="#美团一面" class="headerlink" title="美团一面"></a>美团一面</h2><p>这个座位分配的细节再敲定下。怎么选出一个座位，具体策略今晚肯定得看。</p>
<p>分布式 id 是怎么作为主键的。用什么数据</p>
<p>顺序消息的实现。</p>
<p>canal 的原理 它是对 binlog 进行了预处理对吧，他有对 binlog 解析嘛</p>
<p>具体下单要哪些信息</p>
<h2 id="美团二面"><a href="#美团二面" class="headerlink" title="美团二面"></a>美团二面</h2><p>细问锁座位的粒度：讲了为什么不能以座位为单位进行上锁，首先可能会死锁，其次由于座位与票的特殊关系，如果等待锁，那可能会造成非常多的无效等待，如果不等，那可能整个车厢看了一圈发现没有座位可用，需要有相应的重试逻辑。</p>
<p>微信扫码登录的原理，硬编：<br>二维码是url，用户发送请求，我们给前端返回一个唯一id，标识这次扫码，同时我们调用微信接口发送请求去拿用户信息，用户确认登录后返回事件发生，回调拿到用户信息，讲这个用户信息和刚刚那个唯一 id 关联上放在比如 redis，然后前端轮询那个 唯一 id 去看是否能拿到用户信息。</p>
<p>太久没写题了，很唐。</p>
<p>和面试官聊的很开心哈。</p>
<h2 id="携程一面"><a href="#携程一面" class="headerlink" title="携程一面"></a>携程一面</h2><p>分布式 id 高性能高可用怎么保证   无语</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>短链接并发访问，对某个短链接有很多脏流量该如何处理【恶意流量，只是个场景 不用纠结为什么脏】</p>
<p>消费消息的幂等  幂等的时间如何确定  给用户体验造成的延迟是否会变大</p>
<p>火焰图<br>在 cpu 占用高时用 top-Hp jstack 能解决一部分问题，而比如像多线程 每个线程占用都只增加一点点  但总体就很多了  所以可以用 arthas    a single profile 这种 好像可以累加某个函数的cpu使用量，这种就可以解决这种周期性 cpu 占用量高的问题。</p>
<h2 id="阿里云-一面"><a href="#阿里云-一面" class="headerlink" title="阿里云 一面"></a>阿里云 一面</h2><p>详细讲项目</p>
<p>突然大量高并发请求【其实讲的不太好 虽然讲了很多scale up scale out】<br>好像还可以讲<br>热key出现的典型业务<br>预期外的访问量抖增，如突然出现的爆款商品，访问量暴涨的热点新闻，直播间某大主播搞活动大量的刷屏点赞。</p>
<p>本地缓存HotKey，<br>通过发布订阅解决数据一致性问题</p>
<p>Java缓存技术可分为分布式缓存和本地缓存，分布式缓存在后面的 100Wqps 三级缓存组件中，再细致介绍。<br>先看本地缓存。<br>本地缓存的代表技术主要有HashMap，Guava Cache，Caffeine和 Ehcache。</p>
<p>一个链路中有个节点断了影响整个业务运行 该如何应急处理。</p>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>同样详细讲项目</p>
<p>事务一致性  通过日志来实现</p>
<p>12306 主要改造<br>甚至问道12306是怎么压测的，请求怎么构造【我说自己慢慢构造，也说到了使用csv jmeter】</p>
<p>高并发那里的瓶颈说的很全面了 说了主要升级方向 scale up  scale out<br>问到了短链监控信息落盘始终跟mysql 进行交互，性能上有问题，这块是瓶颈，反复问该如何改进。</p>
<p>面试官提到 理论跟实际相结合 不是所有时候使用异步都能解决问题。</p>
<p>面试的时候太骄傲了吗？直接把所有的offer都露出来了吗？因为这个挂的吗？<br>害  还是得谨慎一点，不能太自信变成骄傲了，即便如此，也不要内耗了。</p>
<h2 id="虾皮"><a href="#虾皮" class="headerlink" title="虾皮"></a>虾皮</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>i++ 原子性<br>工作内存、系统内存 怎么理解<br>栈在操作系统的应用 （方法）<br>实现五个线程能访问一段代码<br>tcp连接是逻辑概念还是物理概念</p>
<h2 id="tcp-细节"><a href="#tcp-细节" class="headerlink" title="tcp 细节"></a>tcp 细节</h2><p>爱问 tcp 细节 恶心人是吧。行 <strong>TCP 真的是太逆天了哈哈</strong></p>
<p>1、服务器出现大量 TIME_WAIT 状态的原因有哪些？<br>第一个场景：HTTP 没有使用长连接<br>根据大多数 Web 服务的实现，不管哪一方禁用【Connection:close】了 HTTP Keep-Alive，都是由服务端主动关闭连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>第二个场景：HTTP 长连接超时<br>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。<br>HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。<br>所以为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。<br>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」</p>
<p>第三个场景：HTTP 长连接的请求数量达到上限<br>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。<br>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。<br>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100 次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>2、TIME_WAIT 过多有什么危害？<br>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<p>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；<br>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 32768～61000<br>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多，占满了所有端口资源，那么就<strong>无法对「目的 IP+ 目的 PORT」都一样的服务端</strong>发起连接了</p>
<p>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<p>3、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？<br>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。<br>所以，当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。<br>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题</p>
<p>4、如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p>TCP keepalive 是 TCP 层（内核态） 实现的，它是给所有基于 TCP 传输协议的程序一个兜底的方案。TCP keepalive 机制探测的时间也太长了吧？<br>实际上，我们应用层可以自己实现一套探测机制，可以在较短的时间内，探测到对方是否存活。</p>
<p>TCP 保活的这个机制检测的时间是有点长，我们可以自己在应用层实现一个心跳机制。<br>比如，web 服务软件一般都会提供 keepalive_timeout 参数，<strong>用来指定 HTTP 长连接的超时时间</strong>。定时器的时间一到，就会触发回调函数来释放该连接。</p>
<p>5、如果已经建立了连接，但是服务端的进程崩溃会发生什么？【<strong>也是个很难想到的问题</strong>】<br><strong>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后</strong>，内核需要回收该进程的所有 TCP 连接资源，<strong>于是内核会发送第一次挥手 FIN 报文</strong>，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<p>syn 半连接队列长度  tcp_max_syn_backlog  最大同步backlog<br>accpet 全队列长度 &#x3D; min(backlog, somaxconn)。   说 backlog 估计也够了</p>
<p>6、没有 accept，能建立 TCP 连接吗？<br>可以的。<br>accpet <strong>系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket</strong>，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p>
<img src="/2024/09/01/BaGu/20.png" class="" title="alt text">
<p>这张图真的讲的很好，<strong>可以看到 connect accept 其实都是阻塞调用</strong>，也能很清楚看到分别在什么时候返回。</p>
<ol>
<li>客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED</li>
<li>ACK 应答包到达服务端后，服务端的 TCP 连接进入 ESTABLISHED 状态，同时服务端协议栈使得 accept 阻塞调用返回，这个时候服务端到客户端的单向连接也建立成功。</li>
</ol>
<img src="/2024/09/01/BaGu/21.png" class="" title="alt text">
<p>这张图也很清楚，实际上连接建立【三次握手】跟accept没有关系，accept是系统调用，专门用来从全连接队列中拿 socket 的。</p>
<p>7、没有 listen，能建立 TCP 连接吗？<br>答案：可以的。<br><strong>客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开）</strong>，这两个情况都有个共同点，就是没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</p>
<p>我们知道<strong>执行 listen 方法时，会创建半连接队列和全连接队列</strong>。<br>三次握手的过程中会在这两个队列中暂存连接信息。<br>所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据 IP + 端口等信息找到对应的 socket。<br>那么客户端会有半连接队列吗？<br>显然没有，因为客户端没有执行listen，因为半连接队列和全连接队列都是在执行 listen 方法时，内核自动创建的。<br><strong>但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。</strong><br>在 <strong>TCP 自连接</strong>的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将消息发出，消息在经过<strong>回环地址</strong>重新回到 TCP 传输层的时候，就会根据 <strong>IP + 端口信息</strong>，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。</p>
<p>netstat -napt | grep “进程名”</p>
<p>7.1、<strong>服务端没有 listen，客户端发起连接建立，会发生什么？</strong></p>
<p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，<strong>服务端会回 RST 报文</strong>。</p>
<p>相当于 ServerSocketChannel 注册到 Selector 里面，但是没有指定自己对 “connect” 事件感兴趣，那自然是什么都没有啦。</p>
<p>8、什么是 SYN 攻击？如何避免 SYN 攻击？</p>
<p>9、拔掉网线后， 原本的 TCP 连接还存在吗？<br>关键点就是 网络（ip层）状态的变化实际上不影响传输层状态的变化【tcp信息由内核维护】，想要引起断开传输层连接那就得四次挥手或者一方察觉不对主动断开，后者有两种。【如果开启了 <strong>TCP 保活机制 keep_alive</strong> ，比如nginx 就有做这个，大概60s就会断开，实际上这个也是http长连接超时断开的实现。】【还有就是超时重传超出一定次数或时间，服务端一直传消息没响应就会一直重传，到次数之后就会断开】 这两种是拔网线这种情况或者客户端直接宕机的情况。更细致的区别在于保活是服务客户端实际上并不通信，所以会保活，第二种是服务端和客户端是正在通信的。<br>【而如果是进程崩溃，内核在回收进程时会发送 fin 包进行四次挥手也就是第一种情况】</p>
<p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。</p>
<p>如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。</p>
<p>而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文</p>
<p>有数据传输的情况：</p>
<p>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。<br>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。</p>
<p>除了客户端拔掉网线的场景，还有客户端「主机宕机和进程崩溃 (opens new window)」的两种场景。</p>
<p>第一个场景，客户端宕机这件事跟拔掉网线是一样无法被服务端的感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。</p>
<p>第二个场景，客户端的进程崩溃后，客户端的内核就会向服务端发送 FIN 报文，与服务端进行四次挥手。</p>
<p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p>
<p>10、没有开启 keepalive，一直没有数据交互；TCP 连接，一端断电和进程崩溃有什么区别？</p>
<p><strong>这两个条件防住了 保活和服务端的超时重试断开</strong>，所以断电的只能一直保持住 ESTABLISH 状态了，然后进程崩溃的可以正常断开。</p>
<p><em><strong>其实宕机和断网 有点像，但又不完全像</strong></em><br>在有数据传输的场景，<br>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p>
<ol>
<li>如果客户端主机上没有进程绑定该 TCP 报文的目标端口号，那么客户端内核就会回复 RST 报文，重置该 TCP 连接；</li>
<li>如果客户端主机上<strong>有进程绑定该 TCP 报文的目标端口号【由于电脑重启，此时运行在这个端口的进程也不是原来的进程了，或者说tcp结构信息丢失了吧】</strong>，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，<strong>于是就会回复 RST 报文</strong>，重置该 TCP 连接。</li>
</ol>
<p><strong>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。</strong></p>
<p>那 TCP 的数据报文具体重传几次呢？<br>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核会根据 tcp_retries2 设置的值，计算出一个 timeout（如果 tcp_retries2 &#x3D;15，那么计算得到的 timeout &#x3D; 924600 ms），<strong>如果总的重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传</strong>，然后就会断开 TCP 连接。</p>
<p>在发生超时重传的过程中，每一轮的超时时间（RTO）都是倍数增长的，比如如果第一轮 RTO 是 200 毫秒，那么第二轮 RTO 是 400 毫秒，第三轮 RTO 是 800 毫秒，以此类推。 <strong>RTO 是基于 RTT（一个包的往返时间） 来计算的</strong>，如果 RTT 较大，那么计算出来的 RTO 就越大，那么经过几轮重传后，很快就达到了上面的 timeout 值了。</p>
<h1 id="简历信息"><a href="#简历信息" class="headerlink" title="简历信息"></a>简历信息</h1><p>自我介绍：<br>我是东南大学26届信息与通信工程硕士生，本科来自西安电子科技大学，本科成绩排名专业第一，在保持成绩的同时积极学习编程，有良好的互联网基础。<br>目前已经完成了 一个Java实现的数据库，铁路购票系统，短链接平台。短链接平台将长链接转为短链接并监控访问情况，目前已经上线并升级 HTTPS。铁路购票系统是仿照12306实现的，完成用户注册、车票查询、下单等核心业务，项目实现更注重代码规范，使用责任链、策略模式等重构代码，以及设计一些可重用组件比如雪花算法id生成器、日志注解和消息队列消费消息幂等注解，并且对核心购票接口反复优化最终实现吞吐量的较大提升。最后是我自己手写的数据库，包含五个主要模块 事务、数据、版本、索引、表管理器，五个模块分层设计清晰，基于mvcc实现读提交和可重复读两种隔离级别，基于二阶段锁实现事务串行化，并实现死锁检测，最终实现类sql语句解析和执行。我很希望能获得这个实习机会。</p>
<p>我是东南大学26届信息与通信工程硕士生，本科来自西安电子科技大学，本科成绩排名专业第一，在保持成绩的同时积极学习互联网技术，有良好的计算机基础。<br>项目是完成了 一个 Java 实现的数据库 ENDB，在腾讯和淘天各做了一段两个月的暑期实习。<br>腾讯是在云产品一部 CLB 负载均衡 部门实习，主要工作是独立完成了限速组件的方案制定、开发和测试的完整流程。CLB 核心前级组件 APIv3 存在高负载 的问题，在深入分析高负载原因的基础上选型多种限速方案，最终选择 基于 Openresty 的具备流量整形能力的漏桶限速器，通过整理请求命中的多维度限速器并以优先级为顺序串联，模拟 TCC 实现多限速器的弱原子性，方案组内认可，实现效果经过测试符合需求。<br>淘天主要是参与 满额发顺丰 业务需求和 运营区迁移 技术需求。满额顺丰主要做的是 将 上门数据 按 指定规则同步给时效，其中 品池 定义、绑品和择配的三表同步的过程中使用了异步任务和反查，通过合理的编排任务实现 数据一致和模型完整，开发过程中关注代码质量主动重构供给的代码，在刷数据的过程中排查并处理了数据库死锁问题，运营区迁移这个需求主要是参与数据迁移方案的设计。<br>ENDB 是用 Java 实现的简易数据库，五个模块分层设计清晰。<br>这是我的自我介绍，很希望能获得这个工作机会。</p>
<hr>
<p>腾讯 | CLB(负载均衡团队) | Lua·Nginx·Openresty<br>简介: 独立设计并交付基于 OpenResty 的高性能限速组件，以解决云负载均衡 (CLB) 核心组件 APIv3 在流量洪峰下的服务稳定性问题。</p>
<p>配置: 实现基于 MySQL 的动态配置中心，支持 Action、AppId、子租户等多维度的组合限流规则，并提供全局控制开关，配置分钟级生效；<br>算法: 分层限流架构，实现具备流量整形的漏桶速率限制器和具备动态反馈控制的并发连接限制器，此外，提出以排队延迟为负载信号，Sigmoid 函数变体动态平滑梯度作为乘性减少因子的自适应限流算法；<br>一致: 通过预检-提交-回滚模式，确保多限流状态的一致性提交，4 Worker 压测时限速值偏差小于1%；<br>GC 调优: 设计并实现 Lua table 对象池，将高频临时对象的 GC 压力降低了约 70%，成功消除了压测场景下的 P99 延迟毛刺（由 50ms+ 降至 5ms）。<br>JIT 编译优化: 运用火焰图定位并优化了因 NYI 原语导致的 JIT 热代码编译中断问题，核心代码 CPU 消耗降低了 35%，吞吐量提升了 12%；</p>
<p>淘天 | 物流要素团队 | Java·MySQL·MetaQ<br>简介: 开发并上线满额发顺丰业务需求，参与运营区迁移技术需求的数据迁移。</p>
<p>设计: 设计并实现上门数据的品池定义、绑品、择配三模型按指定规则同步时效的方案，借助异步任务和<br>反查实现数据的最终一致性，通过任务编排保证模型完整，同步 1600W 行数据；<br>重构: 使用策略模式重构了上门数据同步 组网、SDP、时效 的代码，并将异步调用下沉到最小级别任务；<br>线上: 分析并解决大客托管增量数据同步过程中由于并发 IODKU 导致的数据库死锁问题；<br>迁移: 参与运营区迁移项目的数据迁移，采用 双写、同步存量数据、稽核、切读、切写 的流程；</p>
<p>独立完成者<br>主要完成者<br>ENDB 数据库<br>简介: 用Java 实现的数据库，五个模块分层设计架构清晰。数据库设计为C&#x2F;S 结构，支持启动一个服务器，多个客户端通过Socket 连接，执行SQL 返回结果。</p>
<ol>
<li>Transaction Manager(TM): 通过维护XID 文件来管理事务，向上提供查询事务状态的接口。</li>
<li>Data Manager(DM): 与文件系统交互直接管理数据库文件(DB) 和日志文件(LOG)，包括：(1) 管理LOG, 保证ENDB 的可恢复性；(2) 分页管理DB 并抽象出DataItem 进行缓存供上层模块使用。</li>
<li>Version Manager(VM): 进一步封装DataItem 为记录Entry 并缓存，实现了MVCC以消除读写阻塞，完成RR、RC 两种隔离级别，基于2PL 保证了事务的可串行性，并实现死锁检测。</li>
<li>Index Manager(IM): 维护基于B+ 树的索引结构，向上层提供插入节点和搜索节点两种能力。</li>
<li>Table Manager(TBM): 实现对字段和表结构的管理，解析类SQL 语句，并根据语句操作表。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Iridescent-zhang/ENDB">https://github.com/Iridescent-zhang/ENDB</a></p>
<p>主要完成者<br>铁路购票系统<br>简介: 完成互联网在线购票，实现用户注册、车票查询、车票下单以及支付等核心业务。</p>
<ol>
<li>设计模式: 使用责任链模式重构用户注册、购票请求的参数合规性检验流程。使用策略模式动态选择座位分配策略、Canal RocketMQ 消费者监听订单、座位表的策略实现。借助Spring IOC 满足开闭原则。</li>
<li>系统组件: 设计分布式雪花算法ID 生成器，使用AOP 自定义日志打印注解(方法或类)，借助SPEL 和去重表实现消息队列消费幂等注解。</li>
<li>分库分表: 通过订单号和用户信息复合分片完成订单数据分库分表，支持订单号和用户维度查询。</li>
<li>消息队列: 结合Canal 和RocketMQ 实现MySQL 与Redis 的缓存最终一致性。借助RocketMQ 延时消息，完成用户购票10 分钟内未支付自动关单功能。</li>
<li>令牌限流: 利用Redis Lua 原子特性，完成用户购票令牌分配，通过令牌限流应对高并发购票请求。</li>
<li>接口优化: 升级购票接口，使用编程式事务减小事务粒度，通过扣减令牌成功后投送消息队列，配合前端轮询出票状态，实现下单接口异步化，提升吞吐量20 倍。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Iridescent-zhang/12306">https://github.com/Iridescent-zhang/12306</a></p>
<p>短链接平台<br>项目上线 <a target="_blank" rel="noopener" href="https://strumcode.com/">https://strumcode.com</a><br>简介: 提供长链接转换为短链接服务，支持高并发短链跳转，并提供深入的分析和跟踪功能。</p>
<ol>
<li>使用Redisson 布隆过滤器高效判断短链接是否存在，性能远胜分布式锁(TPS 提升6 倍)，解决缓存穿透。通过缓存预热和双重判定锁解决缓存击穿。</li>
<li>短链接修改分组和监控使用Redisson 分布式读写锁，保障数据准确性和短链并发能力。</li>
<li>借助RocketMQ 的削峰填谷，提升短链接访问的并发性能（2c4g 线上服务吞吐量达到1800）。</li>
<li>网站升级到HTTPS 和HTTP2 协议，提高安全性和用户体验。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Iridescent-zhang/shortLinkRocket">https://github.com/Iridescent-zhang/shortLinkRocket</a></p>
<p>浙江九霄智能科技有限公司<br>C++开发实习生   软件开发部<br>使用QT、C++进行仿真软件开发<br>蒋卓成  13709000443</p>
<p><strong>课题组《铁路货车故障轨边图像异常检测》项目</strong></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/Iridescent-zhang">https://github.com/Iridescent-zhang</a></p>
<p>2023 年中国研究生数学建模竞赛，国家二等奖<br>全国大学生电子设计大赛陕西省二等奖<br>西安电子科技大学2781班校友奖学金<br>校级学业奖学金若干</p>
<p>zlc15160431594<br>350628200110084010<br><a href="mailto:&#x6c;&#x63;&#122;&#104;&#x61;&#110;&#103;&#57;&#51;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;">&#x6c;&#x63;&#122;&#104;&#x61;&#110;&#103;&#57;&#51;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a></p>
<p>遥感科学与技术  信息科学与工程学院   移动通信国家重点实验室  杨绿溪<br>信息与通信工程  电子工程学院  东南大学   西安电子科技大学</p>
<p>自我评价：<br>热爱编程技术，具有较高的学习效率和较强的学习驱动力，本科成绩保持专业第一的同时积极学习互联网编程，热爱互联网技术，熟练使用Java，完成ENDB（用Java 实现的数据库）、铁路购票系统、短链接平台（已上线）、Friendmall商城项目。学习和工作上具有韧性、较好的抗压能力。</p>
<ol>
<li>熟练掌握Java 基础，熟悉JUC、集合、多线程，了解JVM 、设计模式。</li>
<li>掌握MySQL、Redis 的使用和原理，熟悉ShardingSphere 分库分表中间件。</li>
<li>熟悉RocketMQ 消息中间件，熟悉延迟队列的应用，解决重复消费问题。</li>
<li>熟悉SSM、SpringBoot、MyBatis-Plus 等主流开发框架以及Spring Cloud 常见组件。</li>
<li>熟悉常用数据结构、计算机网络、操作系统，掌握Maven、Git、Docker 的基本使用。</li>
</ol>
<p>爱好特长：自学吉他两年有较好的成果（社交媒体上发布视频），热爱运动（长跑），参加过校园马拉松。</p>
<hr>
<p>Friendmall 商城项目<br>技术栈: SpringBoot + SpringCloud+ Mybatis-Plus + MySQL + Redis + RabbitMQ+ Nginx<br>简介:<br>FriendMall 是一个完整的微服务分布式架构电商平台，利用Docker 进行容器化搭建部署，以复杂业务为背景整合SSM，应用Spring CloudAlibaba 微服务组件，分析分布式系统难点，尝试应对高并发场景。<br>亮点：</p>
<ol>
<li>全系统实现微服务，以业务解耦，注册Nacos 服务发现，OpenFeign远程调用，Nginx 反向代理并实现动静分离，Gateway 负载均衡地将请求转达各个服务，搭建微服务域名环境和稳定的调用链路。</li>
<li>OAuth2.0社交登录，SpringSession整合Redis 实现分布式会话共享，ThreadLocal 实现未登录拦截，构造Feign的请求拦截器增强Feign远程调用存入Cookie，全系统内单点登录。</li>
<li>Redis 实现分布式缓存，整合SpringCache 简化缓存开发，自定义缓存逻辑分区，解决缓存穿透、击穿、雪崩问题，满足缓存最终一致性。分布式锁的实现从Redis 的setnx 演进到Redisson。</li>
<li>线程池CompletableFuture 组合式异步编排查询任务提高效率。</li>
<li>分布式事务方案从Seata 演进到由RabbitMQ实现，更适应高并发请求，延时队列实现订单超时关单、自动解锁库存，手动确认消息，不断重发失败的消息保证可靠性，实现分布式事务最终一致性。</li>
<li>秒杀服务独立，定时任务将库存预热到Redis，以RedissonRSemaphore 控制请求，RabbitMQ流量削峰，消息入队由后台异步执行实现，实现安全高性能高并发方案。</li>
<li>关注幂等性处理：库存自动解锁时都会查最新状态防止重复解锁；结合分布式锁，通过在Redis 中占位,防止重复保存秒杀信息。</li>
<li>网关层进行Sentinel 流控(限流、熔断、降级), Zipkin链路追踪可视化资源调用。<br><a target="_blank" rel="noopener" href="https://github.com/Iridescent-zhang/friendmall">https://github.com/Iridescent-zhang/friendmall</a></li>
</ol>
<p>基于FPGA HLS的手势识别系统设计</p>
<ol>
<li>负责基于FPGA实现二维手势识别系统的整体设计与开发，利用高层次综合(HLS)技术优化算法性能。</li>
<li>采用C++语言，依据HLS设计原则，完成图像处理和手势特征提取等核心算法的开发。</li>
<li>通过仿真验证算法功能与性能，确保算法设计满足项目需求。</li>
<li>利用HLS工具的优化指令和约束，指导算法的综合过程，实现高效的RTL设计。</li>
<li>将综合得到的IP核成功集成至ZYNQ硬件系统中，实现算法的硬件加速，提升系统处理速度。</li>
<li>在软件平台上开发调试程序，确保软硬件协同工作，有效控制整个手势识别系统。</li>
<li>针对ZynqSoC 7000平台，精心设计软硬件架构，优化系统资源配置和任务调度。</li>
<li>独立承担项目从概念设计到最终实现的全过程，保证项目按时交付且满足性能要求。</li>
</ol>
<h1 id="要解决的疑难"><a href="#要解决的疑难" class="headerlink" title="要解决的疑难"></a>要解决的疑难</h1><img src="/2024/09/01/BaGu/22.png" class="" title="alt text">


<img src="/2024/09/01/BaGu/image.png" class="" title="Alt text">
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/log/how_update.html#binlog-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E7%9B%98">https://www.xiaolincoding.com/mysql/log/how_update.html#binlog-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E7%9B%98</a></p>
<p>select * from performance_schema.data_locks\G;</p>
<img src="/2024/09/01/BaGu/image-10.png" class="" title="Alt text">


<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/lock/deadlock.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81">https://www.xiaolincoding.com/mysql/lock/deadlock.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81</a></p>
<img src="/2024/09/01/BaGu/image-1.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-2.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-3.png" class="" title="Alt text">

<img src="/2024/09/01/BaGu/image-4.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-5.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-6.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-7.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-8.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-9.png" class="" title="Alt text">

<p><strong>上面的案例是针对唯一二级索引重复插入失败的场景。</strong><br><strong>接下来，分析两个事务执行过程中，执行了相同的 insert 语句的场景。</strong></p>
<img src="/2024/09/01/BaGu/image-11.png" class="" title="Alt text">
<p>这种情况和之前的就不太一样了，第一个插入记录的事务持有的基于 trx_id 的那条记录的隐式锁会变成 X 的<strong>显式</strong>记录锁，X 和 S 锁冲突了（隐式锁旨在冲突的时候才加锁，即延迟加锁）。 注意看是哪个 事务 id 加的锁：</p>
<img src="/2024/09/01/BaGu/image-12.png" class="" title="Alt text">
<img src="/2024/09/01/BaGu/image-13.png" class="" title="Alt text">

<p>注意这个场景事务 A 还没提交，A 持有的隐式锁还在，如果提交了就变成上面那种场景了。</p>
<img src="/2024/09/01/BaGu/image-14.png" class="" title="Alt text">

<p>插入的时候因为 间隙锁 还是因为 唯一键冲突  导致的插入阻塞加锁原因是不一样的;<br>前者是 插入意向锁的冲突，后者是想加 S 型的记录锁 或 临键锁。<br>可以理解为，插入操作的隐式锁，在遇到间隙锁时变为 插入意向锁，在遇到 重复键时 变为 S 型的 记录&#x2F;临键锁，然后锁的状态变为等待状态。</p>
<h1 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h1><p>阿里系列登录 </p>
<p>饿了么 支付宝 </p>
<p>灵犀 阿里云 控股 手机号</p>
<p>蚂蚁 微信</p>
<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><p>淘天集团笔试</p>
<p>第二题  1，2，…，n 找出一个组合等于 target  ，时间要求很高</p>
<hr>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><p>&#x2F;proc&#x2F;meminfo: 查看详细内存信息<br>cat &#x2F;proc&#x2F;meminfo<br>vmstat: 显示内存、进程、CPU 活动信息<br>vmstat -s<br>less: 分页查看文件内容<br>less filename</p>
<p>grep 命令用于搜索文件内容中的模式，并输出包含匹配的行。<br>搜索日志文件中的特定错误信息:<br>grep “ERROR” &#x2F;var&#x2F;log&#x2F;application.log</p>
<p>配合其他命令使用，如搜索包含特定数据目录:<br>ls -l | grep “data”</p>
<p>硬链接（Hard Link）<br><strong>硬链接是指向文件数据的直接链接</strong>。它们共享同一个 inode。<br>删除硬链接不会影响文件数据，<strong>只有当所有的硬链接被删除后，文件数据才会被删除。</strong><br>touch file1.txt<br>echo “Hello World” &gt; file1.txt<br>ln file1.txt hardlinkfile.txt<br>此时 file1.txt 和 hardlinkfile.txt 是两个不同的文件名，<strong>但它们都指向同一个文件数据</strong>。如果你修改其中任何一个文件，另一个文件的内容也会改变。</p>
<p>软链接（Symbolic Link 或 Symlink）<br>软链接类似于 Windows 中的<strong>快捷方式</strong>。<strong>它们指向文件路径而不是文件数据。</strong><br>删除软链接不会影响原文件，但如果原文件被删除，软链接会指向一个无效的位置（称作 “悬挂链接”）。<br>ln -s file1.txt symlinkfile.txt<br>此时 symlinkfile.txt 是 file1.txt 的<strong>软链接，指向 file1.txt 的路径</strong>【快捷方式】。如果你删除或修改 file1.txt，symlinkfile.txt 会受影响【失效了，但如果我重新在创建一个file1.txt，这个软连接又复活了】，因为它只是一个路径引用。</p>
<p><strong>什么是文件名</strong></p>
<p>当我们在文件系统中创建一个文件时，<strong>那个文件名实际上就是该文件数据的一个硬链接</strong>。从这个意义上说，文件系统中的文件名本质上就是指向文件数据的硬链接。因此，<strong>当你创建一个硬链接时，你实际上是在为同一文件数据创建了多个名字</strong>。</p>
<p>inode（索引节点）是一个<strong>数据结构，用于描述一个文件或目录的元数据</strong>。inode 包含以下信息：<br>文件类型（普通文件、目录、符号链接等）<br>文件权限（读、写、执行权限）<br>文件所有者和所属组<br>文件大小<br>文件的时间戳（创建时间、修改时间、访问时间）<br><strong>指向文件数据块的位置指针</strong><br>需要注意的是，inode <strong>不包含文件的名字</strong>。文件名和 inode 之间的关联存储在目录结构中。<br>inode 是一个用于描述文件元数据的结构，不包含文件名。<strong>文件名和 inode 的关联存储在目录结构中</strong>。<br>ls -i 显示文件的 inode （ <strong>inode 是文件内容的标识</strong>）</p>
<p>查看文件的 inode<br>ls -i file1.txt<br>1234567 file1.txt  # 这里的 1234567 就是 file1.txt 的 inode 号<br>查看硬链接的 inode<br>ls -i hardlinkfile.txt<br>输出示例: 1234567 hardlinkfile.txt  # 这里的 inode 号和 file1.txt 一样，因为它们指向相同的文件数据</p>
<p>awk 是一个强大的文本处理工具，适用于<strong>数据提取和报告生成</strong>。awk 基于行和列的文本处理方式，可以对文本中的每一行根据指定的模式进行处理。</p>
<p>awk ‘pattern { action }’ filename<br>pattern：用于匹配输入的文本行<br>action：对匹配的文本行进行的操作</p>
<p>比如可以方便的处理file.csv这种 csv 文件，实际上就是表格，确实方便。</p>
<p>打印文件中的每一行：<br>awk ‘{ print $0 }’ file.txt<br>其中 $0 表示整行内容。</p>
<p>awk ‘{ print $1, $3 }’ file.txt<br>打印文件的第一列和第三列，列由空格或指定的分隔符分隔。</p>
<p>awk -F ‘,’ ‘{ print $1, $2 }’ file.csv<br>指定逗号作为字段分隔符，打印第一和第二列。</p>
<p>awk ‘$3 &gt; 50 { print $1, $3 }’ file.txt<br>打印第三列大于 50 的行的第一列和第三列。</p>
<p>内置变量：<br>NR：当前记录的行号<br>NF：当前记录的字段数（列数）<br>FS：输入字段分隔符<br>OFS：输出字段分隔符</p>
<p>打印所有人的名字和得分（二者相同）<br>awk -F ‘,’ ‘{ if (NR&gt;1) print $1, $3 }’ data.csv<br>awk -F ‘,’ ‘NR&gt;1 {print $1, $3 }’ data.csv</p>
<p>打印年龄大于30的人的名字和年龄<br>awk -F ‘,’ ‘$2 &gt; 30 { print $1, $2 }’ data.csv</p>
<p>du<br>列举目录大小信息。<br>-h 适合人类阅读的；<br>-s 只显示总计大小，不显示具体信息。</p>
<p>less<br>分页显示文件内容，更适合查看大的文件。<br>less cloud-init.log<br>空格键：前进一页（一个屏幕）；<br>b 键：后退一页；<br>上下键：回退或前进一行；<br>&#x3D; 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；<br>&#x2F; 键：进入搜索模式后，按 n 键跳到下一个符合项目，按 N 键跳到上一个符合项目，同时也可以输入正则表达式匹配。相当于 ctrl f<br>q 键：停止读取文件，中止 less 命令；（ctrl c竟然无效）</p>
<p>head<br>显示文件的开头几行（默认是10行）<br>head cloud-init.log<br>-n 指定行数 head cloud-init.log -n 2</p>
<p>tail<br>显示文件的结尾几行（默认是10行）<br>tail cloud-init.log<br>-n 指定行数 tail cloud-init.log -n 2<br>-f 会每过1秒检查下文件是否有更新内容，也可以用 -s 参数指定间隔时间 tail -f -s 4 xxx.log 【<strong>看日志都这么看的</strong>】</p>
<p>mkdir<br>创建一个目录<br>mkdir new_folder<br>-p 递归的创建目录结构 mkdir -p one&#x2F;two&#x2F;three</p>
<p>cp<br>拷贝文件和目录<br>-r 递归的拷贝，常用来拷贝一整个目录m</p>
<p>mv<br>移动（重命名）文件或目录</p>
<p>rm<br>删除文件和目录<br>-r 递归删除文件夹，著名的删除操作 rm -rf</p>
<p>ln<br>英文 Link 的缩写，表示创建链接。</p>
<p>学习创建链接之前，首先要理解链接是什么，我们先来看看 Linux 的文件是如何存储的：</p>
<p>Linux 文件的<strong>存储方式分为3个部分，文件名、文件内容以及权限</strong>，其中<strong>文件名的列表</strong>是存储在硬盘的其它地方【可以理解为一个目录，文件名和inode的映射】，和文件内容是分开存放的，每个文件名通过 inode 标识找到文件内容。</p>
<p>Linux 下有两种链接类型：硬链接和软链接。</p>
<p>硬链接<br>使链接的两个文件共享同样文件内容，就是<strong>同样的 inode <strong>，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，</strong>只能创建指向文件的硬链接</strong>，<strong>不能创建指向目录的（其实也可以，但比较复杂）</strong>而软链接都可以，因此软链接使用更加广泛。<br>ln file1 file2  –&gt; 创建 file2 为 file1 的硬链接<br>对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 file1 与 file2 后，它们共同指向的文件内容才会消失。</p>
<p>软链接就类似 windows 下快捷方式。<br>ln -s file1 file2<br>其实 file2 只是 file1 的一个快捷方式，它指向的是 file1 ，所以显示的是 file1 的内容，但其实 file2 的 inode 与 file1 并不相同。如果我们删除了 file2 的话， file1 是不会受影响的，<strong>但如果删除 file1 的话， file2 就会变成死链接</strong>，因为指向的文件不见了。</p>
<p>seradd + passwd<br>useradd 添加新用户，添加完之后在 &#x2F;home 路径下可以查看<br>passwd 修改用户密码<br>sudo su –&gt; 切换为root用户<br>su lion –&gt; 切换为普通用户</p>
<p>Linux 中<strong>每个用户都属于一个特定的群组</strong>，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。<br>查看用户所在群组<br>groups lion  –&gt; 查看 lion 用户所在的群组</p>
<p>改变文件的所有者，需要 root 身份才能运行。<br>chown lion file.txt –&gt; 把其它用户创建的file.txt转让给lion用户<br>chown lion:bar file.txt –&gt; 把file.txt的用户改为lion，群组改为bar（文件也有群组）</p>
<p>chmod<br>修改访问权限。<br>chmod 740 file.txt<br>-R 可以递归地修改文件访问权限，例如 chmod -R 777 &#x2F;home&#x2F;lion<br>drwxr-xr-x 表示文件或目录的权限。<br>d ：表示目录，就是说这是一个目录，普通文件是 - （硬链接也是这个），软链接是 l 。<br>r ： read 表示文件可读。<br>w ： write 表示文件可写，一般有写的权限，就有删除的权限。<br>x ： execute 表示文件可执行。<br>- ：表示没有相应权限。<br>三个一组，依次是 文件所有者、所有者所在的群组的用户、其他用户<br>chmod 它<strong>不需要是 root 用户才能运行的，只要你是此文件所有者</strong>，就可以用 chmod 来修改文件的访问权限。</p>
<p>u ： user 的缩写，用户的意思，表示所有者。<br>g ： group 的缩写，群组的意思，表示群组用户。<br>o ： other 的缩写，其它的意思，表示其它用户。<br>a ： all 的缩写，所有的意思，表示所有用户。<br>+ ：加号，表示添加权限。<br>- ：减号，表示去除权限。<br>&#x3D; ：等于号，用来直接分配权限。</p>
<p>chmod g+r o-r file –&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限<br>chmod u&#x3D;rwx,g&#x3D;r,o&#x3D;- file –&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</p>
<p>locate<br>搜索<strong>包含关键字的所有文件和目录</strong>。后接需要查找的文件名，也可以用正则表达式。<br>updatedb –&gt; 更新数据库<br>locate file.txt<br>locate fil*.txt<br>[注意] locate 命令会去<strong>文件数据库</strong>中查找，而不是全磁盘查找，因此<strong>刚创建的文件并不会更新到数据库中</strong>，所以无法被查找到，需要执行 updatedb 命令去更新数据库。</p>
<p>find<br>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p>
<p>find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;<br>「何处」：指定在哪个目录查找，此目录的所有子目录也会被查找【<strong>递归查找</strong>】，默认当前目录。<br>「何物」：查找什么，可以<strong>根据文件的名字来查找</strong>，也可以根据其大小来查找，还可以根据其最近访问时间来查找。<br>「做什么」：找到文件后，<strong>可以进行后续处理</strong>，如果不指定这个参数， find 命令只会显示找到的文件。</p>
<p>find -name “file.txt” –&gt; 当前目录以及子目录下通过名称查找文件<br>find &#x2F;var&#x2F;log -name “syslog” –&gt; 在指定的目录&#x2F;var&#x2F;log及其子目录下查找syslog文件<br>find &#x2F;var&#x2F;log -name “syslog*” –&gt; 查找syslog1、syslog2 … 等文件，通配符表示所有<br>find &#x2F;var&#x2F;log -name “<em>syslog</em>“ –&gt; 查找包含syslog的文件<br>[注意] find 命令只会查找完全符合 “何物” 字符串的文件【必须完全匹配】，而 locate 会<strong>查找所有包含关键字的文件</strong>。<br>比如 locate “st.txt” 是能找 test.txt 的，但 find -name “st.txt” 是不行的。</p>
<p>find &#x2F;var -size +10M –&gt; &#x2F;var 目录以及子目录下查找文件大小超过 10M 的文件<br>find &#x2F;var -size -50k –&gt; &#x2F;var 目录以及子目录下查找文件大小小于 50k 的文件<br>find &#x2F;var -size 1M –&gt; &#x2F;var 目录下查找文件大小等于 1M 的文件</p>
<p>【<strong>额外指定目录或文件类型</strong>】<br>find . -name “file” -type f  –&gt; 只查找当前目录下的file文件<br>find . -name “file” -type d  –&gt; 只查找当前目录下的file目录</p>
<p>根据文件最近访问时间查找<br>find -name “*.txt” -atime -7  –&gt; 近 7天内访问过的.txt结尾的文件</p>
<p>操作查找结果<br><code>find -name &quot;*.txt&quot; -printf &quot;%p - %u\n&quot;</code> –&gt; 找出所有后缀为txt的文件，并按照 %p - %u\n 格式打印，其中%p&#x3D;文件名，%u&#x3D;文件所有者，然后换行</p>
<p><code>find -name &quot;*.jpg&quot; -delete </code>–&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用【找到所有这些 jpg 然后执行删除动作】</p>
<p><code>find -name &quot;*.c&quot; -exec chmod 600 &#123;&#125; \;</code> –&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，{} 会用查找到的文件替代，<code>\;</code> 是必须的结尾</p>
<p><code>find -name &quot;*.c&quot; -ok chmod 600 &#123;&#125; \;</code> –&gt; 和上面的功能一直，会多一个确认提示</p>
<hr>
<p>Linux 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式。 Red Hat 家族的软件包后缀名一般为 .rpm ， Debian 家族的软件包后缀是 .deb 。</p>
<p>Linux 的包都存在一个仓库，叫做软件仓库，它可以使用 yum 来管理软件包， yum 是 CentOS 中默认的包管理工具，适用于 Red Hat 一族。可以理解成 Node.js 的 npm 。</p>
<p>man 手册种类</p>
<ol>
<li>可执行程序或 Shell 命令；</li>
<li>系统调用（ Linux 内核提供的函数）；</li>
<li>库调用（程序库中的函数）；</li>
</ol>
<p>输入 <strong>man + 数字 + 命令&#x2F;函数</strong>，可以查到相关的命令和函数，若不加数字， man 默认从数字较小的手册中寻找相关命令和函数</p>
<p>man 3 rand  –&gt; 表示在手册的第三部分查找 rand 函数<br>man ls    –&gt; 查找 ls 用法手册</p>
<p>help<br>man 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， command –help 或 command -h ，它没有 man 命令显示的那么详细，但是它更加易于阅读。</p>
<hr>
<p>grep<br><strong>全局搜索一个正则表达式</strong>，并且打印到屏幕。简单来说就是，<strong>在文件中查找关键字，并显示关键字所在行。</strong><br>grep “text” file # text代表要搜索的文本，file代表供搜索的文件</p>
<p>-n 显示行号，grep -n “text” file<br>-i 忽略大小写， grep -i “text” file<br>-v 只显示搜索文本不在的那些行【相当于反向】，grep -v “text” file<br>-r 递归查找， grep -r “text” dir 可以递归查找文件下的所有文件的匹配情况<br>grep 可以配合正则表达式使用。<br>grep -E path &#x2F;etc&#x2F;profile –&gt; 完全匹配path<br>grep -E ^path &#x2F;etc&#x2F;profile –&gt; 匹配path开头的字符串<br>grep -E [Pp]ath &#x2F;etc&#x2F;profile –&gt; 匹配path或Path</p>
<p>sort<br>对文件的行进行排序。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Christopher</span><br><span class="line">Shawn</span><br><span class="line">Ted</span><br><span class="line">Rock</span><br><span class="line">Noah</span><br><span class="line">Zachary</span><br><span class="line">Bella</span><br></pre></td></tr></table></figure>
<p>执行 sort name.txt 命令，会对文本内容进行排序。<br>-n 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 -n 数字排序的话，则 25 会在 138 前面。</p>
<p>wc<br>word count 的缩写，用于文件的统计。它可以统计<strong>单词数目、行数、字符数，字节数</strong>等。<br>wc name.txt # 统计name.txt<br>13 13 91 name.txt<br>第一个13，表示行数；<br>第二个13，表示单词数；<br>第三个91，表示字节数。</p>
<p>-l 只统计行数， wc -l name.txt ；<br>-w 只统计单词数， wc -w name.txt ；<br>-c 只统计字节数， wc -c name.txt ；<br>-m 只统计字符数， wc -m name.txt 。</p>
<p>标准错误重定向 <code>2&gt;</code><br>cat not_exist_file.csv &gt; res.txt 2&gt; errors.log<br>当我们 cat 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；<br>当使用了 &gt; res.txt 时，则不会打印到屏幕，会把标准输出写入文件 res.txt 文件中；<br><code>2&gt;</code> errors.log 当发生错误时会写入 errors.log 文件中。<br>和 &gt; 跟 &gt;&gt; 的区别一样（前者是覆盖，后者是追加写）<br>标准错误重定向 <code>2&gt;&gt;</code>标准错误输出（追加到文件末尾）同 &gt;&gt; 相似。</p>
<p>标准输出和错误重定向 <code>2&gt;&amp;1</code><br>标准输出和标准错误输出都重定向都一个地方<br>cat not_exist_file.csv &gt; res.txt 2&gt;&amp;1     # 覆盖输出   1 表示的是标准输出，&amp; 表示这俩放到一块<br>cat not_exist_file.csv &gt;&gt; res.txt 2&gt;&amp;1   # 追加输出</p>
<p>查看进程<br>w<br>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。</p>
<p>ps<br>用于显示当前系统中的进程， ps 命令显示的进程列表不会随时间而更新，是静态的，是运行 ps 命令那个时刻的状态或者说是一个进程快照。<br>-aux 通过 CPU 和内存使用来过滤进程 ps -aux | less ;<br>-aux –sort -%cpu  按 CPU 使用降序排列， -aux –sort -%mem 表示按内存使用降序排列;</p>
<p>进程状态<br>主要是切换进程的状态。我们先了解下 Linux 下进程的五种状态：</p>
<p>状态码 R ：表示正在运行的状态；<br>状态码 S ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；<br>状态码 D ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；<br>状态码 Z ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 wait4() 系统函数后将进程释放）；<br>状态码 T ：表示停止（进程收到 SIGSTOP 、 SIGSTP 、 SIGTIN 、 SIGTOU 等停止信号后停止运行）。</p>
<p>前台进程 &amp; 后台进程<br><strong>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器</strong>。例如运行 top 命令，这就是一个一直运行的前台进程。</p>
<p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加 &amp; 符号，就表示启动一个后台进程。</p>
<p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。可以用 nohup。<br>cp name.csv name-copy.csv &amp;</p>
<p>nohup<br>使进程不受挂断（关闭终端等动作）的影响，这时候应该还是前台进程<br>nohup cp name.csv name-copy.csv<br>nohup 命令也可以和 &amp; 结合使用。<br>nohup cp name.csv name-copy.csv &amp;</p>
<p>守护进程<br>一个运行起来的程序被称为进程。在 Linux 中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，<strong>这些进程的父进程是 PID 为1的进程</strong>， <strong>PID 为1的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作</strong>。我们将这类进程称之为守护进程 <strong>daemon</strong> 。<br>守护进程的名字通常会在最后有一个 d ，表示 daemon 守护的意思，例如 systemd 、httpd 。</p>
<p>systemd（<strong>PID 为1的进程就是 systemd 的系统进程</strong>）<br>systemd 是一个 Linux 系统基础组件的集合，提供了一个<strong>系统和服务管理器</strong>，运行为 PID 1 并负责启动其它程序。</p>
<p><strong>systemd 常用命令</strong>（它是一组命令的集合）：<br>systemctl start nginx # 启动服务<br>systemctl stop nginx # 停止服务<br>systemctl restart nginx # 重启服务<br>systemctl status nginx # 查看服务状态<br>systemctl reload nginx # 重载配置文件(不停止服务的情况)  热加载<br>systemctl enable nginx # 开机自动启动服务<br>systemctl disable nginx # 开机不自动启动服务<br>systemctl is-enabled nginx # 查看服务是否开机自动启动<br>systemctl list-unit-files –type&#x3D;service # 查看各个级别下服务的启动和禁用情况</p>
<hr>
<p>打包：<strong>是将多个文件变成一个总的文件</strong>，它的学名叫存档、<strong>归档</strong>。<br>压缩：是将一个大文件（通常指归档）压缩变成一个小文件。</p>
<p>我们常常<strong>使用 tar 将多个文件归档为一个总的文件</strong>，称为 <strong>archive</strong> 。 然后用 gzip 或 bzip2 命令将 archive 压缩为更小的文件。</p>
<p><strong>tar 是用来打包文件的，gzip 用来对打包后的东西进行压缩的。</strong></p>
<p>tar<br>创建一个 tar 归档。<br>tar -cvf sort.tar sort&#x2F;      # 将 sort 文件夹归档为sort.tar<br>tar -cvf archive.tar file1 file2 file3       # 将 file1 file2 file3 归档为 archive.tar</p>
<p>-cvf 表示 create（创建）+ verbose（细节）+ file（文件），创建归档文件并显示操作细节；<br>-tf 显示归档里的内容，并不解开归档；<br>-rvf 追加文件到归档， tar -rvf archive.tar file.txt ；<br>-xvf 解开归档， tar -xvf archive.tar 。</p>
<p>gzip &#x2F; gunzip<br>“压缩&#x2F;解压”归档，默认用 gzip 命令，压缩后的文件后缀名为 .tar.gz （在原来的基础上加了 .gz）。<br>gzip archive.tar # 压缩，压缩完就成了 archive.tar.gz，原来是这么来的<br>gunzip archive.tar.gz # 解压</p>
<p>tar <strong>直接一步归档+压缩 使用 z 参数</strong><br>可以用 tar 命令同时完成归档和压缩的操作，就是给 tar 命令多加一个选项参数，使之完成归档操作后，接着调用 gzip 或 bzip2 命令来完成压缩操作。</p>
<p>tar -zcvf archive.tar.gz archive&#x2F;       # 将archive文件夹归档并压缩<br>tar -zxvf archive.tar.gz                       # 将archive.tar.gz文件解压并解包</p>
<p>zip&#x2F;unzip<br>“压缩&#x2F;解压” zip 文件（ zip 压缩文件一般来自 windows 操作系统）。</p>
<p>unzip archive.zip       # 解压 .zip 文件<br>unzip -l archive.zip    # 不解开 .zip 文件，只看其中内容<br>zip -r sort.zip sort&#x2F;      # 将sort文件夹压缩为 sort.zip，其中-r表示递归</p>
<hr>
<p>ifconfig<br>查看 ip 网络相关信息<br>eth0 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。 eth 是 Ethernet 的缩写，表示“以太网”。有些电脑可能同时有好几条网线连着，例如服务器，那么除了 eht0 ，你还会看到 eth1 、 eth2 等。</p>
<p>lo 表示<strong>本地回环</strong>（ Local Loopback 的缩写，对应一个虚拟网卡）可以看到它的 ip 地址是 127.0.0.1 。每台电脑都应该有这个接口，因为<strong>它对应着“连向自己的链接”</strong>。这也是被称之为“本地回环”的原因。<strong>所有经由这个接口发送的东西都会回到你自己的电脑</strong>。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 127.0.0.1:3000 启动项目就能查看到自己的 web 网站，并且它只有你能看到。</p>
<p>wlan0 表示无线局域网（上面案例并未展示）。</p>
<p><strong>其中的字段详细分析</strong></p>
<hr>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> docker0 接口：</span><br><span class="line">Flags: UP, BROADCAST, RUNNING, MULTICAST</span><br><span class="line">UP：接口已启用。</span><br><span class="line">BROADCAST：接口支持广播。</span><br><span class="line">RUNNING：接口正在运行。</span><br><span class="line">MULTICAST：接口支持多播。</span><br><span class="line">MTU: 最大传输单元设为 1500 字节。</span><br><span class="line">IPv4 地址: 172.17.0.1</span><br><span class="line">子网掩码: 255.255.0.0</span><br><span class="line">广播地址: 172.17.255.255</span><br><span class="line">MAC 地址: 02:42:fe:29:b2:c7</span><br><span class="line">TX Queue Length: 0  (有说明是堆积)</span><br><span class="line">接收数据:</span><br><span class="line">RX packets: 6422689 (673385784 bytes, 642.1 MiB)</span><br><span class="line">发送数据:</span><br><span class="line">TX packets: 8427171 (777251703 bytes, 741.2 MiB)</span><br><span class="line">错误信息:</span><br><span class="line">RX errors: 0</span><br><span class="line">TX errors: 0</span><br><span class="line">Dropped: 0</span><br><span class="line">Overruns: 0</span><br><span class="line">Carrier: 0</span><br><span class="line">Collisions: 0</span><br><span class="line"><span class="bullet">2.</span> eth0 接口：</span><br><span class="line">Flags: UP, BROADCAST, RUNNING, MULTICAST</span><br><span class="line">MTU: 1500 字节。</span><br><span class="line">IPv4 地址: 172.24.49.31</span><br><span class="line">子网掩码: 255.255.192.0</span><br><span class="line">广播地址: 172.24.63.255</span><br><span class="line">MAC 地址: 16:3e:0c:e9:32</span><br><span class="line">TX Queue Length: 1000</span><br><span class="line">接收数据:</span><br><span class="line">RX packets: 145544271 (3074000141 bytes, 2.8 GiB)</span><br><span class="line">发送数据:</span><br><span class="line">TX packets: 20069810 (6829490246 bytes, 6.3 GiB)</span><br><span class="line">错误信息:</span><br><span class="line">RX errors: 0</span><br><span class="line">TX errors: 0</span><br><span class="line">Dropped: 0</span><br><span class="line">Overruns: 0</span><br><span class="line">Carrier: 0</span><br><span class="line">Collisions: 0</span><br><span class="line"><span class="bullet">3.</span> lo 接口 (本地环回):</span><br><span class="line">Flags: UP, LOOPBACK, RUNNING</span><br><span class="line">LOOPBACK：表示这是一个环回接口，可用来测试和诊断。</span><br><span class="line">MTU: 65536 字节。</span><br><span class="line">IPv4 地址: 127.0.0.1</span><br><span class="line">子网掩码: 255.0.0.0</span><br><span class="line">TX Queue Length: 1000</span><br><span class="line">接收数据:</span><br><span class="line">RX packets: 14474386 (965560056 bytes, 920.8 MiB)</span><br><span class="line">发送数据:</span><br><span class="line">TX packets: 14474386 (965560056 bytes, 920.8 MiB)</span><br><span class="line">错误信息:</span><br><span class="line">RX errors: 0</span><br><span class="line">TX errors: 0</span><br><span class="line">Dropped: 0</span><br><span class="line">Overruns: 0</span><br><span class="line">Carrier: 0</span><br><span class="line">Collisions: 0</span><br><span class="line"><span class="bullet">4.</span> veth8c3e389 接口：</span><br><span class="line">Flags: UP, BROADCAST, RUNNING, MULTICAST</span><br><span class="line">MTU: 1500 字节。</span><br><span class="line">MAC 地址: aa:58:e1:08:a2:41</span><br><span class="line">TX Queue Length: 0</span><br><span class="line">接收数据:</span><br><span class="line">RX packets: 201297 (11494783 bytes, 10.9 MiB)</span><br><span class="line">发送数据:</span><br><span class="line">TX packets: 204026 (11465208 bytes, 10.9 MiB)</span><br><span class="line">错误信息:</span><br><span class="line">RX errors: 0</span><br><span class="line">TX errors: 0</span><br><span class="line">Dropped: 0</span><br><span class="line">Overruns: 0</span><br><span class="line">Carrier: 0</span><br><span class="line">Collisions: 0</span><br><span class="line"><span class="bullet">5.</span> veth91ae093 接口：</span><br><span class="line">Flags: UP, BROADCAST, RUNNING, MULTICAST</span><br><span class="line">MTU: 1500 字节。</span><br><span class="line">MAC 地址: e6:be:65:44:4f:0f</span><br><span class="line">TX Queue Length: 0</span><br><span class="line">接收数据:</span><br><span class="line">RX packets: 3792486 (258331820 bytes, 246.3 MiB)</span><br><span class="line">发送数据:</span><br><span class="line">TX packets: 501432 (347569256 bytes, 331.4 MiB)</span><br><span class="line">错误信息:</span><br><span class="line">RX errors: 0</span><br><span class="line">TX errors: 0</span><br><span class="line">Dropped: 0</span><br><span class="line">Overruns: 0</span><br><span class="line">Carrier: 0</span><br><span class="line">Collisions: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>docker0 是 <strong>Docker 创建的一个虚拟桥接网络</strong>，用于容器之间的通信。<br>eth0 是主机的<strong>主要网络接口</strong>，连接到局域网或互联网。<br>lo 是环回接口，用于本地通信。<br>veth8c3e389 和 veth91ae093 是<strong>虚拟以太网设备【veth（Virtual Ethernet）设备】</strong>，用于容器与主机或其他容器之间的通信。</p>
<p>我们<strong>已经有 docker0 网桥来实现容器与容器以及容器与主机之间的通信</strong>，但 veth 设备也是 Docker 网络的关键组成部分。</p>
<p>veth 设备是什么？<br><strong>veth（Virtual Ethernet）设备对由两个虚拟网络接口组成。它们总是成对出现</strong>，<strong>每一对中的一个接口连接到容器内部的网络接口，另一个接口连接到 Docker 网桥</strong>，其中veth 的<strong>一端连接到容器内的虚拟网络接口，另一端连接到主机上的 Docker 网桥</strong>（如 docker0）。<br>我们使用 veth 设备来实现以下通信场景：<br><strong>容器与主机的通信</strong>：veth 的一端位于容器内，另一端连接到<strong>主机的网桥</strong>（如 docker0）。这种配置使容器能够与主机及其上的其他容器通信。<br><strong>容器与容器的通信</strong>：通过连接 veth 设备的另一端到 docker0，容器可以通过网桥与其他容器通信。<br>为什么需要 veth8c3e389 和 veth91ae093<br><strong>docker0 是一个桥接网络接口，它本身并不能直接与容器通信</strong>。<strong>每个运行中的容器</strong>需要<strong>自己的虚拟网络接口以实现网络连接</strong>。<br>在你的系统中，veth8c3e389 和 veth91ae093 是两个容器的虚拟以太网设备。它们通过 docker0 实现了以下通信机制：<br>容器 &lt;-&gt; 容器：多个容器之间通过<strong>虚拟以太网设备和 docker0</strong>进行通信。<br>容器 &lt;-&gt; 主机：容器通过<strong>它们的虚拟以太网设备与 docker0 相连，然后与主机通信</strong>。</p>
<p>veth8c3e389 和 veth91ae093 是 Docker 创建的两个 veth 对的其中一个端口，另一个端口会接入到<strong>对应的容器的内部接口</strong>（如 eth0 一样的接口）。这两个 veth 的<strong>这一端都连接在 Docker 网桥上</strong>，如 docker0。</p>
<p><strong>Docker 网桥 docker0 类似于一个虚拟的以太网交换机</strong>，它将<strong>所有连接到它的 veth 端口互联起来</strong>，<strong>同时它也有自己的 IP 地址</strong>【那两个 veth 都是只有 mac 没有 ip 地址的】。对于在主机和容器之间的通信，情况如下：<br>主机与容器通信： <strong>主机就像其他网络设备一样，也可以与 docker0 进行通信</strong>。docker0 网桥就像主机的另一个网络接口（类似于 eth0 ），它使得主机可以通过它与各个容器通信【<strong>真就交换机</strong>】。这种情况下，主机向 docker0 发送的数据包会通过相应的 veth 接口传递到对应的容器内。</p>
<p>docker0 作为一个虚拟网桥，<strong>在主机上下文中可以看作是一个网络接口，它与主机的 eth0、lo 等接口并列</strong>。<br>它将不同容器的 veth 接口连接起来，通过这种方式实现主机与容器、以及容器与其他容器之间的通信。</p>
<p>网络统计信息的解释<br>Dropped: 0：表示由于<strong>接口的队列已满</strong>、或达到某种限制而<strong>丢弃</strong>的数据包数。0 表示没有丢包。<br>Overruns: 0：进入接口的数据包因为<strong>接口处理速度慢</strong>或者资源不足而被<strong>丢弃</strong>的次数。0 表示没有过载丢包。<br>Carrier: 0：<strong>物理层传输错误的次数</strong>。0 表示物理层没有错误。<br>Collisions: 0：以太网协议下数据包在<strong>同一个网络硬件介质上产生的冲突数</strong>。0 表示没有冲突。<br>Frame: 0：MAC 层<strong>帧校验错误</strong>的次数。0 表示没有帧错误。<br>这些信息帮助你了解网络接口的健康状态和性能。如果这些值不是零，则可能需要进一步调查网络问题。<br>总结起来，veth 设备是 Docker 网络架构的重要组成部分，结合 docker0 实现容器的网络通信。而网络统计数据提供关于网络接口运行状况的详细信息。</p>
<p>在一些服务器和虚拟机的配置中，即使使用 ip addr 或 ifconfig 也看不到外部网络（Public IP）的 IP 地址，这可能有以下几个原因：</p>
<ol>
<li>网络配置方式<br>在很多云服务提供商（如 AWS、Azure、Google Cloud）的虚拟机实例上，外部 IP（Public IP）<strong>通常不会直接配置在服务器的网络接口上</strong>，而是通过一种叫做<strong>网络地址转换</strong>（NAT, Network Address Translation）的技术来进行映射。这种情况下，<strong>实例内部的网络接口（如 eth0）通常只配置有私有 IP 地址</strong>。</li>
</ol>
<p>灵活性：使用 NAT，可以动态映射外部 IP 地址到内部网络，便于管理和负载均衡。</p>
<hr>
<p>host<br>ip 地址和主机名的互相转换。</p>
<p>ssh 用户@ip:port<br>1、ssh <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#x37;&#x32;&#46;&#50;&#x30;&#46;&#x31;&#48;&#x2e;&#49;">&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#x37;&#x32;&#46;&#50;&#x30;&#46;&#x31;&#48;&#x2e;&#49;</a>:22    # 端口号可以省略不写，默认是22端口<br>2、输入连接密码后就可以操作远端服务器了</p>
<p>wget<br>可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。</p>
<p>netstat命令<br>netstat命令用于显示网络相关信息，主要包括<strong>网络连接、路由表接口状态</strong>等信息，<br>常用查询unix、tcp、udp等网络、端口信息的查询。</p>
<p>​ 直接执行无参数的 netstat 得到的信息如下：<br>1、Active Internet connects，其参数含义如下：<br>Proto：网络协议，如 tcp、udp等；<br>Recv-Q：接收队列，如果为非0，表示有堆积数据；<br>Send-Q：发送队列，如果为非0，表示发送消息数据有堆积；<br>Local Address：本地路由表；<br>Forengn Address：远端的ip（或者域名）、端口；<br>State：套接字当前的状态；</p>
<p>2、Active UNIX domain sockets，其参数含义：<br>RefCnt：链接到套接字的进程号；<br>Flags：<br>Type：套接口类型：流套接字(SOCK_STREAM)、数据报套接字(SOCK_DGRAM)、原始套接字(SOCK_RAW)；<br>I-Node：<br>Path：连接到套接口的其它进程使用的路径名；</p>
<p>netstat [选项]<br>-t或–tcp：显示TCP传输协议的连线状况；<br>-u或–udp：显示UDP传输协议的连线状况；<br>-l或–listening：<strong>显示监听中的服务器的Socket</strong>；<br>-n或–numeric：直接使用ip地址，而不通过域名服务器；<strong>速度更快</strong></p>
<p><strong>常用的命令组合有</strong>：<br>1、显示所有的端口<br>netstat -a：列出所有的端口；<br>netstat -at：列出所有的tcp端口；<br>netstat -au：列出所有的udp端口；<br>netstat -ax：列出所有的unix端口；</p>
<p>2、显示监听端口<br>netstat -l：列出所有的监听端口；<br>netstat -lt：列出所有的tcp监听端口；<br>netstat -lu：列出所有的udp监听端口；<br>netstat -lx：列出所有的unix监听端口；</p>
<p>4、netstat -anp（netstat -anp| grep nginx）常用查询命令<br>-a：显示所有；<br>-n：只显示ip不显示域名；<br>-p：显示pid和进程名称；</p>
<p><strong>经常配合 grep 服务名称</strong>，如 grep nginx <strong>查询服务启动的信息</strong>（ nginx 监听ip和端口6379、进程号为21627），这里也可以使用 ps -ef| grep nginx 查询；</p>
<p>5、netstat -r（netstat -rn） 显示路由表信息 【<strong>八股神表</strong>】<br>加上n，则不显示主机名称，只显示ip地址，显示字段含义为：</p>
<p>Destination：目的ip地址；<br>Gateway：路由；<br>Genmask：<br>Flags：<br>MSS Windows：最大报文端大小；<br>irtt Iface：</p>
<hr>
<p>lsof文件工具<br>lsof（list open files）是一个<strong>列出当前系统打开文件的工具</strong>。</p>
<p>在linux环境下，<strong>任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。</strong></p>
<p>所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序<strong>分配了一个文件描述符</strong>，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为<strong>应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息</strong>，因此通过 lsof 工具查看这个列表对系统监测以及排错将是很有帮助的。</p>
<p>2．命令功能：<br><strong>用于查看你进程打开的文件</strong>，打开文件的进程，<strong>进程打开的端口</strong>(TCP、UDP)，找回&#x2F;恢复删除的文件。</p>
<p>是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要root用户执行。</p>
<p>lsof打开的文件可以是：<br>普通文件<br>目录<br>字符或设备文件<br>(函数)共享库<br>管道，命名管道<br>网络文件（例如：NFS file、网络socket，unix域名socket）</p>
<p>3．命令参数<br>-a 列出打开文件存在的进程<br>-c&lt;进程名&gt; 列出指定进程所打开的文件<br>-p&lt;进程号&gt; 列出指定进程号所打开的文件<br>-i&lt;条件&gt; <strong>列出符合条件的进程</strong>。（ipv4、ipv6、tcp\udp协议、:端口、 @ip ）</p>
<p>TYPE：文件类型，如DIR、REG等，常见的文件类型<br>（1）DIR：表示目录<br>（2）CHR：表示字符类型<br>（3）BLK：块设备类型<br>（4）UNIX： UNIX 域套接字<br>（5）FIFO：先进先出 (FIFO) 队列<br>（6）IPv4：网际协议 (IP) 套接字</p>
<p><strong>FD：文件描述符，应用程序通过文件描述符识别该文件</strong>。如cwd、txt等</p>
<p>（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改<br>（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序<br>（15）0：表示标准输入<br>（16）1：表示标准输出<br>（17）2：表示标准错误  【<strong>原来在这呀</strong>】</p>
<p>1、 查找某个文件【&#x2F;bin&#x2F;bash】相关的进程， 查看谁正在使用某个文件<br>lsof &#x2F;home&#x2F;shortlink&#x2F;shortlink-aggregation.jar<br>会返回哪些进程在使用这些文件。</p>
<p>2、列出某个程序进程所打开的文件信息<br>lsof -c mysql<br>说明: -c 选项将会列出所有以 mysql 为开头的进程打开的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</p>
<p>3、通过某个进程号显示该进程打开的文件<br>lsof -p 6429</p>
<p>4、列出所有的网络连接<br>lsof -i</p>
<p>5、列出所有tcp 或 udp 网络连接信息<br>lsof -i tcp<br>lsof -i udp</p>
<p>6、列出谁在使用某个端口<br>lsof -i :3306</p>
<p>7、列出谁在使用某个特定的udp端口<br>命令：lsof -i udp:55<br>或者：特定的tcp端口<br>命令：lsof -i tcp:80</p>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker 包括三个基本概念:</p>
<p>镜像（Image）：Docker 镜像（Image），就相当于是一个 <strong>root 文件系统</strong>。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。<br>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等。<br>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br>我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>总结下：<br>其实yum换源就是把&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo备份之后删除，然后下载新的源curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/repo/Centos-7.repo%E3%80%82%E6%9C%80%E5%90%8E">http://mirrors.aliyun.com/repo/Centos-7.repo。最后</a><br>yum clean all<br>yum make cache。</p>
<p>查看docker配置<br>编辑 &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</p>
<p>docker镜像换源是另外的，这样做：<br>指定Docker镜像源下载地址为阿里云镜像仓库：<br>yum-config-manager –add-repo <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p>
<p>docker的镜像源一定一定要用这个，不然每次都要被气的吐血<br>cat &#x2F;etc&#x2F;docker&#x2F;daemon.json<br>{<br>  “registry-mirrors”: [“<a target="_blank" rel="noopener" href="https://sysxm1uh.mirror.aliyuncs.com&quot;/">https://sysxm1uh.mirror.aliyuncs.com&quot;</a>,<br>    “<a target="_blank" rel="noopener" href="https://docker.m.daocloud.io&quot;/">https://docker.m.daocloud.io&quot;</a>,<br>        “<a target="_blank" rel="noopener" href="https://dockerproxy.com&quot;/">https://dockerproxy.com&quot;</a>,<br>        “<a target="_blank" rel="noopener" href="https://docker.mirrors.ustc.edu.cn&quot;/">https://docker.mirrors.ustc.edu.cn&quot;</a>,<br>        “<a target="_blank" rel="noopener" href="https://docker.nju.edu.cn&quot;/">https://docker.nju.edu.cn&quot;</a><br>    ]<br>}<br>systemctl daemon-reload<br>systemctl restart docker</p>
<!-- flag of hidden posts -->
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>lichao Zhang
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://iridescent-zhang.github.io/2024/09/01/BaGu/" title="BaGu">https://iridescent-zhang.github.io/2024/09/01/BaGu/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E"><span class="nav-number">1.</span> <span class="nav-text">谷粒商城</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B8%80%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">前端学一点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">遇到的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%95%86%E5%9F%8E%E7%BB%86%E8%8A%82"><span class="nav-number">2.</span> <span class="nav-text">商城细节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.1.</span> <span class="nav-text">数据库设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%93%E5%AD%98%E5%BA%93-wms"><span class="nav-number">2.1.1.</span> <span class="nav-text">库存库 wms</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A2%E5%8D%95%E5%BA%93-oms"><span class="nav-number">2.1.2.</span> <span class="nav-text">订单库 oms</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%95%86%E5%93%81%E5%BA%93-pms"><span class="nav-number">2.1.3.</span> <span class="nav-text">商品库 pms</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E5%91%98%E5%BA%93-ums"><span class="nav-number">2.1.4.</span> <span class="nav-text">会员库 ums</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%92%E6%9D%80%E8%A1%A8-sms"><span class="nav-number">2.1.5.</span> <span class="nav-text">秒杀表 sms</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF"><span class="nav-number">2.2.</span> <span class="nav-text">全局异常信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis"><span class="nav-number">2.3.</span> <span class="nav-text">redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E7%9A%84key%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">用过的key、数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%EF%BC%88session%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8C%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">用法（session，分布式锁，幂等性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redisson"><span class="nav-number">2.3.3.</span> <span class="nav-text">redisson</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E6%B5%8B"><span class="nav-number">2.4.</span> <span class="nav-text">压测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-%E7%A7%92%E6%9D%80%E5%95%86%E5%93%81%E4%B8%8A%E6%9E%B6"><span class="nav-number">2.5.</span> <span class="nav-text">定时任务 秒杀商品上架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%92%E6%9D%80"><span class="nav-number">2.6.</span> <span class="nav-text">秒杀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.7.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">2.8.</span> <span class="nav-text">登录拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#session-%E8%B7%A8%E5%9F%9F"><span class="nav-number">2.8.1.</span> <span class="nav-text">session 跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95"><span class="nav-number">2.8.2.</span> <span class="nav-text">社交登录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sentinel-%E8%BF%9B%E8%A1%8C%E6%B5%81%E6%8E%A7"><span class="nav-number">2.9.</span> <span class="nav-text">sentinel 进行流控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93"><span class="nav-number">2.10.</span> <span class="nav-text">项目总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%AD%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">短链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2"><span class="nav-number">3.1.</span> <span class="nav-text">部署</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E4%BB%A5%E5%8F%8A-%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">分库分表 以及 表结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E9%93%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.1.</span> <span class="nav-text">短链重复的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%9F%AD%E9%93%BE"><span class="nav-number">3.3.2.</span> <span class="nav-text">访问短链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.3.</span> <span class="nav-text">分组的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12306"><span class="nav-number">4.</span> <span class="nav-text">12306</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%89%87%E8%A7%84%E5%88%99"><span class="nav-number">4.1.</span> <span class="nav-text">分片规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A2%E5%8D%95%E8%A1%A8%EF%BC%88t-order%E3%80%81t-order-item%E3%80%81t-order-item-passenger%EF%BC%89"><span class="nav-number">4.1.1.</span> <span class="nav-text">订单表（t_order、t_order_item、t_order_item_passenger）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E4%BB%98%E8%A1%A8%EF%BC%88t-pay%EF%BC%89"><span class="nav-number">4.1.2.</span> <span class="nav-text">支付表（t_pay）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%A1%A8"><span class="nav-number">4.1.3.</span> <span class="nav-text">用户表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%A6%E7%A5%A8%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.2.</span> <span class="nav-text">车票服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">简历问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12306-1"><span class="nav-number">5.1.</span> <span class="nav-text">12306</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B8%80%E4%B8%8B-rocketmq"><span class="nav-number">5.1.2.</span> <span class="nav-text">学一下 rocketmq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E5%85%B3"><span class="nav-number">5.1.3.</span> <span class="nav-text">网关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.1.4.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96"><span class="nav-number">5.1.5.</span> <span class="nav-text">接口优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%82%E7%AD%89"><span class="nav-number">5.1.6.</span> <span class="nav-text">幂等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0-ShardingSphere"><span class="nav-number">5.1.7.</span> <span class="nav-text">学习 ShardingSphere</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E9%9A%BE%E9%A2%98"><span class="nav-number">5.1.8.</span> <span class="nav-text">业务难题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%AD%E9%93%BE%E6%8E%A5-1"><span class="nav-number">5.2.</span> <span class="nav-text">短链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ENDB"><span class="nav-number">6.</span> <span class="nav-text">ENDB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TM-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">6.1.</span> <span class="nav-text">TM 事务管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-number">6.1.1.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DM-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">6.2.</span> <span class="nav-text">DM 数据管理器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E6%8B%B7%E6%89%93"><span class="nav-number">7.</span> <span class="nav-text">面试拷打</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%85%BE%E8%AE%AF-cdg-%E4%B8%80%E9%9D%A2"><span class="nav-number">7.1.</span> <span class="nav-text">腾讯 cdg 一面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#teg-%E4%BA%8C%E9%9D%A2"><span class="nav-number">7.2.</span> <span class="nav-text">teg 二面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E6%89%8B%E4%B8%80%E9%9D%A2"><span class="nav-number">7.3.</span> <span class="nav-text">快手一面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E6%89%8B%E4%BA%8C%E9%9D%A2"><span class="nav-number">7.4.</span> <span class="nav-text">快手二面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pdd-%E4%B8%80%E9%9D%A2"><span class="nav-number">7.5.</span> <span class="nav-text">pdd 一面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%85%BE%E8%AE%AF%E4%BA%91"><span class="nav-number">7.6.</span> <span class="nav-text">腾讯云</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B8%80%E9%9D%A2"><span class="nav-number">7.6.1.</span> <span class="nav-text">腾讯云一面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%85%BE%E8%AE%AF%E4%BA%91%E4%BA%8C%E9%9D%A2"><span class="nav-number">7.6.2.</span> <span class="nav-text">腾讯云二面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%98%E5%A4%A9"><span class="nav-number">7.7.</span> <span class="nav-text">淘天</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E5%A4%A9%E4%B8%80%E9%9D%A2"><span class="nav-number">7.7.1.</span> <span class="nav-text">淘天一面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E5%A4%A9%E4%BA%8C%E9%9D%A2"><span class="nav-number">7.7.2.</span> <span class="nav-text">淘天二面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BE%8E%E5%9B%A2"><span class="nav-number">7.8.</span> <span class="nav-text">美团</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2"><span class="nav-number">7.9.</span> <span class="nav-text">美团一面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BE%8E%E5%9B%A2%E4%BA%8C%E9%9D%A2"><span class="nav-number">7.10.</span> <span class="nav-text">美团二面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%BA%E7%A8%8B%E4%B8%80%E9%9D%A2"><span class="nav-number">7.11.</span> <span class="nav-text">携程一面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E9%9D%A2"><span class="nav-number">7.11.1.</span> <span class="nav-text">二面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BF%E9%87%8C%E4%BA%91-%E4%B8%80%E9%9D%A2"><span class="nav-number">7.12.</span> <span class="nav-text">阿里云 一面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E9%9D%A2-1"><span class="nav-number">7.12.1.</span> <span class="nav-text">二面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%BE%E7%9A%AE"><span class="nav-number">7.13.</span> <span class="nav-text">虾皮</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E9%9D%A2"><span class="nav-number">7.13.1.</span> <span class="nav-text">一面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-%E7%BB%86%E8%8A%82"><span class="nav-number">7.14.</span> <span class="nav-text">tcp 细节</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8E%86%E4%BF%A1%E6%81%AF"><span class="nav-number">8.</span> <span class="nav-text">简历信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E7%96%91%E9%9A%BE"><span class="nav-number">9.</span> <span class="nav-text">要解决的疑难</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%95%E9%80%92"><span class="nav-number">10.</span> <span class="nav-text">投递</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AF%95"><span class="nav-number">11.</span> <span class="nav-text">笔试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux"><span class="nav-number">12.</span> <span class="nav-text">linux</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker"><span class="nav-number">13.</span> <span class="nav-text">docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">13.1.</span> <span class="nav-text">配置</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lichao Zhang"
      src="/images/cloud.jpg">
  <p class="site-author-name" itemprop="name">lichao Zhang</p>
  <div class="site-description" itemprop="description">博观而约取，厚积而薄发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Iridescent-zhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Iridescent-zhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lczhang93@gmail.com" title="E-Mail → mailto:lczhang93@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/18558575/wo-ladki" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;18558575&#x2F;wo-ladki" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/channel/UCv42aVozJF9n4hK8xCacCmg" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCv42aVozJF9n4hK8xCacCmg" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.youtube.com/watch?v=DGa4Xv_tcjE&list=LL&index=6" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v&#x3D;DGa4Xv_tcjE&amp;list&#x3D;LL&amp;index&#x3D;6" rel="noopener" target="_blank">Eiro Nareth INTERSTELLAR</a>
        </li>
    </ul>
  </div>

      </div>

	  
		<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
		<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
		<div class="widget-wrap">
		<div id="myCanvasContainer" class="widget tagcloud">
		<canvas width="220" height="250" id="resCanvas" style="width=100%">
			<ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cmd/" rel="tag">Cmd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Guitar/" rel="tag">Guitar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HLS/" rel="tag">HLS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NAT/" rel="tag">NAT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PYNQ/" rel="tag">PYNQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Powershell/" rel="tag">Powershell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP&#x2F;IP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li></ul>
		</canvas>
		</div>
		</div>
	  

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lichao Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">523k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">7:55</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'zmRLZ8XmVpWBhK4yl2baQmHm-gzGzoHsz',
      appKey     : 'c5e4Xhc2Ec8iU5BMArSxhhAu',
      placeholder: "Say something",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://zmrlz8xm.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fa fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fa fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button" onclick="moonMenuClick()">
    <svg class="moon-menu-svg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
      <g class="moon-menu-points">
        <circle class="moon-menu-point" r=".2rem" cx="0" cy="-.8rem"></circle>
        <circle class="moon-menu-point" r=".2rem"></circle>
        <circle class="moon-menu-point" r=".2rem" cx="0" cy=".8rem"></circle>
      </g>
    </svg>
    <div class="moon-menu-icon">
    </div>
    <div class="moon-menu-text">
    </div>
  </div>
</div>
<script src="/js/injector.js"></script>
    </div>
  <!-- 音乐播放器 -->
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
 <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
 <div id="aplayer" class="aplayer" data-id="3470747396" data-server="tencent" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
 <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
 <!-- 音乐播放器 end -->
</body>
</html>
