<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Witcher.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Witcher.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iridescent-zhang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":false,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Disqus","order":-1},"valine":{"text":"Valine","order":-2}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="立志欲坚不欲锐，成功在久不在速">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCodeNote">
<meta property="og:url" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/index.html">
<meta property="og:site_name" content="Iridescent-zhang">
<meta property="og:description" content="立志欲坚不欲锐，成功在久不在速">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/8.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/1.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/2.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/1.jpg">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/3.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/4.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/5.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/6.png">
<meta property="og:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/7.png">
<meta property="article:published_time" content="2024-03-05T12:40:07.000Z">
<meta property="article:modified_time" content="2025-09-17T10:19:40.032Z">
<meta property="article:author" content="lichao Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/8.png">

<link rel="canonical" href="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>LeetCodeNote | Iridescent-zhang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Iridescent-zhang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醉后不知天在水，满船清梦压星河</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cloud.jpg">
      <meta itemprop="name" content="lichao Zhang">
      <meta itemprop="description" content="博观而约取，厚积而薄发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Iridescent-zhang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCodeNote
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-03-05 12:40:07" itemprop="dateCreated datePublished" datetime="2024-03-05T12:40:07Z">2024-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-17 10:19:40" itemprop="dateModified" datetime="2025-09-17T10:19:40Z">2025-09-17</time>
              </span>

          
            <span id="/2024/03/05/LeetCodeNote/" class="post-meta-item leancloud_visitors" data-flag-title="LeetCodeNote" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/03/05/LeetCodeNote/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/03/05/LeetCodeNote/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>73k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:07</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><em><strong>立志欲坚不欲锐，成功在久不在速</strong></em></p>
<span id="more"></span>

<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p>原地算法基本就是：双指针加反转。</p>
<h2 id="必会知识点"><a href="#必会知识点" class="headerlink" title="必会知识点"></a>必会知识点</h2><p>原来如此，既然<strong>ArrayDeque</strong>是双端队列，那我如果只对一端进行操作那不就变成了栈了，管它是队列头还是队列尾，也就是说如果想当成栈操作，则各个操作要在同一端<br>比如 peek、pop、push、poll都在队列头部操作   getLast、removeLast、offer&#x2F;add都在队列尾部操作   所以这两种方式都可以模拟成栈</p>
<p>PriorityQueue&lt;int[]&gt; queue &#x3D; new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[0]-o2[0]); &#x2F;&#x2F; 这样的话就是小根堆</p>
<p><code>int[][] prerequisites， Arrays.sort(prerequisites, (o1, o2) -&gt; o1[0]-o2[0]); </code><br>通过调用 Arrays.sort(prerequisites, (o1, o2) -&gt; o1[0] - o2[0]);，你正在对二维数组 prerequisites 进行排序。具体来说，它会按照每个子数组（即 prerequisites 中的每一个一维数组）的第一个元素（o1[0] 和 o2[0]）进行升序排序</p>
<p><strong>PriorityQueue 默认是最小堆，Comparator (a, b) -&gt; a - b 也会导致元素以升序排列</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/16320430.html">红黑树好文</a><br>左旋：选择一个pivot节点，其父节点（root）左旋为自己的左子树，然后自己的原左子树变为原root节点的右子树，其他不变。（能这样旋转说明pivot原先是root的右子树，也就是右边高度太大了）<br>右旋：选择一个pivot节点，其父节点（root）右旋为自己的右子树，然后自己的原右子树变为原root节点的左子树，其他不变。（能这样旋转说明pivot原先是root的左子树，也就是左边高度太大了）</p>
<p>在 Java 中，所有的整数都是以二进制「补码」的形式存储的（PS：正数补码是本身，负数补码是对应正数带上符号位一块取反，然后加一）<br>比如-2^31是1000….000，实际上就是最高位（第32位的1，也即符号位1）本身就是代表-2^31，所以后面我们想要哪些负数，就在这个基础上加”正数”就好了，比如我加一个2^31-1即0111…111，那就得到了-1即1111…111。</p>
<p>在 Java 中，&gt;&gt; 是「带符号右移」操作符，它会将所有位向右移动指定的位数，「左边」空出的位「用原来的符号位」填充。这里注意：假如一个负数右移十位，实际上是在左边补了10个1。</p>
<img src="/2024/03/05/LeetCodeNote/8.png" class="">
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904025880526861">想研究可以在看看这篇</a></p>
<p>在 Java 中，&gt;&gt;&gt; 是无符号右移操作符，它会将所有位向右移动指定的位数，左边空出的位用 0 填充，不论原来的数是正数还是负数。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>二维数组</strong>用的时候不能直接push_back()一个元素，要往某一维上push一个元素先要往这个二维数组里push一个一维数组，like this:<br><code>ret.push_back(vector &lt;int&gt; ());</code><br>或者先建立一维数组来存放值，再push进二维数组。<br>或者动态resize二维数组的大小。</p>
<h3 id="n数之和"><a href="#n数之和" class="headerlink" title="n数之和"></a>n数之和</h3><p>经典题，用哈希表会非常难写，虽然也可以做到O(n^2)的时间复杂度，但是很难去重。</p>
<p>这题比较好的解法是排序加双指针，<strong>排序后的双指针非常好用</strong>。</p>
<h3 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912 排序数组"></a>912 排序数组</h3><p>经典排序题</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/">复习基础排序算法</a><br>这篇题解写的非常好，将排序算法讲的很通透。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>来一波二分查找的总结吧。</p>
<p>二分查找有两种题（目前做到的）<br>第一种：你的目标一定存在，你一定能找到唯一一个数符合你的目标，比如<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/guess-number-higher-or-lower/description/">374. 猜数字大小</a> 这种题随便写，可以用我后面重点说的通用解法，也可以用在循环里分(&lt;、&gt;、 &#x3D;&#x3D;)三种情况，都很好写。<br>第二种题：你的目标不一定存在，你可能要找你的理论目标最近的一个数，可能是 小于等于target的最大数 或 大于等于target的最小数。比如<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/solutions/333632/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/">35. 搜索插入位置</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/description/"> 69. x 的平方根</a>、（注：这种平方题可以用二分迭代法做）<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/description/">367. 有效的完全平方数</a> 等都是要找离目标最近的数，并且大多数不止要让你返回 true or false，还要你返回索引。</p>
<p>接下来重点介绍通用二分模板：<br>以<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/description/">367. 有效的完全平方数</a> 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = <span class="number">1</span>&lt;&lt;<span class="number">16</span>, mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line">    mid = (high-low)/<span class="number">2</span>+low;</span><br><span class="line">    <span class="keyword">if</span>(mid*mid&gt;=num) high = mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&lt;num) low = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> high*high==num;</span><br></pre></td></tr></table></figure>

<p>首先，用 <code>mid=(low+high)/2</code> 可以，但是用 <code>(high-low)/2+low</code> 更好（这俩是一模一样的），因为 <code>(low+high)</code> 可能超出 int 的范围。</p>
<p>其次，用 <code> while(low&lt;high)</code> 更好。根据这里我们可以找<strong>第一个平方大于等于目标数</strong>的数（当然也可以找<strong>最后一个平方小于等于目标数</strong>的数），并且注意到<code>(mid*mid&gt;=num) high = mid</code> 也就是说high始终有可能就是<strong>第一个平方大于等于目标数</strong>的数，而<code>(mid*mid&lt;num)</code>是mid很明显不是我们想要的，所以我们让<code>low = mid+1</code>，能不能让<code>low=mid</code>也不动，绝对不行！因为这里的mid已经确定不符合题意，<strong>一定要有一个逼近的过程</strong>，即使逼近程度只有1，否则等<code>low high</code>很接近的时候一定会死循环。<br>这样有什么好处？我的目标就是，始终让<strong>第一个平方大于等于目标数</strong>的数就在<code>[low,high]</code>中间，这里是<strong>闭区间</strong>，那么当<code>low==high</code>的时候左右两区间重合就可以自动退出循环，并且<code>low or high</code>就是我们想要的，后续所有的判断都可以根据这两个数来。这里又体现一个好处，退出循环的时候一定是<code>low==high</code>（因为两个数加起来一次循环也只会变化1），如果用的是<code> while(low&lt;=high)</code>退出的时候还要去想诶，到底<code>low or high or mid</code>哪个是有价值的数据，很折磨的。</p>
<p>还有一个<strong>很重要的问题</strong>，如果我找<strong>最后一个平方小于等于目标数</strong>的数，是不是只需要修改以下两个关键语句就可以呢？也就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line">    mid = (high-low)/<span class="number">2</span>+low;</span><br><span class="line">    <span class="keyword">if</span>(mid*mid&gt;num) high = mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&lt;=num) low = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错误</strong>！为什么？<br>细想，当low high 只差1的时候，mid是不是等于low，如果此时的low*low&lt;&#x3D;num是不是死循环了，low又等于mid，mid永远等于low，high根本没判断过呢，万一high才是<strong>最后一个平方小于等于目标数</strong>的数呢。<br>所以关键就是：low可能不动，所以要让mid去等于high（当然是low high 只差1的情况），也就是得这样<code>mid = (high-low+1)/2+low;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line">    mid = (high-low+<span class="number">1</span>)/<span class="number">2</span>+low;</span><br><span class="line">    <span class="keyword">if</span>(mid*mid&gt;num) high = mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&lt;=num) low = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下来：low和high中一个不动，计算mid的时候一定要等于另一个，不然low high相邻的时候就会死循环。</p>
<p>目前来看，所有二分查找都可以用这个模板，灵活变通吧。</p>
<h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/description/">169. 多数元素</a><br>被简单题薄纱(加进阶是真难)<br>这题有很多解法：随机化（第一次见这种抽象解法）、分治、Boyer-Moore 投票算法</p>
<p>分治的关键在于：将数组分成两个子数组之后，数组的主要元素一定是两个子数组主要元素之中的一个，因为如果数组的主要元素不是两个子数组主要元素之一，那这个主要元素出现次数一定小于数组一半(反证法)。<br>分治法还要考虑到最小子问题才能成型，也就是长度为1的数组的主要元素就是其中唯一的数。<br>分支法还能解决问题：<strong>数组中出现次数最多的数字</strong>，不会受到题目中的限制（超过半数）。<br>merge过程中都是要再遍历一次数组的，两个子问题加上n，总的时间复杂度就是O(nlgn)。</p>
<p>Boyer-Moore 投票算法：同归于尽消杀法</p>
<h3 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/solutions/601946/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/">448. 找到所有数组中消失的数字</a><br>利用数组当哈希表（原地），巧妙利用数据的宽度，结合取模在保有原数据信息的同时加入了新的信息。</p>
<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/?envType=study-plan-v2&envId=top-100-liked">4. 寻找两个正序数组的中位数</a></p>
<p>二分查找 真的难 写不出来。二分简单，但关键是怎么把问题抽象成二分，像这题转换为找第K数，然后每次减半，我就没想到这个转换，麻了。</p>
<p>二分法我思路差不多呀，但我想的是大的那个数的右边也要删，两边都删然后向中间靠拢，然后破防了太难整了。转换成第K数真的太关键了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex1</span> <span class="operator">=</span> totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthElement</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kthElement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-primes/solutions/507273/ji-shu-zhi-shu-by-leetcode-solution/">埃氏筛</a></p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><strong>位运算很重要，有些题很有技巧性</strong></p>
<img src="/2024/03/05/LeetCodeNote/1.png" class="">
<img src="/2024/03/05/LeetCodeNote/2.png" class="">
<p><strong>注意观察规律</strong>，A 到 Z 的低六位是 1 到 26，也就是 000001 到 011010。<br>而 a 到 z 的 低六位 是 33 到 58，也就是 100001 到 111010。<br>相差刚好是 倒数第六位的二进制 1 ，也就是 32（97-65），应该ascii码就是这么设计的，这样的话 <code>(A |= 1&lt;&lt;5)==a</code>，| 运算在这里<strong>等效于加法</strong>。<br>并且 A 到 Z 、a 到 z 的 低六位各不一样，分布在 1 到 64内，可以直接用 一个64bit 的long型整数<strong>压缩存储</strong>A 到 Z 、a 到 z，如：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jewels-and-stones/solutions/2356253/ben-ti-zui-you-jie-xian-xing-shi-jian-ch-ddw3/">771. 宝石与石头</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; (ch&amp;<span class="number">63</span>);</span><br></pre></td></tr></table></figure>
<p>这样每个 A 到 Z 、a 到 z 都可以用 mask 的 1 bit 来存储。<br>上面提到的两种用法都是在题里面见到过的。</p>
<h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/solutions/242211/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/">只出现一次的数字</a></p>
<p>对于这道题，可使用异或运算 ^。异或运算有以下三个性质。<br>任何数和 0 做异或运算，结果仍然是原来的数。<br>任何数和其自身做异或运算，结果是 0。<br>异或运算满足交换律和结合律。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number-ii/description/">137. 只出现一次的数字 II</a><br>这题是真难。<br>其实关键就是：数电的方法优化在<strong>利用位运算的并行性</strong>，直接使用32个状态机（每个二进制位都当作一个状态机），而方法二只使用了一个状态机，所以时间复杂度多了一个logC。</p>
<img src="/2024/03/05/LeetCodeNote/1.jpg" class="">


<h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-binary/solutions/299667/er-jin-zhi-qiu-he-by-leetcode-solution/">二进制求和</a></p>
<p>两个二进制数 异或^ 可以视作忽略进位的求和，但之后要补上进位。<br>怎么补呢？用 与&amp; ，&amp;完之后还需要左移一位（能理解吧），之后迭代重复以上步骤直到进位变为0。</p>
<p>同时注意：java里数字异或不需要转为二进制数，用十进制数来异或是正确的。<br>Integer.parseInt(String 2)将字符串a按二进制解析其内容(解析成10进制数)，Integer.toBinaryString(int n)将十进制数转为<strong>二进制字符串</strong>。</p>
<h3 id="颠倒二进制位"><a href="#颠倒二进制位" class="headerlink" title="颠倒二进制位"></a>颠倒二进制位</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-bits/solutions/685436/dian-dao-er-jin-zhi-wei-by-leetcode-solu-yhxz/">190. 颠倒二进制位</a><br>这个分治解法太骚了，翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。<br>上面的是正常解法，是自顶向下的。<br>但是，注意到位运算的特殊性，并且左右两边的计算方法相同，<strong>并且</strong>已知是32位的二进制数，所以我们可以直接自底向上（到这里总算开始理解了自底向上，其实自底向上并不总是用在递归中，用在这里或者用在动态规划就像作弊一样，关键点就在你要知道底在哪里，并且向上的过程要很清楚）。<br>这里直接定义4个常数M1234，他们的意思分别就是最后一层(只颠倒奇偶)、倒数第二层(将颠倒奇偶之后的按两位一组分成奇偶组，接着颠倒奇偶组)、倒数第三层、倒数第四层。</p>
<p>另外注意的是，在某些语言（如Java）中，<strong>没有无符号整数类型</strong>，因此对 n 的右移操作应使用<strong>逻辑右移</strong> <code>&gt;&gt;&gt;</code>。</p>
<p>同样的分治解法还有数1的个数<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-1-bits/solutions/">191. 位1的个数</a></p>
<h3 id="4的幂"><a href="#4的幂" class="headerlink" title="4的幂"></a>4的幂</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/power-of-four/solutions/798268/4de-mi-by-leetcode-solution-b3ya/">342. 4的幂</a><br><code>n &amp; (n - 1)==0 </code>判断 n 是否是 2 的幂，&#x3D;&#x3D;0就是2的幂，2 的幂是一个很严格的条件。5*2^6并不是2的幂，2的幂和4的幂真的就差一点，补充条件即可。</p>
<h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/power-of-two/solutions/796201/2de-mi-by-leetcode-solution-rny3/">2的幂</a></p>
<p>一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1。</p>
<p>因此我们可以考虑使用位运算，将 <strong>n 的二进制表示中最低位的那个 1</strong> 提取出来，再判断剩余的数值是否为 0 即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。</p>
<p>关键就是只管最低位的1。</p>
<p><strong>n &amp; (n - 1)&#x3D;&#x3D;0</strong> 注意，<code>n = n &amp; (n - 1)</code>操作可以将任意整数 n 的最后一位1变为0，由于2的幂只有一位1，所以最后一位1变为0之后结果如果是0则n为2的幂。</p>
<p><strong>n &amp; (-n)&#x3D;&#x3D;n</strong> 能够直接提取最低位的1，其他位都变为0。</p>
<p>那么 n 就是 2 的幂。</p>
<p>还有剑招：用2的最大幂除n，能整除则true。</p>
<h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">338. 比特位计数</a> 有库函数法(Integer.bitCount())、动态规划解法，也可以用Brian Kernighan 算法，原理就是利用前面说过的<code>n = n &amp; (n - 1)</code>操作可以将任意整数 n 的最后一位二进制 1 变为 0 ，那么对 x 重复该操作，直到 x变成 0，则操作次数即为 x 的「一比特数」。</p>
<h3 id="错误的集合"><a href="#错误的集合" class="headerlink" title="错误的集合"></a>错误的集合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-mismatch/solutions/857255/cuo-wu-de-ji-he-by-leetcode-solution-1ea4/">645. 错误的集合</a></p>
<p>这个位运算解法还不错，</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="环形链表2"><a href="#环形链表2" class="headerlink" title="环形链表2"></a>环形链表2</h3><p><strong>哈希表</strong><br> unordered_set&lt;ListNode *&gt; visited;<br>  unordered_set可以用 ListNode * 数据类型</p>
<p><strong>快慢指针</strong>一定在环内相遇，根据数学来找到开始入环的第一个节点。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoquantouer/article/details/51620657">Floyd 判圈算法</a><br>Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。</p>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p>被简单题薄纱（没有题感说实话）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">相交链表</a></p>
<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/solutions/492301/pai-xu-lian-biao-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">148. 排序链表</a></p>
<p>自底向上归并排序（用迭代不用递归），第一次见归并竟然没用递归然后做到了O(1)，真牛啊自底向上。<br>难哟。<br>以后可以尝试写一下，其实思路和递归归并是一样的，不过要在循环里控制长度sublength进行手动分组，记得分组完要切断其与前后的联系，相当于独立出两个小链表，然后合并(O(n)时间和O(1)空间)。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>在<strong>字符匹配的题里尽量用数组代替哈希表</strong>。这个<strong>很重要很重要</strong></p>
<p><strong>哈希表的 value 可以是一个数组</strong>，见<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/degree-of-an-array/description/">697. 数组的度</a><br><strong>这个用法真的很重要</strong>。如java：<br><code> Map&lt;Integer, int[]&gt; map = new HashMap&lt;Integer, int[]&gt;();</code></p>
<p>在实际代码中，我们使用哈希表实现该功能，<strong>每一个数映射到一个长度为 3 的数组</strong>，数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。</p>




<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202  快乐数"></a>202  快乐数</h3><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>要找是否存在环(循环)的题都可以用 快慢指针 这种思想。<br>本题还可以使用哈希表unordered_set。</p>
<h3 id="设计哈希集合"><a href="#设计哈希集合" class="headerlink" title="设计哈希集合"></a>设计哈希集合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-hashset/description/">705. 设计哈希集合</a></p>
<p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：</p>
<p><strong>哈希函数</strong>：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。<br><strong>冲突处理</strong>：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：</p>
<ul>
<li>链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</li>
<li>开放地址法：当发现哈希值 h 处产生冲突时，根据某种策略，从 h 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,… 这些整数对应的位置。</li>
<li>再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</li>
</ul>
<p><strong>扩容</strong>：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</p>
<blockquote>
<p>质数取模，其实是利用了同余的概念：当元素是个有规律的等差数列时，并且和基数（数组大小）最大公约数不为1时，就会造成哈希映射时冲突变高（数组某些位置永远不会有值）。比如数列0,6,12,18,24,30…，</p>
<p>base为10，取模(0,6,2,8,4,0…)后，放入哈希表中位置将只能在0,2,4,6,8这几个数组位置上；<br>但我们如果把base取7（数组大小甚至比10小），同样数列取模后(0,6,5,4,3,2,1,0,…)，可以分布在哈希表中的0,1,2,3,4,5,6所有位置上；<br>后续：若x和y的最大公约为z，x和y的最小公倍数就为(xy)&#x2F;z，很明显，若z为1，也就是俩数的最大公约数为1的时候，那么俩数的最小公倍数就为xy。</p>
<p>那么当一个数为质数时，除了其自身的倍数外，其余数和其的最大公约数都将是1，这时，步长选任何数（除了倍数）都可以满足桶的均匀分布。</p>
<p>所以，以取模计算哈希值在桶中的位置是，用一个质数当作基数时可以使得哈希表中每个位置都“有用武之地”。</p>
</blockquote>
<blockquote>
<p>Hash表为什么需要使用mod素数？</p>
<p>从素数定理出发，我们可以知道素数有如下性质 素数定理：在初等数学中有一个基本定理，任意一个大于1的自然数，要么本身就是质数，要么可以分解为几个质数之积，这种分解本身，具有唯一性</p>
<p>在知道素数的性质后，回过头来看Hash表，我们将元素放在Hash表当中，需要解决的一个问题就是尽量解决冲突。</p>
<p>给出一份实验，结论表明：模数的因子会影响数列的冲突，而且因子越多，冲突的可能性就越大。而素数的因子恰好只有1和其本身,就非常适合用于解决冲突。<br>比如 2 4 6 8 10 12这6个数，如果对 6 取余 得到 2 4 0 2 4 0 只会得到3种HASH值，6的因子有1，2，6。冲突会很多。如果对 7 取余 得到 2 4 6 1 3 5 得到6种HASH值，而7的因子只有1，7。</p>
<p>由3可知，即使1的因子最小，但是在实际中并不用，因为mod1相当于不解决冲突。而初始化的的数组就会非常大。</p>
</blockquote>
<h3 id="原地哈希-41-缺失的第一个正数"><a href="#原地哈希-41-缺失的第一个正数" class="headerlink" title="原地哈希 41. 缺失的第一个正数"></a>原地哈希 41. 缺失的第一个正数</h3><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked">41. 缺失的第一个正数</a> 被原地哈希薄纱了，之前也遇到过<strong>原地哈希</strong>的。也是在数组的值上动手脚让它能够和其他值区分开来，但这题由于数值不限，所以直接把无用的负值置0，然后用取负值做标志位。</p>
<h3 id="Rabin-Karp-算法"><a href="#Rabin-Karp-算法" class="headerlink" title="Rabin-Karp 算法"></a>Rabin-Karp 算法</h3><p>有一题字符串的题也用的这个解法，哪题我忘记了，好像是快乐字符串什么的困难题，还有另一题也用这个，所以这是第三次遇到这个解法。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a></p>
<p>Rabin-Karp 算法将一个序列 S 计算为哈希值，首先指定基数 base（最好是个质数），将序列 S 看作 base 进制的数求得哈希值，为防哈希冲突可以再哈希等等，不过也够用了。由于这个值一般会非常大，因此会将它对另一个素数 mod 取模。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>字符串匹配问题可以多尝试再复制一份母串</strong>，可能会有奇效， 如<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-string/description/">796. 旋转字符串</a></p>
<p><strong>C++ 中的 String 类</strong><br>C++ 标准库提供了 string 类类型。</p>
<p>string类提供了一系列成员函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">append</span>() -- 在字符串的末尾添加字符(单字符也可以) <span class="comment">// 也可以使用+和+=运算符对 string 对象执行字符串的连接操作</span></span><br><span class="line"><span class="built_in">append</span>()相比于+和<span class="built_in">push_back</span>()有更强的功能，可以加入一个string对象的子串，如下;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">append</span>(s2);  <span class="comment">// s1 = &quot;123abc&quot;</span></span><br><span class="line">s1.<span class="built_in">append</span>(s2, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s1 = &quot;123abcbc&quot;</span></span><br><span class="line">s1.<span class="built_in">append</span>(<span class="number">3</span>, <span class="string">&#x27;K&#x27;</span>);  <span class="comment">// s1 = &quot;123abcbcKKK&quot;</span></span><br><span class="line">s1.<span class="built_in">append</span>(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s1 = &quot;123abcbcKKKCDE&quot;，添加 &quot;ABCDE&quot; 的子串(2, 3)</span></span><br><span class="line">这里子串(n, m)是指从原字符串下标 n 开始、长度为 m 的字符串</span><br><span class="line"><span class="number">2.</span> <span class="built_in">find</span>() -- 在字符串中查找字符串</span><br><span class="line"><span class="number">3.</span> <span class="built_in">insert</span>() -- 插入字符</span><br><span class="line"><span class="number">4.</span> <span class="built_in">length</span>() -- 返回字符串的长度 <span class="comment">// 用size()也可以</span></span><br><span class="line"><span class="number">5.</span> <span class="built_in">replace</span>() -- 替换字符串</span><br><span class="line"><span class="number">6.</span> <span class="built_in">substr</span>(pos, n) -- 返回s中从<span class="built_in">pos</span>(索引)开始的n个字符的拷贝，可以只有pos，这时返回从pos开始的剩余的所有字符</span><br><span class="line"><span class="number">7.</span> <span class="built_in">erase</span>() -- 删除<span class="function">zi</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//删除子串(1, 3)，此后 s1 = &quot;R Steel&quot;</span></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">5</span>);  <span class="comment">//删除下标5及其后面的所有字符，此后 s1 = &quot;R Ste&quot;</span></span><br><span class="line"></span><br><span class="line">std::string 类本身就提供了类似「入栈」和「出栈」的接口，因此我们可以直接将字符串作为栈使用。类似的成员函数有：</span><br><span class="line"><span class="number">1.</span> <span class="built_in">empty</span>()</span><br><span class="line"><span class="number">2.</span> <span class="built_in">back</span>()  <span class="comment">// 相当于top()  取出最后一个元素</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">pop_back</span>() <span class="comment">// 相当于pop()</span></span><br><span class="line"><span class="number">4.</span> <span class="built_in">push_back</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="built_in">front</span>()  <span class="comment">// 取出第一个元素</span></span><br><span class="line">string类重载了[]运算符像数组一样直接访问元素</span><br><span class="line"></span><br><span class="line">判断相等直接用==就可以了，但是！要注意string对象不能和<span class="string">&#x27;单字符&#x27;</span>比较，一定要和<span class="string">&quot;字符串&quot;</span>比较。</span><br><span class="line">和单字符比较时也一定要用双引号<span class="string">&quot;&quot;</span>。</span><br><span class="line"></span><br><span class="line">string数字怎么转换为真正的数字，如<span class="string">&quot;-123&quot;</span>-&gt;<span class="number">-123</span></span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">atoi</span>( str.<span class="built_in">c_str</span>() ) <span class="comment">// C风格</span></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>( str )              <span class="comment">// C++风格 直接用就完事</span></span><br><span class="line"></span><br><span class="line">atoi 可以将字符数组转换为数字，并且可以加号和负号一同变为数字。</span><br><span class="line">string str = <span class="string">&quot;-100&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">atoi</span>(str); <span class="comment">// 这样是不行的，因为atoi不支持直接把c++的字符串改为数字，只能先变为字符数组才行</span></span><br><span class="line">通过c_str将string变为字符数组，再用atoi来变为数字</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">algorithm库中的<span class="built_in">reverse</span>()函数可以直接反转字符串, 对vector也适用</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(s.begin(),s.end())</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(s[i]m s[j])</span>；swap方法可以交换两个元素</span></span><br></pre></td></tr></table></figure>


<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151 翻转字符串里的单词"></a>151 翻转字符串里的单词</h3><p><strong>真的好题，确实难</strong>双指针的极致应用</p>
<p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p>
<p>O(1)空间复杂度的解法确实想不出来。<br>整个字符串翻转，再翻转各个单词。思路太难想了吧。<br>其实想不出来也应该把删除所有多余空格这一步弄出来，一步步做题。之后没准就想出来了。其实还是字符串不熟，没用过erase()；<br>但是erase()是O(n)的时间复杂度，所以不能用。<br>用前后快慢指针删除vector&#x2F;string的某一种元素，如果是相向指针会改变顺序，所以得用前后快慢指针来删除空格。</p>
<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p><strong>KMP算法经典问题， 找字串</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> k = next[i<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">// 找到子对称字符串为止</span></span><br><span class="line">            <span class="keyword">while</span>( s[i] != s[k] &amp;&amp; k&gt;<span class="number">0</span> ) &#123;</span><br><span class="line">                k = next[k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面这段代码有更常见的形式，其实是一模一样的</span></span><br><span class="line">            <span class="comment">// if( s[i]==s[k] )&#123;</span></span><br><span class="line">            <span class="comment">//     next[i] = k + 1;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">//     next[i] = 0;</span></span><br><span class="line">            <span class="comment">// 退出循环只有两种情况</span></span><br><span class="line">            <span class="keyword">if</span>( s[i]==s[k] )&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yearn520/article/details/6729426">KMP算法的前缀next数组最通俗的解释</a> 这篇文章讲的不错。</p>
<p>很重要的一点就是，匹配失败的时候要找<strong>已经匹配的字符串内部</strong>对称的子字符串，这也是KMP的内核，当一个字符串的对称程度越高，KMP算法效果越好。这里的对称不是指一次对称，而是像这样的:<br>0123456789<strong>1011</strong><br>abtab <strong>g</strong>abtab<strong>t</strong>3<br>00012012345<br>t无法继承（如果这个字符没有失配，配哪个呢，索引就是前一个字符的next值，那它的next就是前一个字符的next加一）前一个字符的next对应值因为这里失配了，即t&#x3D;s[i]，这时候s[i]不等于s[(k&#x3D;next[i-1]&#x3D;next[b]&#x3D;5)]&#x3D;g。<br>那这时候t的next值怎么看，开始找匹配好的字符串里面的子对称字符串，并且t一定要和那个子对称的下一个字符相同。<br>更新k &#x3D; next[k - 1]&#x3D;next[4]&#x3D;2;这时候的k代表已经匹配好的字符串里的子对称的长度，你看abtab里面的ab。ab就是我们要找的子对称字符串，它的下一个字符是不是t，这时候就匹配了可以退出循环，next[t]&#x3D;k+1；<br>那为什么更新k &#x3D; next[k - 1]呢，这一步挺关键的。<br>原来的k是5，是什么意思？这个5&#x3D;next[t-1]是t前一个字符b的next，表示这个字符和它前四个字符也就是长度为5的后缀与长度为5的前缀相同。<br>那我要找这个匹配好的长为5的字符串的子对称字符串怎么找，那当然是next[4](索引是长度-1)直接查前缀就行。<br>有更复杂的情况<br>abtab<em>abtab</em>  <strong>g</strong> abtab<em>abtab</em><strong>t</strong><br>0001212345<strong>0</strong>123456789<strong>10</strong>3<br><strong>这种才是真正的对称</strong><br>更新k &#x3D; next[k - 1]你要更新两次才能找到，找到什么？<strong>匹配好的字符串里面的子对称字符串，并且t一定要和那个子对称的下一个字符相同</strong>。<br>刚开始：k &#x3D; 10；<br>更新：k&#x3D;next[k-1]&#x3D;next[9]&#x3D;5<br>这不是找到abtababtab长为5的对称子串了吗？但是，这个字串的下一个字符是a，不等于t就，也就是while循环里的判断条件，还得更新。<br>更新：k&#x3D;next[k-1]&#x3D;next[4]&#x3D;2<br>这时候终于找到了，所以next[t]&#x3D;k+1&#x3D;3;<br>k&#x3D;0当然就没意思了，说明没有对称子串了，因为k即next代表相同的前后缀的长度，零的话我直接比较s[i]和s[0](也是s[k])不就好了。</p>
<p>时间复杂度O(m+n)，空间复杂度O(m)  n是主串长度，m是模式串长度</p>
<p><a target="_blank" rel="noopener" href="https://quant67.com/post/algorithms/kmp/kmp.html">字符串匹配算法: kmp和bm算法</a></p>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><p><strong>上限很高的简单题</strong></p>
<p>要理解一个关键原理:<br>长度为 n 的字符串 s 是字符串 t&#x3D;s+s 的子串，并且 s 在 t 中的起始位置不为 0 或 n，当且仅当 s 满足题目的要求(给定一个非空的字符串s，可以通过由它的一个子串重复多次构成。)，即为充要条件。<br>可以用string类自带的find函数查找索引，之所以要求索引不为0或n，是因为第一个删除了s+s的第一个和最后一个”子串”，两个s都不完整，由于子串长度至少大于1，所以删除前后各一个字符。<br>当然也可以用<strong>KMP实现自己的查找函数</strong>。</p>
<p>这题还能进一步优化。<br>符合要求的字符串，最后一位的next值&#x3D;n-i;<br>其中n为字符串长度，i为重复的子串的长度。<br>所以 i &#x3D; n-next[n-1]<br>又有<code>gcd(n,i) = i </code> <strong>n肯定整除i，并且i为最小的起始位置。</strong><br>所以只要判断n是否能整除i(n-next[n-1])即可，能整除则true。</p>
<h2 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h2><p><strong>匹配问题都是栈的强项。</strong></p>
<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232 用栈实现队列"></a>232 用栈实现队列</h3><p>就差一点就能更优化，应该再多想想不要急。画个图就能发现，用来输出的第二个栈的元素不用再倒回去。<br>基本就是输入输出栈完全分开了。</p>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p>这不仅仅是一道好题，也展现出计算机的思考方式</p>
<p>为什么要将看似简单的中缀表达式转换为复杂的逆波兰式？原因就在于这个简单是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。相对的，逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普<strong>遍采用的内存结构是栈式结构</strong>，它执行先进后出的顺序。</p>
<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p>我用的哈希表加剪枝，以临界时间通过，如果题目数据大一点就不容易通过了。</p>
<p>很难很好的题。<br>学到很多：优先队列(堆)，单调队列(由deque实现，满足单调性的双端队列)，通常并不是单独使用的，还有分块加预处理(很有意思的解法，类似稀疏表，其实和线段树有一丢丢像，像53题的线段树也维护最大前缀和、最大后缀和，这里是维护最大前缀最大后缀)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = &#123;q.<span class="built_in">top</span>().first&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">top</span>().second &lt;= i - k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/">解法</a></p>
<h3 id="数据流中的第-K-大元素-优先队列"><a href="#数据流中的第-K-大元素-优先队列" class="headerlink" title="数据流中的第 K 大元素 优先队列"></a>数据流中的第 K 大元素 优先队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/solutions/600598/shu-ju-liu-zhong-de-di-k-da-yuan-su-by-l-woz8/">703. 数据流中的第 K 大元素</a></p>
<p><strong>小顶堆</strong><br>直接当普通队列使用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;();</span><br><span class="line">pq.offer(val);</span><br><span class="line">pq.poll();</span><br><span class="line">pq.peek();</span><br></pre></td></tr></table></figure>




<h3 id="347-前-K-个高频元素-优先队列"><a href="#347-前-K-个高频元素-优先队列" class="headerlink" title="347. 前 K 个高频元素 优先队列"></a>347. 前 K 个高频元素 优先队列</h3><p>好题。<br><strong>优先队列</strong> ，要知道堆的操作时间复杂度是和堆总元素数有关的，如果堆大小至多为k，则每次堆操作需要O(logk)的时间，操作N次的话就是O(Nlogk) 的时间。<br>还学到了自定义排序规则：<br>注意定义优先队列的排序时是反过来的，比如&gt;号是小根堆，&lt;号是大根堆。以下的例子都是小根堆，默认创建时为大根堆。<br>并且注意调用时候的用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//自定义的比较函数，按第一个元素从小到大排序，如果第一个元素相同，则按第二个元素从小到大排序</span></span><br><span class="line">    <span class="keyword">if</span>(a.first == b.first)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(&amp;cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列常用成员函数</span></span><br><span class="line">q.<span class="built_in">emplace</span>(a,b); <span class="comment">// pair&lt;int,int&gt;</span></span><br><span class="line">q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用内置greater函数就是小根堆，默认的less是大根堆；</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &gt; q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>priority_queue 对象的第一个模板参数是 pair&lt;int, int&gt;，表示队列中的元素类型为 pair。第二个模板参数是 vector&lt;pair&lt;int, int&gt;&gt;，表示使用 vector 作为底层容器。第三个模板参数是自定义的比较函数 cmp 的<strong>类型</strong>，使用 <strong>decltype(&amp;cmp)</strong> 来<strong>获取函数指针的类型</strong>。</p>
<p>读者需要掌握自己实现堆的方法，包括「建堆」、「调整」和「删除」的过程。<br>可以再看看912排序数组，用了堆排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大根堆  堆就是完美二叉树并且存储在数组中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的作用是调整 O(lgn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxHeapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 左右子节点</span></span><br><span class="line">        <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>；</span><br><span class="line">        <span class="type">int</span> r = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> largest = i;</span><br><span class="line">        <span class="comment">// 找到两个子节点的较大值 将其与父节点交换，换完之后要对这个父节点往下递归，也就是下沉，因为有可能这个父节点很小(至少比换位置后新的子节点小)，要一直往下沉</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[largest]);</span><br><span class="line">            <span class="built_in">maxHeapify</span>(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    其实是调整前半个堆，为什么？因为堆是一个完美二叉树，而且只对所有父节点有要求，要求每个父节点大于其所有子节点，</span></span><br><span class="line"><span class="comment">    而所有树的父节点数(非叶子节点)不会超过树总结点数的一半，而且在maxHeapify里会判断子节点是否存在，所以这样写没有问题。</span></span><br><span class="line"><span class="comment">    也就是说，建堆过程是至多调整前半个堆，也就是前半个数组，循环调用maxHeapify来把nums[i]调整到合适的位置</span></span><br><span class="line"><span class="comment">    O(n*lgn)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> heapSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">buildMaxHeap</span>(nums, heapSize); <span class="comment">// 建好了整个大根堆 准备pop K-1次，堆顶的值就是第K最大</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*删除操作的完成是这样的：</span></span><br><span class="line"><span class="comment">        1. 将堆顶(nums[0])与堆最后一个节点(nums[heap.size()-1])交换，令记录的堆大小减一，实际上并没有改变vector的大小，相当于删除当前的堆尾，也就是刚刚pop的堆首；</span></span><br><span class="line"><span class="comment">        2. 调整当前的堆，也就是对调整新堆首到合适的位置，由于maxHeapify中的递归，能将整个堆调整好。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">            --heapSize;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>还有<strong>快速选择</strong>法(基于快速排序的选择方法)，通过每次都只在其中一个分支进行递归，能够将算法的平均复杂度降低到O(N)。<br>快排可以通过在每次递归的开始<em><strong>随机选取中枢元素</strong></em>来降低出现最坏情况的概率。还可以使用双指针的方法，这种方法可以较好的应对各种数据。<br><strong>再做一题K大数</strong>：</p>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h3><p>字节真的考过这个，还是得实现O(n)的时间复杂度，所以用堆是不行的。得用快速选择：</p>
<p>根据快排的原理我们知道，在递归一次的时候我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1]中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r]中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l⋯q−1]和 a[q+1⋯r]是否是有序的，我们不关心。</p>
<p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以<strong>把原来递归两个区间变成只递归一个区间</strong>，提高了时间效率。这就是「快速选择」算法。</p>
<p><strong>基于快速排序的选择方法</strong><br>只讨论大量相同的数据的情况，如果只是选择随机数的话是无效选择，基本就是快排的最坏情况即冒泡排序。用双指针版快排则可以有O(nlgn)的时间复杂度因为每次都可以跑到最中间，（顺便说一下，快排有三指针的优化）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickselect</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="type">int</span> partition = nums[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; partition);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; partition);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= j)<span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意，双指针是应对大量重复数据的，这也是为什么用 do while ，如果很多数据，则 i j 索引指的数据都相同，这时候 i j 交换完数据后会同时减，这样 i j 碰头的时候基本就在中间，后面只递归一次的时候基本可以少递归一半的重复数组。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>好难的二叉树( 迭代 递归 都难 )</strong></p>
<h3 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h3><p><strong>满二叉树</strong></p>


<p><strong>完全二叉树</strong></p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最后一层其它层全部填满，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p>
<p>优先级队列其实是一个堆，<strong>堆就是一棵完全二叉树</strong>，同时保证父子节点的顺序关系。</p>


<p><strong>二叉搜索树</strong></p>
<p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树<br>（严格递增）</li>
</ul>
<p>如：</p>


<p><strong>平衡二叉搜索树</strong></p>
<p>平衡二叉搜索树：又被称为<strong>AVL</strong>（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵<strong>空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过1</strong>，<strong>并且左右两个子树都是一棵平衡二叉树</strong>。</p>
<p>C++中map、set、multimap，multiset的底层实现都是<strong>平衡二叉搜索树</strong>(红黑树)，所以map、set的<strong>增删操作时间时间复杂度是logn</strong>，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set，因为它们的底层实现是哈希表。</p>



<h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p><strong>链式存储</strong>与<strong>顺序存储</strong></p>
<p>链式存储方式就用<strong>指针</strong>， 顺序存储的方式就是用<strong>数组</strong>。</p>
<p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>




<p>用数组来存储二叉树如何遍历的呢？</p>
<p>如果<strong>父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2</strong>。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历：一层一层的去遍历。</li>
</ol>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p><strong>深度优先遍历</strong></p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<p>前中后序遍历的前中后，其实指的就是<strong>中间节点的遍历顺序</strong>，只要记住 前中后序 指的就是中间节点的位置就可以了。</p>
<p><strong>中间节点的顺序就是所谓的遍历方式（左子树一定在右子树之前）</strong></p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中<br>这里的左右理解为左右子树更好，同时左右子树也要保持相同的遍历顺序。</li>
</ul>


<p>做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。<br>讲栈与队列的时候，就说过<strong>栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p>
<p>而<strong>广度优先遍历一般使用队列来实现</strong>，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS 递归"></a>DFS 递归</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  递归  前序遍历  中序后序同理，修改顺序即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="DFS-迭代"><a href="#DFS-迭代" class="headerlink" title="DFS 迭代"></a>DFS 迭代</h5><p><strong>二叉树</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官解的迭代写的真的好</span></span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( !stk.<span class="built_in">empty</span>() || node ) &#123;</span><br><span class="line">            <span class="keyword">while</span>(node) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()||node) &#123;</span><br><span class="line">            <span class="keyword">while</span>(node) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()||node) &#123;</span><br><span class="line">            <span class="keyword">while</span>(node) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>( node-&gt;right==<span class="literal">nullptr</span>||node-&gt;right==prev ) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                prev = node;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(prev&amp;&amp;(node==prev-&gt;right))</span><br><span class="line">                node = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 官解后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官解后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>N叉树</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/solutions/1317175/n-cha-shu-de-qian-xu-bian-li-by-leetcode-bg99/">589. N 叉树的前序遍历</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Node&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> node.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                stack.push(node.children.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/solutions/1327327/n-cha-shu-de-hou-xu-bian-li-by-leetcode-txesi/">590. N 叉树的后序遍历</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 HashSet 标记是否把子节点放进来了，第二次访问才能读取它的 val</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Set&lt;Node&gt; hset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()) &#123;</span><br><span class="line">            node = stk.peek();</span><br><span class="line">            <span class="keyword">if</span>(node.children.size() == <span class="number">0</span> || hset.contains(node)) &#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                hset.remove(node);</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hset.add(node);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> node.children.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    stk.push(node.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


























<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p><strong>广度优先一定要想到队列</strong></p>
<p><strong>二叉树层序遍历 也即 广度优先遍历</strong>，图的广度优先也是要用队列，出队入队等。</p>
<ul>
<li>层次遍历（迭代法）</li>
</ul>
<p>需要借用一个辅助数据结构即<strong>队列</strong>来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p>
<p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        TreeNode *idx = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> i = que.<span class="built_in">size</span>(); <span class="comment">// 每次new一个一位vector，存完之后再push进res里比较好</span></span><br><span class="line">            res.<span class="built_in">resize</span>(res.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                idx = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                res[cnt].<span class="built_in">push_back</span>(idx-&gt;val); </span><br><span class="line">                <span class="keyword">if</span>(idx-&gt;left) que.<span class="built_in">push</span>(idx-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(idx-&gt;right) que.<span class="built_in">push</span>(idx-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p>体会递归的自顶向下和自底向上<br>本题时间复杂度是自顶向下(n^2)和自底向上(n)。</p>
<p>自底向上是这样的：要求出当前的值，我先去求子值也即缩小问题规模，不断缩小，再有得出来的一个个小问题的解来构建当前的值并根据题意做出相应的操作。实际上是怎么实现的？那便是二话不说直接往下递归，当然子问题的解你肯定要保留下来，得到了子问题的解边进行你要的操作。放在本题就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">Verify</span><span class="params">(TreeNode *root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> flag1 = <span class="built_in">Verify</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="type">bool</span> flag2 = <span class="built_in">Verify</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// if(((root==q||root==p)&amp;&amp;(flag1||flag2))||(flag1&amp;&amp;flag2))</span></span><br><span class="line">        <span class="comment">//     node =  root;</span></span><br><span class="line">        <span class="comment">// if(root==p||root==q)</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// return flag1||flag2;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>除了第一句判断root存在否以外，直接就往下递归并保留下子问题的解。</p>
<p>而自顶向下是我往下递归，如果我需要当前问题的解来进行后序的操作，那我一定要现在立刻马上获得，比如这里为了获得flag1 2，我甚至用了Verify这个递归的函数来求解，那肯定带了许多重复运算。那便是O(n^2)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Verify</span><span class="params">(TreeNode *root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==p||root==q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Verify</span>(root-&gt;left, p, q) || <span class="built_in">Verify</span>(root-&gt;right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">bool</span> flag1 = <span class="built_in">Verify</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="type">bool</span> flag2 = <span class="built_in">Verify</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if((root==q||root==p)&amp;&amp;(flag1||flag2))</span></span><br><span class="line">        <span class="comment">//     return root;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(flag1&amp;&amp;flag2)</span></span><br><span class="line">        <span class="comment">//     return root;</span></span><br><span class="line">        <span class="comment">// else if(flag1)</span></span><br><span class="line">        <span class="comment">//     return lowestCommonAncestor(root-&gt;left, p, q);</span></span><br><span class="line">        <span class="comment">// else </span></span><br><span class="line">        <span class="comment">//     return lowestCommonAncestor(root-&gt;right, p, q);</span></span><br><span class="line">        <span class="comment">// return nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我认为自顶向下和自底向上最核心的区别就是自底向上一定先会递归到底再求解问题。而自顶向下不一定会到底(这里考虑的肯定是递归的主函数，而不是Verify)，通过在每个节点都立刻算出当前的值，只要问题的解存在，那想必在递归的过程中就已经把问题解决了。</p>
<p>还有一个原因是我没想到可以用全局变量，没必要让递归来返回TreeNode*。</p>
<h3 id="两数之和-IV-输入二叉搜索树"><a href="#两数之和-IV-输入二叉搜索树" class="headerlink" title="两数之和 IV - 输入二叉搜索树"></a>两数之和 IV - 输入二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/description/">653. 两数之和 IV - 输入二叉搜索树</a></p>
<p>这题的方法四还是挺厉害的。</p>
<p>具体地，我们对于每个指针新建一个栈。<strong>初始，我们让左指针移动到树的最左端点</strong>，并将路径保存在栈中，接下来我们可以依据栈来 O(1) 地计算出左指针的下一个位置。右指针也是同理。</p>
<p>计算下一个位置时，我们首先将位于<strong>栈顶的当前节点从栈中弹出</strong>，此时首先判断当前节点是否存在右子节点，如果存在，那么我们将<strong>右子节点的最左子树</strong>加入到栈中；否则我们就完成了当前层的遍历，无需进一步修改栈的内容，直接回溯到上一层即可。</p>
<p>实现起来有点像 头尾双指针 遍历 树。<br>在很多题都可以用，记得在对称二叉树那里也可以用。</p>
<p><strong>两个栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root, right = root;</span><br><span class="line">        Deque&lt;TreeNode&gt; leftStack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; rightStack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        leftStack.push(left);</span><br><span class="line">        <span class="keyword">while</span> (left.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            leftStack.push(left.left);</span><br><span class="line">            left = left.left;</span><br><span class="line">        &#125;</span><br><span class="line">        rightStack.push(right);</span><br><span class="line">        <span class="keyword">while</span> (right.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            rightStack.push(right.right);</span><br><span class="line">            right = right.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val + right.val == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left.val + right.val &lt; k) &#123;</span><br><span class="line">                left = getLeft(leftStack);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = getRight(rightStack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getLeft</span><span class="params">(Deque&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getRight</span><span class="params">(Deque&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h3><p><strong>难死了</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/solutions/233896/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/">572. 另一棵树的子树</a></p>
<p><strong>方法一</strong>：<br>深度优先搜索暴力匹配<br>做两次深度优先，对每个节点的子树做一次暴力匹配。</p>
<p><strong>方法二</strong>：深度优先搜索序列上做串匹配</p>
<p>因为一棵子树上的点在 先、中、后序 遍历下是连续的，所以可以判断 串2 是否是 串1 的子串。<br>我想到这个了，<strong>但是</strong>，这只是一个必要条件，并不充分。<br>可以通过引入节点的两个空值 leftNull 和 rightNull 节点来进行标记，这样子串就能唯一匹配。</p>
<p>可以用 KMP 来进行匹配判断。（KMP不知可以用来对字符串进行匹配，也可以用来对数组匹配）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">kmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="type">int</span>[] fail = <span class="keyword">new</span> <span class="title class_">int</span>[tOrder.size()];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = -<span class="number">1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = -<span class="number">1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong>： <strong>树哈希</strong></p>
<p>很牛的方法，字节面过要求写出这个，估计是故意为难人的。</p>
<p>自定义哈希函数，把每个子树都映射成一个唯一的数。</p>
<p>本质就是每个子树的哈希值要考虑每个节点的值，子树哈希值，子树大小，以及左右子树拥有不同权值，这样出现冲突的几率比较小。如果还怕出现冲突，可以设计两个哈希函数，由这两个哈希函数生成第三个哈希函数，这就是<strong>双哈希</strong>。</p>
<p>这里求素数再用上之前学过的 <strong>埃氏筛法</strong>（此处为欧拉筛）。</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p><strong>讲道理，遇到回溯题，自己把递归树稍微画一下</strong>。</p>
<p>回溯本质就是暴力枚举，通过递归来实现。</p>
<p><strong>尽量多用全局变量</strong>（就算<strong>集合也可以用全局</strong>），可以省内存，但要注意。<br>不管什么写法（用全局还是传下来的集合参数），添加结果的时候都一定要<strong>拷贝一份</strong>，不然结果会出错，因为 Java 是 pass by reference。如：<code>ans.add(new ArrayList&lt;&gt;(temp));</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯的第二种经典写法 即：不选走一次，选的话也走一次</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一种经典写法是用 for 循环，也就是回溯里用for循环表示层内遍历，</span></span><br><span class="line"><span class="comment">而递归本身是纵向遍历。 这种写法能更好地理解回溯，</span></span><br><span class="line"><span class="comment">回溯相当于树的深度，而for循环本身是树的宽度， 我常用这种写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(t));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.add(nums[cur]);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.remove(t.size() - <span class="number">1</span>);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="二进制手表"><a href="#二进制手表" class="headerlink" title="二进制手表"></a>二进制手表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-watch/description/">401. 二进制手表</a></p>
<p>这是这题的回溯解法，其实就是<strong>罗列所有</strong>  1 的位数等于 turnedOn 的10位二进制数，进一步判断是否题意( 即 <code>private String convert(int num)</code>中所列的，当不满足时返回空串)，所以明确回溯的目标和难点就是<strong>罗列所有</strong>  1 的位数等于 turnedOn 的10位二进制数（这也是我不会的，毕竟第一次做回溯，后面肯定拿下）。</p>
<p>turnedOn( 1 的总位数 )肯定是关键，分散到十位二进制数的每一位看就是 <strong>这一位取0还是取1</strong> 的小问题，取了 0，剩余位数一定要满足一共有 <code>turnedOn</code> 个 1 ，取了 1 ，剩余位数一定要满足一共有 <code>turnedOn-1</code> 个 1 ，那很明显了，这就是递归，我们用num保存这个结果传递给两个子递归。剩余 1 的总位数一定要传递，还有个关键就是记录当前走到这个十位二进制数的哪一位了，也就是 参数 <code>idx</code>。</p>
<p>说到递归一定要想到 递归的底是什么，底当然是 turnedOn递减为0，这时候的 数(num) 才能符合第一个要求，这时候就交给<code>private String convert(int num)</code>函数了。</p>
<p>还要注意对回溯剪枝，毕竟回溯是暴力解法，适当的剪枝能提高程序性能，结合我们的<br><strong>参数 idx 表示走到哪一位了，参数 turnedOn 表示剩余位数还需要取几个1，还有这一定是一个十位二进制数</strong>，剪枝呼之欲出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (turnedOn+idx)&gt;<span class="number">10</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">readBinaryWatch</span><span class="params">(<span class="type">int</span> turnedOn)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrace(<span class="number">0</span>, <span class="number">0</span>, turnedOn, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> idx, <span class="type">int</span> turnedOn, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (turnedOn == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> convert(num);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(r)) &#123;</span><br><span class="line">            res.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剪枝  现在有的位数加上你还需要的1的数目超过了10位，那这个肯定不是你要的数了</span></span><br><span class="line">    <span class="keyword">if</span> ( (turnedOn+idx)&gt;<span class="number">10</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选和不选</span></span><br><span class="line">    backtrace(num, idx + <span class="number">1</span>, turnedOn, res);</span><br><span class="line">    num |= (<span class="number">1</span> &lt;&lt; idx);</span><br><span class="line">    backtrace(num, idx + <span class="number">1</span>, turnedOn - <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">convert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> (num &amp; <span class="number">0b1111000000</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> (num &amp; <span class="number">0b111111</span>);</span><br><span class="line">    <span class="keyword">if</span> (hour &gt;= <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minute &gt; <span class="number">59</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(hour + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (minute &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(minute);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">77. 组合</a></p>
<p>非递归（<strong>字典序法</strong>）实现组合型枚举 <strong>看不懂，好难</strong></p>
<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h3><p>前提：去重一定要排序。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a><br>第一次做要去重的题，我真的麻了，<strong>仅仅是因为不确定局部变量在递归时候的变化</strong>（实际上递归时是会进行<strong>压栈保存环境</strong>的，当你递归出来的时候数据是完全不会变的，看了这么多理论竟然不会用，我真的服了你了），仅仅把preval定成全局的，没有去思考定成局部的数据并付诸行动导致失败，各种尝试都做不出来，离成功就差一点。真的服了你了。</p>
<p>看看人家的：<br>去重就是，dfs的<strong>同一层第二次遍历到一个数</strong>，那么就是重复的，保证<strong>每一层一种数只会遍历到一次</strong>，又因为进入dfs前数组经过了排序（相同数一定相邻），所以去重只需要在每一层遍历一个数时，判断上一个数是否和当前数相同，相同的话就是重复了，就不需要再对这个数进行递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; temp, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> index, <span class="type">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断temp加上当前index的值是否是</span></span><br><span class="line">		<span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// preVal是解决会出现重复结果问题</span></span><br><span class="line">		<span class="type">int</span> preVal = <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">// 如果sum小于target</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (candidates[i] != preVal &amp;&amp; (sum + candidates[i]) &lt;= target) &#123;</span><br><span class="line">				preVal = candidates[i];</span><br><span class="line">				temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">				sum += candidates[i];</span><br><span class="line">				<span class="built_in">backtracking</span>(res, temp, candidates, target, i + <span class="number">1</span>, sum);</span><br><span class="line">				sum -= candidates[i];</span><br><span class="line">				temp.<span class="built_in">pop_back</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">		<span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">		<span class="comment">// 从小到大排序</span></span><br><span class="line">		<span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; temp = &#123;&#125;;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">backtracking</span>(res, temp, candidates, target, <span class="number">0</span>, sum);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看看我的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTrace(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preVal</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i&lt;candidates.length &amp;&amp; (sum + candidates[i]) &lt;= target ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]!=preVal)&#123;</span><br><span class="line">                tmp.add(candidates[i]);</span><br><span class="line">                preVal = candidates[i];</span><br><span class="line">                backTrace(candidates, target, sum + candidates[i], i + <span class="number">1</span>);</span><br><span class="line">                tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题的去重原理可以看<a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE"> 代码随想录</a></p>
<p>这个去重为什么很难理解呢，所谓去重，其实就是使用过的元素不能重复选取。 这么一说好像很简单！</p>
<p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是<strong>同一树枝上使用过</strong>（同一子树, 一个子树就是一个集合），一个维度是<strong>同一树层</strong>上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</p>
<p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p>
<p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p>
<p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。其实就是，重复出现的元素，第一次出现的是最好用的，它会把所有有用的集合都包括起来，而后面出现的只会造成重复！</p>
<p><strong>强调一下，树层去重的话，需要对数组排序</strong>！</p>
<img src="/2024/03/05/LeetCodeNote/3.png" class="">

<p><strong>讲道理，遇到回溯题，自己把递归树稍微画一下</strong>。</p>
<p>重点在于区分 “<strong>树层去重</strong>”和“<strong>树枝去重</strong>”。</p>
<p>妈的还有更狠的：<strong>直接用startIndex来去重</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i + <span class="number">1</span>); <span class="comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="子集-II"><a href="#子集-II" class="headerlink" title="子集 II"></a>子集 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">子集 II</a></p>
<p><strong>注意子集(子序列)和之前的区别</strong>，之前是不选没关系，直接往下走就可以，等走到底添加结果，相当于<strong>只要叶子节点</strong>，而<strong>子集</strong>在你选或者不选的情况下都需要直接添加进<strong>结果</strong>，也就是所有节点都是我们想要的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">          List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">              Arrays.sort(nums);</span><br><span class="line">              ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">              backTrace(nums, <span class="number">0</span>);</span><br><span class="line">              <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(startIdx==nums.length) &#123;</span><br><span class="line">                  <span class="keyword">return</span> ;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i&lt;nums.length; i++) &#123;</span><br><span class="line">                  <span class="keyword">if</span>(i&gt;startIdx &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  tmp.add(nums[i]);</span><br><span class="line">                  ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp)); <span class="comment">// 就是这里</span></span><br><span class="line">                  backTrace(nums, i+<span class="number">1</span>);</span><br><span class="line">                  tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">491.递增子序列</a><br>真尼玛难啊</p>
<p>这里不能排序了，所以用 hashset uset 表示这层用过的符合要求的数，这里的符合要求指的是非递减。<br>这种hashset用法也可以用于前面的 子集Ⅱ 题，但是依然需要排序。<br>比如 4 4 1 4 4 4 不排序的话会有 4 1 和 1 4，那为什么这题不需要排序呢。<br>因为这题要求非严格递增，不会有 4 1 ，只会有 1 4。</p>
<p>去重题看 <a target="_blank" rel="noopener" href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a> 讲的确实清楚。<br>关键还是 树层 不能重复。</p>
<p>唉真是无语了，心累。</p>
<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></p>
<p>我写了标记数组 ，没想到还有这么秀的解法。<br>要好好理解<strong>递归的变量保存</strong>，<strong>回溯的撤销</strong>操作。<br>这两点很重要。<br><strong>撤销撤销撤销</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">          List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">              List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                  output.add(num);</span><br><span class="line">              &#125;</span><br><span class="line">              backTrack(output, <span class="number">0</span>);</span><br><span class="line">              <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(startIdx==nums.size()) &#123;</span><br><span class="line">                  ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums));</span><br><span class="line">                  <span class="keyword">return</span> ;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i&lt;nums.size(); i++) &#123;</span><br><span class="line">                  Collections.swap(nums, startIdx, i);</span><br><span class="line">                  backTrack(nums, startIdx+<span class="number">1</span>);</span><br><span class="line">                  Collections.swap(nums, startIdx, i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/description/">47.全排列 II</a></p>
<p>目前为止已经遇到了 组合、子集、排列的去重。</p>
<p>允许排序的题都可以先排序再去重，当然对这题而言也可以不排序的去重也就是用 uset 记录当前树层使用过的数字，但是之前的组合用 uset 的话也得去重，之前讲过了，这题的话因为是全排列所以可以。</p>
<p>排序去重的话效率肯定更高，这里的话得用标记数组了，不能用之前全排列的优化方法，因为那个方法会改变数字的顺序，排序数组也变乱序数组了。</p>
<p>排序去重最为关键的代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果改成 used[i - <span class="number">1</span>] == <span class="literal">true</span>， 也是正确的!，去重代码如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要对树层中前一位去重，就用used[i - 1] &#x3D;&#x3D; false，如果要对树枝前一位去重用used[i - 1] &#x3D;&#x3D; true。<br>具体可以看 <a target="_blank" rel="noopener" href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%80%9D%E8%B7%AF">47.全排列 II</a>中的图。</p>
<h3 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a>51. N 皇后</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/description/">51. N 皇后</a></p>
<p>经典回溯，没写出来</p>
<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/description/">37. 解数独</a></p>
<p>做出来了。</p>
<p>有迭代优化，不断循环固定那些只能放一个数字的位置，之后再去回溯。</p>
<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a></p>
<p>这题最好的做法是转化为0-1背包问题进行求解。</p>
<p>这里说一个回溯的<strong>注意事项</strong>，困扰了很久。</p>
<p>首先此背包问题可以转化为一个组合问题，关键在于递归的返回时间。</p>
<p>如果用的是 for 循环的写法，不能加上判断索引是否走到数组末尾这个条件，表面上没有影响，实际上是有的，会影响那么几个值，调试一下就知道了，因为如果<strong>最后一个数不取</strong>也就是不拿(startIndex-1)能达到target，<strong>不取之后并没有继续调用递归函数，因为for循环到底了</strong>，所以不取最后一个数的结果是没有计入ans的（因为此时startIndex !&#x3D; candidates.length），所以判断不拿是否应该计入ans得在for循环之前判断，而此时startIndex !&#x3D; candidates.length，也就是加入判断索引是否走到数组末尾这个条件确实是会影响的，之前的写法都没有<strong>写这个条件所以能通过</strong>，之前没注意到这个，没想到今天被暴击了。</p>
<p>并且注意到，反正是组合，达到条件之后自然可以记录下来。</p>
<p>调试果然还是好用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum() + target;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span> || sum%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bagSize</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">            backtracking(nums, bagSize, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">            <span class="comment">// 这是错误的，不能多加这个判断</span></span><br><span class="line"><span class="comment">//              if(startIndex == candidates.length) &#123;</span></span><br><span class="line"><span class="comment">//                  if (sum == target) &#123;</span></span><br><span class="line"><span class="comment">//                      cnt++;</span></span><br><span class="line"><span class="comment">//                  &#125;</span></span><br><span class="line"><span class="comment">//              &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i&lt;candidates.length; i++) &#123;</span><br><span class="line">                sum += candidates[i];</span><br><span class="line">                backtracking(candidates, target, sum, i + <span class="number">1</span>);</span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//    public int findTargetSumWays(int[] nums, int target) &#123;</span></span><br><span class="line"><span class="comment">//        int sum = Arrays.stream(nums).sum() + target;</span></span><br><span class="line"><span class="comment">//        if(sum&lt;0 || sum%2!=0) return 0;</span></span><br><span class="line"><span class="comment">//        sum /= 2;</span></span><br><span class="line"><span class="comment">//        int [] dp = new int[sum+1]; // 表示凑到总和为 j 有几种方案</span></span><br><span class="line"><span class="comment">//        dp[0] = 1;</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i&lt;nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for(int j = sum; j&gt;=nums[i]; j--) &#123;</span></span><br><span class="line"><span class="comment">//                dp[j] += dp[j-nums[i]];</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return dp[sum];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>贪心基本都是 O(n)  O(1)</p>
<h3 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/solutions/230241/tiao-yue-you-xi-ii-by-leetcode-solution/">跳跃游戏 II</a><br>有点难，但是能做，迭代有点难看懂。</p>
<p>关键在于：每次选<strong>能跳最远的那个位置</strong>去跳，别理解成每次跳最远的位置。比如当前位置我能跳到两三个位置，我看从这两三个位置起跳哪个能跳的更远，那这个位置就是局部最优的，当前我就选择跳这个位置。<br>也就是需要统计<strong>两个覆盖范围</strong>，当前这一步的最大覆盖和下一步最大覆盖。</p>
<p>每次以最大覆盖范围为一次跳跃次数。</p>
<h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列</a></p>
<p>烂题，烂的要死。</p>
<p>没做出来</p>
<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h3><p>没做出来 想死</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/solutions/541543/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/">435. 无重叠区间</a></p>
<p>妈的两题都倒在排序上，没有一点思路，怎么回事啊</p>
<p>我一直想的是移除，实际上反着来才好做，怎样符合题意地去放最多的区间。</p>
<p>我一直找最早下课的，这样我一天才可能上最多的课。</p>
<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/description/">763. 划分字母区间</a></p>
<p>没用贪心做就是没做出来 ， 废物</p>
<p>只要记录最远出现的位置，说实话贪心代码都不太好实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           right = <span class="built_in">max</span>(right, hash[S[i] - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 找到字符出现的最远边界</span></span><br><span class="line">           <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">               result.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">               left = i + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


<h3 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/description/">968. 监控二叉树</a></p>
<p>这个确实做不来，树dp也看不懂。</p>
<p>这题的<strong>后序遍历可以由底至上</strong>我知道，输在<strong>定义状态</strong>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">随想录</a>定义了三个状态在进行状态转移真的舒服很多。</p>
<p>定义状态真的很重要啊，像之前的线段树，还有很多动规题，定义出好的状态基本就成功了。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43294560/article/details/121292475">动态规划思想</a></p>
<p>状态设计很重要，有时候状态设计是很难看出来的，没有定义状态也就没办法进行状态转移了。</p>
<p>第 300 题：「最长上升子序列」 待做</p>
<p>最后再谈谈状态转移的「无后效性」(当前状态与之后状态无关)</p>
<p>为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。<br>我的解释：</p>
<p>「有向无环图」「拓扑序」表示了每一个子问题只求解一次，以后求解问题的过程不会修改以前求解的子问题的结果；<br>换句话说：如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫「有后效性」，我们在当前这个问题第 1 次拆分的子问题就是「有后效性」的（大家可以再翻到上面再看看）；<br>解决「<strong>有后效性</strong>」的办法是<strong>固定住需要分类讨论的地方</strong>，记录下更多的结果。在代码层面上表现为：<br><strong>状态数组增加维度</strong>，例如：「力扣」的股票系列问题；<br>把<strong>状态定义得更细致、准确</strong>，例如：前天推送的第 124 题：状态定义只解决路径来自左右子树的其中一个子树。</p>
<p>可以看看这篇讲股票系列问题的动规题解<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/qiAgHn/">股票问题系列通解（转载翻译）</a></p>
<p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「<strong>最优子结构</strong>」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。</p>
<h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/solutions/346539/pan-duan-zi-xu-lie-by-leetcode-solution/">392. 判断子序列</a><br>判断 s 是否是 t 的子序列。</p>
<p>本质就是对 s 中每一个字符，在 t 中寻找下一个匹配字符，这也是时间复杂度的主要来源，当要匹配的子串 s 很多的时候，重复工作很多，所以可以尝试用动态规划的思想对母串 t 做预处理。</p>
<p>我们可以预处理出对于 t 的每一个位置(0~t.length-1)，从该位置开始往后每一个字符(a,b,c,…,z)第一次出现的位置(只需要记录第一次出现的位置即可，不需要更新也不能更新)，所以预处理数组dp[t.length][26]是一个二维数组。</p>
<p>令 dp[idx][c] 表示从 idx 位置开始字符 c (也就是当前匹配到的s中的字符)第一次出现的索引，<strong>状态转移</strong>是：<br>如果 dp[idx] 处的字符就是 c ，则 dp[idx][c] &#x3D; idx ，否则 dp[idx][c] &#x3D; dp[idx+1][c]，因为 c 没在 idx 位置，那么 c 一定在 (idx+1) 位置或之后的位置，也就是 dp[idx+1][c]。</p>
<p>状态转移表示 前面的状态要由后面的状态而来，所以动态规划应该倒过来，由底至上。<br>底部就是 dp[t.length-1][c]，如果在 t.length-1 位置出现了字符 c ，则dp[t.length-1][c] &#x3D; t.length-1，其余的 25个字符不会再出现，dp值会等于 dp[t.length][c]，所以我们建的二维数组应该是 (t.length+1)*26 的，让边界也能进行状态转移，并且 dp[t.length][…] 应该初始化为让我们能够判断这个字符不存在的索引，比如就是t.length。<br>在遍历 s 中字符的时候，如果发现这个字符在 t 中的索引是 t.length ，则说明 s 并不是 t 的子序列，能够遍历完成则成功。</p>
<p>匹配过程就是直接dp[idx][s.charAt(j)]跳到这个字符所在的索引。</p>
<p>预处理的时间是固定的，并且之后匹配每一个 s 的时间复杂度都是 O(s.length)，所以当s数目很多的时候也可以完成匹配。</p>
<p>注意先判断这个字符所在的索引是不是t.length，不是的话索引更新为idx &#x3D; dp[idx][c]+1用来匹配下一个字符(因为dp[idx][c]已经和这一个字符匹配了)，如果没有这个+1一定错。</p>
<h3 id="比特位计数-1"><a href="#比特位计数-1" class="headerlink" title="比特位计数"></a>比特位计数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">338. 比特位计数</a></p>
<p>三种动规都很好理解。</p>
<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/">前缀和解法</a></p>
<p>要边维护最小前缀和一边求答案，不能求出最大、最小前缀和再算差值，因为最小前缀和可能会出现在最大前缀和后面，我就是犯了这个错误一直写不出来。<br>并且前缀和要初始化为0，并且 curSum 加上当前值之后才能与 minPreSum 相减，因为子数组至少要有一个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">minPreSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n : nums) &#123;</span><br><span class="line">    curSum += n;</span><br><span class="line">    ans = Math.max(ans, curSum-minPreSum);</span><br><span class="line">    minPreSum = Math.min(minPreSum, curSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<p>第一次接触到 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/">线段树</a><br><strong>这个线段树很有意思</strong> ，维护四个变量，合并过程也很有趣</p>
<p><strong>线段树区间合并法</strong>解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」</p>
<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/solutions/518296/bai-dong-xu-lie-by-leetcode-solution-yh2m/">376. 摆动序列</a></p>
<p>这个动规解释的很好 </p>
<p>定义双状态，两个状态之间进行转移，不同于以前见到的只有一个状态。<br>上升摆动序列<br>下降摆动序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">wiggleMaxLength_2</span> <span class="operator">=</span> function (nums) &#123;</span><br><span class="line">	<span class="type">const</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">	<span class="comment">//! up[i] 记录以i截止的上升摆动的最大长度</span></span><br><span class="line">	<span class="type">const</span> <span class="variable">up</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//! down[i] 记录以i截止的下降摆动的最大长度</span></span><br><span class="line">	<span class="type">const</span> <span class="variable">down</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">	up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="comment">//! 上升摆动：</span></span><br><span class="line">			<span class="comment">//情况1：连续的上升，不用当前元素，沿用之前的上升摆动长度值</span></span><br><span class="line">			<span class="comment">//情况2：下降过程，从上一个下降摆动过来 + 当前元素 成为上升摆动</span></span><br><span class="line">			up[i] = Math.max(up[i - <span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//! 此过程是上升摆动，所以下降摆动未变化，所以沿用之前的值</span></span><br><span class="line">			down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="comment">//! 下降摆动：</span></span><br><span class="line">			<span class="comment">//情况1：连续的下降，不用当前元素，沿用之前的下降摆动长度</span></span><br><span class="line">			<span class="comment">//情况2: 下降过程，由上一个上升摆动过来 + 当前元素 成为下降摆动</span></span><br><span class="line">			down[i] = Math.max(down[i - <span class="number">1</span>], up[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//! 此过程是下降摆动，所以上升摆动未变化，所以沿用之前的值</span></span><br><span class="line">			up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//!既不是上升也不是下降，直接沿用直接的值 </span></span><br><span class="line">			up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">			down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.max(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><img src="/2024/03/05/LeetCodeNote/4.png" class="">

<p><strong>0-1背包问题</strong>讲解见 <a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">代码随想录</a></p>
<p>在一维dp中很重要的一点就是遍历的顺序，首先，最外层应该是待放物品，这是最基本的<strong>保证物品只取一次</strong>的要求，其二，<strong>内层循环应该倒序</strong>，因为：在dp数组更新的时候是用上一层的<strong>左边索引处的值</strong>来更新当前层<strong>当前索引处</strong>的值，如果正序的话，那每个左边索引值都给你改成新值，还是错的，当前索引值有可能是对的么？</p>
<p>上面两个坑我都踩过了，卡哥还是牛。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完全背包问题讲解</strong><br>01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。<br>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒的，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</p>
<p>在<strong>完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓</strong>的！</p>
<p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要<strong>保证下标j之前的dp[j]都是经过计算的新值</strong>就可以了。</p>
<p>对于纯完全背包问题，其for循环的先后循环是可以颠倒的！</p>
<p>但如果题目稍稍有点变化，就会体现在遍历顺序上。</p>
<p>如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了。</p>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></p>
<p>至于上面说到的 “在dp数组更新的时候是用上一层的<strong>左边索引处的值</strong>来更新当前层<strong>当前索引处</strong>的值” ，到底什么时候用左边更新当前，什么时候用右边更新当前呢？<br><strong>还得看题意</strong>。</p>
<p>以本题为例：如果设dp[0] &#x3D; true，慢慢更新到dp[sum]判断是否等于 true ，翻译过来就是用数组里的数能不能叠加到 sum，那很明显从索引0-&gt;sum自然就是以左更新右。<br>此时要用dp左边更新dp右边，所以肯定是先改右边的数再去改左边的数，即逆序。</p>
<p>我也可以这么看：设dp[sum] &#x3D; true，慢慢更新到dp[0]判断是否等于 true ，翻译过来就是我能不能用 sum 去减数组的数，最终减到0，从索引sum-&gt;0自然就是以右更新左。<br>此时要用dp右边更新dp左边，所以肯定是先改左边的数再去改右边的数，即正序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span> [] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 以左更新右</span></span><br><span class="line"><span class="comment">//        dp[0] = true;</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i&lt;nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for(int j = sum; j&gt;=nums[i]; j--) &#123;</span></span><br><span class="line"><span class="comment">//                dp[j] |= dp[j-nums[i]];</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以右更新左</span></span><br><span class="line">        dp[sum] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;=sum-nums[i]; j++) &#123;</span><br><span class="line">                dp[j] |= dp[j+nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a>1049. 最后一块石头的重量 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049. 最后一块石头的重量 II</a></p>
<p>这个讲的也不错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：</span></span><br><span class="line"><span class="comment">// 动态规划：01背包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.分析：</span></span><br><span class="line"><span class="comment">// 我们由题目可以知道经过n次粉碎后，最终最多只会剩下1个石头，并且我们需要让最后一块石头的质量最小</span></span><br><span class="line"><span class="comment">// 我们继续分析可以发现（关键）：我们可以将这一堆石头分成两堆（heap1和heap2）</span></span><br><span class="line"><span class="comment">// 我们不妨设 heap1总质量 &gt;= heap2总质量，而最后的结果就是heap1 - heap2，我们只需要保证heap1 - heap2最小即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.1 如何计算：</span></span><br><span class="line"><span class="comment">// 我们可以先求出这一堆石头的总质量sum，</span></span><br><span class="line"><span class="comment">// 而sum = heap1 + heap2    （heap1 &gt; heap2）</span></span><br><span class="line"><span class="comment">// heap1 - heap2 = sum - 2 * heap2</span></span><br><span class="line"><span class="comment">// 要求heap1 - heap2 的最小值，就可以转化成求sum - 2 * heap2 的最小值，</span></span><br><span class="line"><span class="comment">// 也就转化成了求 2 * heap2 的最大值，也就是求heap2的最大值（前提：sum - 2 * heap2 &gt;= 0 等价于 heap2 &lt;= sum / 2）</span></span><br><span class="line"><span class="comment">// 那么就转化成了01背包问题：背包的最大容量为 sum / 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.状态表示：f[i][j]</span></span><br><span class="line"><span class="comment">// 1.1 集合划分：i表示前i个石头，j表示背包最大容量；f[i][j]就表示前i个数，容量为j的背包能装下的石头最大质量</span></span><br><span class="line"><span class="comment">// （注意：此题的石头体积与石头质量都是stones[i]）</span></span><br><span class="line"><span class="comment">// 1.2 属性（一般为最大值、最小值、数量）：最大值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.状态计算：</span></span><br><span class="line"><span class="comment">// 2.1 f[i][j]可以表示成f[i - 1][j]，表示不加上当前第i块石头的背包最大质量</span></span><br><span class="line"><span class="comment">// 2.2 f[i][j]还可以表示成f[i - 1][j - stones[i]] + stones[i]，表示加上第i块石头后背包最大质量</span></span><br><span class="line"><span class="comment">// 2.3 所以最后总和为j的所有方案为：f[i][j] = max(f[i - 1][j] + f[i - 1][j - stones[i]] + stones[i])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.优化：</span></span><br><span class="line"><span class="comment">// 通过滚动数组可以将二维数组优化成一维数组：f[i][j] --&gt; f[j] </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : stones) sum += s;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(sum / <span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = sum / <span class="number">2</span>; j &gt;= stones[i]; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * f[sum / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II</a></p>
<p>纯完全背包问题由于并不限制数组只取一次，所以内外循环没有额外要求，但某些情况除外！因为纯完全背包问题求的是最大价值，多余的排列并不影响这个值，但是影响计数！</p>
<p>不限制数目，所以是一个完全背包问题，但要注意的本题求的是组合数。<br>做法就是固定硬币的顺序，让外层循环遍历数组 coins 的值，内层循环遍历背包的大小，这样在求出 dp[i]的时候，该金额对应的硬币面额的顺序就固定了，因此不会计算重复的排列。<br>如 coins &#x3D; [1,2]，对于 dp[3] 的计算，因为先遍历面额 1 再遍历面额 2，所以不会出现2+1的组合，只有1+1+1 和 1+2的组合。</p>
<p>反之，如果两个循环遍历颠倒，外层循环遍历背包的大小，内层循环遍历数组 coins 的值，则因为每个dp[i]都去尝试各个硬币值，一定会出现重复的排列，如coins &#x3D; [2，3，5]，对于 dp[5] &#x3D; 2+3 和 3+2，这就是区别。</p>
<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a></p>
<p>刚好，上一题是组合，这一题考的是排列，很明显，只要更换内外层循环的顺序即可。</p>
<p>外层循环遍历从 1 到 target 的每个值，内层循环遍历数组 nums 的值，外层的每个值作为一个总和计算 dp[i] 时要考虑以 nums 的每一个小于等于 i 的数作为排列的最后一个元素的情况，将这些情况加起来作为当前的排列数。<br>如：以 nums&#x3D;{2,3,5} 为例，计算 dp[5]时会以 2 为结尾，以 3 为结尾，所以dp[5] &#x3D; dp[3]+dp[2]。动手模拟下也能发现。</p>
<h4 id="背包总结"><a href="#背包总结" class="headerlink" title="背包总结"></a>背包总结</h4><p>背包的递推公式比较容易，难在遍历顺序上，把遍历顺序摸透，才算是真正理解背包。</p>
<p>一维 dp 数组 <strong>01背包</strong> 只能先遍历物品再遍历背包容量（因为每个物品只有一个），且第二层for循环是从大到小遍历（因为要用dp数组左边的旧值更新当前的值，所以只能从右往左更新）。</p>
<p>一维 dp 数组 <strong>纯完全背包</strong>先遍历物品还是先遍历背包都是可以的（因为纯完全背包求得是最大价值，求排列还是组合并不影响），且第二层for循环是从小到大遍历（因为每个物品可以取无限次）。</p>
<p><strong>完全背包</strong>如果求<strong>组合数</strong>就是<strong>外层</strong>for循环<strong>遍历物品</strong>，<strong>内层</strong>for<strong>遍历背包</strong>（固定物品的顺序）。</p>
<p><strong>完全背包</strong>如果求<strong>排列数</strong>就是<strong>外层</strong>for<strong>遍历背包</strong>，<strong>内层</strong>for循环<strong>遍历物品</strong>（不固定物品顺序）。</p>
<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/description/">198.打家劫舍</a></p>
<p>动态规划经典题，有扩展。</p>
<p>关键就在于 <strong>考虑</strong>这个关键字。</p>
<p>如果偷当前 i 这个房间，则 i-1不能考虑，注意，考虑不代表一定偷，偷不偷由遍历过程中的max来决定，保证取最大值。</p>
<p>也就是 <code>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</code></p>
<h3 id="树-dp"><a href="#树-dp" class="headerlink" title="树 dp"></a>树 dp</h3><p>目前做到的树 dp 都是<strong>用数组作为容器储存状态</strong>，就像之前提过的，问题复杂时可以用更多的状态来实现动态规划。</p>
<h4 id="968-监控二叉树-1"><a href="#968-监控二叉树-1" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/description/">968. 监控二叉树</a></p>
<h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a>337. 打家劫舍 III</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/description/">337. 打家劫舍 III</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> traversal(root)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] traversal(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] status = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>]; <span class="comment">// 不考虑自身时能获得的最大值，考虑自身时能获得的最大值</span></span><br><span class="line">        <span class="type">int</span>[] left = traversal(root.left);</span><br><span class="line">        <span class="type">int</span>[] right = traversal(root.right);</span><br><span class="line">        status[<span class="number">0</span>] = left[<span class="number">1</span>]+right[<span class="number">1</span>];</span><br><span class="line">        status[<span class="number">1</span>] = Math.max( left[<span class="number">1</span>]+right[<span class="number">1</span>], root.val+left[<span class="number">0</span>]+right[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p>股票问题常常<strong>增加状态的维度</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III</a><br>这题比较难，很关键的一点就在于一定要<strong>定义清楚状态</strong>，不能把第一次交易和第二次交易混在一起，第二次交易一定是在第一次交易结束的时候进行的。</p>
<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h3><p>这题的贪心解法很有意思，也很难想。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">最长递增子序列</a></p>
<p>贪在让子序列最后一个元素最小，让 minTail[i] 为所有长度为 i 的子序列中最小的尾元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 贪心</span></span><br><span class="line">        <span class="comment">// minTail</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] minTail = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        minTail[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;minTail[len-<span class="number">1</span>]) &#123;</span><br><span class="line">                minTail[len++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> find(minTail,<span class="number">0</span>,len-<span class="number">1</span>,nums[i]);</span><br><span class="line">                minTail[idx+<span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end-start+<span class="number">1</span>)/<span class="number">2</span>+start;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;num) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[start]&gt;=num) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字符串二维-dp"><a href="#字符串二维-dp" class="headerlink" title="字符串二维 dp"></a>字符串二维 dp</h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.    最长公共子序列"></a>1143.    最长公共子序列</h4><p>拼多多一面原题</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143.    最长公共子序列</a></p>
<p>明明<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a>一下就写出来了，这题基本一样写老半天。</p>
<p>这种题就得动态规划做，整那种花里胡哨的就等死吧。</p>
<p>和以前做的题很不一样的是这种<strong>匹配问题</strong>关键就是这种都是 <strong>二维dp</strong>。</p>
<p>状态转移的关键不再是判断一维状态是否相等了，而是二维各自的元素是否相等了，一共两种状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> s2.length();</span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1+<span class="number">1</span>][n2+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i)==s2.charAt(j)) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离</a><br>编辑距离算法被数据科学家广泛应用，是用作机器翻译和语音识别评价标准的基本算法。</p>
<p><strong>编辑距离</strong>是一系列经典题目，很多<strong>二维dp</strong>题都由编辑距离改编而来，重中之重。</p>
<p>这题的关键在于 虽然说是让 word1 向 word2 靠齐，也就是字面意义的 word2 不能改，但在逻辑上是可以改的，word1 插入一个最合适的数等效于 word2 删除一个数，毕竟在 dp 过程中是肯定不能在word1 显式插入一个数字的。</p>
<p>妈的就倒在这了，只考虑word1删除和替换元素，甚至考虑到如果 word1 比 word2 短就反过来执行程序。</p>
<p>唉，so close。</p>
<p>关键：对两个单词计算编辑距离，<strong>插入与删除等价</strong>！</p>
<p>这样一来，本质不同的操作实际上只有三种：<br>在单词 A 中删除一个字符；<br>在单词 B 中删除一个字符；<br>修改单词 A&#x2F;B 的一个字符。</p>
<h4 id="回文-dp"><a href="#回文-dp" class="headerlink" title="回文 dp"></a>回文 dp</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串</a> 许多回文题基本都很相似，可以用 dp 做， 也可以用 中心扩展法（双指针法）做，还有 Manacher 算法。</p>
<p><strong>中心扩展法</strong> 空间性能比 DP 更好，关键就是 首先回文串要么是偶数长度要么是奇数长度，而区分不同回文串的要点除了回文串的内容，还有就是回文串的中心（这个中心更具体地是指中心在原字符串中所处的位置），因为当回文中心不一样时<strong>也算不同的回文子串</strong>，计算 <strong>回文子串数目</strong> 或者 <strong>回文子串长度</strong> 都是不影响的。</p>
<p>那接下要做的就是遍历所有的回文中心，获得这个中心能向外扩展得到的偶数长奇数长回文子串，故谓<strong>中心扩展</strong>。当然这里的回文中心是广义的，因为偶数长回文子串肯定是由起始长度为2的回文中心向外扩展而来的。</p>
<p>写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;=<span class="number">1</span>; j++) &#123;  <span class="comment">// j 为0， 奇数长； j 为1， 偶数长</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i+j;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&lt;n &amp;&amp; ch[l]==ch[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r-l+<span class="number">1</span>&gt;maxLen) &#123;</span><br><span class="line">                left = l;</span><br><span class="line">                right = r;</span><br><span class="line">                maxLen = r-l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a>97. 交错字符串</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&envId=top-interview-150">97. 交错字符串</a> 真难阿，好久没遇到写不出来的中等题了。唉悲伤</p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>什么时候用单调栈呢？</p>
<p>通常是一维数组，要<strong>寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置</strong>，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。</p>
<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/solutions/1/zhua-wa-mou-si-by-muse-77-myd7/">图解</a>讲的很清楚</p>
<p>这题用单调栈<br><strong>边遍历数组边构造树只遍历一次</strong>，真的太精妙了。<br>感觉关键就在于：<br>1、有大小的比较<br>2、入栈元素可能是我的右节点，也可能我(栈顶)或者我下面的一些都属于它的左子树。一切都是根据大小的比较。<br>最难的就是想到边形成单调栈边构造，我一直以为单调栈是生成完了才用，和单调队列一样。</p>
<h3 id="下一个更大元素-I"><a href="#下一个更大元素-I" class="headerlink" title="下一个更大元素 I"></a>下一个更大元素 I</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/description/">496. 下一个更大元素 I</a></p>
<p>自己写出单调栈了哈哈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; stk.peek()&lt;nums2[i]) &#123;</span><br><span class="line">                tmp = stk.pop();</span><br><span class="line">                hmap.put(tmp, nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums1.length; i++) &#123;</span><br><span class="line">            ans[i] = hmap.containsKey(nums1[i])? hmap.get(nums1[i]) : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度</a></p>
<p>第一次做到<strong>存储下标</strong>的，之前都是直接存储数，还是看需求的，必须这题的需求就是两个数索引的差。</p>
<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水</a> 一开始我是用类dp法写的，比较简单。</p>
<p>这题的单调栈法很不错，有种一层层往上加的感觉，原理就是栈里保存比栈顶大的，然后遍历过程中遇到比当前栈顶大的，那么对这个栈顶来说就已经是一个坑了，可以装水。</p>
<p>双指针法有点难，关键是只需要知道左右两边比自己高的两个柱子中比较低的一个，所以当左边&#x2F;右边出现了一个比现在明确的真正意义上的右边&#x2F;左边最大高度柱子时，当前位置能接的水量也就知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">    rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">    <span class="comment">// 对 left 来说，leftMax 是明确的真正意义上的左边最大高度</span></span><br><span class="line">    <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">        ans += leftMax - height[left];</span><br><span class="line">        ++left;</span><br><span class="line">    <span class="comment">// 对 right 来说，rightMax 是明确的真正意义上的左边最大高度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += rightMax - height[right];</span><br><span class="line">        --right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>


<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形</a></p>
<p>看看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/2749284/dan-diao-zhan-by-iridescent-zhang-33zk/">我的题解</a></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><a target="_blank" rel="noopener" href="https://wansuanfa.com/index.php/816">图的遍历</a> 讲的不错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsTree</span><span class="params">(Tree root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问当前节点，不一定放在这，也可以放到其他地方</span></span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.子节点个数; i++) &#123;</span><br><span class="line">        dfsTree(root.第i个子节点);</span><br><span class="line">        <span class="comment">// 如果需要回溯，这里要撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于矩阵的访问我们可以把它看做是一棵 4 叉树的前序遍历</span></span><br><span class="line"><span class="comment">// 如果是矩阵，需要访问和他挨着的上下左右4个方向，(x,y)是当前位置的坐标。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">boolean</span>[][] visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先不能越界。</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= matrix.length || y &lt; <span class="number">0</span> || y &gt;= matrix[<span class="number">0</span>].length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果当前位置被访问过，就不要在重复访问，直接跳过。</span></span><br><span class="line">    <span class="keyword">if</span> (visited[x][y])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;<span class="comment">// 先标记，表示当前位置被访问过。</span></span><br><span class="line">    <span class="comment">// 访问当前位置的上下左右4个方向，也可以像BFS中使用for循环来访问他的4个方向。</span></span><br><span class="line">    dfsMatrix(matrix, visited, x - <span class="number">1</span>, y);<span class="comment">//上</span></span><br><span class="line">    dfsMatrix(matrix, visited, x + <span class="number">1</span>, y);<span class="comment">//下</span></span><br><span class="line">    dfsMatrix(matrix, visited, x, y - <span class="number">1</span>);<span class="comment">//左</span></span><br><span class="line">    dfsMatrix(matrix, visited, x, y + <span class="number">1</span>);<span class="comment">//右</span></span><br><span class="line">    <span class="comment">// 递归之后还要往回走，如果需要回溯这个位置要还原，</span></span><br><span class="line">    <span class="comment">// 如果不需要回溯，下面这行代码就不要写。</span></span><br><span class="line">    visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>广搜： 广搜的搜索方式就适合于解决<strong>两个点之间的最短路径</strong>问题。</p>
<p>因为广搜是从<strong>起点出发</strong>，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p>
<p>当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，这类问题的特征就是不涉及具体的遍历方式，只要能把<strong>相邻且相同属性的节点标记上</strong>就行。</p>
<p><strong>只要BFS只要搜到终点(搜到的一瞬间)一定是一条最短路径</strong>，不管有没有障碍。DFS 应该是需要遍历完所有的路径并维护最短路径。</p>
<p>一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历？</p>
<p>很多网上的资料都是直接说用队列来实现。</p>
<p>其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。</p>
<p>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。</p>
<p>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p>
<p>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。</p>
<p>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</p>
<p>那么广搜需要<strong>注意转圈搜索的顺序</strong>吗？ <strong>不需要</strong>！</p>
<p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以。</p>
<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><p><strong>flood fill</strong> 算法，水漫算法，相当于用每种颜色填充每一个连通块。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量</a> 好难</p>
<p>难在想到每次处理一个岛屿，只处理所有连成一片的 1 。</p>
<p>广搜难在需要注意到：是加入队列时进行标记访问过这个点，而不是出队的时候进行标记。<br>这取决于我们对 代码中队列的定义，<strong>队列中的节点就表示已经走过的节点</strong>。 所以<strong>只要加入队列，立即标记该节点走过</strong>。</p>
<h4 id="并查集解法"><a href="#并查集解法" class="headerlink" title="并查集解法"></a>并查集解法</h4><p>已经完全解析了，看注释吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[m * n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    parent[i * n + j] = i * n + j;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class="line">        <span class="keyword">return</span> parent[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;  <span class="comment">// 不在一个集合，如果已经在一个集合的话不会再次操作，也就不会再次减 count</span></span><br><span class="line">            parent[rootx] = rooty;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;  <span class="comment">// 比如总共五个 1 ，会拉四个集合，每拉一个 union count 自减一次，所以能得到岛屿数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">nr</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nc</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num_islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(grid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[r][c] = <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 减少一点 union 操作次数，对结果不影响 </span></span><br><span class="line">                <span class="comment">// 换句话说是表示这个 1 已经完成了它的使命，把所有与它相连的 1 都拉到集合里面了，这些 1 后面没必要再访问它</span></span><br><span class="line">                <span class="comment">// 当然，由于集合的性质，不改为0，后面访问了也没关系，count不会再减了</span></span><br><span class="line">                <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    uf.union(r * nc + c, (r-<span class="number">1</span>) * nc + c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    uf.union(r * nc + c, (r+<span class="number">1</span>) * nc + c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uf.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集常用来解决<strong>连通性问题</strong>。</p>
<p>大白话就是当我们需要<strong>判断两个元素是否在同一个集合</strong>里的时候，我们就要想到用并查集。</p>
<p>并查集主要有两个功能：</p>
<p>将两个元素添加到一个集合中。<br>判断两个元素在不在同一个集合</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">并查集理论基础</a> 讲的不错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parent = vector&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程  Java 写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class="line">        <span class="keyword">return</span> parent[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line">bool <span class="title function_">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    u = find(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = find(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，join 函数中前三行和 isSame 函数是重复的，但这三行绝对不能用通过调用 isSame 函数来替换，因为下一行的 <code>father[v] = u</code> 表示的意思是让 v 的 根 指向 u的 根，这样才能通过<strong>单向的连接就能表示两个元素的相连</strong>。否则单单 <code>father[v] = u</code> 的意思就是让 v 指向 u ，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">join</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这是用 isSame 替换，此时无法表示 1 与 3 在一个集合里。</p>
<img src="/2024/03/05/LeetCodeNote/5.png" class=""> 

<p>这是不用 isSame 替换，此时可以表示 1 与 3 在一个集合里。</p>
<img src="/2024/03/05/LeetCodeNote/6.png" class=""> 


<p><code>join(u, v) </code>的含义就是 v 的根（或者叫头）指向 u 的根（或者叫头）。这点和上面的那个<strong>易错点</strong>是很关连的。</p>
<p>还有：<strong>路径压缩</strong> &#x2F;&#x2F; 验证过了<br>路径压缩会在寻根的<strong>漫长过程</strong>中，把这条路径上的<strong>所有非根节点</strong>的<strong>父节点</strong>全都设为<strong>最前端的根节点</strong>，只要这条路径跑一次，基本都会重设父节点，这些子节点都会直接挂载到根节点下面。</p>
<p>注意看：无论使用并查集模板里哪一个函数（除了init函数），都会有路径压缩的过程（因为里面都调用了 find 函数），第二次访问相同节点的时候，这个节点就是直连根节点的，即 第一次访问的时候它的路径就被压缩了。</p>
<p>路径压缩后的<strong>并查集时间复杂度</strong>在<strong>O(logn)与O(1)<strong>之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。<br>在第一次查询（find）的时候，相当于是</strong>n叉树上从叶子节点到根节点</strong>的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame 函数里涉及的查询操作也是一样的过程。</p>
<p><strong>拓展</strong></p>
<p>在「路径压缩」讲解中，我们知道如何靠压缩路径来缩短查询根节点的时间。</p>
<p>其实还有另一种方法：<strong>按秩（rank）合并</strong>。</p>
<p>rank表示<strong>树的高度</strong>，即树中结点<strong>层次的最大值</strong>。</p>
<p>为防止两颗树合并后整棵树的高度变的更高，一定是 rank 小的树合入 到 rank大 的树（比较矮的树合入比较高的树），这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。</p>
<p><strong>按秩（rank）合并</strong>不需要路径压缩，因为一旦做路径压缩，rank记录的高度就不准了，根据rank来判断如何合并就没有意义。</p>
<p>其实我们在优化并查集查询效率的时候，只用路径压缩的思路就够了，不仅代码实现精简，而且效率足够高。<br>按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rank = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>); <span class="comment">// 初始每棵树的高度都为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>; <span class="comment">// 也可以不写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : <span class="built_in">find</span>(father[u]);<span class="comment">// 注意这里不做路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="comment">// rank小的树合入到rank大的树</span></span><br><span class="line">    <span class="keyword">else</span> father[v] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; </span><br><span class="line">    <span class="comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked">207. 课程表</a></p>
<p>还是容易理解的</p>
<h2 id="字典序算法"><a href="#字典序算法" class="headerlink" title="字典序算法"></a>字典序算法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HappyRocking/article/details/83619392">字典序算法详解</a> 讲的挺好的。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked">31. 下一个排列</a></p>
<p>字典序算法用来解决这样一个问题：给定其中一种排列，求基于字典序的下一种排列。</p>
<p>比如给定一种排列为 abc，则其基于字典序的下一种排列为 acb。</p>
<p>要求下一种排列既要比原排列大，又不能有第三种排列位于他俩之间。即下一种排列为大于原排列的最小排列。</p>
<p>其实我们总体目标就是把一个递增序的123456转为递减序的654321【这里是从左往右看的】<br>以输入为 3 2 5 8 7 6 4 为例，字典序算法的步骤：<br>1、从右往左看，寻找最先出现的两个<strong>从右往左</strong>看呈递减趋势的数字，这里就是5 8，称5为左邻，8为右邻。【右邻8及其右边已经呈我们要的递减了，没法再在这边操作了】<br>2、重新从右往左找第一个比左邻5大的数（这里一定是找大于它的数，换一个等于的数有啥用），因为我们要用一个较小的数去和5换。这样换完之后才能小一点。这里我们找到6，将它和5换，则得到  3 2 6 8 7 5 4，左邻位置现在是6。【这里我们注意到8 7 5 4和原来一样是递减的，原因就是因为6是第一个大于5的】<br>3、将左邻位置(也就是现在的6)后面的所有数字重排序成递增的，得到3 2 6 4 5 7 8，这里我们只要使用双指针一直头尾交换就可以啦。</p>
<p>还是很简单滴。注意第一步如果没有这样的两个数说明已经全局递减的，这时候直接跳到第三步，形成一个循环。</p>
<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300 动态规划、二分查找解法</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">105 106从前序与中序遍历序列构造二叉树</a> 迭代法很恶心</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-triangle-area/description/">812. 最大三角形面积 凸包问题</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">77. 组合 字典序法解决组合枚举</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/solutions/387656/di-zeng-zi-xu-lie-by-leetcode-solution/">491. 非递减子序列 回溯去重</a><br>这个回溯去重真看不懂</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/solutions/389885/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/">332. 重新安排行程 Hierholzer 算法</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked">295. 数据流的中位数</a> 题简单，但是第一次见到用TreeMap，可以再了解下</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/1208350/cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526/?envType=study-plan-v2&envId=top-interview-150">373. 查找和最小的 K 对数字</a> 这题的二分查找可能有点难了</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><h3 id="给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩"><a href="#给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩" class="headerlink" title="给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩"></a>给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩</h3><p><strong>太难了呀</strong><br>select s.sid, s.name, sc.cid, sc.score<br>from studeng s join score sc on s.sid&#x3D;sc.sid and  sc.sid&#x3D;’02’<br>where not exists (select 1 from Score where Score.sid&#x3D;s.sid and Score.cid&#x3D;’01’) </p>
<p>select s.sid, s.name, sc.cid, sc.score<br>from<br>student s  left join score as sc1 on s.sid&#x3D;sc1.sid and sc1.cid&#x3D;’01’ left join score as sc2 on s.sid&#x3D;sc2.sid and sc2.cid&#x3D;’02’<br>where sc1.cid is null and sc2.cid is not null;</p>
<h3 id="给定一个学生表-student-score（stu-id，subject-id，score），查询总分排名在5-10名的学生id及对应的总分"><a href="#给定一个学生表-student-score（stu-id，subject-id，score），查询总分排名在5-10名的学生id及对应的总分" class="headerlink" title="给定一个学生表 student_score（stu_id，subject_id，score），查询总分排名在5-10名的学生id及对应的总分"></a>给定一个学生表 student_score（stu_id，subject_id，score），查询总分排名在5-10名的学生id及对应的总分</h3><p>WITH StudentTotalScores AS (…): 定义 CTE（子查询 (Common Table Expressions, CTE)，计算每个学生的总分。</p>
<p>RANK()函数是一种窗口函数，用于生成一个特定排序的序号。它与OVER子句结合使用，以指定排名的排序依据。<br>RANK()函数用于生成排序结果中的排名。不同于ROW_NUMBER()，它会处理并列的情况。例如，如果有两个记录的得分相同，那么它们会得到相同的排名，下一名将跳过。<br>OVER子句用于定义窗口函数的分区和排序方式，在你的例子中，它指定了如何排序生成排名：<br>窗口函数应用于ORDER BY total_score DESC：按总分从高到低进行排序。</p>
<p>RANK() OVER (ORDER BY total_score DESC) AS rank:<br>    RANK(): 生成排名。<br>    OVER (ORDER BY total_score DESC): 按总分从高到低排序来计算排名。<br>    AS rank: 给生成的排名列取名为rank。</p>
<p>WITH StudentTotalScores AS (<br>    SELECT<br>        stu_id,<br>        SUM(score) AS total_score<br>    FROM<br>        student_score<br>    GROUP BY<br>        stu_id<br>),<br>RankedStudents AS (<br>    SELECT<br>        stu_id,<br>        total_score,<br>        RANK() OVER (ORDER BY total_score DESC) AS ranking<br>    FROM<br>        StudentTotalScores<br>)<br>SELECT<br>    stu_id,<br>    total_score<br>FROM<br>    RankedStudents<br>WHERE<br>    ranking BETWEEN 5 AND 10;</p>
<p>除了这种声明子查询为某个表的with方式，还可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM (</span><br><span class="line">    SELECT</span><br><span class="line">        Prices.product_id AS product_id,</span><br><span class="line">        Prices.price * UnitsSold.units AS sales,</span><br><span class="line">        UnitsSold.units AS units</span><br><span class="line">    FROM Prices </span><br><span class="line">    LEFT JOIN UnitsSold ON Prices.product_id = UnitsSold.product_id</span><br><span class="line">    AND (UnitsSold.purchase_date BETWEEN Prices.start_date AND Prices.end_date)</span><br><span class="line">) T</span><br></pre></td></tr></table></figure>
<p>在from的时候用小括号命名别名为表T</p>
<h3 id="1934-确认率"><a href="#1934-确认率" class="headerlink" title="1934. 确认率"></a>1934. 确认率</h3><p><strong>有个问题待解决，当两个相同的表leftjoin似乎会产生类笛卡尔积，实际上是由于连接条件不唯一导致的</strong></p>
<p><strong>原来join是（以left join为例），此刻选择两条记录，如果满足on后面的条件，就将右边的记录接在左边后面成为一条新纪录作为结果集之一，并且如果对一条左边记录来说，右边没有任何一条符合则会生成一条【左边记录-null】的新纪录。所以以后连接条件一定要唯一，否则容易拿不到自己想要的结果</strong>。</p>
<p>SELECT *<br>FROM table1 AS alias1<br>LEFT JOIN table2 AS alias2<br>ON alias1.column &#x3D; alias2.column;<br>会从 table1 中获取所有记录，并根据 ON 条件与 table2 中的记录进行匹配。如果匹配成功，返回匹配的记录；如果匹配不成功，则返回 table1 的记录，并用 NULL 填充 table2 的列。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/confirmation-rate/description/?envType=study-plan-v2&envId=sql-free-50">1934. 确认率</a></p>
<p>IFNULL(expression, alt_value)<br>如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。</p>
<p>IF函数根据条件的结果为true或false，返回第一个值，或第二个值<br>IF(condition, value_if_true, value_if_false)</p>
<p>ROUND() 函数用于把数值字段舍入为指定的小数位数。<br>ROUND(column_name,decimals) decimals：可选。规定要返回的小数位数decimals 甚至可以是0、负数，用于对小数点左边进行四舍五入。</p>
<p><strong>COUNT：是对记录进行汇总，即计数记录数</strong><br><strong>SUM：是对符合条件的数值列字段进行求和</strong><br>SUM函数内部设置筛选条件<br>sum( action &#x3D; ‘confirmed’ ) <a target="_blank" rel="noopener" href="https://www.cnblogs.com/bravesunforever/p/11722995.html"> sum不止可以用于字段</a><br>每个Price与25对比后的判断结果，小于25，判断为False，用数字0表示；大于25，判断为True，用数字1表示；<br>可以发现，虽然判断结果为False，但仍然是一条记录，所以前两行虽然判断结果为0，但是 count(price&gt;25)列仍填充1（对count来说只要不为null就计数）<br>price&gt;25为False，即0，相当于sum( 0 ) 结果仍然是0<br>也可以在sum内部写if条件<code>sum(if(tb2.action=&#39;confirmed&#39;,1,0)</code><br><strong>按照这样的理论</strong>，sum绝对不止局限在字段，可以理解为对每条记录可以进行一样计算，并为其总和，比如我可以在sum中进行两个字段的相乘。</p>
<p>可以考虑使用AVG函数，需要注意的是AVG函数是可以写条件判断的。<br>AVG(c.action&#x3D;’confirmed’)  应该也是判断为False，用数字0表示，判断为True，用数字1表示，然后除以总行数</p>
<p><strong>布尔表达式在MySQL中的行为</strong><br>在MySQL中，布尔表达式（如 c.action &#x3D; ‘confirmed’）在数值上下文中会被隐式转换为数值：<br>真（TRUE）被转换为 1。<br>假（FALSE）被转换为 0。<br>因此，表达式 c.action &#x3D; ‘confirmed’ 对于每一行来说，要么是1（如果 action 是 ‘confirmed’），要么是0（否则）。</p>
<h3 id="1251-平均售价"><a href="#1251-平均售价" class="headerlink" title="1251. 平均售价"></a>1251. 平均售价</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-selling-price/description/?envType=study-plan-v2&envId=sql-free-50">1251. 平均售价</a></p>
<h3 id="1633-各赛事的用户注册率"><a href="#1633-各赛事的用户注册率" class="headerlink" title="1633. 各赛事的用户注册率"></a>1633. 各赛事的用户注册率</h3><p><strong>两个表没必要连接，但主表需要另一个表的某个信息，此时就是子查询嵌套，不是连接了</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/percentage-of-users-attended-a-contest/description/?envType=study-plan-v2&envId=sql-free-50">1633. 各赛事的用户注册率</a></p>
<p>在select里面用**(select count(1) from users)**表示从user表查到的行数，直接就用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">contest_id , round(100*count(1)/(select count(1) from users),2) as percentage </span><br><span class="line">from         </span><br><span class="line">Register</span><br><span class="line">group by contest_id</span><br><span class="line">order by percentage desc, contest_id asc</span><br></pre></td></tr></table></figure>

<p>mysql order排序 默认是<strong>升序</strong><br>多字段排序需要各自分别定义升降序<br>比如<br> SELECT * FROM students st <strong>ORDER BY</strong> st.sAge DESC, st.sGrade ASC;<br>并且按字段先后顺序排优先级，这里就先Age降序，然后Grade 升序</p>
<p>用<strong>distinct</strong>来返回不重复的用户名select distinct name，id from user, 去重</p>
<h3 id="1211-查询结果的质量和占比"><a href="#1211-查询结果的质量和占比" class="headerlink" title="1211. 查询结果的质量和占比"></a>1211. 查询结果的质量和占比</h3><img src="/2024/03/05/LeetCodeNote/7.png" class="">


<p>判断字段是否为null 要用 字段-IS NOT NULL，不能用！&#x3D;</p>
<h3 id="1193-每月交易-I"><a href="#1193-每月交易-I" class="headerlink" title="1193. 每月交易 I"></a>1193. 每月交易 I</h3><p>我们在用Mysql抽取数据时候，经常需要按照天、周、月等不同的粒度对数据进行分组统计。而我们的时间可能是“2017&#x2F;12&#x2F;5 0:0:0”这种准确的时间。所以在进行分组之前我们需要对时间进行一下处理。</p>
<p>DATE_FORMAT是MySQL内置的一个函数，作用是以不同的格式显示日期&#x2F;时间数据。具体的语法如下：</p>
<p>DATE_FORMAT(date,format)，其中<br>date：合法的日期。format：规定日期&#x2F;时间的输出格式</p>
<p>按天统计：select DATE_FORMAT(start_time,<strong>‘%Y%m%d’</strong>) days<br>按周统计：select DATE_FORMAT(start_time,<strong>‘%Y%u’</strong>) weeks<br>按月统计:  select DATE_FORMAT(start_time,<strong>‘%Y%m’</strong>) months  这样的会转化成字符串”201812”<br>其中年的Y换成y则只会输出后两位，比如2018的18，m换成M则变成月份英文单词，d同理。</p>
<p>这题要输出成【2018-12 】这样的格式，所以使用date_format(trans_date,’%Y-%m’)<br> 或者也可以left(trans_date, 7) 从左侧取七位</p>
<h3 id="550-游戏玩法分析-IV"><a href="#550-游戏玩法分析-IV" class="headerlink" title="550. 游戏玩法分析 IV"></a>550. 游戏玩法分析 IV</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/game-play-analysis-iv/description/?envType=study-plan-v2&envId=sql-free-50">550. 游戏玩法分析 IV</a></p>
<p>被子查询狠狠坑了，就是基础不好。（时间加一天不会，多表联查不知道，）</p>
<p>草泥马的，我以为 select from只能从一张表查，我真服了!<br>原来可以用逗号分隔查两张表（这样是笛卡尔积连结），比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select Activity.player_id as player_id</span><br><span class="line">  from (</span><br><span class="line">    select player_id, DATE_ADD(MIN(event_date), INTERVAL 1 DAY) as second_date</span><br><span class="line">    from Activity</span><br><span class="line">    group by player_id</span><br><span class="line">  ) as Expected, Activity</span><br><span class="line">  where Activity.event_date = Expected.second_date and Activity.player_id = Expected.player_id</span><br></pre></td></tr></table></figure>

<p>能够直接求出某列去重后的元素<br><strong>select count(distinct player_id) from activity</strong><br>count(distinct Activity.player_id) 直接就是去重后的行数<br>仔细看这里的区别， 第一个多表联查result, Activity，所以只要count(distinct Activity.player_id)就行，第二个只有result，所以要(select count(distinct player_id) from activity)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- select round(result.cnt/ count(distinct Activity.player_id),2) as fraction </span><br><span class="line">-- ) as result, Activity</span><br><span class="line"></span><br><span class="line">-- select round(result.cnt/ (select count(distinct player_id) from activity),2) as fraction </span><br><span class="line">-- ) as result</span><br></pre></td></tr></table></figure>

<h3 id="1378-使用唯一标识码替换员工ID"><a href="#1378-使用唯一标识码替换员工ID" class="headerlink" title="1378. 使用唯一标识码替换员工ID"></a>1378. 使用唯一标识码替换员工ID</h3><p>join（外连接）<br>1.inner join，内连接,显示两个表中有联系的所有数据;简写成join，如果一边缺了会自动重复。<br>2.left join，左链接,以左表为参照,显示所有数据,右表中没有则以null显示<br>3.right join，右链接,以右表为参照显示数据，,左表中没有则以null显示<br>比如这题就要用到left&#x2F;right JOIN<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/description/?envType=study-plan-v2&envId=sql-free-50">1378. 使用唯一标识码替换员工ID</a>因为要留NULL。<br>关键字 on<br>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。<br>在使用 left&#x2F;right jion 时，on 和 where 条件的区别如下：<br>1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。<br>2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。<br>使用 inner join 时on和where是一样的<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45906830/article/details/111133181">mysql的left join和inner join的详细用法</a> 这篇讲得好</p>
<h3 id="1280-学生们参加各科测试的次数"><a href="#1280-学生们参加各科测试的次数" class="headerlink" title="1280. 学生们参加各科测试的次数"></a>1280. 学生们参加各科测试的次数</h3><p>交叉联结（corss join）：<br>使用交叉联结会将两个表中所有的数据两两组合<br>写join时默认就是 cross join ，这东西真的很重要，有时候为了获得某几列的所有组合就要用这个东西。<br>比如<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/students-and-examinations/solutions/2366340/students-and-examinations-by-leetcode-so-3oup/?envType=study-plan-v2&envId=sql-free-50">难题</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">官解的写法也能学到些东西</span><br><span class="line">SELECT </span><br><span class="line">    s.student_id, s.student_name, sub.subject_name, IFNULL(grouped.attended_exams, <span class="number">0</span>) AS attended_exams</span><br><span class="line">FROM </span><br><span class="line">    Students s</span><br><span class="line">CROSS JOIN </span><br><span class="line">    Subjects sub</span><br><span class="line">LEFT <span class="title function_">JOIN</span> <span class="params">(</span></span><br><span class="line"><span class="params">    SELECT student_id, subject_name, COUNT(*) AS attended_exams</span></span><br><span class="line"><span class="params">    FROM Examinations</span></span><br><span class="line"><span class="params">    GROUP BY student_id, subject_name</span></span><br><span class="line"><span class="params">)</span> grouped </span><br><span class="line">ON s.student_id = grouped.student_id AND sub.subject_name = grouped.subject_name</span><br><span class="line">ORDER BY s.student_id, sub.subject_name;</span><br></pre></td></tr></table></figure>

<p>注意 USING (student_id,subject_name)意思是连结的用student_id subject_name这两列，也就是两个表有相同名称的这两列时可以这么用，完全可以用on代替，但是这里代替的写法应该是<br>ON stu.student_id &#x3D; ex.student_id AND sub.subject_name &#x3D; ex.subject_name 注意中间的and。<br>还发现 GROUP BY 、ORDER BY 都可以选一列以上</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">   stu.student<span class="emphasis">_id, stu.student_</span>name, sub.subject<span class="emphasis">_name, COUNT(ex.subject_</span>name) attended<span class="emphasis">_exams</span></span><br><span class="line"><span class="emphasis">FROM</span></span><br><span class="line"><span class="emphasis">    Students stu JOIN Subjects sub LEFT JOIN Examinations ex on stu.student_</span>id = ex.student<span class="emphasis">_id and sub.subject_</span>name = ex.subject<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">GROUP BY </span></span><br><span class="line"><span class="emphasis">    stu.student_</span>id, sub.subject<span class="emphasis">_name</span></span><br><span class="line"><span class="emphasis">ORDER BY</span></span><br><span class="line"><span class="emphasis">    stu.student_</span>id, sub.subject<span class="emphasis">_name</span></span><br></pre></td></tr></table></figure>

<h3 id="570-至少有5名直接下属的经理"><a href="#570-至少有5名直接下属的经理" class="headerlink" title="570. 至少有5名直接下属的经理"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/managers-with-at-least-5-direct-reports/description/?envType=study-plan-v2&envId=sql-free-50">570. 至少有5名直接下属的经理</a></h3><p>having count(Report.Id) &gt;&#x3D; 5 应该也是返回临时表</p>
<p>函数合集：<br>计算字符串中字符数的最佳函数是 CHAR_LENGTH(str)<br>另一个常用的函数 LENGTH(str) 返回字符串 str 的字节数，如果包含特殊字符(某些字符包含多于 1 个字节)，结果可能和预期不太一样</p>
<p>COUNT 想计数某个字段重复次数，先按这个字段group，然后count（另一个字段），这题就用到了，比如：想计算customer_id下有几个visit_id，就GROUP BY customer_id然后 COUNT(visit_id)<br>| visit_id | customer_id |<br>| 4        | 30          |<br>| 6        | 96          |<br>| 7        | 54          |<br>| 8        | 54          |</p>
<h3 id="1581-进店却未进行过交易的顾客"><a href="#1581-进店却未进行过交易的顾客" class="headerlink" title="1581. 进店却未进行过交易的顾客"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/description/?envType=study-plan-v2&envId=sql-free-50">1581. 进店却未进行过交易的顾客</a></h3><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。COUNT(visit_id)是统计表中，visit_id 字段不为 NULL 的记录有多少个</p>
<p>时间计算的函数：<br>datediff(日期1, 日期2)：很重要<br>得到的结果是日期1与日期2相差的天数。</p>
<h3 id="197-上升的温度"><a href="#197-上升的温度" class="headerlink" title="197. 上升的温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rising-temperature/description/?envType=study-plan-v2&envId=sql-free-50">197. 上升的温度</a></h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT w1.id</span><br><span class="line">FROM Weather w1, Weather w2 --这样写默认就是cross join</span><br><span class="line">WHERE datediff(w1.recordDate, w2.recordDate)=1 AND w1.temperature&gt;w2.temperature</span><br></pre></td></tr></table></figure>


<h2 id="MySQL-知识点"><a href="#MySQL-知识点" class="headerlink" title="MySQL 知识点"></a>MySQL 知识点</h2><p>count(age &gt; 20 or null) 最好不要用 or null 这种写法，用count(if(age &gt; 20,1,null)或者 sum(age &gt; 20)比较好。注意这里之所以可以sum(age &gt; 20)因为对布尔表达式会默认转为0、1。</p>
<p>判断字段空：只有name 为null 的时候 ISNULL(exp) 函数的返回值为1 ，空串和有数据都为0；<br>也可以 name is not null; 或 name is null;</p>
<p>排序：order by 排序字段 asc（默认，还可选desc）</p>
<p>去重：根据某些字段的去重查询（不考虑查询其他字段）<br>select <strong>distinct</strong> 字段 from table</p>
<p>或者 group by 也可以去重<br>select c_name,c_year,c_month from table<br>group by c_name,c_year,c_month</p>
<p>别名<br>列别名：SELECT  字段 [AS] 别名（AS关键字是可选的，别名如果有空格最好用单引号括起来）</p>
<p>组合字段并使用别名<br>CONCAT_WS(‘, ‘, lastName, firstname) [AS] ‘Full name’</p>
<p>ORDER BY，GROUP BY和HAVING子句中<strong>可以引用这些别名</strong>，不能在WHERE子句中使用列别名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  customerName,</span><br><span class="line"><span class="built_in">COUNT</span>(o.orderNumber) [<span class="keyword">as</span>] total #列别名，并且用函数作为一个字段  </span><br><span class="line"><span class="keyword">FROM</span> customers [<span class="keyword">as</span>] c <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders [<span class="keyword">as</span>] o  #表别名，内联<span class="keyword">INNER</span> <span class="keyword">JOIN</span>应该是配合<span class="keyword">ON</span>使用的</span><br><span class="line"><span class="keyword">ON</span> c.customerNumber <span class="operator">=</span> o.customerNumber</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customerName  # 去重？是的，而且要在<span class="keyword">ORDER</span> <span class="keyword">BY</span>前面</span><br><span class="line"><span class="keyword">HAVING</span> total <span class="operator">&gt;=</span><span class="number">5</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>


<h3 id="select-命令执行流程"><a href="#select-命令执行流程" class="headerlink" title="select 命令执行流程"></a>select 命令执行流程</h3><p><strong>sql查询语句执行逻辑顺序</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">9</span>) SELECT </span><br><span class="line">(<span class="number">10</span>) DISTINCT &lt;column&gt;,</span><br><span class="line">(<span class="number">6</span>) AGG_FUNC &lt;column&gt; or &lt;expression&gt;, ...</span><br><span class="line">(<span class="number">1</span>) FROM &lt;left_table&gt; </span><br><span class="line">    (<span class="number">3</span>) &lt;join_type&gt;JOIN&lt;right_table&gt;</span><br><span class="line">    (<span class="number">2</span>) ON&lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>) WHERE &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">7</span>) WITH &#123;CUBE|ROLLUP&#125;</span><br><span class="line">(<span class="number">8</span>) HAVING &lt;having_condtion&gt;</span><br><span class="line">(<span class="number">11</span>) ORDER BY &lt;order_by_list&gt;</span><br><span class="line">(<span class="number">12</span>) LIMIT &lt;limit_number&gt;;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) FROM &lt;left_table&gt;      首先从表 MyNumbers 读取数据</span><br><span class="line">    (<span class="number">2</span>) ON&lt;join_condition&gt;</span><br><span class="line">    (<span class="number">3</span>) &lt;join_type&gt;JOIN&lt;right_table&gt;</span><br><span class="line">(<span class="number">4</span>) WHERE &lt;where_condition&gt;      对单记录进行过滤</span><br><span class="line">(<span class="number">5</span>) GROUP BY &lt;group_by_list&gt;      按照 num 列对数据进行分组。</span><br><span class="line">(<span class="number">6</span>) AGG_FUNC &lt;column&gt; or &lt;expression&gt;, ...      在分组的基础上计算每组的 COUNT(num)。</span><br><span class="line">(<span class="number">7</span>) WITH &#123;CUBE|ROLLUP&#125;</span><br><span class="line">(<span class="number">8</span>) HAVING &lt;having_condtion&gt;</span><br><span class="line">(<span class="number">9</span>) SELECT         返回要的字段作为结果集</span><br><span class="line">(<span class="number">10</span>) UNION         将两个查询结果集合并。一般情况下不说</span><br><span class="line">(<span class="number">11</span>) DISTINCT &lt;column&gt;,   注意DISTINCT是可以用在聚合函数比如count中的</span><br><span class="line">(<span class="number">12</span>) ORDER BY &lt;order_by_list&gt;</span><br><span class="line">(<span class="number">13</span>) LIMIT &lt;limit_number&gt; OFFSET &lt;offset_number&gt;;</span><br></pre></td></tr></table></figure>
<p>但<strong>注意 sum&#x2F;count(distinct 某列)是能发挥distinct作用的，因为此时distinct是作为聚合函数的参数一块执行的</strong>。</p>
<p>但注意日期格式化data_format之后的字段别名可以用在group by中，因为涉及到SQL 的执行流程，在 SELECT 语句执行前会经历：语义校验（词法分析） -&gt;语法校验（语法分析）-&gt;（构建）语法树-&gt;优化器-&gt;执行器。本例的 date_formate 就是在语法树之前就编译好了的，所以最后丢给执行器执行时就能使用前面的编译内容去得出结果。【select date_format(trans_date,’%Y-%m’) as month…from…group by month】</p>
<h3 id="MySQL-日期函数"><a href="#MySQL-日期函数" class="headerlink" title="MySQL 日期函数"></a>MySQL 日期函数</h3><p>mysql日期函数<br>now() 当前日期和时间<br>curdate() 当前日期<br>date(某个日期时间) 获取日期或日期时间的日期部分<br>time() 仅时间<br>date_format()将日期和时间转为指定格式字符串</p>
<p>between…and（推荐）判断某个时间是否在某个时间范围内<br><code>SELECT * FROM k_student WHERE create_time  between &#39;2019-07-25 00:00:33&#39; and &#39;2019-07-25 00:54:33&#39;</code><br>也可以用大小于号</p>
<p>datediff(expr1, expr2)用于计算两个日期之间的<strong>天数差</strong>。<br>expr1 和 expr2 是两个日期表达式。expr1 表示结束日期，expr2 表示起始日期。<br>DATEDIFF 函数返回的是 expr1 与 expr2 之间相差的天数。</p>
<p>最小天数加一天<br>DATE_ADD(MIN(event_date), INTERVAL 1 DAY)<br>DATE_SUB(MIN(event_date), INTERVAL 1 DAY)</p>
<p>另一个关于时间计算的函数是：<br>timestampdiff(时间类型, 日期1, 日期2)<br>这个函数和上面 datediff 的正、负号规则刚好相反。<br>日期1大于日期2，结果为负，日期1小于日期2，结果为正。</p>
<p>在“时间类型”的参数位置，通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差。</p>
<hr>
<p>在 SQL 语句中，对字段加单引号的情况通常是为了区分字符串常量和列名，而不加单引号的情况通常是用于列名或保留字。</p>
<p>何时加单引号<br>字符串常量：在条件语句中如果要对一个列进行字符串比较或使用字符串常量，需要用单引号。例如：’approved’, ‘active’ 等。<br>日期常量：日期常量也需要用单引号。例如：’2023-12-08’, ‘2024-01-01’ 等。<br>字符型数据的插入：在插入字符型数据时需要用单引号。例如：<br>   INSERT INTO users (name, status) VALUES (‘John Doe’, ‘active’);<br>何时不加单引号<br>列名：列名通常不需要用单引号。例如：state, amount 等。<br>保留字：保留字在某些情况下可能会被错误识别，但如果它们明确指向数据库中的列或表，则不需要单引号。为了避免冲突，可以用反引号（MySQL）或双引号（标准 SQL）来引用，例如：state, `table` 等。<br>数值型常量：数值型数据在 SQL 语句中无需用单引号。例如：100, 0, 3.14 等。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count 的 case 写法</span><br><span class="line">COUNT(</span><br><span class="line"><span class="code">    CASE </span></span><br><span class="line"><span class="code">        WHEN state = &#x27;approved&#x27; </span></span><br><span class="line"><span class="code">    THEN 1 </span></span><br><span class="line"><span class="code">    ELSE NULL </span></span><br><span class="line"><span class="code">END)</span></span><br></pre></td></tr></table></figure>


<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><strong>子查询能否使用外部查询的字段取决于其位置和类型</strong>：</p>
<ol>
<li>具有独立上下文的子查询（如作为表达式使用）不能使用外部查询的字段。</li>
<li>在 FROM 子句中的子查询可以是独立的，但也可以通过 JOIN 关联外部查询的字段。</li>
<li><strong>关联子查询（例如在 WHERE 子句和 SELECT 子句中的子查询）通常会使用外部查询的字段。</strong></li>
</ol>
<h4 id="1、作为表达式使用："><a href="#1、作为表达式使用：" class="headerlink" title="1、作为表达式使用："></a>1、作为表达式使用：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select contest<span class="emphasis">_id , round(count(user_</span>id) <span class="emphasis">* 100/ (select count(*</span>) from users), 2) as percentage </span><br><span class="line">from Register</span><br><span class="line">group by contest<span class="emphasis">_id</span></span><br><span class="line"><span class="emphasis">order by percentage desc, contest_</span>id;</span><br></pre></td></tr></table></figure>

<p>子查询<code>(select count(*) from users)</code>为主查询中的表达式提供数据，甚至可以 <code>(select count(distinct name) from users) </code>查询users 表中的用户总数。</p>
<p>这种子查询不能使用外部查询的字段，因为它在单独的、独立的上下文中运行。</p>
<p>看这里甚至在where中的datediff里也用了子查询作为一个表达式，也就是这题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restaurant-growth/description/?envType=study-plan-v2&envId=sql-free-50">1321. 餐馆营业额变化增长</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> visited_on, amount, round(amount<span class="operator">/</span><span class="number">7</span>, <span class="number">2</span>) <span class="keyword">as</span> average_amount </span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> visited_on,</span><br><span class="line">        <span class="comment">-- (select min(distinct(visited_on)) from customer) as mindate , 这一列没必要，可以直接在where中用表达式</span></span><br><span class="line">        (<span class="keyword">select</span> <span class="built_in">sum</span>(amount) <span class="keyword">from</span> customer c2 <span class="keyword">where</span> datediff(c1.visited_on, c2.visited_on)<span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">and</span> datediff(c1.visited_on, c2.visited_on)<span class="operator">&gt;=</span><span class="number">0</span>) <span class="keyword">as</span> amount       </span><br><span class="line">    <span class="keyword">from</span> customer c1</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">where</span> datediff(visited_on, (<span class="keyword">select</span> <span class="built_in">min</span>(visited_on) <span class="keyword">from</span> customer))<span class="operator">&gt;=</span><span class="number">6</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> visited_on, amount</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> visited_on </span><br></pre></td></tr></table></figure>




<h4 id="2、在-FROM-子句中作为一个临时表使用："><a href="#2、在-FROM-子句中作为一个临时表使用：" class="headerlink" title="2、在 FROM 子句中作为一个临时表使用："></a>2、在 FROM 子句中作为一个临时表使用：</h4><p>子查询可以作为一个临时表来使用，并在主查询中引用，这里的引用不局限于单表引用，也可以join其他表。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select t.contest_id, t.avg_score</span><br><span class="line">from </span><br><span class="line">    (select contest_id, avg(score) as avg_score from Results group by contest_id) as t</span><br><span class="line">where t.avg_score &gt; 50;</span><br></pre></td></tr></table></figure>
<p>这里子查询将 Results 表按照 contest_id 分组并计算 avg_score，然后主查询从这个子查询结果中过滤 avg_score 大于 50 的记录。</p>
<h4 id="3、在-WHERE-字段-in、EXIST-或-HAVING-子句中使用："><a href="#3、在-WHERE-字段-in、EXIST-或-HAVING-子句中使用：" class="headerlink" title="3、在 WHERE 字段 in、EXIST 或 HAVING 子句中使用："></a>3、在 WHERE 字段 in、EXIST 或 HAVING 子句中使用：</h4><p>子查询很常用的一个场景是在 WHERE 或 HAVING 子句中，通常用于提供过滤条件。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT contest<span class="emphasis">_id, user_</span>id </span><br><span class="line">FROM Register </span><br><span class="line">WHERE user<span class="emphasis">_id IN (</span></span><br><span class="line"><span class="emphasis">    SELECT user_</span>id </span><br><span class="line"><span class="code">    FROM Rewards </span></span><br><span class="line"><span class="code">    WHERE points &gt; 100</span></span><br><span class="line"><span class="code">);</span></span><br></pre></td></tr></table></figure>

<p><strong>WHERE EXIST 这种子查询还经常会使用外部查询的字段</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT u.user<span class="emphasis">_id, u.name</span></span><br><span class="line"><span class="emphasis">FROM Users u</span></span><br><span class="line"><span class="emphasis">WHERE EXISTS (</span></span><br><span class="line"><span class="emphasis">    SELECT 1 </span></span><br><span class="line"><span class="emphasis">    FROM Orders o </span></span><br><span class="line"><span class="emphasis">    WHERE o.user_</span>id = u.user<span class="emphasis">_id </span></span><br><span class="line"><span class="emphasis">      AND o.amount &gt; 100</span></span><br><span class="line"><span class="emphasis">); </span></span><br></pre></td></tr></table></figure>

<h4 id="4、在-SELECT-子句中使用（SELECT-子句的结果作为一列）："><a href="#4、在-SELECT-子句中使用（SELECT-子句的结果作为一列）：" class="headerlink" title="4、在 SELECT 子句中使用（SELECT 子句的结果作为一列）："></a>4、在 SELECT 子句中使用（SELECT 子句的结果作为一列）：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user<span class="emphasis">_id, </span></span><br><span class="line"><span class="emphasis">       (select count(*) from Orders where Orders.user_</span>id = Users.user<span class="emphasis">_id) as order_</span>count</span><br><span class="line">from Users;</span><br></pre></td></tr></table></figure>
<p>这里子查询还用了外部查询的字段作为子查询内部的过滤条件，甚至子查询发生在外部查询的from子句前面。</p>
<hr>
<p>由于子查询需要嵌套并执行多次，因此在性能方面要特别注意。如果你的数据集非常大，频繁的子查询可能会导致查询性能下降。在可能的情况下，使用 JOIN 操作或优化索引策略可能会更有效。</p>
<hr>
<p>在 SELECT 子句中使用的这种子查询，如果子查询结果集是空集，那么外部查询对该结果的处理通常为返回 NULL。</p>
<p>SELECT (SELECT Salary FROM Employee WHERE Salary &#x3D; 10000) AS Result;<br>结果就是：<br>Result<br>NULL</p>
<p>在 SQL 查询中，<strong>当在 SELECT 子句中使用子查询时，通常要求子查询返回的结果集只有一行</strong>。如果子查询返回多行而没有适当处理，会导致 SQL 查询执行失败。<br><strong>当在 SELECT 子句中使用子查询时</strong>，情况有两种：<br>子查询返回零行或一行：<br>这是期望的标准情况。<br>当子查询返回零行时，外查询结果为 NULL。<br>当子查询返回一行时，外查询结果为该行的值。<br>子查询返回多行：<br>这会导致 SQL 查询执行失败，抛出错误，如 Subquery returns more than 1 row。</p>
<p><strong>在 SQL 中，子查询返回多行时不能直接用在 SELECT 子句中</strong>。这是因为<strong>SELECT子句期望的是标量子查询</strong>（即返回单一值的子查询）。如果子查询返回了多行数据，SQL 查询将会失败，并报错类似于 Subquery returns more than 1 row。</p>
<p><strong>其实，如果子查询返回空集，那么外部查询就可以把它视为NULL</strong>。这个在其他情况待定，但基本没问题。</p>
<h3 id="having-where"><a href="#having-where" class="headerlink" title="having where"></a>having where</h3><p>官网中明确表示</p>
<p><strong>可以在group by、order by、having子句中使用别名。<br>不可以在where中使用别名。</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/poloyy/p/12871310.html">having 过滤分组结果集 </a></p>
<p><strong>having是执行select前的最后一步</strong></p>
<p><strong>注意：在 HAVING 子句中不允许使用聚合函数和一个原始字段进行比较</strong>，因为 HAVING 是在分组后进行过滤的，而这个分组后的过滤无法访问原始的非聚合字段。<br>having只能使用GROUP BY分组之后的聚合结果字段，也就是每一组数据的统计数据，比如SUM、AVG、MAX、MIN 和 COUNT 等，这些函数计算的结果就是聚合后的结果。这个分组的名字也可以用（GROUP BY 子句中的分组字段）。</p>
<p>如果你试图在 HAVING 中使用一个原始数据的字段，则会出现错误。因为这些字段已经被聚合，或者说这些字段在分组后已经不再代表原始的单个数据行，而是代表整组数据的聚合结果。</p>
<p><strong>当SQL语句中使用了group by关键字后，select后面除了聚合函数，就只能是group by后面出现的字段。</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pure3417/p/15224587.html">包括select也是只能用这几个字段</a> 这篇文章写得好。</p>
<p>WHERE 用于在数据分组和聚合之前过滤记录。换句话说，它作用在 GROUP BY 语句之前，因此不能使用聚合函数。<br>HAVING 用于在数据分组和聚合之后过滤记录，通常与 GROUP BY 一起使用。HAVING 可以使用聚合函数。</p>
<p>使用 WHERE 条件<br>使用 WHERE 来过滤记录时，不能直接基于聚合函数（如 SUM）进行过滤（也就是说不能用聚合函数），而只能过滤分组前的记录。例如，我们只能在数据分组前过滤 sale_amount 小于 50 的记录：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT product<span class="emphasis">_id, SUM(sale_</span>amount) as total<span class="emphasis">_sales</span></span><br><span class="line"><span class="emphasis">FROM Sales</span></span><br><span class="line"><span class="emphasis">WHERE sale_</span>amount &gt;= 50</span><br><span class="line">GROUP BY product<span class="emphasis">_id;</span></span><br></pre></td></tr></table></figure>
<p>这个查询会<strong>首先过滤掉</strong> sale_amount &lt; 50 的记录，然后对剩下的记录进行分组并计算总销售额。<br>使用 HAVING 可以也只能基于聚合函数的结果进行过滤（不能再用原始字段）<br><code>HAVING SUM(sale_amount) &gt; 200;</code></p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>JOIN … ON … 默认是 INNER JOIN，与显式的 INNER JOIN 等价。<br>明确的 CROSS JOIN 或使用逗号 FROM table1, table2 会生成两个表所有行的笛卡尔积。<br>INNER JOIN 是在 ON 条件过滤后的联结，而逗号分隔的 FROM（from table1,table2） 是生成笛卡尔积，然后（可选）通过 WHERE 子句进行过滤可能可以达到类似 INNER JOIN 的效果。</p>
<p>注意：只要是同一张表与自身进行连接，无论使用 LEFT JOIN、RIGHT JOIN、INNER JOIN 或 CROSS JOIN 等不同的连接方式，都可以称之为<strong>自连接</strong>（Self Join）。</p>
<p>自连接的关键点在于，<strong>同一张表在查询中被引用多次</strong>。具体的连接类型只是决定了数据的匹配方式和返回结果的内容。<br>自连接指的是同一张表在查询中被引用多次，<strong>并以不同的别名进行关联</strong>。<br>自连接用途广泛，可以用于处理记录间亲缘关系、<strong>比较同表内记录</strong>（用的很多）等场景。</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit N,M : 相当于 limit M offset N , 从第 N 条记录开始, 返回 M 条记录<br>注意，这里两种写法是相反的意思。以后就用limit M offset N比较清晰一些。</p>
<p>SELECT * FROM table_name LIMIT offset, limit;<br>limit带两个参数时即 limit N,M，偏移N，限制M条<br>SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15   </p>
<p>如果只给定一个参数，它表示返回最大的记录行数目，即LIMIT N返回从0开始N条：<br>SELECT * FROM table LIMIT 5; &#x2F;&#x2F; 检索记录行 1-5</p>
<h3 id="WITH-子句"><a href="#WITH-子句" class="headerlink" title="WITH 子句"></a>WITH 子句</h3><p>WITH 子句也被称为 “公用表表达式”（Common Table Expression, CTE）。它的主要作用是提高代码的可读性和重用性。WITH 子句允许您定义一个临时的、命名的<strong>结果集</strong>，可以在后续的 SELECT、INSERT、UPDATE 或 DELETE 语句中使用。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">    SELECT</span><br><span class="line">        ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个名字叫 t 的临时结果集。</p>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>MySQL 8.0 版本中可以使用窗口函数，它很像分组函数却又区别于分组函数，在使用group by后每组只有一个结果，而窗口函数不论是否分组都是一行一个结果。窗口函数不对数据进行分组，而是按照窗口划分，<strong>计算与当前窗口的聚合值，并将计算结果返回给这个窗口的每一行</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chengyj0505/article/details/130057113">MySQL 窗口函数</a> 这篇讲的很清楚。</p>
<p>窗口函数允许您在<strong>不通过 GROUP BY 聚合</strong>的情况下，在查询<strong>结果集</strong>中计算<strong>某些聚合值</strong>。窗口函数通常与 <strong>OVER 子句</strong>一起使用，它指定了<strong>窗口的划分方式</strong>（即如何分组数据）。</p>
<p><code>COUNT(*) OVER(PARTITION BY employee_id) AS count_over</code></p>
<p><code>OVER(PARTITION BY employee_id)</code> 指定了<strong>窗口分组</strong>方式，即按 employee_id 划分数据。</p>
<p>COUNT(*) 对这个划分得到的分组进行聚合，对这个分组进行计数。<br>AS count_over 给这个<strong>计算结果列</strong>起了一个别名叫 count_over。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/primary-department-for-each-employee/solutions/2702019/qiang-lie-jian-yi-bu-yao-shi-yong-unionc-l86h/?envType=study-plan-v2&envId=sql-free-50">1789. 员工的直属部门</a> 这里之所以要这么做是因为我既需要分组得到count，我又想要不分组时候的原字段。（因为group之后非group字段就消失了）</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>字符串转换为大写，可以使用UPPER函数<br>SELECT UPPER(‘hello world’) AS UpperCaseString;<br>– 输出：HELLO WORLD</p>
<p>要将字符串转换为小写，可以使用LOWER函数</p>
<p>SUBSTRING(column_name, start, <strong>length</strong>)：从列的值中提取一个子串，从指定的起始位置开始，直到指定的长度。<br>SUBSTRING(name, 1, 1) 拿到name的子串，从位置1开始长度为1的子串。</p>
<p>都可以用来拼接字段<br>CONCAT(UPPER(SUBSTRING(name, 1, 1)), LOWER(SUBSTRING(name, 2))): 将首字母（大写）和其余部分（小写）进行拼接，得到所需格式的姓名。<br>CONCAT_WS(separator,str1,str2,…))函数表示使用指定的分隔符 separator 连接多个字符串，分隔符为 NULL 则返回 NULL。<br>超牛的<strong>将多行的字符串按分组整合成一个字符串</strong>，必须配合group使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GROUP_CONCAT(</span><br><span class="line">    DISTINCT expression1</span><br><span class="line">    ORDER BY expression2 asc/desc</span><br><span class="line">    SEPARATOR sep</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product asc) as products</span><br><span class="line">from activities</span><br><span class="line">group by sell_date</span><br><span class="line">order by sell_date</span><br></pre></td></tr></table></figure>

<p>INSTR()<br>INSTR(str, substr)函数用于返回子串 substr 在字符串 str 中第一次出现的索引位置，没有找到子串时返回 0。<br>另外，LOCATE(substr,str)函数也可以用于返回子串 substr 在字符串 str 中第一次出现的索引位置，和 INSTR(str,substr) 函数唯一的不同就是参数的顺序相反。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/horses/article/details/118344265">MySQL 十大常用字符串函数</a> 讲的挺好。</p>
<p>正则表达式<br>在正则表达式中，一些字符具有特殊意义，比如 .、*、+、?、^、$、(、)、[、]、{、}、| 等等。如果你想要匹配这些字符本身，需要进行转义，即在这些字符前面加一个反斜杠 \。<br><strong>由于反斜杠\本身也是特殊字符需要转义</strong>，而<strong>字符串又以 \ 作为转义符</strong>，所以在字符串中表示反斜杠时需要双写象征一个反斜杠，即我们需要使用<code> \\</code> 来表示一个反斜杠。<br>在正则表达式中，<code>\s</code>表示匹配任何空白字符，包括空格、制表符、换页符等。在正则表达式的语法中，这是一个预定义字符类。<br>同理在正则表达式内，匹配空白字符需要使用 “\s”。</p>
<p>在正则表达式中，方括号 [] 定义<strong>字符类</strong>，字符类是一个特殊的表示法，用于<strong>匹配方括号内任意一个字符</strong><br>[abc] 匹配 ‘a’、’b’ 或者 ‘c’ 中的任意一个字符。<br>[0-9] 匹配任意一个数字。<br>字符类内的大多数字符不具备特殊意义，即它们被视作字面量字符，因此在字符类内不需要转义。例如，. 在字符类外表示任意字符，但在字符类内 [.] 就只表示字面上的一个点号。</p>
<p><strong>元字符在字符类内部的处理 应该只需要考虑这两个</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">反斜杠是转义字符，其本身需要转义。不论在字符类内外都需要转义。</span><br><span class="line"><span class="comment">// 在字符类内外都需要双写反斜杠进行转义</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[\\]&quot;</span>;</span><br><span class="line">方括号本身具有定义字符类的功能，需要在字符类内使用时，需要通过反斜杠 \进行转义。</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[\\[\\]]&quot;</span>; <span class="comment">// 匹配 [ 或 ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">元字符（Meta Characters）</span><br><span class="line">. (点)</span><br><span class="line">匹配除换行符 \n 之外的任何单个字符。</span><br><span class="line">例如：a.b 可以匹配 aab, aXb, a0b 等等。</span><br><span class="line">^ (脱字符)</span><br><span class="line">匹配字符串的开始位置。</span><br><span class="line">例如：^abc 只能匹配以 abc 开头的字符串。</span><br><span class="line">$ (美元符)</span><br><span class="line">匹配字符串的结束位置。</span><br><span class="line">例如：abc$ 只能匹配以 abc 结尾的字符串。</span><br><span class="line">* (星号)</span><br><span class="line">匹配前面的字符零次或多次。</span><br><span class="line">例如：a* 可以匹配空字符串、a、aa、aaa 等。</span><br><span class="line">+ (加号)</span><br><span class="line">匹配前面的字符一次或多次。</span><br><span class="line">例如：a+ 可以匹配 a、aa、aaa 等，但不能匹配空字符串。</span><br><span class="line">? (问号)</span><br><span class="line">匹配前面的字符零次或一次（即前面的字符是可选的）。</span><br><span class="line">例如：a? 可以匹配空字符串或 a。</span><br><span class="line">&#123;n&#125;</span><br><span class="line">匹配前面的字符恰好 n 次。</span><br><span class="line">例如：a&#123;<span class="number">3</span>&#125; 只能匹配 aaa。</span><br><span class="line">&#123;n,&#125;</span><br><span class="line">匹配前面的字符至少 n 次。</span><br><span class="line">例如：a&#123;<span class="number">2</span>,&#125; 可以匹配 aa、aaa、aaaa，等等。</span><br><span class="line">&#123;n,m&#125;</span><br><span class="line">匹配前面的字符至少 n 次，但不超过 m 次。</span><br><span class="line">例如：a&#123;<span class="number">2</span>,<span class="number">4</span>&#125; 可以匹配 aa、aaa 和 aaaa。</span><br><span class="line">[] (中括号)</span><br><span class="line">匹配括号内的任意一个字符。</span><br><span class="line">例如：[abc] 可以匹配 a、b 或 c。</span><br><span class="line">[^]（脱字符在中括号里）</span><br><span class="line">匹配括号内未列出的任意字符。</span><br><span class="line">例如：[^abc] 可以匹配除 a、b 和 c 之外的任意字符。</span><br><span class="line">| (竖线)</span><br><span class="line">表示 <span class="string">&quot;或&quot;</span> 逻辑运算符。</span><br><span class="line">例如：a|b 可以匹配 a 或 b。</span><br><span class="line">() (圆括号)</span><br><span class="line">用于分组，将多个字符视为一个整体。</span><br><span class="line">例如：(abc) 将 abc 视为一个整体，并且可以引用分组。</span><br><span class="line">\ (反斜杠)</span><br><span class="line">转义字符，用于转义元字符使其失去特殊含义。</span><br><span class="line">例如：\. 可以匹配 . 字符本身，而不再是任意字符。</span><br><span class="line">预定义字符类（Predefined Character Classes）</span><br><span class="line">\d</span><br><span class="line">匹配任何数字字符，相当于 [<span class="number">0</span>-<span class="number">9</span>]。</span><br><span class="line">例如：\d 可以匹配 <span class="number">0</span> 到 <span class="number">9</span> 之间的任何一个数字。</span><br><span class="line">\D</span><br><span class="line">匹配任何非数字字符，相当于 [^<span class="number">0</span>-<span class="number">9</span>]。</span><br><span class="line">例如：\D 可以匹配字母、符号、空格等非数字字符。</span><br><span class="line">\w</span><br><span class="line">匹配任何单词字符（包括下划线），相当于 [a-zA-Z0-9_]。</span><br><span class="line">例如：\w 可以匹配 a 到 z、A 到 Z、<span class="number">0</span> 到 <span class="number">9</span> 和 _。</span><br><span class="line">\W</span><br><span class="line">匹配任何非单词字符，相当于 [^a-zA-Z0-9_]。</span><br><span class="line">例如：\W 可以匹配符号、空格等非单词字符。</span><br><span class="line">\s</span><br><span class="line">匹配任何空白字符，包括空格、制表符、换页符等，相当于 [ \t\n\x0B\f\r]。</span><br><span class="line">例如：\s 可以匹配空格和其他空白字符。</span><br><span class="line">\S</span><br><span class="line">匹配任何非空白字符，相当于 [^ \t\n\x0B\f\r]。</span><br><span class="line">例如：\S 可以匹配所有非空白字符。</span><br><span class="line">边界匹配（Boundary Matchers）</span><br><span class="line">\b</span><br><span class="line">匹配一个单词的边界。</span><br><span class="line">例如：\bword\b 可以匹配 word，但不能匹配 sword 或 words。</span><br><span class="line">\B</span><br><span class="line">匹配非单词边界。</span><br><span class="line">例如：\Bword\B 可以匹配 swords 中的 word 部分。</span><br></pre></td></tr></table></figure>


<h3 id="delete语句"><a href="#delete语句" class="headerlink" title="delete语句"></a>delete语句</h3><p>一般是 delete from tableName where</p>
<p>注意：为了 SQL 语法和执行流程中的一致性，在删除操作中直接查询同一张表是不允许的。</p>
<p>这里理解下派生表（Derived Table）：派生表即子查询生成的一块临时数据集，如这里的 <code>select min(id) id from person p2 group by email</code> 生成的临时数据集。<br>派生表只在查询执行过程中生存，并且只在此次查询范围内有效。<br>同样的：这个也是一个派生表，并且由于多加了外层select就”<strong>避免</strong>“了同时删除和查询同一张表？</p>
<p>具体来讲，当我们在一个查询中既要删除数据又要查询数据时，直接在删除子句 (DELETE) 中操作和查询同一个表可能会引发未定义的行为或者错误。通过使用额外的一层 SELECT，可以有效地避免这些情况。这一层 SELECT 生成了一个派生表，用于隔离修改和查询操作。【有点玄乎，先这么理解吧，得靠外层的select的派生表才能隔绝】【额外的 SELECT 创建了一个派生表，从而建立起了一种逻辑上的数据隔离。这样，不会因为删除操作进行时表的数据变化而影响到查询结果。】<br>在某些数据库管理系统中，一边查询一边删除同一个表可能会导致死锁或其它并发问题。通过这种<strong>迂回查询</strong>，避免了直接操作同一张表的问题，从而提高了操作的安全性。</p>
<p>外层 t 的 SELECT <strong>包装了一层</strong>将其<strong>命名为 t 从而创建了派生表</strong>，这样可以确保后续语句引用此子查询结果。而非直接行操作。</p>
<p>派生表 t 的数据在子查询执行的一开始就已经确定了，它不会随着对表 person 的后续操作而变化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.id</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(id) <span class="keyword">AS</span> id</span><br><span class="line">    <span class="keyword">FROM</span> person p2</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> email</span><br><span class="line">) <span class="keyword">AS</span> t</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-duplicate-emails/description/">196. 删除重复的电子邮箱</a> 重要的delete题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1 <span class="keyword">FROM</span> Person p1,</span><br><span class="line">    Person p2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    p1.Email <span class="operator">=</span> p2.Email <span class="keyword">AND</span> p1.Id <span class="operator">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure>

<p><strong>这种DELETE方式很陌生</strong>，竟然和SELETE的写法类似。它涉及到t1和t2两张表，<strong>DELETE t1表示要删除t1的一些记录</strong>，具体删哪些，就看WHERE条件，满足就删；</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-duplicate-emails/solutions/219860/dui-guan-fang-ti-jie-zhong-delete-he-de-jie-shi-by/">可以看这篇题解</a></p>
<h3 id="UNION和UNION-ALL"><a href="#UNION和UNION-ALL" class="headerlink" title="UNION和UNION ALL"></a>UNION和UNION ALL</h3><p>UNION和UNION ALL 具有不同工作机制：</p>
<p>UNION：默认会对合并的结果集进行<strong>去重</strong>操作，因此在UNION中每个子查询的ORDER BY子句必须放在整体查询之外，因为在去重之前的排序操作是无意义的。ORDER BY子句在使用UNION时应该对<strong>最终合并、去重后的结果进行排序</strong>。</p>
<p>UNION ALL：则不进行去重操作，直接合并所有结果集。因此，<strong>每个子查询的ORDER BY子句可以保留在自己的子查询内部</strong>，因为UNION ALL是直接将所有结果集按照子查询的顺序合并，保留各自的排序。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/tree/master">CS-Notes</a> </p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a> </p>
<p><a target="_blank" rel="noopener" href="https://algo.itcharge.cn/07.Tree/">算法通关手册（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/BillCYJ/article/details/79250382">深入理解递归</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>lichao Zhang
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/" title="LeetCodeNote">https://iridescent-zhang.github.io/2024/03/05/LeetCodeNote/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/23/javaNote/" rel="prev" title="javaNote">
      <i class="fa fa-chevron-left"></i> javaNote
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/01/InternetBasicsNote/" rel="next" title="InternetBasicsNote">
      InternetBasicsNote <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode"><span class="nav-number">1.</span> <span class="nav-text">leetcode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%85%E4%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">必会知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#n%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.2.1.</span> <span class="nav-text">n数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">912 排序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.3.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.4.</span> <span class="nav-text">多数元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.2.5.</span> <span class="nav-text">448. 找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">1.2.6.</span> <span class="nav-text">4. 寻找两个正序数组的中位数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-number">1.3.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">计数质数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.4.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">只出现一次的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="nav-number">1.4.2.</span> <span class="nav-text">二进制求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="nav-number">1.4.3.</span> <span class="nav-text">颠倒二进制位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E7%9A%84%E5%B9%82"><span class="nav-number">1.4.4.</span> <span class="nav-text">4的幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E7%9A%84%E5%B9%82"><span class="nav-number">1.4.5.</span> <span class="nav-text">2的幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0"><span class="nav-number">1.4.6.</span> <span class="nav-text">比特位计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-number">1.4.7.</span> <span class="nav-text">错误的集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82"><span class="nav-number">1.5.1.</span> <span class="nav-text">环形链表2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">148. 排序链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">1.6.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-number">1.6.1.</span> <span class="nav-text">202  快乐数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="nav-number">1.6.2.</span> <span class="nav-text">设计哈希集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="nav-number">1.6.3.</span> <span class="nav-text">原地哈希 41. 缺失的第一个正数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rabin-Karp-%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.4.</span> <span class="nav-text">Rabin-Karp 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.7.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">1.7.1.</span> <span class="nav-text">151 翻转字符串里的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%AE%9E%E7%8E%B0-strStr"><span class="nav-number">1.7.2.</span> <span class="nav-text">28. 实现 strStr()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.7.3.</span> <span class="nav-text">459.重复的子字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88"><span class="nav-number">1.8.</span> <span class="nav-text">队列与栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">1.8.1.</span> <span class="nav-text">232 用栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">1.8.2.</span> <span class="nav-text">150. 逆波兰表达式求值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">1.8.3.</span> <span class="nav-text">239. 滑动窗口最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E5%A4%A7%E5%85%83%E7%B4%A0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">1.8.4.</span> <span class="nav-text">数据流中的第 K 大元素 优先队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">1.8.5.</span> <span class="nav-text">347. 前 K 个高频元素 优先队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">1.8.6.</span> <span class="nav-text">215. 数组中的第K个最大元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.9.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.9.1.</span> <span class="nav-text">树的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.9.2.</span> <span class="nav-text">二叉树的存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.9.3.</span> <span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DFS-%E9%80%92%E5%BD%92"><span class="nav-number">1.9.3.1.1.</span> <span class="nav-text">DFS 递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DFS-%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.9.3.1.2.</span> <span class="nav-text">DFS 迭代</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BFS"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">1.9.4.</span> <span class="nav-text">二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.9.5.</span> <span class="nav-text">两数之和 IV - 输入二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-number">1.9.6.</span> <span class="nav-text">另一棵树的子树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">1.10.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8"><span class="nav-number">1.10.1.</span> <span class="nav-text">二进制手表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88"><span class="nav-number">1.10.2.</span> <span class="nav-text">77. 组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">1.10.3.</span> <span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%9B%86-II"><span class="nav-number">1.10.4.</span> <span class="nav-text">子集 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.10.5.</span> <span class="nav-text">491.递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">1.10.6.</span> <span class="nav-text">46. 全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="nav-number">1.10.7.</span> <span class="nav-text">全排列 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N-%E7%9A%87%E5%90%8E"><span class="nav-number">1.10.8.</span> <span class="nav-text">51. N 皇后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="nav-number">1.10.9.</span> <span class="nav-text">37. 解数独</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">1.10.10.</span> <span class="nav-text">494. 目标和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83"><span class="nav-number">1.11.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="nav-number">1.11.1.</span> <span class="nav-text">跳跃游戏 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">1.11.2.</span> <span class="nav-text">406. 根据身高重建队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">1.11.3.</span> <span class="nav-text">435. 无重叠区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">1.11.4.</span> <span class="nav-text">763. 划分字母区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.11.5.</span> <span class="nav-text">968. 监控二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.12.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.12.1.</span> <span class="nav-text">判断子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0-1"><span class="nav-number">1.12.2.</span> <span class="nav-text">比特位计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">1.12.3.</span> <span class="nav-text">53. 最大子数组和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="nav-number">1.12.4.</span> <span class="nav-text">376. 摆动序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.5.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">1.12.5.1.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="nav-number">1.12.5.2.</span> <span class="nav-text">1049. 最后一块石头的重量 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="nav-number">1.12.5.3.</span> <span class="nav-text">518. 零钱兑换 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="nav-number">1.12.5.4.</span> <span class="nav-text">377. 组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93"><span class="nav-number">1.12.5.5.</span> <span class="nav-text">背包总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">1.12.6.</span> <span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91-dp"><span class="nav-number">1.12.7.</span> <span class="nav-text">树 dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">1.12.7.1.</span> <span class="nav-text">968. 监控二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="nav-number">1.12.7.2.</span> <span class="nav-text">337. 打家劫舍 III</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.8.</span> <span class="nav-text">股票问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.12.9.</span> <span class="nav-text">300. 最长递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%8C%E7%BB%B4-dp"><span class="nav-number">1.12.10.</span> <span class="nav-text">字符串二维 dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.12.10.1.</span> <span class="nav-text">1143.    最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">1.12.10.2.</span> <span class="nav-text">72. 编辑距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%96%87-dp"><span class="nav-number">1.12.10.3.</span> <span class="nav-text">回文 dp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.12.10.4.</span> <span class="nav-text">97. 交错字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">1.13.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.13.1.</span> <span class="nav-text">654. 最大二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I"><span class="nav-number">1.13.2.</span> <span class="nav-text">下一个更大元素 I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">1.13.3.</span> <span class="nav-text">739. 每日温度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">1.13.4.</span> <span class="nav-text">42. 接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="nav-number">1.13.5.</span> <span class="nav-text">84. 柱状图中最大的矩形</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">1.14.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">1.14.1.</span> <span class="nav-text">200. 岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E6%B3%95"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">并查集解法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">1.14.2.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.14.3.</span> <span class="nav-text">拓扑排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.15.</span> <span class="nav-text">字典序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%9A%BE"><span class="nav-number">1.16.</span> <span class="nav-text">疑难</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL"><span class="nav-number">2.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E5%AD%A6%E7%94%9F%E8%A1%A8%E3%80%81%E8%AF%BE%E7%A8%8B%E6%88%90%E7%BB%A9%E8%A1%A8%EF%BC%8C%E6%B1%82%E4%B8%8D%E5%AD%98%E5%9C%A801%E8%AF%BE%E7%A8%8B%E4%BD%86%E5%AD%98%E5%9C%A802%E8%AF%BE%E7%A8%8B%E7%9A%84%E5%AD%A6%E7%94%9F%E7%9A%84%E6%88%90%E7%BB%A9"><span class="nav-number">2.1.1.</span> <span class="nav-text">给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E8%A1%A8-student-score%EF%BC%88stu-id%EF%BC%8Csubject-id%EF%BC%8Cscore%EF%BC%89%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%80%BB%E5%88%86%E6%8E%92%E5%90%8D%E5%9C%A85-10%E5%90%8D%E7%9A%84%E5%AD%A6%E7%94%9Fid%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%80%BB%E5%88%86"><span class="nav-number">2.1.2.</span> <span class="nav-text">给定一个学生表 student_score（stu_id，subject_id，score），查询总分排名在5-10名的学生id及对应的总分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1934-%E7%A1%AE%E8%AE%A4%E7%8E%87"><span class="nav-number">2.1.3.</span> <span class="nav-text">1934. 确认率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1251-%E5%B9%B3%E5%9D%87%E5%94%AE%E4%BB%B7"><span class="nav-number">2.1.4.</span> <span class="nav-text">1251. 平均售价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1633-%E5%90%84%E8%B5%9B%E4%BA%8B%E7%9A%84%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E7%8E%87"><span class="nav-number">2.1.5.</span> <span class="nav-text">1633. 各赛事的用户注册率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1211-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E8%B4%A8%E9%87%8F%E5%92%8C%E5%8D%A0%E6%AF%94"><span class="nav-number">2.1.6.</span> <span class="nav-text">1211. 查询结果的质量和占比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1193-%E6%AF%8F%E6%9C%88%E4%BA%A4%E6%98%93-I"><span class="nav-number">2.1.7.</span> <span class="nav-text">1193. 每月交易 I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#550-%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E5%88%86%E6%9E%90-IV"><span class="nav-number">2.1.8.</span> <span class="nav-text">550. 游戏玩法分析 IV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1378-%E4%BD%BF%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%A0%81%E6%9B%BF%E6%8D%A2%E5%91%98%E5%B7%A5ID"><span class="nav-number">2.1.9.</span> <span class="nav-text">1378. 使用唯一标识码替换员工ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1280-%E5%AD%A6%E7%94%9F%E4%BB%AC%E5%8F%82%E5%8A%A0%E5%90%84%E7%A7%91%E6%B5%8B%E8%AF%95%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">2.1.10.</span> <span class="nav-text">1280. 学生们参加各科测试的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#570-%E8%87%B3%E5%B0%91%E6%9C%895%E5%90%8D%E7%9B%B4%E6%8E%A5%E4%B8%8B%E5%B1%9E%E7%9A%84%E7%BB%8F%E7%90%86"><span class="nav-number">2.1.11.</span> <span class="nav-text">570. 至少有5名直接下属的经理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1581-%E8%BF%9B%E5%BA%97%E5%8D%B4%E6%9C%AA%E8%BF%9B%E8%A1%8C%E8%BF%87%E4%BA%A4%E6%98%93%E7%9A%84%E9%A1%BE%E5%AE%A2"><span class="nav-number">2.1.12.</span> <span class="nav-text">1581. 进店却未进行过交易的顾客</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#197-%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6"><span class="nav-number">2.1.13.</span> <span class="nav-text">197. 上升的温度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">MySQL 知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">select 命令执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">MySQL 日期函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BD%9C%E4%B8%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">1、作为表达式使用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%9C%A8-FROM-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">2、在 FROM 子句中作为一个临时表使用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%9C%A8-WHERE-%E5%AD%97%E6%AE%B5-in%E3%80%81EXIST-%E6%88%96-HAVING-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">3、在 WHERE 字段 in、EXIST 或 HAVING 子句中使用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%9C%A8-SELECT-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%88SELECT-%E5%AD%90%E5%8F%A5%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA%E4%B8%80%E5%88%97%EF%BC%89%EF%BC%9A"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">4、在 SELECT 子句中使用（SELECT 子句的结果作为一列）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#having-where"><span class="nav-number">2.2.4.</span> <span class="nav-text">having where</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join"><span class="nav-number">2.2.5.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#limit"><span class="nav-number">2.2.6.</span> <span class="nav-text">limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WITH-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.2.7.</span> <span class="nav-text">WITH 子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.8.</span> <span class="nav-text">窗口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.9.</span> <span class="nav-text">字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.2.10.</span> <span class="nav-text">delete语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNION%E5%92%8CUNION-ALL"><span class="nav-number">2.2.11.</span> <span class="nav-text">UNION和UNION ALL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">3.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lichao Zhang"
      src="/images/cloud.jpg">
  <p class="site-author-name" itemprop="name">lichao Zhang</p>
  <div class="site-description" itemprop="description">博观而约取，厚积而薄发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Iridescent-zhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Iridescent-zhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lczhang93@gmail.com" title="E-Mail → mailto:lczhang93@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/18558575/wo-ladki" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;18558575&#x2F;wo-ladki" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/channel/UCv42aVozJF9n4hK8xCacCmg" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCv42aVozJF9n4hK8xCacCmg" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.youtube.com/watch?v=DGa4Xv_tcjE&list=LL&index=6" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v&#x3D;DGa4Xv_tcjE&amp;list&#x3D;LL&amp;index&#x3D;6" rel="noopener" target="_blank">Eiro Nareth INTERSTELLAR</a>
        </li>
    </ul>
  </div>

      </div>

	  
		<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
		<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
		<div class="widget-wrap">
		<div id="myCanvasContainer" class="widget tagcloud">
		<canvas width="220" height="250" id="resCanvas" style="width=100%">
			<ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/" rel="tag">CV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cmd/" rel="tag">Cmd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Guitar/" rel="tag">Guitar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HLS/" rel="tag">HLS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NAT/" rel="tag">NAT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PYNQ/" rel="tag">PYNQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Powershell/" rel="tag">Powershell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP&#x2F;IP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li></ul>
		</canvas>
		</div>
		</div>
	  

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lichao Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">523k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">7:55</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'zmRLZ8XmVpWBhK4yl2baQmHm-gzGzoHsz',
      appKey     : 'c5e4Xhc2Ec8iU5BMArSxhhAu',
      placeholder: "Say something",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://zmrlz8xm.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fa fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fa fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button" onclick="moonMenuClick()">
    <svg class="moon-menu-svg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
      <g class="moon-menu-points">
        <circle class="moon-menu-point" r=".2rem" cx="0" cy="-.8rem"></circle>
        <circle class="moon-menu-point" r=".2rem"></circle>
        <circle class="moon-menu-point" r=".2rem" cx="0" cy=".8rem"></circle>
      </g>
    </svg>
    <div class="moon-menu-icon">
    </div>
    <div class="moon-menu-text">
    </div>
  </div>
</div>
<script src="/js/injector.js"></script>
    </div>
  <!-- 音乐播放器 -->
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
 <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
 <div id="aplayer" class="aplayer" data-id="3470747396" data-server="tencent" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
 <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
 <!-- 音乐播放器 end -->
</body>
</html>
